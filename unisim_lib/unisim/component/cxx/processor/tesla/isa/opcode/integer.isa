/*
 *  Copyright (c) 2009,
 *  University of Perpignan (UPVD),
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of UPVD nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Sylvain Collange (sylvain.collange@univ-perp.fr)
 */


/***************************************************

	ARITHMETIC AND LOGICAL INSTRUCTIONS

****************************************************/


// TODO: no src1_neg if immediate!
// no, src1_neg, 32/16-bit instead??
op iadd_full_normal( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:src1_neg[1]:0[2]:?[22]:/*marker*/0[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*src2*/0[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op iadd_full_end( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:src1_neg[1]:0[2]:?[22]:/*marker*/1[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*src2*/0[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op iadd_full_join( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:src1_neg[1]:0[2]:?[22]:/*marker*/2[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*src2*/0[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)


group iadd_full(iadd_full_normal, iadd_full_end, iadd_full_join)

iadd_full.disasm = {
	buffer << "add";
	insn->DisasmControl(buffer);
	buffer << ".s32";	// TODO: unsigned ??
	if(sat)
		buffer << ".sat";
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	//DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer);
	
	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc3(buffer);
}

iadd_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a + c
	reg_t a = insn->ReadSrc1();
	reg_t c = insn->ReadSrc3();
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = cpu->I32Add(a, c, flags, sat, /*src1_neg*/0, src3_neg);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}

op iadd_full_imm( \
	/*subop*/0[3]:/*?*/0[1]:/*imm_hi*/?[26]:/*marker*/3[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*imm_lo*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

iadd_full_imm.disasm = {
	buffer << "add";
	insn->DisasmControl(buffer);
	buffer << ".s32";	// TODO: unsigned ??
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
//	DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer);
	
	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc2(buffer);
}

iadd_full_imm.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a + c
	reg_t a = insn->ReadSrc1();
	reg_t c = insn->ReadSrc2();
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = cpu->I32Add(a, c, flags, 0, /*src1_neg*/0, src3_neg);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}


op umad24_lo_full( \
	/*subop*/3[3]:/*?*/0[1]:src3_neg[1]:src1_neg[1]:0[2]:/*const_seg*/?[2]:/*src1_sh*/?[1]:/*src3*/?[7]: \
	/*pred_reg*/?[2]:/*pred_cond*/?[5]:/*set_pred*/?[1]:/*set_pred_reg*/?[2]:/*output*/?[1]:/*addr_hi*/?[1]:/*marker*/?[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src2*/?[7]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1]\
)



