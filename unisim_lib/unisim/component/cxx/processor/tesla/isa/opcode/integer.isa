/*
 *  Copyright (c) 2009,
 *  University of Perpignan (UPVD),
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of UPVD nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Sylvain Collange (sylvain.collange@univ-perp.fr)
 */


/***************************************************

	ARITHMETIC AND LOGICAL INSTRUCTIONS

****************************************************/


// what about Decuda's 'subr' instruction?
op iadd_full_normal( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:m32[1]:0[2]:?[22]:/*marker*/0[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*src2*/0[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op iadd_full_end( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:m32[1]:0[2]:?[22]:/*marker*/1[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*src2*/0[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op iadd_full_join( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:m32[1]:0[2]:?[22]:/*marker*/2[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*src2*/0[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

group iadd_full(iadd_full_normal, iadd_full_end, iadd_full_join)

iadd_full.disasm = {
	buffer << "add";
	insn->DisasmControl(buffer);
	DisasmSignWidth(true, m32, buffer);
	// no unsigned saturation, so always signed
	if(sat)
		buffer << ".sat";
		
	buffer << " ";
	insn->DisasmDest(buffer, RegType(m32));

	buffer << ", ";
	//DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer, RegType(m32));
	
	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc3(buffer, RegType(m32));
}

iadd_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a + c
	reg_t a = insn->ReadSrc1(0, RegType(m32));
	reg_t c = insn->ReadSrc3(0, RegType(m32));
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = IAdd(a, c, flags, sat, /*src1_neg*/0, src3_neg, m32);
	
	insn->WriteDest(output, 0, RegType(m32));
	insn->SetPredI32(output, flags);
}

op iadd_half( \
	?[32]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src1_sh*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*imm_lo*/?[6]:\
	m32[1]:/*src1*/?[6]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/0[1] \
)

op iadd_imm( \
	/*subop*/0[3]:/*?*/0[1]:/*imm_hi*/?[26]:/*marker*/3[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src1_sh*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*imm_lo*/?[6]:\
	m32[1]:/*src1*/?[6]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

group iadd_halfimm(iadd_half, iadd_imm)

// TODO: group with iadd_full_imm?

iadd_halfimm.disasm = {
	buffer << "add";
	insn->DisasmControl(buffer);
	DisasmSignWidth(true, m32, buffer);
		
	buffer << " ";
	insn->DisasmDest(buffer, RegType(m32));

	buffer << ", ";
	insn->DisasmSrc1(buffer, RegType(m32));
	
	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc2(buffer, RegType(m32));
}

iadd_halfimm.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a + c
	reg_t a = insn->ReadSrc1(0, RegType(m32));
	reg_t c = insn->ReadSrc2(0, RegType(m32));
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = IAdd(a, c, flags, false, false, src3_neg, m32);
	
	insn->WriteDest(output, 0, RegType(m32));
	insn->SetPredI32(output, flags);
}


op imad_full_normal( \
	subop[3]:/*?*/0[1]:src3_neg[1]:src1_neg[1]:0[2]:?[22]:/*marker*/0[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src2*/?[7]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op imad_full_end( \
	subop[3]:/*?*/0[1]:src3_neg[1]:src1_neg[1]:0[2]:?[22]:/*marker*/1[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src2*/?[7]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op imad_full_join( \
	subop[3]:/*?*/0[1]:src3_neg[1]:src1_neg[1]:0[2]:?[22]:/*marker*/2[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src2*/?[7]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)


group imad_full(imad_full_normal, imad_full_end, imad_full_join)

imad_full.disasm = {
	RegType rt = RT_U32;
	//buffer << "umad16x16+32";
	buffer << "mad24";
	insn->DisasmControl(buffer);
	switch(subop) {
	case 0:
		buffer << ".u16.lo";
		rt = RT_U16;
		break;
	// TODO: CHECK semantics of 1, 2
	case 3:
		buffer << ".u32.lo";
		break;
	case 4:
		buffer << ".s32.lo";
		break;
	case 5:
		buffer << ".s32.lo.sat";
		break;
	case 6:
		buffer << ".u32.hi";
		break;
	case 7:
		buffer << ".s32.hi";
		break;
	default:
		buffer << ".?" << subop << "?";
	}
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	//DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer, rt);

	buffer << ", ";
	insn->DisasmSrc2(buffer, rt);
		
	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc3(buffer);
}

imad_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	RegType rt = RT_U32;
	bool issigned = false, hi = false, sat = false;
	switch(subop) {
	case 0:
		rt = RT_U16;
		break;
	case 3:
		break;
	case 5:	// s32.lo.sat
		sat = true;
	case 4:	// s32.lo
		issigned = true;
		break;
	case 7:	// s32.hi
		issigned = true;
	case 6:	// u32.hi
		hi = true;
		break;
	default:
		assert(false);
	}
	// dest = a * b + c
	reg_t a = insn->ReadSrc1(0, rt);
	reg_t b = insn->ReadSrc2(0, rt);
	reg_t c = insn->ReadSrc3();	// Always 32-bit
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = Mad24(a, b, c, flags, sat, src1_neg, src3_neg, rt, issigned, hi);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}

op imac_imm( \
	/*subop*/subop[3]:/*?*/0[1]:/*imm_hi*/?[26]:/*marker*/3[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*imm_lo*/?[6]:\
	/*src1*/?[7]:dest[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

imac_imm.disasm = {
	// r <- a * b + r
	RegType rt = RT_U32;
	buffer << "mac24";
	insn->DisasmControl(buffer);
	switch(subop) {
	case 0:
		buffer << ".u16.lo";
		rt = RT_U16;
		break;
	// TODO: CHECK semantics of 1, 2
	case 3:
		buffer << ".u32.lo";
		break;
	case 4:
		buffer << ".s32.lo";
		break;
	case 5:
		buffer << ".s32.lo.sat";
		break;
	case 6:
		buffer << ".u32.hi";
		break;
	case 7:
		buffer << ".s32.hi";
		break;
	default:
		buffer << ".?" << subop << "?";
	}
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	//DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer, rt);

	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc2(buffer, rt);
}

imac_imm.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	RegType rt = RT_U32;
	bool issigned = false, hi = false, sat = false;
	switch(subop) {
	case 0:
		rt = RT_U16;
		break;
	case 3:
		break;
	case 5:	// s32.lo.sat
		sat = true;
	case 4:	// s32.lo
		issigned = true;
		break;
	case 7:	// s32.hi
		issigned = true;
	case 6:	// u32.hi
		hi = true;
		break;
	default:
		assert(false);
	}

	// dest = a * b + c
	reg_t a = insn->ReadSrc1(0, rt);
	reg_t b = insn->ReadSrc2(0, rt);
	reg_t c = cpu->GetGPR(dest);
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = Mad24(a, b, c, flags, sat, /*src1_neg*/0, src3_neg, rt, issigned, hi);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}


op imul24_full_normal( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:src1_neg[1]:0[2]:/*const_seg*/?[2]:/*src1_sh*/?[1]:/*?*/0[4]:m32[1]:issigned[1]:hi[1]:?[12]:/*marker*/0[2]: \
	0x4[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src2_neg[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op imul24_full_end( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:src1_neg[1]:0[2]:/*const_seg*/?[2]:/*src1_sh*/?[1]:/*?*/0[4]:m32[1]:issigned[1]:hi[1]:?[12]:/*marker*/1[2]: \
	0x4[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src2_neg[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op imul24_full_join( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:src1_neg[1]:0[2]:/*const_seg*/?[2]:/*src1_sh*/?[1]:/*?*/0[4]:m32[1]:issigned[1]:hi[1]:?[12]:/*marker*/2[2]: \
	0x4[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src2_neg[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op imul24_half( \
	?[32]: \
	0x4[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src1_sm*/?[1]:/*src2_cm*/?[1]:m32[1]:/*src2*/?[6]:\
	issigned[1]:/*src1*/?[6]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/0[1] \
)

op imul24_imm( \
	/*subop*/0[3]:/*?*/0[1]:/*imm_hi*/?[26]:/*marker*/3[2]: \
	0x4[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src1_sm*/?[1]:/*src2_cm*/?[1]:m32[1]:/*src2*/?[6]:\
	issigned[1]:/*src1*/?[6]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)


group imul24(imul24_full_normal, imul24_full_end, imul24_full_join)

group imul24_halfimm(imul24_half, imul24_imm)

imul24.disasm = {
	buffer << "mul24";
	insn->DisasmControl(buffer);
	buffer << ".";
	buffer << (issigned ? "s" : "u");
	buffer << (m32 ? "32" : "16");
	buffer << (hi ? ".hi" : ".lo");

	// no unsigned saturation
//	assert(issigned || !sat);
	if(sat)
		buffer << ".sat";
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer, RegType(m32));
	
	buffer << ", ";
	DisasmSign(src2_neg, buffer);
	insn->DisasmSrc2(buffer, RegType(m32));
}

imul24.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a * b
	reg_t a = insn->ReadSrc1(0, RegType(m32));
	reg_t b = insn->ReadSrc2(0, RegType(m32));
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = Mul24(a, b, sat, src1_neg, src2_neg, m32, issigned, hi);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}

imul24_halfimm.disasm = {
	buffer << "mul24";
	insn->DisasmControl(buffer);
	buffer << ".";
	buffer << (issigned ? "s" : "u");
	buffer << (m32 ? "32" : "16");
	buffer << ".lo";
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	insn->DisasmSrc1(buffer, RegType(m32));
	
	buffer << ", ";
	insn->DisasmSrc2(buffer, RegType(m32));
}

imul24_halfimm.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a * b
	reg_t a = insn->ReadSrc1(0, RegType(m32));
	reg_t b = insn->ReadSrc2(0, RegType(m32));
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = Mul24(a, b, 0, 0, 0, m32, issigned, 0);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}


////////////////////////////////////////////////////////////////
// logical instructions


// No need to check for "immediate" marker,
// shift amount fits in 7 bits.
op shl_full( \
	/*subop*/6[3]:/*?*/0[1]:issigned[1]:u32[1]:0[2]:?[3]:/*imm*/0[1]:?[18]:/*marker*/?[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op shl_full_imm2( \
	/*subop*/6[3]:/*?*/0[1]:issigned[1]:u32[1]:0[2]:?[3]:/*imm*/1[1]:?[18]:/*marker*/?[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:src2[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)


// TODO: end, join

//group shl_full(shl_full_normal)

//group shl_full_imm2(shl_full_imm2_normal)

shl_full.disasm = {
	buffer << "shl";
	insn->DisasmControl(buffer);
	DisasmSignWidth(issigned, u32, buffer);

	buffer << " ";
	insn->DisasmDest(buffer, RegType(u32));

	buffer << ", ";
	insn->DisasmSrc1(buffer, RegType(u32));
	
	buffer << ", ";
	insn->DisasmSrc2(buffer, RegType(u32));
}

shl_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	// dest = a << c
	reg_t a = insn->ReadSrc1(0, RegType(u32));
	reg_t c = insn->ReadSrc2(0, RegType(u32));
	
	reg_t output = ShiftLeft(a, c, u32, issigned);
	
	insn->WriteDest(output, 0, RegType(u32));
	insn->SetPredI32(output);
}

shl_full_imm2.disasm = {
	buffer << "shl";
	insn->DisasmControl(buffer);
	DisasmSignWidth(issigned, u32, buffer);

	buffer << " ";
	insn->DisasmDest(buffer, RegType(u32));

	buffer << ", ";
	insn->DisasmSrc1(buffer, RegType(u32));
	
	buffer << ", ";
	buffer << src2;
}

shl_full_imm2.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	// dest = a << c
	reg_t a = insn->ReadSrc1(0, RegType(u32));
	//reg_t c = reg_t(src2);
	
	reg_t output = ShiftLeft(a, src2, u32);
	
	insn->WriteDest(output, 0, RegType(u32));
	insn->SetPredI32(output);
}

op shr_full( \
	/*subop*/7[3]:/*?*/0[1]:issigned[1]:u32[1]:0[2]:?[3]:/*imm*/0[1]:?[18]:/*marker*/?[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op shr_full_imm2( \
	/*subop*/7[3]:/*?*/0[1]:issigned[1]:u32[1]:0[2]:?[3]:/*imm*/1[1]:?[18]:/*marker*/?[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:src2[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)


// TODO: end, join?

shr_full.disasm = {
	buffer << "shr";
	insn->DisasmControl(buffer);
	DisasmSignWidth(issigned, u32, buffer);

	buffer << " ";
	insn->DisasmDest(buffer, RegType(u32));

	buffer << ", ";
	insn->DisasmSrc1(buffer, RegType(u32));
	
	buffer << ", ";
	insn->DisasmSrc2(buffer, RegType(u32));
}

shr_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	// dest = a << c
	reg_t a = insn->ReadSrc1(0, RegType(u32));
	reg_t c = insn->ReadSrc2(0, RegType(u32));
	
	reg_t output = ShiftRight(a, c, u32, issigned);
	
	insn->WriteDest(output, 0, RegType(u32));
	insn->SetPredI32(output);
}

shr_full_imm2.disasm = {
	buffer << "shr";
	insn->DisasmControl(buffer);
	DisasmSignWidth(issigned, u32, buffer);

	buffer << " ";
	insn->DisasmDest(buffer, RegType(u32));

	buffer << ", ";
	insn->DisasmSrc1(buffer, RegType(u32));
	
	buffer << ", ";
	buffer << src2;
}

shr_full_imm2.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	// dest = a << c
	reg_t a = insn->ReadSrc1(0, RegType(u32));
	//reg_t c = reg_t(src2);
	
	reg_t output = ShiftRight(a, src2, u32, issigned);
	
	insn->WriteDest(output, 0, RegType(u32));
	insn->SetPredI32(output);
}


// and, or, xor, 2nd

// TODO: forbid immediate

op and_full( \
	/*subop*/0[3]:/*?*/0[1]:?[1]:u32[1]:0[2]:?[3]:/*imm*/0[1]:0[2]:src2_not[1]:src1_not[1]:/*lop*/0[2]:?[12]:/*marker*/?[2]: \
	0xd[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

and_full.disasm = {
	buffer << "and";
	insn->DisasmControl(buffer);

	buffer << " ";
	insn->DisasmDest(buffer, RegType(u32));

	buffer << ", ";
	DisasmNot(src1_not, buffer);
	insn->DisasmSrc1(buffer, RegType(u32));
	
	buffer << ", ";
	DisasmNot(src2_not, buffer);
	insn->DisasmSrc2(buffer, RegType(u32));
}

and_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	// dest = (neg?)a & (neg?)b
	reg_t a = insn->ReadSrc1(0, RegType(u32));
	if(src1_not) {
		a = BinNeg(a);
	}
	reg_t b = insn->ReadSrc2(0, RegType(u32));
	if(src2_not) {
		b = BinNeg(b);
	}
	
	reg_t output = BinAnd(a, b);
	
	insn->WriteDest(output, 0, RegType(u32));
	insn->SetPredI32(output);
}

op or_full( \
	/*subop*/0[3]:/*?*/0[1]:?[1]:u32[1]:0[2]:?[3]:/*imm*/0[1]:0[2]:src2_not[1]:src1_not[1]:/*lop*/1[2]:?[12]:/*marker*/?[2]: \
	0xd[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

or_full.disasm = {
	buffer << "or";
	insn->DisasmControl(buffer);

	buffer << " ";
	insn->DisasmDest(buffer, RegType(u32));

	buffer << ", ";
	DisasmNot(src1_not, buffer);
	insn->DisasmSrc1(buffer, RegType(u32));
	
	buffer << ", ";
	DisasmNot(src2_not, buffer);
	insn->DisasmSrc2(buffer, RegType(u32));
}

or_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	// dest = (neg?)a & (neg?)b
	reg_t a = insn->ReadSrc1(0, RegType(u32));
	if(src1_not) {
		a = BinNeg(a);
	}
	reg_t b = insn->ReadSrc2(0, RegType(u32));
	if(src2_not) {
		b = BinNeg(b);
	}
	
	reg_t output = BinOr(a, b);
	
	insn->WriteDest(output, 0, RegType(u32));
	insn->SetPredI32(output);
}

op xor_full( \
	/*subop*/0[3]:/*?*/0[1]:?[1]:u32[1]:0[2]:?[3]:/*imm*/0[1]:0[2]:src2_not[1]:src1_not[1]:/*lop*/2[2]:?[12]:/*marker*/?[2]: \
	0xd[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

xor_full.disasm = {
	buffer << "xor";
	insn->DisasmControl(buffer);

	buffer << ", ";
	DisasmNot(src1_not, buffer);
	insn->DisasmSrc1(buffer, RegType(u32));
	
	buffer << ", ";
	DisasmNot(src2_not, buffer);
	insn->DisasmSrc2(buffer, RegType(u32));
}

xor_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	//assert(u32);

	// dest = (neg?)a & (neg?)b
	reg_t a = insn->ReadSrc1(0, RegType(u32));
	if(src1_not) {
		a = BinNeg(a);
	}
	reg_t b = insn->ReadSrc2(0, RegType(u32));
	if(src2_not) {
		b = BinNeg(b);
	}
	
	reg_t output = BinXor(a, b);
	
	insn->WriteDest(output, 0, RegType(u32));
	insn->SetPredI32(output);
}


op set_full( \
	/*subop*/3[3]:/*?*/0[1]:sign[1]:w32[1]:const_seg[4]:/*src1_sh*/?[1]:abs_sat[2]:cvt_round[2]:cond[3]:?[12]:/*marker*/?[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*f64*/0[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

set_full.disasm = {
	buffer << "set.";
	buffer << SetCondString(SetCond(cond));
	insn->DisasmControl(buffer);
	
	DisasmSignWidth(sign, w32, buffer);

	buffer << " ";
	insn->DisasmDest(buffer, RegType(w32));

	buffer << ", ";
	insn->DisasmSrc1(buffer, RegType(w32));
	
	buffer << ", ";
	insn->DisasmSrc2(buffer, RegType(w32));
}

set_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	// dest = cond(a, b)
	reg_t a = insn->ReadSrc1(0, RegType(w32));
	reg_t b = insn->ReadSrc2(0, RegType(w32));
	
	reg_t output;
	VectorFlags<CONFIG> vf;

	vf = ComputePredSetI(output, a, b, SetCond(cond), sign, w32);
	
	insn->WriteDest(output, 0, RegType(w32));
	insn->SetPred(vf);
}

op min_full_normal( \
	/*subop*/5[3]:/*?*/0[1]:sign[1]:w32[1]:?[24]:/*marker*/0[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*f64*/0[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op min_full_end( \
	/*subop*/5[3]:/*?*/0[1]:sign[1]:w32[1]:?[24]:/*marker*/1[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*f64*/0[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op min_full_join( \
	/*subop*/5[3]:/*?*/0[1]:sign[1]:w32[1]:?[24]:/*marker*/2[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*f64*/0[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)



group min(min_full_normal, min_full_end, min_full_join)

min.disasm = {
	buffer << "min";
	insn->DisasmControl(buffer);
	DisasmSignWidth(sign, w32, buffer);

	buffer << " ";
	insn->DisasmDest(buffer, RegType(w32));

	buffer << ", ";
	insn->DisasmSrc1(buffer, RegType(w32));
	
	buffer << ", ";
	insn->DisasmSrc2(buffer, RegType(w32));
}

min.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	 assert(w32);	// TODO

	// dest = cond(a, b)
	reg_t a = insn->ReadSrc1(0, RegType(w32));
	reg_t b = insn->ReadSrc2(0, RegType(w32));
	
	reg_t output = Min(a, b, w32, sign);
	
	insn->WriteDest(output, 0, RegType(w32));
	insn->SetPredI32(output);
}



op nop_full_normal( \
	/*subop*/7[3]:/*?*/0[1]:?[26]:/*marker*/0[2]: \
	0xf[4]:?[28] \
)

op nop_full_end( \
	/*subop*/7[3]:/*?*/0[1]:?[26]:/*marker*/1[2]: \
	0xf[4]:?[28] \
)

op nop_full_join( \
	/*subop*/7[3]:/*?*/0[1]:?[26]:/*marker*/2[2]: \
	0xf[4]:?[28] \
)

group nop_full(nop_full_normal, nop_full_end, nop_full_join)

nop_full.disasm = {
	buffer << "nop";
	insn->DisasmControl(buffer);
}

nop_full.execute = {
}

