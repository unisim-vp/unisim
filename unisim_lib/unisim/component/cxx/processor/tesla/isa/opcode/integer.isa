/*
 *  Copyright (c) 2009,
 *  University of Perpignan (UPVD),
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of UPVD nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Sylvain Collange (sylvain.collange@univ-perp.fr)
 */


/***************************************************

	ARITHMETIC AND LOGICAL INSTRUCTIONS

****************************************************/


// TODO: no src1_neg if immediate!
// no, src1_neg, 32/16-bit instead??
op iadd_full_normal( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:src1_neg[1]:0[2]:?[22]:/*marker*/0[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*src2*/0[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op iadd_full_end( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:src1_neg[1]:0[2]:?[22]:/*marker*/1[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*src2*/0[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op iadd_full_join( \
	/*subop*/0[3]:/*?*/0[1]:sat[1]:src1_neg[1]:0[2]:?[22]:/*marker*/2[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*src2*/0[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)


group iadd_full(iadd_full_normal, iadd_full_end, iadd_full_join)

iadd_full.disasm = {
	buffer << "add";
	insn->DisasmControl(buffer);
	buffer << ".s32";	// TODO: unsigned ??
	if(sat)
		buffer << ".sat";
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	//DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer);
	
	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc3(buffer);
}

iadd_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a + c
	reg_t a = insn->ReadSrc1();
	reg_t c = insn->ReadSrc3();
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = cpu->I32Add(a, c, flags, sat, /*src1_neg*/0, src3_neg);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}

op iadd_full_imm( \
	/*subop*/0[3]:/*?*/0[1]:/*imm_hi*/?[26]:/*marker*/3[2]: \
	0x2[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*imm_lo*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

iadd_full_imm.disasm = {
	buffer << "add";
	insn->DisasmControl(buffer);
	buffer << ".s32";	// TODO: unsigned ??
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
//	DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer);
	
	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc2(buffer);
}

iadd_full_imm.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a + c
	reg_t a = insn->ReadSrc1();
	reg_t c = insn->ReadSrc2();
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = cpu->I32Add(a, c, flags, 0, /*src1_neg*/0, src3_neg);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}


op umad16_lo_full_normal( \
	/*subop*/0[3]:/*?*/0[1]:src3_neg[1]:src1_neg[1]:0[2]:?[22]:/*marker*/0[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src2*/?[7]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op umad16_lo_full_end( \
	/*subop*/0[3]:/*?*/0[1]:src3_neg[1]:src1_neg[1]:0[2]:?[22]:/*marker*/1[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src2*/?[7]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op umad16_lo_full_join( \
	/*subop*/0[3]:/*?*/0[1]:src3_neg[1]:src1_neg[1]:0[2]:?[22]:/*marker*/2[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src2*/?[7]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

group umad16_lo_full(umad16_lo_full_normal, umad16_lo_full_end, umad16_lo_full_join)

umad16_lo_full.disasm = {
	buffer << "umad16x16+32";
	insn->DisasmControl(buffer);
//	buffer << ".u32";
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	//DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer, RT_U16);	// 16-bit

	buffer << ", ";
	insn->DisasmSrc2(buffer, RT_U16);	// 16-bit
		
	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc3(buffer);
}

umad16_lo_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a * b + c
	reg_t a = insn->ReadSrc1(0, RT_U16);
	reg_t b = insn->ReadSrc2(0, RT_U16);
	reg_t c = insn->ReadSrc3();
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = cpu->UMad24(a, b, c, flags, src1_neg, src3_neg);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}

op umac16_lo_imm( \
	/*subop*/0[3]:/*?*/0[1]:/*imm_hi*/?[26]:/*marker*/3[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:src3_neg[1]:/*imm_lo*/?[6]:\
	/*src1*/?[7]:dest[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

umac16_lo_imm.disasm = {
	// r <- a * b + r
	buffer << "umac16x16+32";
//	buffer << ".u32";
		
	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	//DisasmSign(src1_neg, buffer);
	insn->DisasmSrc1(buffer, RT_U16);	// 16-bit

	buffer << ", ";
	DisasmSign(src3_neg, buffer);
	insn->DisasmSrc2(buffer, RT_U16);	// 16-bit
}

umac16_lo_imm.execute = {
	typedef VectorRegister<CONFIG> reg_t;

	// dest = a * b + c
	reg_t a = insn->ReadSrc1(0, RT_U16);
	reg_t b = insn->ReadSrc2(0, RT_U16);
	reg_t c = cpu->GetGPR(dest);
	
	VectorFlags<CONFIG> flags;
	
	reg_t output = cpu->UMad24(a, b, c, flags, /*src1_neg*/0, src3_neg);
	
	insn->WriteDest(output);
	insn->SetPredI32(output, flags);
}



op umad24_lo_full( \
	/*subop*/3[3]:/*?*/0[1]:src3_neg[1]:src1_neg[1]:0[2]:/*const_seg*/?[2]:/*src1_sh*/?[1]:/*src3*/?[7]: \
	/*pred_reg*/?[2]:/*pred_cond*/?[5]:/*set_pred*/?[1]:/*set_pred_reg*/?[2]:/*output*/?[1]:/*addr_hi*/?[1]:/*marker*/?[2]: \
	0x6[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src2*/?[7]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1]\
)




// No need to check for "immediate" marker,
// shift amount fits in 7 bits.
op shl_full( \
	/*subop*/6[3]:/*?*/0[1]:?[1]:u32[1]:0[2]:?[3]:/*imm*/0[1]:?[18]:/*marker*/?[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

op shl_full_imm2( \
	/*subop*/6[3]:/*?*/0[1]:?[1]:u32[1]:0[2]:?[3]:/*imm*/1[1]:?[18]:/*marker*/?[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:src2[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)


// TODO: end, join

//group shl_full(shl_full_normal)

//group shl_full_imm2(shl_full_imm2_normal)

shl_full.disasm = {
	buffer << "shl";
	insn->DisasmControl(buffer);

	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	insn->DisasmSrc1(buffer);
	
	buffer << ", ";
	insn->DisasmSrc2(buffer);
}

shl_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	assert(u32);

	// dest = a << c
	reg_t a = insn->ReadSrc1();
	reg_t c = insn->ReadSrc2();
	
	reg_t output = cpu->ShiftLeft(a, c);
	
	insn->WriteDest(output);
	insn->SetPredI32(output);
}

shl_full_imm2.disasm = {
	buffer << "shl";
	insn->DisasmControl(buffer);

	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	insn->DisasmSrc1(buffer);
	
	buffer << ", ";
	buffer << src2;
}

shl_full_imm2.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	assert(u32);

	// dest = a << c
	reg_t a = insn->ReadSrc1();
	reg_t c = reg_t(src2);
	
	reg_t output = cpu->ShiftLeft(a, c);
	
	insn->WriteDest(output);
	insn->SetPredI32(output);
}

// and, or, xor, 2nd

// TODO: forbid immediate

op and_full( \
	/*subop*/0[3]:/*?*/0[1]:?[1]:u32[1]:0[2]:?[3]:/*imm*/0[1]:0[2]:src1_not[1]:src2_not[1]:/*lop*/0[2]:?[12]:/*marker*/?[2]: \
	0xd[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*src3_neg*/?[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

and_full.disasm = {
	buffer << "and";
	insn->DisasmControl(buffer);

	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	insn->DisasmSrc1(buffer);
	
	buffer << ", ";
	insn->DisasmSrc2(buffer);
}

and_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	assert(u32);

	// dest = (neg?)a & (neg?)b
	reg_t a = insn->ReadSrc1();
	if(src1_not) {
		a = BinNeg(a);
	}
	reg_t b = insn->ReadSrc2();
	if(src2_not) {
		b = BinNeg(b);
	}
	
	reg_t output = BinAnd(a, b);
	
	insn->WriteDest(output);
	insn->SetPredI32(output);
}


op set_full( \
	/*subop*/3[3]:/*?*/0[1]:/*cvt_round_half*/0[1]:u32[1]:const_seg[4]:/*src1_sh*/?[1]:abs_sat[2]:cvt_round[2]:cond[3]:?[12]:/*marker*/?[2]: \
	0x3[4]:/*addr_lo*/?[2]:/*addr_imm*/?[1]:/*src3_cm*/?[1]:/*src2_cm*/?[1]:/*f64*/0[1]:/*src2*/?[6]:\
	/*src1*/?[7]:/*dest*/?[7]:/*flow*/0[1]:/*IWidth*/1[1] \
)

set_full.disasm = {
	buffer << "set.";
	buffer << SetCondString(SetCond(cond));
	insn->DisasmControl(buffer);
	buffer << ".u32";

	buffer << " ";
	insn->DisasmDest(buffer);

	buffer << ", ";
	insn->DisasmSrc1(buffer);
	
	buffer << ", ";
	insn->DisasmSrc2(buffer);
}

set_full.execute = {
	typedef VectorRegister<CONFIG> reg_t;
	
	assert(u32);	// TODO

	// dest = cond(a, b)
	reg_t a = insn->ReadSrc1();
	reg_t b = insn->ReadSrc2();
	
	reg_t output;
	VectorFlags<CONFIG> vf;
	// GRRRRR
//	vf = ComputePredSetI32<CONFIG>(output, a, b, cond);
	
	insn->WriteDest(output);
	insn->SetPred(vf);
}

op nop_full_normal( \
	/*subop*/7[3]:/*?*/0[1]:?[26]:/*marker*/0[2]: \
	0xf[4]:?[28] \
)

op nop_full_end( \
	/*subop*/7[3]:/*?*/0[1]:?[26]:/*marker*/1[2]: \
	0xf[4]:?[28] \
)

op nop_full_join( \
	/*subop*/7[3]:/*?*/0[1]:?[26]:/*marker*/2[2]: \
	0xf[4]:?[28] \
)

group nop_full(nop_full_normal, nop_full_end, nop_full_join)

nop_full.disasm = {
	buffer << "nop";
	insn->DisasmControl(buffer);
}

nop_full.execute = {
}
