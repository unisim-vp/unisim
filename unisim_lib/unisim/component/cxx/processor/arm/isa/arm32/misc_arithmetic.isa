/*
 *  Copyright (c) 2007-2013,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

       SATURATING ARITHMETIC INSTRUCTIONS

**********************************************/

impl {
#include "unisim/util/arithmetic/arithmetic.hh"

using unisim::util::arithmetic::SignedSatAdd32;
using unisim::util::arithmetic::SignedSatSub32;

};

/*******************************************************************
 * qadd instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qadd(cond[4]:0b00010000[8]:rn[4]:rd[4]:0[4]:0b0101[4]:rm[4]);

qadd.disasm = {
  buffer << "qadd" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qadd.execute = {
  uint8_t does_sat;
  uint32_t result;
  
  if (not CheckCondition(cpu, cond)) return;
  
  if(rd == cpu.PC_reg || rm == cpu.PC_reg || rn == cpu.PC_reg) {
    // unpredictable behavior, we do nothing
    return;
  }
  
  SignedSatAdd32(result, does_sat, cpu.GetGPR(rn) , cpu.GetGPR(rm));
  cpu.SetCPSR_Q(does_sat == 1 ? true : false);
  cpu.SetGPR(rd, result);
};

/*
 * end of qadd instruction
 *******************************************************************/

/*******************************************************************
 * qsub instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qsub(cond[4]:0b00010010[8]:rn[4]:rd[4]:/*sbz*/0[4]:0b0101[4]:rm[4]);

qsub.disasm = {
  buffer << "qsub" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qsub.execute = {
  uint8_t does_sat;
  uint32_t result;
  
  if (not CheckCondition(cpu, cond)) return;
  
  if(rd == cpu.PC_reg || rm == cpu.PC_reg || rn == cpu.PC_reg) {
    // unpredictable behavior, we do nothing
    return;
  }
  
  SignedSatSub32(result, does_sat, cpu.GetGPR(rm) , cpu.GetGPR(rn));
  cpu.SetCPSR_Q(does_sat == 1 ? true : false);
  cpu.SetGPR(rd, result);
};

/*
 * end of qsub instruction
 *******************************************************************/

/*******************************************************************
 * qdadd instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qdadd(cond[4]:0b00010100[8]:rn[4]:rd[4]:/*sbz*/0[4]:0b0101[4]:rm[4]);

qdadd.disasm = {
  buffer << "qdadd" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qdadd.execute = {
  uint8_t does_sat, does_sat_tmp;
  uint32_t result;
  
  if (not CheckCondition(cpu, cond)) return;
  
  if(rd == cpu.PC_reg || rm == cpu.PC_reg || rn == cpu.PC_reg) {
    // unpredictable behavior, we do nothing
    return;
  }
  
  SignedSatAdd32(result, does_sat_tmp, cpu.GetGPR(rn) , cpu.GetGPR(rn));
  SignedSatAdd32(result, does_sat, cpu.GetGPR(rm) , result);
  cpu.SetCPSR_Q(does_sat == 1 || does_sat_tmp == 1? true : false);
  cpu.SetGPR(rd, result);
};

/*
 * end of qdadd instruction
 *******************************************************************/

/*******************************************************************
 * qdsub instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qdsub(cond[4]:0b00010110[8]:rn[4]:rd[4]:/*sbz*/0[4]:0b0101[4]:rm[4]);

qdsub.disasm = {
  buffer << "qdsub" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qdsub.execute = {
  uint8_t does_sat, does_sat_tmp;
  uint32_t result;
  
  if (not CheckCondition(cpu, cond)) return;
  
  if(rd == cpu.PC_reg || rm == cpu.PC_reg || rn == cpu.PC_reg) {
    // unpredictable behavior, we do nothing
    return;
  }
  
  SignedSatAdd32(result, does_sat_tmp, cpu.GetGPR(rn) , cpu.GetGPR(rn));
  SignedSatSub32(result, does_sat, cpu.GetGPR(rm) , result);
  cpu.SetCPSR_Q(does_sat == 1 ? true : false);
  cpu.SetGPR(rd, result);
};

/*
 * end of qdsub instruction
 *******************************************************************/

/**********************************************

       HINTS INSTRUCTIONS

**********************************************/

/*******************************************************************
 * nop instruction
 */

op nop( cond[4]:0b0011[4]:0b0010[4]:0b0000[4]:/*sbo*/0b1111[4]:/*sbz*/0b0000[4]:idx[8] );

nop.disasm = {
  buffer << "nop" << DisasmCondition(cond) << "\t{" << idx << "}";
};

/*
 * end of nop instruction
 *******************************************************************/

/*******************************************************************
 * yield instruction
 */

op yield( cond[4]:0b0011[4]:0b0010[4]:0b0000[4]:/*sbo*/0b1111[4]:/*sbz*/0b0000[4]:1[8] );

yield.disasm = {
  buffer << "yield" << DisasmCondition(cond);
};

/*
 * end of yield instruction
 *******************************************************************/

/*******************************************************************
 * wfe instruction
 */

op wfe( cond[4]:0b0011[4]:0b0010[4]:0b0000[4]:/*sbo*/0b1111[4]:/*sbz*/0b0000[4]:2[8] );

wfe.disasm = {
  buffer << "wfe" << DisasmCondition(cond);
};

/*
 * end of wfe instruction
 *******************************************************************/

/*******************************************************************
 * wfi instruction
 */

op wfi( cond[4]:0b0011[4]:0b0010[4]:0b0000[4]:/*sbo*/0b1111[4]:/*sbz*/0b0000[4]:3[8] );

wfi.disasm = {
  buffer << "wfi" << DisasmCondition(cond);
};

/*
 * end of wfi instruction
 *******************************************************************/

/*******************************************************************
 * sev instruction
 */

op sev( cond[4]:0b0011[4]:0b0010[4]:0b0000[4]:/*sbo*/0b1111[4]:/*sbz*/0b0000[4]:4[8] );

sev.disasm = {
  buffer << "sev" << DisasmCondition(cond);
};

/*
 * end of sev instruction
 *******************************************************************/

/*******************************************************************
 * dbg instruction
 */

op dbg( cond[4]:0b0011[4]:0b0010[4]:0b0000[4]:/*sbo*/0b1111[4]:/*sbz*/0b0000[4]:0b1111[4]:idx[4] );

dbg.disasm = {
  buffer << "dbg" << DisasmCondition(cond) << '\t' << DisasmI(idx);
};

/*
 * end of dbg instruction
 *******************************************************************/

/**********************************************

       PACKING INSTRUCTIONS

**********************************************/

/*******************************************************************
 * pkh (Pack Halfword) instruction
 *
 * PKH combines one halfword of its first operand with the other
 * halfword of its shifted second operand.
 */

op pkh(cond[4]:0b01101000[8]:rn[4]:rd[4]:imm[5]:tb[1]:0b01[2]:rm[4]);

pkh.disasm = {
  buffer << "pkh" << (tb?"tb":"bt")<< DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( tb?2:0, imm );
};

/*
 * end of pkh instruction
 *******************************************************************/

/**********************************************

       TO SORT INSTRUCTIONS

**********************************************/

/*******************************************************************
 * sxtab16 (Signed Extend and Add Byte 16) instruction
 *
 * SXTAB16 extracts two 8-bit values from a register, sign-extends
 * them to 16 bits each, adds the results to two 16-bit values from
 * another register, and writes the final results to the destination
 * register. You can specify a rotation by 0, 8, 16, or 24 bits before
 * extracting the 8-bit values.
 */

op sxtab16(cond[4]:0b01101000[8]:rn[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

sxtab16.disasm = {
  buffer << "sxtab16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of sxtab16 instruction
 *******************************************************************/

/*******************************************************************
 * sxtb16 (Signed Extend Byte 16) instruction
 *  
 * SXTB16 extracts two 8-bit values from a register, sign-extends them
 * to 16 bits each, and writes the results to the destination
 * register. You can specify a rotation by 0, 8, 16, or 24 bits before
 * extracting the 8-bit values.
 */

op sxtb16(cond[4]:0b01101000[8]:0b1111[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

sxtb16.disasm = {
  buffer << "sxtb16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of sxtb16 instruction
 *******************************************************************/

/*******************************************************************
 * uxtab16 (Unsigned Extend and Add Byte 16) instruction
 *
 * UXTAB16 extracts two 8-bit values from a register, sign-extends
 * them to 16 bits each, adds the results to two 16-bit values from
 * another register, and writes the final results to the destination
 * register. You can specify a rotation by 0, 8, 16, or 24 bits before
 * extracting the 8-bit values.
 */

op uxtab16(cond[4]:0b01101100[8]:rn[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

uxtab16.disasm = {
  buffer << "uxtab16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of uxtab16 instruction
 *******************************************************************/

/*******************************************************************
 * uxtb16 (Unsigned Extend Byte 16) instruction
 *  
 * UXTB16 extracts two 8-bit values from a register, sign-extends them
 * to 16 bits each, and writes the results to the destination
 * register. You can specify a rotation by 0, 8, 16, or 24 bits before
 * extracting the 8-bit values.
 */

op uxtb16(cond[4]:0b01101100[8]:0b1111[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

uxtb16.disasm = {
  buffer << "uxtb16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of uxtb16 instruction
 *******************************************************************/

/*******************************************************************
 * sel (Select Bytes) instruction
 *
 * SEL selects each byte of its result from either its first operand
 * or its second operand, according to the values of the GE flags.
 */

op sel(cond[4]:0b01101000[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1011[4]:rm[4]);

sel.disasm = {
  buffer << "sel" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm);
};

/*
 * end of sel instruction
 *******************************************************************/

/*******************************************************************
 * ssat (Signed Saturate) instruction
 *  
 * SSAT saturates an optionally-shifted signed value to a selectable
 * signed range.  The Q flag is set if the operation saturates.
 */

op ssat(cond[4]:0b0110101[7]:sat_imm[5]:rd[4]:imm[5]:sh[1]:0b01[2]:rm[4]);

ssat.disasm = {
  buffer << "ssat" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmI(sat_imm+1) << ", "
         << DisasmRegister(rm) << DisasmShImm(sh?2:0,imm);
};

/*
 * end of ssat instruction
 *******************************************************************/

/*******************************************************************
 * ssat16 (Signed Saturate 16) instruction
 *  
 * SSAT16 saturates two signed 16-bit values to a selectable signed
 * range.  The Q flag is set if the operation saturates.
 */

op ssat16(cond[4]:0b01101010[8]:sat_imm[4]:rd[4]:/*sbo*/0b1111[4]:0b0011[4]:rm[4]);

ssat16.disasm = {
  buffer << "ssat16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmI(sat_imm+1) << ", " << DisasmRegister(rm);
};

/*
 * end of ssat16 instruction
 *******************************************************************/

/*******************************************************************
 * usat (Unsigned Saturate) instruction
 *  
 * USAT saturates an optionally-shifted unsigned value to a selectable
 * unsigned range.  The Q flag is set if the operation saturates.
 */

op usat(cond[4]:0b0110111[7]:sat_imm[5]:rd[4]:imm[5]:sh[1]:0b01[2]:rm[4]);

usat.disasm = {
  buffer << "usat" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmI(sat_imm) << ", "
         << DisasmRegister(rm) << DisasmShImm(sh?2:0,imm);
};

/*
 * end of usat instruction
 *******************************************************************/

/*******************************************************************
 * usat16 (Unsigned Saturate 16) instruction
 *  
 * USAT16 saturates two unsigned 16-bit values to a selectable unsigned
 * range.  The Q flag is set if the operation saturates.
 */

op usat16(cond[4]:0b01101110[8]:sat_imm[4]:rd[4]:/*sbo*/0b1111[4]:0b0011[4]:rm[4]);

usat16.disasm = {
  buffer << "usat16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmI(sat_imm) << ", " << DisasmRegister(rm);
};

/*
 * end of usat16 instruction
 *******************************************************************/

/*******************************************************************
 * sxtab (Signed Extend and Add Byte) instruction
 *
 * SXTAB extracts an 8-bit value from a register, sign-extends it to
 * 32 bits, adds the result to the value in another register, and
 * writes the final result to the destination register. You can
 * specify a rotation by 0, 8, 16, or 24 bits before extracting the
 * 8-bit value.
 */

op sxtab(cond[4]:0b01101010[8]:rn[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

sxtab.disasm = {
  buffer << "sxtab" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of sxtab instruction
 *******************************************************************/

/*******************************************************************
 * sxtb (Signed Extend Byte 16) instruction
 *  
 * SXTB extracts two 8-bit values from a register, sign-extends them
 * to 16 bits each, and writes the results to the destination
 * register. You can specify a rotation by 0, 8, 16, or 24 bits before
 * extracting the 8-bit values.
 */

op sxtb(cond[4]:0b01101010[8]:0b1111[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

sxtb.disasm = {
  buffer << "sxtb" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of sxtb instruction
 *******************************************************************/

/*******************************************************************
 * sxtah (Signed Extend and Add Halfword) instruction
 *  
 * SXTAH extracts a 16-bit value from a register, sign-extends it to
 * 32 bits, adds the result to a value from another register, and
 * writes the final result to the destination register. You can
 * specify a rotation by 0, 8, 16, or 24 bits before extracting the
 * 16-bit value.
 */

op sxtah(cond[4]:0b01101011[8]:rn[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

sxtah.disasm = {
  buffer << "sxtah" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of sxtah instruction
 *******************************************************************/

/*******************************************************************
 * sxth (Signed Extend Halfword) instruction
 */

op sxth(cond[4]:0b01101011[8]:0b1111[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

sxth.disasm = {
  buffer << "sxth" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of sxth instruction
 *******************************************************************/

/*******************************************************************
 * uxtab (Signed Extend and Add Byte) instruction
 *
 * UXTAB extracts an 8-bit value from a register, sign-extends it to
 * 32 bits, adds the result to the value in another register, and
 * writes the final result to the destination register. You can
 * specify a rotation by 0, 8, 16, or 24 bits before extracting the
 * 8-bit value.
 */

op uxtab(cond[4]:0b01101110[8]:rn[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

uxtab.disasm = {
  buffer << "uxtab" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of uxtab instruction
 *******************************************************************/

/*******************************************************************
 * uxtb (Signed Extend Byte 16) instruction
 *  
 * UXTB extracts two 8-bit values from a register, sign-extends them
 * to 16 bits each, and writes the results to the destination
 * register. You can specify a rotation by 0, 8, 16, or 24 bits before
 * extracting the 8-bit values.
 */

op uxtb(cond[4]:0b01101110[8]:0b1111[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

uxtb.disasm = {
  buffer << "uxtb" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of uxtb instruction
 *******************************************************************/

/*******************************************************************
 * uxtah (Signed Extend and Add Halfword) instruction
 *  
 * UXTAH extracts a 16-bit value from a register, sign-extends it to
 * 32 bits, adds the result to a value from another register, and
 * writes the final result to the destination register. You can
 * specify a rotation by 0, 8, 16, or 24 bits before extracting the
 * 16-bit value.
 */

op uxtah(cond[4]:0b01101111[8]:rn[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

uxtah.disasm = {
  buffer << "uxtah" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of uxtah instruction
 *******************************************************************/

/*******************************************************************
 * uxth (Signed Extend Halfword) instruction
 */

op uxth(cond[4]:0b01101111[8]:0b1111[4]:rd[4]:rotate[2]:/*sbz*/0b00[2]:0b0111[4]:rm[4]);

uxth.disasm = {
  buffer << "uxth" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( rotate?3:0, (rotate<<3) );
};

/*
 * end of uxth instruction
 *******************************************************************/

/*******************************************************************
 * usad8 (Unsigned Sum of Absolute Differences) instruction
 *
 * USAD8 performs four unsigned 8-bit subtractions, and adds the
 * absolute values of the differences together.
 */

op usad8(cond[4]:0b01111000[8]:rd[4]:0b1111[4]:rm[4]:0b0001[4]:rn[4]);

usad8.disasm = {
  buffer << "usad8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of usad8 instruction
 *******************************************************************/

/*******************************************************************
 * usada8 (Unsigned Sum of Absolute Differences and Accumulate) instruction
 *
 */

op usada8(cond[4]:0b01111000[8]:rd[4]:ra[4]:rm[4]:0b0001[4]:rn[4]);

usada8.disasm = {
  buffer << "usada8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn)
         << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

/*
 * end of usada8 instruction
 *******************************************************************/

/*******************************************************************
 * sbfx (Signed Bit Field Extract) instruction
 *
 * SBFX extracts any number of adjacent bits at any position from a
 * register, sign-extends them to 32 bits, and writes the result to
 * the destination register.
 */

op sbfx(cond[4]:0b01111[5]:0[1]:1[1]:widthm1[5]:rd[4]:lsb[5]:0b101[3]:rn[4]);

sbfx.disasm = {
  buffer << "sbfx" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn)
         << ", " << DisasmI(lsb) << ", " << DisasmI(widthm1+1);
};

/*
 * end of sbfx instruction
 *******************************************************************/

/*******************************************************************
 * bfi (Bit Field Insert) instruction
 * 
 * BFI copies any number of low order bits from a register into the
 * same number of adjacent bits at any position in the destination
 * register.
 */

op bfi(cond[4]:0b0111110[7]:msb[5]:rd[4]:lsb[5]:0b001[3]:rn[4]);

bfi.disasm = {
  if (lsb <= msb) {
    buffer << "bfi"  << DisasmCondition(cond) << '\t'
           << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
           << DisasmI(lsb) << ", " << DisasmI(msb-lsb+1);
  } else {
    buffer << "bfi"  << DisasmCondition(cond) << '\t'
           << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
           << "(invalid: " << lsb << ':' << msb << ")";
  }
};

/*
 * end of bfi instruction
 *******************************************************************/

/*******************************************************************
 * bfc (Bit Field Clear) instruction
 *
 * BFC clears any number of adjacent bits at any position in a
 * register, without affecting the other bits in the register.
 */

op bfc(cond[4]:0b0111110[7]:msb[5]:rd[4]:lsb[5]:0b001[3]:0b1111[4]);

bfc.disasm = {
  if (lsb <= msb) {
    buffer << "bfc"  << DisasmCondition(cond) << '\t'
           << DisasmRegister(rd) << ", " << DisasmI(lsb) << ", " << DisasmI(msb-lsb+1);
  } else {
    buffer << "bfc"  << DisasmCondition(cond) << '\t'
           << DisasmRegister(rd) << ", " << "(invalid: " << lsb << ':' << msb << ")";
  }
};

/*
 * end of bfc instruction
 *******************************************************************/

/*******************************************************************
 * ubfx (Unsigned Bit Field Extract) instruction
 *
 * UBFX extracts any number of adjacent bits at any position from a
 * register, zero-extends them to 32 bits, and writes the result to
 * the destination register.
 */

op ubfx(cond[4]:0b01111[5]:1[1]:1[1]:widthm1[5]:rd[4]:lsb[5]:0b101[3]:rn[4]);

ubfx.disasm = {
  buffer << "ubfx" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn)
         << ", " << DisasmI(lsb) << ", " << DisasmI(widthm1+1);
};

/*
 * end of ubfx instruction
 *******************************************************************/

/*******************************************************************
 * sadd16 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op sadd16(cond[4]:0b01100001[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0001[4]:rm[4]);

sadd16.disasm = {
  buffer << "sadd16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of sadd16 instruction
 *******************************************************************/

/*******************************************************************
 * sadd8 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op sadd8(cond[4]:0b01100001[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rm[4]);

sadd8.disasm = {
  buffer << "sadd8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of sadd8 instruction
 *******************************************************************/

/*******************************************************************
 * ssub16 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op ssub16(cond[4]:0b01100001[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0111[4]:rm[4]);

ssub16.disasm = {
  buffer << "ssub16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of ssub16 instruction
 *******************************************************************/

/*******************************************************************
 * ssub8 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op ssub8(cond[4]:0b01100001[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1111[4]:rm[4]);

ssub8.disasm = {
  buffer << "ssub8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of ssub8 instruction
 *******************************************************************/

/*******************************************************************
 * sasx instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op sasx(cond[4]:0b01100001[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0011[4]:rm[4]);

sasx.disasm = {
  buffer << "sasx" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of sasx instruction
 *******************************************************************/

/*******************************************************************
 * ssax instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op ssax(cond[4]:0b01100001[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0101[4]:rm[4]);

ssax.disasm = {
  buffer << "ssax" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of ssax instruction
 *******************************************************************/

/*******************************************************************
 * shadd16 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op shadd16(cond[4]:0b01100011[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0001[4]:rm[4]);

shadd16.disasm = {
  buffer << "shadd16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of shadd16 instruction
 *******************************************************************/

/*******************************************************************
 * shasx instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op shasx(cond[4]:0b01100011[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0011[4]:rm[4]);

shasx.disasm = {
  buffer << "shasx" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of shasx instruction
 *******************************************************************/

/*******************************************************************
 * shsax instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op shsax(cond[4]:0b01100011[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0101[4]:rm[4]);

shsax.disasm = {
  buffer << "shsax" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of shsax instruction
 *******************************************************************/

/*******************************************************************
 * shsub16 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op shsub16(cond[4]:0b01100011[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0111[4]:rm[4]);

shsub16.disasm = {
  buffer << "shsub16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of shsub16 instruction
 *******************************************************************/

/*******************************************************************
 * shadd8 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op shadd8(cond[4]:0b01100011[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rm[4]);

shadd8.disasm = {
  buffer << "shadd8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of shadd8 instruction
 *******************************************************************/

/*******************************************************************
 * shsub8 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op shsub8(cond[4]:0b01100011[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1111[4]:rm[4]);

shsub8.disasm = {
  buffer << "shsub8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of shsub8 instruction
 *******************************************************************/

/*******************************************************************
 * uadd16 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op uadd16(cond[4]:0b01100101[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0001[4]:rm[4]);

uadd16.disasm = {
  buffer << "uadd16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uadd16 instruction
 *******************************************************************/

/*******************************************************************
 * uasx instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op uasx(cond[4]:0b01100101[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0011[4]:rm[4]);

uasx.disasm = {
  buffer << "uasx" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uasx instruction
 *******************************************************************/

/*******************************************************************
 * usax instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op usax(cond[4]:0b01100101[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0101[4]:rm[4]);

usax.disasm = {
  buffer << "usax" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of usax instruction
 *******************************************************************/

/*******************************************************************
 * usub16 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op usub16(cond[4]:0b01100101[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0111[4]:rm[4]);

usub16.disasm = {
  buffer << "usub16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of usub16 instruction
 *******************************************************************/

/*******************************************************************
 * uadd8 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op uadd8(cond[4]:0b01100101[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rm[4]);

uadd8.disasm = {
  buffer << "uadd8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uadd8 instruction
 *******************************************************************/

/*******************************************************************
 * usub8 instruction
 */

{ STATE::MODEL == ARMV7 }:                                              \
op usub8(cond[4]:0b01100101[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1111[4]:rm[4]);

usub8.disasm = {
  buffer << "usub8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of usub8 instruction
 *******************************************************************/

/*******************************************************************
 * qadd16 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qadd16(cond[4]:0b01100010[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0001[4]:rm[4]);

qadd16.disasm = {
  buffer << "qadd16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of qadd16 instruction
 *******************************************************************/

/*******************************************************************
 * qasx instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qasx(cond[4]:0b01100010[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0011[4]:rm[4]);

qasx.disasm = {
  buffer << "qasx" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of qasx instruction
 *******************************************************************/

/*******************************************************************
 * qsax instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qsax(cond[4]:0b01100010[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0101[4]:rm[4]);

qsax.disasm = {
  buffer << "qsax" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of qsax instruction
 *******************************************************************/

/*******************************************************************
 * qsub16 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qsub16(cond[4]:0b01100010[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0111[4]:rm[4]);

qsub16.disasm = {
  buffer << "qsub16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of qsub16 instruction
 *******************************************************************/

/*******************************************************************
 * qadd8 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qadd8(cond[4]:0b01100010[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rm[4]);

qadd8.disasm = {
  buffer << "qadd8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of qadd8 instruction
 *******************************************************************/

/*******************************************************************
 * qsub8 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op qsub8(cond[4]:0b01100010[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1111[4]:rm[4]);

qsub8.disasm = {
  buffer << "qsub8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of qsub8 instruction
 *******************************************************************/

/*******************************************************************
 * uqadd16 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uqadd16(cond[4]:0b01100110[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0001[4]:rm[4]);

uqadd16.disasm = {
  buffer << "uqadd16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uqadd16 instruction
 *******************************************************************/

/*******************************************************************
 * uqasx instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uqasx(cond[4]:0b01100110[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0011[4]:rm[4]);

uqasx.disasm = {
  buffer << "uqasx" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uqasx instruction
 *******************************************************************/

/*******************************************************************
 * uqsax instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uqsax(cond[4]:0b01100110[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0101[4]:rm[4]);

uqsax.disasm = {
  buffer << "uqsax" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uqsax instruction
 *******************************************************************/

/*******************************************************************
 * uqsub16 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uqsub16(cond[4]:0b01100110[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0111[4]:rm[4]);

uqsub16.disasm = {
  buffer << "uqsub16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uqsub16 instruction
 *******************************************************************/

/*******************************************************************
 * uqadd8 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uqadd8(cond[4]:0b01100110[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rm[4]);

uqadd8.disasm = {
  buffer << "uqadd8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uqadd8 instruction
 *******************************************************************/

/*******************************************************************
 * uqsub8 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uqsub8(cond[4]:0b01100110[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1111[4]:rm[4]);

uqsub8.disasm = {
  buffer << "uqsub8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uqsub8 instruction
 *******************************************************************/

/*******************************************************************
 * uhadd16 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uhadd16(cond[4]:0b01100111[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0001[4]:rm[4]);

uhadd16.disasm = {
  buffer << "uhadd16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uhadd16 instruction
 *******************************************************************/

/*******************************************************************
 * uhasx instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uhasx(cond[4]:0b01100111[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0011[4]:rm[4]);

uhasx.disasm = {
  buffer << "uhasx" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uhasx instruction
 *******************************************************************/

/*******************************************************************
 * uhsax instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uhsax(cond[4]:0b01100111[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0101[4]:rm[4]);

uhsax.disasm = {
  buffer << "uhsax" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uhsax instruction
 *******************************************************************/

/*******************************************************************
 * uhsub16 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uhsub16(cond[4]:0b01100111[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b0111[4]:rm[4]);

uhsub16.disasm = {
  buffer << "uhsub16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uhsub16 instruction
 *******************************************************************/

/*******************************************************************
 * uhadd8 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uhadd8(cond[4]:0b01100111[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rm[4]);

uhadd8.disasm = {
  buffer << "uhadd8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uhadd8 instruction
 *******************************************************************/

/*******************************************************************
 * uhsub8 instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op uhsub8(cond[4]:0b01100111[8]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1111[4]:rm[4]);

uhsub8.disasm = {
  buffer << "uhsub8" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of uhsub8 instruction
 *******************************************************************/
