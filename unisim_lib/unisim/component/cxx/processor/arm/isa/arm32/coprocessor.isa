/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 */
 
/**********************************************

         COPROCESSOR INSTRUCTIONS

**********************************************/

/*******************************************************************
 * cdp instruction
 */

op cdp(cond[4]:0b1110[4]:op1[4]:crn[4]:crd[4]:cp_num[4]:op2[3]:0b0[1]:crm[4])

cdp.disasm = {
	buffer << "cdp";
	buffer << DisasmCondition(cond);
	buffer << " " << dec << (unsigned int) cp_num;
	buffer << ", " << dec << (unsigned int) op1;
	buffer << ", cr" << dec << (unsigned int) crd;
	buffer << ", cr" << dec << (unsigned int) crn;
	buffer << ", cr" << dec << (unsigned int) crm;
	buffer << ", " << dec << (unsigned int) op2;
}

cdp.execute = {
	if(not CheckCondition(cpu, cond)) return;
	
	cpu.CoprocessorDataProcess(cp_num, op1, op2, crd, crn, crm);
}

/*
 * end of cdp instruction
 *******************************************************************/

/*******************************************************************
 * ldc instruction
 */

op ldc_offset(cond[4]:0b110[3]:/*p*/0b1[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b0[1]:0b1[1]:rn[4]:crd[4]:cp_num[4]:offset[8])

op ldc_pre(cond[4]:0b110[3]:/*p*/0b1[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b1[1]:0b1[1]:rn[4]:crd[4]:cp_num[4]:offset[8])

op ldc_post(cond[4]:0b110[3]:/*p*/0b0[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b1[1]:0b1[1]:rn[4]:crd[4]:cp_num[4]:offset[8])

op ldc_unindexed(cond[4]:0b110[3]:/*p*/0b0[1]:/*u*/0b1[1]:/*n*/n[1]:/*w*/0b0[1]:0b1[1]:rn[4]:crd[4]:cp_num[4]:option[8])

ldc_offset.disasm = {
	buffer << "ldc";
	buffer << DisasmCondition(cond);
	if(n == 1) buffer << "l";
	buffer << " " << (unsigned int) cp_num;
	buffer << ", cr" << (unsigned int) crd;
	buffer << ", ";
	DisasmCLSImm_offset(u, rn, offset, buffer);
}

ldc_pre.disasm = {
	buffer << "ldc";
	buffer << DisasmCondition(cond);
	if(n == 1) buffer << "l";
	buffer << " " << (unsigned int) cp_num;
	buffer << ", cr" << (unsigned int) crd;
	buffer << ", ";
	DisasmCLSImm_pre(u, rn, offset, buffer);
}

ldc_post.disasm = {
	buffer << "ldc";
	buffer << DisasmCondition(cond);
	if(n == 1) buffer << "l";
	buffer << " " << (unsigned int) cp_num;
	buffer << ", cr" << (unsigned int) crd;
	buffer << ", ";
	DisasmCLSImm_post(u, rn, offset, buffer);
}

ldc_unindexed.disasm = {
	buffer << "ldc";
	buffer << DisasmCondition(cond);
	if(n == 1) buffer << "l";
	buffer << " " << (unsigned int) cp_num;
	buffer << ", cr" << (unsigned int) crd;
	buffer << ", ";
	DisasmCLSUnindexed(rn, option, buffer);
}

ldc_offset.execute = {
	if(not CheckCondition(cpu, cond)) return;
	
	uint32_t address = CLSOpDec(u, cpu.GetGPR(rn), offset);
	while(cpu.CoprocessorLoad(cp_num, address)) {
		address += 4;
	}
}

ldc_pre.execute = {
	if(not CheckCondition(cpu, cond)) return;
        
	uint32_t address = CLSOpDec(u, cpu.GetGPR(rn), offset);
	cpu.SetGPR(rn, address);
	while(cpu.CoprocessorLoad(cp_num, address)) {
		address += 4;
	}
}

ldc_post.execute = {
	if(not CheckCondition(cpu, cond)) return;
	
	uint32_t address = cpu.GetGPR(rn);
	cpu.SetGPR(rn, CLSOpDec(u, address, offset));
	while(cpu.CoprocessorLoad(cp_num, address)) {
		address += 4;
	}
}

ldc_unindexed.execute = {
	if(not CheckCondition(cpu, cond)) return;
	
	uint32_t address = cpu.GetGPR(rn);
	while(cpu.CoprocessorLoad(cp_num, address, option)) {
		address += 4;
	}
}

/*
 * end of ldc instruction
 *******************************************************************/

/*******************************************************************
 * mcr instruction
 */

op mcr(cond[4]:0b1110[4]:op1[3]:0b0[1]:crn[4]:rd[4]:cp_num[4]:op2[3]:0b1[1]:crm[4])

mcr.disasm = {
	buffer << "mcr";
	buffer << DisasmCondition(cond);
	buffer << " " << (unsigned int) cp_num;
	buffer << ", " << (unsigned int) op1;
	buffer << ", r" << (unsigned int) rd;
	buffer << ", cr" << (unsigned int) crn;
	buffer << ", cr" << (unsigned int) crm;
	if(op2 != 0) buffer << ", " << (unsigned int) op2;
}

mcr.execute = {
	if(not CheckCondition(cpu, cond)) return;

	cpu.MoveToCoprocessor(cp_num, op1, op2, rd, crn, crm);
}

/*
 * end of mcr instruction
 *******************************************************************/

/*******************************************************************
 * mrc instruction
 */

op mrc(cond[4]:0b1110[4]:op1[3]:0b1[1]:crn[4]:rd[4]:cp_num[4]:op2[3]:0b1[1]:crm[4])

mrc.disasm = {
	buffer << "mrc";
	buffer << DisasmCondition(cond);
	buffer << " " << (unsigned int) cp_num;
	buffer << ", " << (unsigned int) op1;
	buffer << ", r" << (unsigned int) rd;
	buffer << ", cr" << (unsigned int) crn;
	buffer << ", cr" << (unsigned int) crm;
	if(op2 != 0) buffer << ", " << (unsigned int) op2;
}

mrc.execute = {
	if(not CheckCondition(cpu, cond)) return;

	cpu.MoveFromCoprocessor(cp_num, op1, op2, rd, crn, crm);
}

/*
 * end of mrc instruction
 *******************************************************************/

/*******************************************************************
 * stc instruction
 */

op stc_offset(cond[4]:0b110[3]:/*p*/0b1[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b0[1]:0b0[1]:rn[4]:crd[4]:cp_num[4]:offset[8])

op stc_pre(cond[4]:0b110[3]:/*p*/0b1[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b1[1]:0b0[1]:rn[4]:crd[4]:cp_num[4]:offset[8])

op stc_post(cond[4]:0b110[3]:/*p*/0b0[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b1[1]:0b0[1]:rn[4]:crd[4]:cp_num[4]:offset[8]);

op stc_unindexed(cond[4]:0b110[3]:/*p*/0b0[1]:/*u*/0b1[1]:/*n*/n[1]:/*w*/0b0[1]:0b0[1]:rn[4]:crd[4]:cp_num[4]:option[8])

stc_offset.disasm = {
	buffer << "stc";
	buffer << DisasmCondition(cond);
	if(n == 1) buffer << "l";
	buffer << " " << (unsigned int) cp_num;
	buffer << ", cr" << (unsigned int) crd;
	buffer << ", ";
	DisasmCLSImm_offset(u, rn, offset, buffer);
}

stc_pre.disasm = {
	buffer << "stc";
	buffer << DisasmCondition(cond);
	if(n == 1) buffer << "l";
	buffer << " " << (unsigned int) cp_num;
	buffer << ", cr" << (unsigned int) crd;
	buffer << ", ";
	DisasmCLSImm_pre(u, rn, offset, buffer);
}

stc_post.disasm = {
	buffer << "stc";
	buffer << DisasmCondition(cond);
	if(n == 1) buffer << "l";
	buffer << " " << (unsigned int) cp_num;
	buffer << ", cr" << (unsigned int) crd;
	buffer << ", ";
	DisasmCLSImm_post(u, rn, offset, buffer);
}

stc_unindexed.disasm = {
	buffer << "stc";
	buffer << DisasmCondition(cond);
	if(n == 1) buffer << "l";
	buffer << " " << (unsigned int) cp_num;
	buffer << ", cr" << (unsigned int) crd;
	buffer << ", ";
	DisasmCLSUnindexed(rn, option, buffer);
}

stc_offset.execute = {
	if(not CheckCondition(cpu, cond)) return;
	
	uint32_t address = CLSOpDec(u, cpu.GetGPR(rn), offset);
	while(cpu.CoprocessorStore(cp_num, address)) {
		address += 4;
	}
}

stc_pre.execute = {
	if(not CheckCondition(cpu, cond)) return;
	
	uint32_t address = CLSOpDec(u, cpu.GetGPR(rn), offset);
	cpu.SetGPR(rn, address);
	while(cpu.CoprocessorStore(cp_num, address)) {
		address += 4;
	}
}

stc_post.execute = {
	if(not CheckCondition(cpu, cond)) return;
	
	uint32_t address = cpu.GetGPR(rn);
	cpu.SetGPR(rn, CLSOpDec(u, address, offset));
	while(cpu.CoprocessorStore(cp_num, address)) {
		address += 4;
	}
}

stc_unindexed.execute = {
	if(not CheckCondition(cpu, cond)) return;
	
	uint32_t address = cpu.GetGPR(rn);
	while(cpu.CoprocessorStore(cp_num, address, option)) {
		address += 4;
	}
}

/*
 * end of stc instruction
 *******************************************************************/

/*******************************************************************
 * cdp2 instruction
 */

{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op cdp2(0b1111[4]:0b1110[4]:op1[4]:crn[4]:crd[4]:cp_num[4]:op2[3]:0b0[1]:crm[4])

cdp2.disasm = {
	buffer << "cdp2";
	buffer << " " << dec << (unsigned int) cp_num;
	buffer << ", " << dec << (unsigned int) op1;
	buffer << ", cr" << dec << (unsigned int) crd;
	buffer << ", cr" << dec << (unsigned int) crn;
	buffer << ", cr" << dec << (unsigned int) crm;
	buffer << ", " << dec << (unsigned int) op2;
}

cdp2.execute = {

	cpu.CoprocessorDataProcess(cp_num, op1, op2, crd, crn, crm);
}

/*
 * end of cdp2 instruction
 *******************************************************************/

/*******************************************************************
 * ldc2 instruction
 */

{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op ldc2_offset(0b1111[4]:0b110[3]:/*p*/0b1[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b0[1]:0b1[1]:rn[4]:crd[4]:cp_num[4]:offset[8])
{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op ldc2_pre(0b1111[4]:0b110[3]:/*p*/0b1[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b1[1]:0b1[1]:rn[4]:crd[4]:cp_num[4]:offset[8])
{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op ldc2_post(0b1111[4]:0b110[3]:/*p*/0b0[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b1[1]:0b1[1]:rn[4]:crd[4]:cp_num[4]:offset[8])
{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op ldc2_unindexed(0b1111[4]:0b110[3]:/*p*/0b0[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b0[1]:0b1[1]:rn[4]:crd[4]:cp_num[4]:option[8])

ldc2_offset.disasm = {
  buffer << "ldc";
  if(n == 1) buffer << "l";
  buffer << " " << (unsigned int) cp_num;
  buffer << ", cr" << (unsigned int) crd;
  buffer << ", ";
  DisasmCLSImm_offset(u, rn, offset, buffer);
}

ldc2_pre.disasm = {
  buffer << "ldc";
  if(n == 1) buffer << "l";
  buffer << " " << (unsigned int) cp_num;
  buffer << ", cr" << (unsigned int) crd;
  buffer << ", ";
  DisasmCLSImm_pre(u, rn, offset, buffer);
}

ldc2_post.disasm = {
  buffer << "ldc";
  if(n == 1) buffer << "l";
  buffer << " " << (unsigned int) cp_num;
  buffer << ", cr" << (unsigned int) crd;
  buffer << ", ";
  DisasmCLSImm_post(u, rn, offset, buffer);
}

ldc2_unindexed.disasm = {
	buffer << "ldc";
	if(n == 1) buffer << "l";
	buffer << " " << (unsigned int) cp_num;
	buffer << ", cr" << (unsigned int) crd;
	buffer << ", ";
	DisasmCLSUnindexed(rn, option, buffer);
}

ldc2_offset.execute = {
	uint32_t address = CLSOpDec(u, cpu.GetGPR(rn), offset);
	while(cpu.CoprocessorLoad(cp_num, address)) {
		address += 4;
	}
}

ldc2_pre.execute = {
	uint32_t address = CLSOpDec(u, cpu.GetGPR(rn), offset);
	cpu.SetGPR(rn, address);
	while(cpu.CoprocessorLoad(cp_num, address)) {
		address += 4;
	}
}

ldc2_post.execute = {
	uint32_t address = cpu.GetGPR(rn);
	cpu.SetGPR(rn, CLSOpDec(u, address, offset));
	while(cpu.CoprocessorLoad(cp_num, address)) {
		address += 4;
	}
}

ldc2_unindexed.execute = {
	uint32_t address = cpu.GetGPR(rn);
	while(cpu.CoprocessorLoad(cp_num, address, option)) {
		address += 4;
	}
}

/*
 * end of ldc2 instruction
 *******************************************************************/

/*******************************************************************
 * mcr2 instruction
 */

{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op mcr2(0b1111[4]:0b1110[4]:op1[3]:0b0[1]:crn[4]:rd[4]:cp_num[4]:op2[3]:0b1[1]:crm[4])

mcr2.disasm = {
  buffer << "mcr2";
  buffer << " " << (unsigned int) cp_num;
  buffer << ", " << (unsigned int) op1;
  buffer << ", r" << (unsigned int) rd;
  buffer << ", cr" << (unsigned int) crn;
  buffer << ", cr" << (unsigned int) crm;
  if(op2 != 0) buffer << ", " << (unsigned int) op2;
}

mcr2.execute = {
	cpu.MoveToCoprocessor(cp_num, op1, op2, rd, crn, crm);
}

/*
 * end of mcr2 instruction
 *******************************************************************/

/*******************************************************************
 * mrc2 instruction
 */

{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op mrc2(0b1111[4]:0b1110[4]:op1[3]:0b1[1]:crn[4]:rd[4]:cp_num[4]:op2[3]:0b1[1]:crm[4])

mrc2.disasm = {
  buffer << "mrc2";
  buffer << " " << (unsigned int) cp_num;
  buffer << ", " << (unsigned int) op1;
  buffer << ", r" << (unsigned int) rd;
  buffer << ", cr" << (unsigned int) crn;
  buffer << ", cr" << (unsigned int) crm;
  if(op2 != 0) buffer << ", " << (unsigned int) op2;
}

mrc2.execute = {

	cpu.MoveFromCoprocessor(cp_num, op1, op2, rd, crn, crm);
}

/*
 * end of mrc2 instruction
 *******************************************************************/

/*******************************************************************
 * stc2 instruction
 */

{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op stc2_offset(0b1111[4]:0b110[3]:/*p*/0b1[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b0[1]:0b0[1]:rn[4]:crd[4]:cp_num[4]:offset[8])
{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op stc2_pre(0b1111[4]:0b110[3]:/*p*/0b1[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b1[1]:0b0[1]:rn[4]:crd[4]:cp_num[4]:offset[8])
{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op stc2_post(0b1111[4]:0b110[3]:/*p*/0b0[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b1[1]:0b0[1]:rn[4]:crd[4]:cp_num[4]:offset[8])
{ STATE::MODEL == ARMV5T ||
  STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op stc2_unindexed(0b1111[4]:0b110[3]:/*p*/0b0[1]:/*u*/u[1]:/*n*/n[1]:/*w*/0b0[1]:0b0[1]:rn[4]:crd[4]:cp_num[4]:option[8])

stc2_offset.disasm = {
  buffer << "stc";
  if(n == 1) buffer << "l";
  buffer << " " << (unsigned int) cp_num;
  buffer << ", cr" << (unsigned int) crd;
  buffer << ", ";
  DisasmCLSImm_offset(u, rn, offset, buffer);
}

stc2_pre.disasm = {
  buffer << "stc";
  if(n == 1) buffer << "l";
  buffer << " " << (unsigned int) cp_num;
  buffer << ", cr" << (unsigned int) crd;
  buffer << ", ";
  DisasmCLSImm_pre(u, rn, offset, buffer);
}

stc2_post.disasm = {
  buffer << "stc";
  if(n == 1) buffer << "l";
  buffer << " " << (unsigned int) cp_num;
  buffer << ", cr" << (unsigned int) crd;
  buffer << ", ";
  DisasmCLSImm_post(u, rn, offset, buffer);
}

stc2_unindexed.disasm = {
  buffer << "stc";
  if(n == 1) buffer << "l";
  buffer << " " << (unsigned int) cp_num;
  buffer << ", cr" << (unsigned int) crd;
  buffer << ", ";
  DisasmCLSUnindexed(rn, option, buffer);
}

stc2_offset.execute = {
	uint32_t address = CLSOpDec(u, cpu.GetGPR(rn), offset);
	while(cpu.CoprocessorStore(cp_num, address)) {
		address += 4;
	}
}

stc2_pre.execute = {
	uint32_t address = CLSOpDec(u, cpu.GetGPR(rn), offset);
	cpu.SetGPR(rn, address);
	while(cpu.CoprocessorStore(cp_num, address)) {
		address += 4;
	}
}

stc2_post.execute = {
	uint32_t address = cpu.GetGPR(rn);
	cpu.SetGPR(rn, CLSOpDec(u, address, offset));
	while(cpu.CoprocessorStore(cp_num, address)) {
		address += 4;
	}
}

stc2_unindexed.execute = {
	uint32_t address = cpu.GetGPR(rn);
	while(cpu.CoprocessorStore(cp_num, address, option)) {
		address += 4;
	}
}
/*
 * end of stc2 instruction
 *******************************************************************/
