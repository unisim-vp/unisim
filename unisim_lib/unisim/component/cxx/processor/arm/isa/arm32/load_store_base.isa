/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 */
 
/**********************************************

         LOAD AND STORE INSTRUCTIONS

**********************************************/

{
#include <iostream>
}

/*******************************************************************
 * ldr instruction
 */

op ldr_imm_post(cond[4]:0b010[3]:0b0[1]:u[1]:0b0[1]:0b0[1]:0b1[1]:rn[4]:rd[4]:offset[12])
op ldr_imm_offset(cond[4]:0b010[3]:0b1[1]:u[1]:0b0[1]:0b0[1]:0b1[1]:rn[4]:rd[4]:offset[12])
op ldr_imm_pre(cond[4]:0b010[3]:0b1[1]:u[1]:0b0[1]:0b1[1]:0b1[1]:rn[4]:rd[4]:offset[12])
op ldr_reg_post(cond[4]:0b011[3]:0b0[1]:u[1]:0b0[1]:0b0[1]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op ldr_reg_offset(cond[4]:0b011[3]:0b1[1]:u[1]:0b0[1]:0b0[1]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op ldr_reg_pre(cond[4]:0b011[3]:0b1[1]:u[1]:0b0[1]:0b1[1]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])

group ldr_group(ldr_imm_post, ldr_imm_offset, ldr_imm_pre, \
		ldr_reg_post, ldr_reg_offset, ldr_reg_pre)

ldr_imm_post.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_post(u, rn, offset, buffer);
}

ldr_imm_offset.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_offset(u, rn, offset, buffer);
}

ldr_imm_pre.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_pre(u, rn, offset, buffer);
}

ldr_reg_post.disasm = {
			   buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  DisasmLSWUBReg_post(u, rn, shift_imm, shift, rm, buffer);
}

ldr_reg_offset.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  DisasmLSWUBReg_offset(u, rn, shift_imm, shift, rm, buffer);
}

ldr_reg_pre.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  DisasmLSWUBReg_pre(u, rn, shift_imm, shift, rm, buffer);
}

ldr_imm_post.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t new_rn_value = 0;

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value; // address used is the contents of rn
	new_rn_value = LSWUBImmOffset(u, rn_value, offset);
	cpu.SetGPR(rn, new_rn_value); // update rn

	if(rd == cpu.PC_reg) {
		cpu.Read32toPCUpdateT(address);
	} else {
		cpu.Read32toGPR(address, rd);
	}
}

ldr_imm_offset.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = LSWUBImmOffset(u, rn_value, offset); 
	if(rd == cpu.PC_reg) {
		cpu.Read32toPCUpdateT(address);
	} else {
		cpu.Read32toGPR(address, rd);
	}
}

ldr_imm_pre.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = LSWUBImmOffset(u, rn_value, offset); // compute address
	cpu.SetGPR(rn, address); // update rn with the address
	if(rd == cpu.PC_reg) {
		cpu.Read32toPCUpdateT(address);
	} else {
		cpu.Read32toGPR(address, rd);
	}
}

ldr_reg_post.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value;
	cpu.SetGPR(rn, 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C()));
	if(rd == cpu.PC_reg) {
		cpu.Read32toPCUpdateT(address);
	} else {
		cpu.Read32toGPR(address, rd);
	}
}

ldr_reg_offset.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C());
	if(rd == cpu.PC_reg) {
		cpu.Read32toPCUpdateT(address);
	} else {
		cpu.Read32toGPR(address, rd);
	}
}

ldr_reg_pre.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
	
	if(!cpu.CheckCondition(cond)) return;

	address = 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C());
	cpu.SetGPR(rn, address);
	if(rd == cpu.PC_reg) {
		cpu.Read32toPCUpdateT(address);
	} else {
		cpu.Read32toGPR(address, rd);
	}
}

/*
 * end of ldr instruction
 *******************************************************************/

/*******************************************************************
 * ldrb instruction
 */

op ldrb_imm_post(cond[4]:0b010[3]:0b0[1]:u[1]:0b1[1]:0b0[1]:0b1[1]:rn[4]:rd[4]:offset[12])
op ldrb_imm_offset(cond[4]:0b010[3]:0b1[1]:u[1]:0b1[1]:0b0[1]:0b1[1]:rn[4]:rd[4]:offset[12])
op ldrb_imm_pre(cond[4]:0b010[3]:0b1[1]:u[1]:0b1[1]:0b1[1]:0b1[1]:rn[4]:rd[4]:offset[12])
op ldrb_reg_post(cond[4]:0b011[3]:0b0[1]:u[1]:0b1[1]:0b0[1]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op ldrb_reg_offset(cond[4]:0b011[3]:0b1[1]:u[1]:0b1[1]:0b0[1]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op ldrb_reg_pre(cond[4]:0b011[3]:0b1[1]:u[1]:0b1[1]:0b1[1]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])

ldrb_imm_post.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_post(u, rn, offset, buffer);
}

ldrb_imm_offset.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_offset(u, rn, offset, buffer);
}

ldrb_imm_pre.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_pre(u, rn, offset, buffer);
}

ldrb_reg_post.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  DisasmLSWUBReg_post(u, rn, shift_imm, shift, rm, buffer);
}

ldrb_reg_offset.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  DisasmLSWUBReg_offset(u, rn, shift_imm, shift, rm, buffer);
}

ldrb_reg_pre.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  DisasmLSWUBReg_pre(u, rn, shift_imm, shift, rm, buffer);
}

ldrb_imm_post.execute = {
	typedef Operation<CONFIG> inherited;
	
	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = cpu.GetGPR(rn); // address used is the contents of rn
	cpu.SetGPR(rn, LSWUBImmOffset(u, rn_value, offset)); // update rn
	cpu.Read8toGPR(address, rd);
}

ldrb_imm_offset.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = LSWUBImmOffset(u, rn_value, offset); 
	cpu.Read8toGPR(address, rd);
}

ldrb_imm_pre.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = LSWUBImmOffset(u, rn_value, offset); // compute address
	cpu.SetGPR(rn, address); // update rn with the address
	cpu.Read8toGPR(address, rd);
}

ldrb_reg_post.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = cpu.GetGPR(rn);
	cpu.SetGPR(rn, 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C()));
	cpu.Read8toGPR(address, rd);
}

ldrb_reg_offset.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
	
	address = 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C());
	cpu.Read8toGPR(address, rd);
}

ldrb_reg_pre.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C());
	cpu.SetGPR(rn, address);
	cpu.Read8toGPR(address, rd);
}

/*
 * end of ldrb instruction
 *******************************************************************/

/*******************************************************************
 * ldrb_rd15 instruction
 * this is the specialization of the instruction ldrb when rd = 15
 * for most of the arm architectures this is an undefined behavior instruction (do nothing is our action)
 * however for the armv5e architectures some of the combinations correspond to a pld instruction if
 * it is a imm_offset or reg_offset type and cond == 0b1111
 */

op ldrb_rd15_imm_post(cond[4]:0b010[3]:0b0[1]:u[1]:0b1[1]:0b0[1]:0b1[1]:rn[4]:0b1111[4]:offset[12])
op ldrb_rd15_imm_offset(cond[4]:0b010[3]:0b1[1]:u[1]:0b1[1]:0b0[1]:0b1[1]:rn[4]:0b1111[4]:offset[12])
op ldrb_rd15_imm_pre(cond[4]:0b010[3]:0b1[1]:u[1]:0b1[1]:0b1[1]:0b1[1]:rn[4]:0b1111[4]:offset[12])
op ldrb_rd15_reg_post(cond[4]:0b011[3]:0b0[1]:u[1]:0b1[1]:0b0[1]:0b1[1]:rn[4]:0b1111[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op ldrb_rd15_reg_offset(cond[4]:0b011[3]:0b1[1]:u[1]:0b1[1]:0b0[1]:0b1[1]:rn[4]:0b1111[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op ldrb_rd15_reg_pre(cond[4]:0b011[3]:0b1[1]:u[1]:0b1[1]:0b1[1]:0b1[1]:rn[4]:0b1111[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])

ldrb_rd15_imm_post.disasm = {
	buffer << "unpredictable instruction (ldrb)";
}

ldrb_rd15_imm_offset.disasm = {
	if(CONFIG::HAS_LOAD_STORE_V5E) {
		buffer << "pld";
		DisasmLSWUBImmOffset_offset(u, rn, offset, buffer);
	} else
		buffer << "unpredictable instruction (ldrb)";
}

ldrb_rd15_imm_pre.disasm = {
	buffer << "unpredictable instruction (ldrb)";
}

ldrb_rd15_reg_post.disasm = {
	buffer << "unpredictable instruction (ldrb)";
}

ldrb_rd15_reg_offset.disasm = {
	if(CONFIG::HAS_LOAD_STORE_V5E) {
		buffer << "pld ";
		DisasmLSWUBReg_offset(u, rn, shift_imm, shift, rm, buffer);
	} else
		buffer << "unpredictable instruction (ldrb)";
}

ldrb_rd15_reg_pre.disasm = {
	buffer << "unpredictable instruction (ldrb)";
}

ldrb_rd15_imm_post.execute = {
	/* unpredictable */
	cpu.Unpredictable();
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
}

ldrb_rd15_imm_offset.execute = {
	if(CONFIG::HAS_LOAD_STORE_V5E && cond == 15) {
		typedef Operation<CONFIG> inherited;

		typename CONFIG::address_t address;
		typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);

		cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

		address = LSWUBImmOffset(u, rn_value, offset);
		cpu.ReadPrefetch(address);
	} else {
		/* unpredictable */
		cpu.Unpredictable();
		cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
	}
}

ldrb_rd15_imm_pre.execute = {
	/* unpredictable */
	cpu.Unpredictable();
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
}

ldrb_rd15_reg_post.execute = {
	/* unpredictable */
	cpu.Unpredictable();
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
}

ldrb_rd15_reg_offset.execute = {
	if(CONFIG::HAS_LOAD_STORE_V5E && cond == 15) {
		typedef Operation<CONFIG> inherited;

		typename CONFIG::address_t address;
		typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
		typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);

		cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

		address = 
			LSWUBReg(u, rn_value, 15, shift_imm, shift, rm_value,
				cpu.GetCPSR_C());
		cpu.ReadPrefetch(address);
	} else {
		/* unpredictable */
		cpu.Unpredictable();
		cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
	}
}

ldrb_rd15_reg_pre.execute = {
	/* unpredictable */
	cpu.Unpredictable();
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
}

/*
 * end of ldrb instruction
 *******************************************************************/

/*******************************************************************
 * ldrt instruction
 * TODO: check running mode
 */

op ldrt_imm(cond[4]:0b0100[4]:u[1]:0b011[3]:rn[4]:rd[4]:offset[12])
op ldrt_reg(cond[4]:0b0110[4]:u[1]:0b011[3]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])

ldrt_imm.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "t r" << rd << ", ";
  DisasmLSWUBImmOffset_post(u, rn, offset, buffer);
}

ldrt_reg.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "t r" << rd << ", ";
  DisasmLSWUBReg_post(u, rn, shift_imm, shift, rm, buffer);
}

ldrt_imm.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value;
	cpu.SetGPR(rn, LSWUBImmOffset(u, rn_value, offset));
	cpu.Read32toGPR(address, rd);
}

ldrt_reg.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value;
	cpu.Read32toGPR(address, rd);
}

/*
 * end of ldrt instruction
 *******************************************************************/

/*******************************************************************
 * ldrbt instruction
 * TODO: check running mode
 */

op ldrbt_imm(cond[4]:0b0100[4]:u[1]:0b111[3]:rn[4]:rd[4]:offset[12])
op ldrbt_reg(cond[4]:0b0110[4]:u[1]:0b111[3]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])

ldrbt_imm.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "bt r" << rd << ", ";
  DisasmLSWUBImmOffset_post(u, rn, offset, buffer);
}

ldrbt_reg.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "bt r" << rd << ", ";
  DisasmLSWUBReg_post(u, rn, shift_imm, shift, rm, buffer);
}

ldrbt_imm.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value;
	cpu.SetGPR(rn, LSWUBImmOffset(u, rn_value, offset));
	cpu.Read8toGPR(address, rd);
}

ldrbt_reg.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value;
	cpu.SetGPR(rn, 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C()));
	cpu.Read8toGPR(address, rd);
}

/*
 * end of ldrbt instruction
 *******************************************************************/

/*******************************************************************
 * str instruction
 */

op str_imm_post(cond[4]:0b010[3]:0b0[1]:u[1]:0b0[1]:0b0[1]:0b0[1]:rn[4]:rd[4]:offset[12])
op str_imm_offset(cond[4]:0b010[3]:0b1[1]:u[1]:0b0[1]:0b0[1]:0b0[1]:rn[4]:rd[4]:offset[12])
op str_imm_pre(cond[4]:0b010[3]:0b1[1]:u[1]:0b0[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:offset[12])
op str_reg_post(cond[4]:0b011[3]:0b0[1]:u[1]:0b0[1]:0b0[1]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op str_reg_offset(cond[4]:0b011[3]:0b1[1]:u[1]:0b0[1]:0b0[1]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op str_reg_pre(cond[4]:0b011[3]:0b1[1]:u[1]:0b0[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])

str_imm_post.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  DisasmLSWUBImmOffset_post(u, rn, offset, buffer);
}

str_imm_offset.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  DisasmLSWUBImmOffset_offset(u, rn, offset, buffer);
}

str_imm_pre.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  DisasmLSWUBImmOffset_pre(u, rn, offset, buffer);
}

str_reg_post.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  DisasmLSWUBReg_post(u, rn, shift_imm, shift, rm, buffer);
}

str_reg_offset.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  DisasmLSWUBReg_offset(u, rn, shift_imm, shift, rm, buffer);
}

str_reg_pre.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << " r" << rd << ", ";
  DisasmLSWUBReg_pre(u, rn, shift_imm, shift, rm, buffer);
}

str_imm_post.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value; // address used is the contents of rn
	cpu.CheckAlignmentExcep(address); // TODO
	cpu.SetGPR(rn, LSWUBImmOffset(u, rn_value, offset)); // update rn
	value = rd_value;
	cpu.Write32(address, value);
}

str_imm_offset.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = LSWUBImmOffset(u, rn_value, offset); 
	cpu.CheckAlignmentExcep(address); // TODO
	value = rd_value;

	cpu.Write32(address, value);
}

str_imm_pre.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = LSWUBImmOffset(u, rn_value, offset); // compute address
	cpu.CheckAlignmentExcep(address); // TODO
	cpu.SetGPR(rn, address); // update rn with the address
	value = rd_value;
	cpu.Write32(address, value);
}

str_reg_post.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value;
	cpu.CheckAlignmentExcep(address); // TODO
	cpu.SetGPR(rn, 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C()));
	value = rd_value;
	cpu.Write32(address, value);
}

str_reg_offset.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
	
	if(!cpu.CheckCondition(cond)) return;

	address = 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C());
	cpu.CheckAlignmentExcep(address); // TODO
	value = rd_value;
	cpu.Write32(address, value);
}

str_reg_pre.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C());
	cpu.CheckAlignmentExcep(address); // TODO
	cpu.SetGPR(rn, address);
	value = rd_value;
	cpu.Write32(address, value);
}

/*
 * end of str instruction
 *******************************************************************/

/*******************************************************************
 * strb instruction
 */

op strb_imm_post(cond[4]:0b010[3]:0b0[1]:u[1]:0b1[1]:0b0[1]:0b0[1]:rn[4]:rd[4]:offset[12])
op strb_imm_offset(cond[4]:0b010[3]:0b1[1]:u[1]:0b1[1]:0b0[1]:0b0[1]:rn[4]:rd[4]:offset[12])
op strb_imm_pre(cond[4]:0b010[3]:0b1[1]:u[1]:0b1[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:offset[12])
op strb_reg_post(cond[4]:0b011[3]:0b0[1]:u[1]:0b1[1]:0b0[1]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op strb_reg_offset(cond[4]:0b011[3]:0b1[1]:u[1]:0b1[1]:0b0[1]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op strb_reg_pre(cond[4]:0b011[3]:0b1[1]:u[1]:0b1[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])

strb_imm_post.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_post(u, rn, offset, buffer);
}

strb_imm_offset.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_offset(u, rn, offset, buffer);
}

strb_imm_pre.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_pre(u, rn, offset, buffer);
}

strb_reg_post.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  DisasmLSWUBReg_post(u, rn, shift_imm, shift, rm, buffer);
}

strb_reg_offset.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  DisasmLSWUBReg_offset(u, rn, shift_imm, shift, rm, buffer);
}

strb_reg_pre.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "b r" << rd << ", ";
  DisasmLSWUBReg_pre(u, rn, shift_imm, shift, rm, buffer);
}

strb_imm_post.execute = {
	typedef Operation<CONFIG> inherited;
	
	typename CONFIG::address_t address;
	uint8_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
	
	address = rn_value; // address used is the contents of rn
	cpu.SetGPR(rn, LSWUBImmOffset(u, rn_value, offset)); // update rn
	value = rd_value & 0x0FF;
	cpu.Write8(address, value);
}

strb_imm_offset.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	uint8_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = LSWUBImmOffset(u, rn_value, offset); 
	value = rd_value & 0x0FF;
	cpu.Write8(address, value);
}

strb_imm_pre.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	uint8_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = LSWUBImmOffset(u, rn_value, offset); // compute address
	cpu.SetGPR(rn, address); // update rn with the address
	value = rd_value & 0x0FF;
	cpu.Write8(address, value);
}

strb_reg_post.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	uint8_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = cpu.GetGPR(rn);
	cpu.SetGPR(rn, 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C()));
	value = rd_value & 0x0FF;
	cpu.Write8(address, value);
}

strb_reg_offset.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	uint8_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
	
	address = 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C());
	value = rd_value & 0x0FF;
	cpu.Write8(address, value);
}

strb_reg_pre.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	uint8_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C());
	cpu.SetGPR(rn, address);
	value = rd_value & 0x0FF;
	cpu.Write8(address, value);
}

/*
 * end of strb instruction
 *******************************************************************/

/*******************************************************************
 * strt instruction
 * TODO: check running mode
 */

op strt_imm(cond[4]:0b010[3]:0b0[1]:u[1]:0b0[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:offset[12])
op strt_reg(cond[4]:0b011[3]:0b0[1]:u[1]:0b0[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])

strt_imm.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "t r" << rd << ", ";
  DisasmLSWUBImmOffset_post(u, rn, offset, buffer);
}

strt_reg.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "t r" << rd << ", ";
  DisasmLSWUBReg_post(u, rn, shift_imm, shift, rm, buffer);
}

strt_imm.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value; // address used is the contents of rn
	cpu.CheckAlignmentExcep(address); // TODO
	cpu.SetGPR(rn, LSWUBImmOffset(u, rn_value, offset)); // update rn
	value = rd_value;
	cpu.Write32(address, value);
}

strt_reg.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	typename CONFIG::reg_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	address = rn_value;
	cpu.CheckAlignmentExcep(address); // TODO
	cpu.SetGPR(rn, 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C()));
	value = rd_value;
	cpu.Write32(address, value);
}

/*
 * end of strt instruction
 *******************************************************************/

/*******************************************************************
 * strbt instruction
 * TODO: check running mode
 */

op strbt_imm(cond[4]:0b010[3]:0b0[1]:u[1]:0b1[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:offset[12])
op strbt_reg(cond[4]:0b011[3]:0b0[1]:u[1]:0b1[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])

strbt_imm.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "bt r" << rd << ", ";
  // LSWUB = Load Store Word or Unsigned Byte
  DisasmLSWUBImmOffset_post(u, rn, offset, buffer);
}

strbt_reg.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "bt r" << rd << ", ";
  DisasmLSWUBReg_post(u, rn, shift_imm, shift, rm, buffer);
}

strbt_imm.execute = {
	typename CONFIG::address_t address;
	uint8_t value;
  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
	
	if(!cpu.CheckCondition(cond)) return;
  
	address = cpu.GetGPR(rn); // address used is the contents of rn
	cpu.SetGPR(rn, LSWUBImmOffset(u, cpu.GetGPR(rn), offset)); // update rn
	value = cpu.GetGPR(rd) & 0x0FF;
	cpu.Write8(address, value);
}

strbt_reg.execute = {
	typedef Operation<CONFIG> inherited;

	typename CONFIG::address_t address;
	uint8_t value;
	typename CONFIG::reg_t rn_value = inherited::rn_init + cpu.GetGPR(rn);
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t rd_value = inherited::rd_init + cpu.GetGPR(rd);

	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
  
	address = rn_value;
	cpu.SetGPR(rn, 
		LSWUBReg(u, rn_value, rd_value, shift_imm, shift, rm_value,
			cpu.GetCPSR_C()));
	value = rd_value & 0x0FF;
	cpu.Write8(address, value);
}

/*
 * end of strbt instruction
 *******************************************************************/

group load_store_rn_init(ldr_imm_post, ldr_imm_offset, ldr_imm_pre,\
						ldr_reg_post, ldr_reg_offset, ldr_reg_pre, \
						ldrb_imm_post, ldrb_imm_offset, ldrb_imm_pre, \
						ldrb_reg_post, ldrb_reg_offset, ldrb_reg_pre, \
						ldrb_rd15_imm_offset, ldrb_rd15_reg_offset, \
						ldrt_imm, ldrt_reg, \
						ldrbt_imm, ldrbt_reg, \
						str_imm_post, str_imm_offset, str_imm_pre, \
						str_reg_post, str_reg_offset, str_reg_pre, \
						strb_imm_post, strb_imm_offset, strb_imm_pre, \
						strb_reg_post, strb_reg_offset, strb_reg_pre, \
						strt_imm, strt_reg, \
						strbt_imm, strbt_reg)
load_store_rn_init.initialize_rn_init = {
	typedef Operation<CONFIG> inherited;

	if(rn == 15) inherited::rn_init = 8;
	else inherited::rn_init = 0;
}

group load_store_rm_init(ldr_reg_post, ldr_reg_offset, ldr_reg_pre, \
						ldrb_reg_post, ldrb_reg_offset, ldrb_reg_pre, \
						ldrb_rd15_reg_offset, \
						ldrt_reg, \
						ldrbt_reg, \
						str_reg_post, str_reg_offset, str_reg_pre, \
						strb_reg_post, strb_reg_offset, strb_reg_pre, \
						strt_reg, \
						strbt_reg)
load_store_rm_init.initialize_rm_init = {
	typedef Operation<CONFIG> inherited;

	if(rm == 15) inherited::rm_init = 8;
	else inherited::rm_init = 0;
}

group load_store_rd_init(ldr_reg_post, ldr_reg_offset, ldr_reg_pre, \
						ldrb_reg_post, ldrb_reg_offset, ldrb_reg_pre, \
						ldrt_reg, \
						ldrbt_reg, \
						str_imm_post, str_imm_offset, str_imm_pre, \
						str_reg_post, str_reg_offset, str_reg_pre, \
						strb_imm_post, strb_imm_offset, strb_imm_pre, \
						strb_reg_post, strb_reg_offset, strb_reg_pre, \
						strt_imm, strt_reg, \
						strbt_imm, strbt_reg)
load_store_rd_init.initialize_rd_init = {
	typedef Operation<CONFIG> inherited;

	if(rd == 15) inherited::rd_init = 8;
	else inherited::rd_init = 0;
}
