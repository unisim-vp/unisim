/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 */
 
/**********************************************

         LOAD AND STORE INSTRUCTIONS
         (specific for arm version 5e)

**********************************************/

/*******************************************************************
 * ldrd instruction
 */

{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op ldrd_imm_post(cond[4]:0b000[3]:/*p*/0b0[1]:u[1]:/*i*/0b1[1]:/*w*/0b0[1]:0b0[1]:rn[4]:rd[4]:immedH[4]:0b1101[4]:immedL[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU

}:op ldrd_imm_offset(cond[4]:0b000[3]:/*p*/0b1[1]:u[1]:/*i*/0b1[1]:/*w*/0b0[1]:0b0[1]:rn[4]:rd[4]:immedH[4]:0b1101[4]:immedL[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU

}:op ldrd_imm_pre(cond[4]:0b000[3]:/*p*/0b1[1]:u[1]:/*i*/0b1[1]:/*w*/0b1[1]:0b0[1]:rn[4]:rd[4]:immedH[4]:0b1101[4]:immedL[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU

}:op ldrd_reg_post(cond[4]:0b000[3]:/*p*/0b0[1]:u[1]:/*i*/0b0[1]:/*w*/0b0[1]:0b0[1]:rn[4]:rd[4]:sbz[4]:0b1101[4]:rm[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU

}:op ldrd_reg_offset(cond[4]:0b000[3]:/*p*/0b1[1]:u[1]:/*i*/0b0[1]:/*w*/0b0[1]:0b0[1]:rn[4]:rd[4]:sbz[4]:0b1101[4]:rm[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU

}:op ldrd_reg_pre(cond[4]:0b000[3]:/*p*/0b1[1]:u[1]:/*i*/0b0[1]:/*w*/0b1[1]:0b0[1]:rn[4]:rd[4]:sbz[4]:0b1101[4]:rm[4])

ldrd_imm_post.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSImmOffset_post(u, rn, immedH, immedL, buffer);
}

ldrd_imm_offset.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSImmOffset_offset(u, rn, immedH, immedL, buffer);
}

ldrd_imm_pre.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSImmOffset_pre(u, rn, immedH, immedL, buffer);
}

ldrd_reg_post.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSReg_post(u, rn, rm, buffer);
}

ldrd_reg_offset.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSReg_offset(u, rn, rm, buffer);
}

ldrd_reg_pre.disasm = {
  buffer << "ldr";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSReg_pre(u, rn, rm, buffer);
}

ldrd_imm_post.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;
	
	address = rn_value; // address used is the contents of rn
	// TODO: Check Alignment Exception

	if(rd % 2 != 0) // rd must be even numbered, unpredictable behavior
		return;
	if ( ((address & (uint32_t)0x07) != 0) ||
			(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR(rn, MLSImmOffset(u, rn_value, immedH, immedL)); // update rn
	cpu.SetGPR( rd, cpu.MemRead32( address & -4 ) );
	cpu.SetGPR( rd + 1, cpu.MemRead32( (address + 4) & -4 ) );
}

ldrd_imm_offset.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;
  
	address = MLSImmOffset(u, rn_value, immedH, immedL); 
	// TODO: Check Alignment Exception

	if(rd % 2 != 0) // rd must be even numbered, unpredictable behavior
		return;
	if ( ((address & (uint32_t)0x07) != 0) ||
			(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR( rd, cpu.MemRead32( address & -4 ) );
	cpu.SetGPR( rd + 1, cpu.MemRead32( (address + 4) & -4 ) );
}

ldrd_imm_pre.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);

	
	if(!cpu.CheckCondition(cond)) return;
	
	address = MLSImmOffset(u, rn_value, immedH, immedL); // compute address
	// TODO: Check Alignment Exception

	if(rd % 2 != 0) // rd must be even numbered, unpredictable behavior
		return;
	if ( ((address & (uint32_t)0x07) != 0) ||
			(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR(rn, address); // update rn with the address
	cpu.SetGPR( rd, cpu.MemRead32( address & -4 ) );
	cpu.SetGPR( rd + 1, cpu.MemRead32( (address + 4) & -4 ) );
}

ldrd_reg_post.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rd_value = cpu.GetGPR(rd);


	if(!cpu.CheckCondition(cond)) return;
  
	address = rn_value;
	// TODO: Check Alignment Exception

	if(rd % 2 != 0) // rd must be even numbered, unpredictable behavior
		return;
	if ( ((address & (uint32_t)0x07) != 0) ||
			(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR(rn, MLSReg(u, rn_value, rd_value, rm_value));
	cpu.SetGPR( rd, cpu.MemRead32( address & -4 ) );
	cpu.SetGPR( rd + 1, cpu.MemRead32( (address + 4) & -4 ) );
}

ldrd_reg_offset.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rd_value = cpu.GetGPR(rd);


	if(!cpu.CheckCondition(cond)) return;
	
	address = MLSReg(u, rn_value, rd_value, rm_value);
	// TODO: Check Alignment Exception

	if(rd % 2 != 0) // rd must be even numbered, unpredictable behavior
		return;
	if ( ((address & (uint32_t)0x07) != 0) ||
			(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR( rd, cpu.MemRead32( address & -4 ) );
	cpu.SetGPR( rd + 1, cpu.MemRead32( (address + 4) & -4 ) );
}

ldrd_reg_pre.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rd_value = cpu.GetGPR(rd);


	if(!cpu.CheckCondition(cond)) return;
  
	address = MLSReg(u, rn_value, rd_value, rm_value);
	// TODO: Check Alignment Exception

	if(rd % 2 != 0) // rd must be even numbered, unpredictable behavior
		return;
	if ( ((address & (uint32_t)0x07) != 0) ||
			(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR(rn, address);
	cpu.SetGPR( rd, cpu.MemRead32( address & -4 ) );
	cpu.SetGPR( rd + 1, cpu.MemRead32( (address + 4) & -4 ) );
}

/*
 * end of ldrd instruction
 *******************************************************************/

/*******************************************************************
 * strd instruction
 */

{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op strd_imm_post(cond[4]:0b000[3]:/*p*/0b0[1]:u[1]:/*i*/0b1[1]:/*w*/0b0[1]:0b0[1]:rn[4]:rd[4]:immedH[4]:0b1111[4]:immedL[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op strd_imm_offset(cond[4]:0b000[3]:/*p*/0b1[1]:u[1]:/*i*/0b1[1]:/*w*/0b0[1]:0b0[1]:rn[4]:rd[4]:immedH[4]:0b1111[4]:immedL[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op strd_imm_pre(cond[4]:0b000[3]:/*p*/0b1[1]:u[1]:/*i*/0b1[1]:/*w*/0b1[1]:0b0[1]:rn[4]:rd[4]:immedH[4]:0b1111[4]:immedL[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op strd_reg_post(cond[4]:0b000[3]:/*p*/0b0[1]:u[1]:/*i*/0b0[1]:/*w*/0b0[1]:0b0[1]:rn[4]:rd[4]:sbz[4]:0b1111[4]:rm[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op strd_reg_offset(cond[4]:0b000[3]:/*p*/0b1[1]:u[1]:/*i*/0b0[1]:/*w*/0b0[1]:0b0[1]:rn[4]:rd[4]:sbz[4]:0b1111[4]:rm[4])
{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMEMU
}:op strd_reg_pre(cond[4]:0b000[3]:/*p*/0b1[1]:u[1]:/*i*/0b0[1]:/*w*/0b1[1]:0b0[1]:rn[4]:rd[4]:sbz[4]:0b1111[4]:rm[4])

strd_imm_post.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSImmOffset_post(u, rn, immedH, immedL, buffer);
}

strd_imm_offset.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSImmOffset_offset(u, rn, immedH, immedL, buffer);
}

strd_imm_pre.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSImmOffset_pre(u, rn, immedH, immedL, buffer);
}

strd_reg_post.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSReg_post(u, rn, rm, buffer);
}

strd_reg_offset.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSReg_offset(u, rn, rm, buffer);
}

strd_reg_pre.disasm = {
  buffer << "str";
  DisasmCondition(cond, buffer);
  buffer << "d r" << (unsigned int) rd << ", ";
  // MLS = Miscellaneous Load Store
  DisasmMLSReg_pre(u, rn, rm, buffer);
}

strd_imm_post.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rd_value = cpu.GetGPR(rd);
	uint32_t rdp1_value = cpu.GetGPR(rd + 1);
 

	if(!cpu.CheckCondition(cond)) return;
  
	address = rn_value; // address used is the contents of rn
	// TODO: Check Alignment Exception

	if( (rd % 2) != 0) // rd must be even numbered, unpredictable behavior
		return;
	if ( ((address & (uint32_t)0x07) != 0) ||
			(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR(rn, MLSImmOffset(u, rn_value, immedH, immedL)); // update rn
	cpu.MemWrite32(address, rd_value);
	cpu.MemWrite32(address + 4, rdp1_value);
}

strd_imm_offset.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rd_value = cpu.GetGPR(rd);
	uint32_t rdp1_value = cpu.GetGPR(rd + 1);


	if(!cpu.CheckCondition(cond)) return;
	
	address = MLSImmOffset(u, rn_value, immedH, immedL); 
	// TODO: Check Alignment Exception

	if ( (rd % 2) != 0) // rd must be even numbered, unpredictable behavior
		return;
	if ( ((address & (uint32_t)0x07) != 0) ||
		(rd == 14) ) // undefined behavior
		return;

	cpu.MemWrite32(address, rd_value);
	cpu.MemWrite32(address + 4, rdp1_value);
}

strd_imm_pre.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rd_value = cpu.GetGPR(rd);
	uint32_t rdp1_value = cpu.GetGPR(rd + 1);


	if(!cpu.CheckCondition(cond)) return;
  
	address = MLSImmOffset(u, rn_value, immedH, immedL); // compute address
	// TODO: Check Alignment Exception

	if ( (rd % 2) != 0 ) // rd must be even numbered, unpredictable behavior
		return;
	if( ((address & (uint32_t)0x07) != 0) ||
		(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR(rn, address); // update rn with the address
	cpu.MemWrite32(address, rd_value);
	cpu.MemWrite32(address + 4, rdp1_value);
}

strd_reg_post.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rd_value = cpu.GetGPR(rd);
	uint32_t rdp1_value = cpu.GetGPR(rd + 1);


	if(!cpu.CheckCondition(cond)) return;
  
	address = rn_value;
	// TODO: Check Alignment Exception

	if ( (rd % 2) != 0 ) // rd must be even numbered, unpredictable behavior
		return;
	if ( ((address & (uint32_t)0x07) != 0) ||
		(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR(rn, MLSReg(u, rn_value, rd_value, rm_value));
	cpu.MemWrite32(address, rd_value);
	cpu.MemWrite32(address + 4, rdp1_value);
}

strd_reg_offset.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rd_value = cpu.GetGPR(rd);
	uint32_t rdp1_value = cpu.GetGPR(rd + 1);

	
	if(!cpu.CheckCondition(cond)) return;
	
	address = MLSReg(u, rn_value, rd_value, rm_value);
	// TODO: Check Alignment Exception

	if ( (rd % 2) != 0 ) // rd must be even numbered, unpredictable behavior
		return;
	if( ((address & (uint32_t)0x07) != 0) ||
		(rd == 14) ) // undefined behavior
		return;

	cpu.MemWrite32(address, rd_value);
	cpu.MemWrite32(address + 4, rdp1_value);
}

strd_reg_pre.execute = {
	uint32_t address;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rd_value = cpu.GetGPR(rd);
	uint32_t rdp1_value = cpu.GetGPR(rd + 1);

	
	if(!cpu.CheckCondition(cond)) return;
	
	address = MLSReg(u, rn_value, rd_value, rm_value);
	// TODO: Check Alignment Exception

	if ( (rd % 2) != 0 ) // rd must be even numbered, unpredictable behavior
		return;
	if( ((address & (uint32_t)0x07) != 0) ||
		(rd == 14) ) // undefined behavior
		return;

	cpu.SetGPR(rn, address);
	cpu.MemWrite32(address, rd_value);
	cpu.MemWrite32(address + 4, rdp1_value);
}

/*
 * end of strd instruction
 *******************************************************************/

/*******************************************************************
 * pld instruction
 * 
 * this instruction conflicts with a case of ldrb (with rd = 15) which is an invalid
 *   instruciton.
 * you will find the implementation of pld in load_store.isa under the implementation of ldrb_rd15
 */

/*
 * end of pld instruction
 *******************************************************************/
