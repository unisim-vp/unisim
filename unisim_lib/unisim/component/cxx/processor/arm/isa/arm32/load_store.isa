/*
 *  Copyright (c) 2007-2013,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

         LOAD AND STORE INSTRUCTIONS

**********************************************/

/*******************************************************************
 * ldr instruction
 */

op ldr_imm(cond[4]:0b010[3]:p[1]:u[1]:0b0[1]:w[1]:0b1[1]:rn[4]:rd[4]:offset[12]);
ldr_imm.var imm : {int32_t} = {u?offset:-offset};

ldr_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

ldr_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemRead32( p?oaddr:addr ) );
};

op ldr_reg(cond[4]:0b011[3]:p[1]:u[1]:0b0[1]:w[1]:0b1[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

ldr_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
         << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm) << (p?(w?"]!":"]"):"");
};

ldr_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemRead32( p?oaddr:addr ) );
};

/*
 * end of ldr instruction
 *******************************************************************/

/*******************************************************************
 * ldrh instruction
 */

op ldrh_imm(cond[4]:0b000[3]:p[1]:u[1]:0b1[1]:w[1]:0b1[1]:rn[4]:rd[4]:shl<4> im1[4]:0b1011[4]:im0[4]);
ldrh_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrh_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"h") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

ldrh_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemRead16( p?oaddr:addr ) );
};

op ldrh_reg(cond[4]:0b000[3]:p[1]:u[1]:0b0[1]:w[1]:0b1[1]:rn[4]:rd[4]:/*sbz*/0[4]:0b1011[4]:rm[4]);

ldrh_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"h") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
         << (u?"":"-") << DisasmRegister(rm) << (p?(w?"]!":"]"):"");
};

ldrh_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemRead16( p?oaddr:addr ) );
};

/*
 * end of ldrh instruction
 *******************************************************************/

/*******************************************************************
 * ldrsh instruction
 */

op ldrsh_imm(cond[4]:0b000[3]:p[1]:u[1]:0b1[1]:w[1]:0b1[1]:rn[4]:rd[4]:shl<4> im1[4]:0b1111[4]:im0[4]);
ldrsh_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrsh_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"sh") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

ldrsh_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemReadS16( p?oaddr:addr ) );
};

op ldrsh_reg(cond[4]:0b000[3]:p[1]:u[1]:0b0[1]:w[1]:0b1[1]:rn[4]:rd[4]:/*sbz*/0[4]:0b1111[4]:rm[4]);

ldrsh_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"sh") << '\t'
  << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
  << (u?"":"-") << DisasmRegister(rm) << (p?(w?"]!":"]"):"");
};

ldrsh_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemReadS16( p?oaddr:addr ) );
};

/*
 * end of ldrsh instruction
 *******************************************************************/

/*******************************************************************
 * ldrb instruction
 */

op ldrb_imm(cond[4]:0b010[3]:p[1]:u[1]:0b1[1]:w[1]:0b1[1]:rn[4]:rd[4]:offset[12]);
ldrb_imm.var imm : {int32_t} = {u?offset:-offset};

ldrb_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"b") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

ldrb_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemRead8( p?oaddr:addr ) );
};

op ldrb_reg(cond[4]:0b011[3]:p[1]:u[1]:0b1[1]:w[1]:0b1[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

ldrb_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"b") << '\t'
  << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
  << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm) << (p?(w?"]!":"]"):"");
};

ldrb_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemRead8( p?oaddr:addr ) );
};

/*
 * end of ldrb instruction
 *******************************************************************/

/*******************************************************************
 * ldrsb instruction
 */

op ldrsb_imm(cond[4]:0b000[3]:p[1]:u[1]:0b1[1]:w[1]:0b1[1]:rn[4]:rd[4]:shl<4> im1[4]:0b1101[4]:im0[4]);
ldrsb_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrsb_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"sb") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

ldrsb_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemReadS8( p?oaddr:addr ) );
};

op ldrsb_reg(cond[4]:0b000[3]:p[1]:u[1]:0b0[1]:w[1]:0b1[1]:rn[4]:rd[4]:/*sbz*/0[4]:0b1101[4]:rm[4]);

ldrsb_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"sb") << '\t'
  << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
  << (u?"":"-") << DisasmRegister(rm) << (p?(w?"]!":"]"):"");
};

ldrsb_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemReadS8( p?oaddr:addr ) );
};

/*
 * end of ldrsb instruction
 *******************************************************************/

/*******************************************************************
 * ldrd instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op ldrd_imm(cond[4]:0b000[3]:p[1]:u[1]:0b1[1]:w[1]:0b0[1]:rn[4]:rd[4]:shl<4> im1[4]:0b1101[4]:im0[4]);
ldrd_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrd_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"d") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

ldrd_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( (rd + 0) & 0xf, cpu.MemRead32( (p?oaddr:addr) + 0 ) );
  cpu.SetGPR( (rd + 1) & 0xf, cpu.MemRead32( (p?oaddr:addr) + 4 ) );
};

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op ldrd_reg(cond[4]:0b000[3]:p[1]:u[1]:0b0[1]:w[1]:0b0[1]:rn[4]:rd[4]:/*sbz*/0[4]:0b1101[4]:rm[4]);

ldrd_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"d") << '\t'
  << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
  << (u?"":"-") << DisasmRegister(rm) << (p?(w?"]!":"]"):"");
};

ldrd_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( (rd + 0) & 0xf, cpu.MemRead32( (p?oaddr:addr) + 0 ) );
  cpu.SetGPR( (rd + 1) & 0xf, cpu.MemRead32( (p?oaddr:addr) + 4 ) );
};

/*
 * end of ldrd instruction
 *******************************************************************/

/*******************************************************************
 * str instruction
 */

op str_imm(cond[4]:0b010[3]:p[1]:u[1]:0b0[1]:w[1]:0b0[1]:rn[4]:rd[4]:offset[12]);
str_imm.var imm : {int32_t} = {u?offset:-offset};

str_imm.disasm = {
  buffer << "str" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

str_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( p?oaddr:addr, cpu.GetGPR( rd ) );
};

op str_reg(cond[4]:0b011[3]:p[1]:u[1]:0b0[1]:w[1]:0b0[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

str_reg.disasm = {
  buffer << "str" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
         << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm) << (p?(w?"]!":"]"):"");
};

str_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( p?oaddr:addr, cpu.GetGPR( rd ) );
};

/*
 * end of str instruction
 *******************************************************************/

/*******************************************************************
 * strh instruction
 */

op strh_imm(cond[4]:0b000[3]:p[1]:u[1]:0b1[1]:w[1]:0b0[1]:rn[4]:rd[4]:shl<4> im1[4]:0b1011[4]:im0[4]);
strh_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

strh_imm.disasm = {
  buffer << "str" << DisasmCondition(cond,"h") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

strh_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite16( p?oaddr:addr, cpu.GetGPR( rd ) );
};

op strh_reg(cond[4]:0b000[3]:p[1]:u[1]:0b0[1]:w[1]:0b0[1]:rn[4]:rd[4]:/*sbz*/0[4]:0b1011[4]:rm[4]);
 
strh_reg.disasm = {
  buffer << "str" << DisasmCondition(cond,"h") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
         << (u?"":"-") << DisasmRegister(rm) << (p?(w?"]!":"]"):"");
};

strh_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite16( p?oaddr:addr, cpu.GetGPR( rd ) );
};

/*
 * end of strh instruction
 *******************************************************************/

/*******************************************************************
 * strb instruction
 */

op strb_imm(cond[4]:0b010[3]:p[1]:u[1]:0b1[1]:w[1]:0b0[1]:rn[4]:rd[4]:offset[12]);
strb_imm.var imm : {int32_t} = {u?offset:-offset};

strb_imm.disasm = {
  buffer << "str" << DisasmCondition(cond,"b") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

strb_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite8( p?oaddr:addr, cpu.GetGPR( rd ) );
};

op strb_reg(cond[4]:0b011[3]:p[1]:u[1]:0b1[1]:w[1]:0b0[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

strb_reg.disasm = {
  buffer << "str" << DisasmCondition(cond,"b") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
         << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm) << (p?(w?"]!":"]"):"");
};

strb_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite8( p?oaddr:addr, cpu.GetGPR( rd ) );
};

/*
 * end of strb instruction
 *******************************************************************/

/*******************************************************************
 * strd instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op strd_imm(cond[4]:0b000[3]:p[1]:u[1]:0b1[1]:w[1]:0b0[1]:rn[4]:rd[4]:shl<4> im1[4]:0b1111[4]:im0[4]);
strd_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

strd_imm.disasm = {
  buffer << "str" << DisasmCondition(cond,"d") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]")
         << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
};

strd_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( (p?oaddr:addr) + 0, cpu.GetGPR( (rd + 0) & 0xf ) );
  cpu.MemWrite32( (p?oaddr:addr) + 4, cpu.GetGPR( (rd + 1) & 0xf ) );
};

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op strd_reg(cond[4]:0b000[3]:p[1]:u[1]:0b0[1]:w[1]:0b0[1]:rn[4]:rd[4]:/*sbz*/0[4]:0b1111[4]:rm[4]);

strd_reg.disasm = {
  buffer << "str" << DisasmCondition(cond,"d") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << (p?"":"]") << ", "
         << (u?"":"-") << DisasmRegister(rm) << (p?(w?"]!":"]"):"");
};

strd_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( (p?oaddr:addr) + 0, cpu.GetGPR( (rd + 0) & 0xf ) );
  cpu.MemWrite32( (p?oaddr:addr) + 4, cpu.GetGPR( (rd + 1) & 0xf ) );
};

/*
 * end of strd instruction
 *******************************************************************/

/*******************************************************************
 * ldrt instruction
 * TODO: check running mode
 */

op ldrt_imm(cond[4]:0b0100[4]:u[1]:0b011[3]:rn[4]:rd[4]:offset[12] );
ldrt_imm.var imm : {int32_t} = {u?offset:-offset};

ldrt_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"t") << '\t' << DisasmRegister(rd)
         << ", [" << DisasmRegister(rn) << "], " << DisasmI(imm);
};

ldrt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR( rd, cpu.MemRead32( addr ) );
}

op ldrt_reg(cond[4]:0b0110[4]:u[1]:0b011[3]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

ldrt_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"t") << '\t' << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], " << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm);
};

ldrt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemRead32( addr ) );
};

/*
 * end of ldrt instruction
 *******************************************************************/

/*******************************************************************
 * ldrht instruction
 * TODO: force user running mode access
 */

op ldrht_imm(cond[4]:0b0000[4]:u[1]:0b111[3]:rn[4]:rd[4]:shl<4> im1[4]:0b1011[4]:im0[4]);
ldrht_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrht_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"ht") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], " << DisasmI(imm);
};

ldrht_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR( rd, cpu.MemRead16( addr ) );
}

op ldrht_reg(cond[4]:0b0000[4]:u[1]:0b011[3]:rn[4]:rd[4]:/*sbz*/0[4]:0b1011[4]:rm[4]);

ldrht_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"ht") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], "
         << (u?"":"-") << DisasmRegister(rm);
};

ldrht_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemRead32( addr ) );
};

/*
 * end of ldrht instruction
 *******************************************************************/

/*******************************************************************
 * ldrsht instruction
 * TODO: force user running mode access
 */

op ldrsht_imm(cond[4]:0b0000[4]:u[1]:0b111[3]:rn[4]:rd[4]:shl<4> im1[4]:0b1111[4]:im0[4]);
ldrsht_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrsht_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"sht") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], " << DisasmI(imm);
};

ldrsht_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR( rd, cpu.MemReadS16( addr ) );
}

op ldrsht_reg(cond[4]:0b0000[4]:u[1]:0b011[3]:rn[4]:rd[4]:/*sbz*/0[4]:0b1111[4]:rm[4]);

ldrsht_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"sht") << '\t'
  << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], "
  << (u?"":"-") << DisasmRegister(rm);
};

ldrsht_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemReadS16( addr ) );
};

/*
 * end of ldrsht instruction
 *******************************************************************/

/*******************************************************************
 * ldrbt instruction
 * TODO: force user running mode access
 */

op ldrbt_imm( cond[4]:0b0100[4]:u[1]:0b111[3]:rn[4]:rd[4]:offset[12] );
ldrbt_imm.var imm : {int32_t} = {u?offset:-offset};

ldrbt_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"bt") << '\t' << DisasmRegister(rd)
         << ", [" << DisasmRegister(rn) << "], " << DisasmI(imm);
};

ldrbt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR( rd, cpu.MemRead8( addr ) );
};

op ldrbt_reg(cond[4]:0b0110[4]:u[1]:0b111[3]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

ldrbt_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"bt") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], "
         << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm);
};

ldrbt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemRead8( addr ) );
};

/*
 * end of ldrbt instruction
 *******************************************************************/

/*******************************************************************
 * ldrsbt instruction
 * TODO: force user running mode access
 */

op ldrsbt_imm(cond[4]:0b0000[4]:u[1]:0b111[3]:rn[4]:rd[4]:shl<4> im1[4]:0b1101[4]:im0[4]);
ldrsbt_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrsbt_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"sbt") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], " << DisasmI(imm);
};

ldrsbt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR( rd, cpu.MemReadS8( addr ) );
};

op ldrsbt_reg(cond[4]:0b0000[4]:u[1]:0b011[3]:rn[4]:rd[4]:/*sbz*/0[4]:0b1101[4]:rm[4]);

ldrsbt_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond,"sbt") << '\t'
  << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], "
  << (u?"":"-") << DisasmRegister(rm);
};

ldrsbt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR( rd, cpu.MemReadS8( addr ) );
};

/*
 * end of ldrsbt instruction
 *******************************************************************/

/*******************************************************************
 * strt instruction
 * TODO: force user running mode access
 */

op strt_imm(cond[4]:0b010[3]:0b0[1]:u[1]:0b0[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:offset[12]);
strt_imm.var imm : {int32_t} = {u?offset:-offset};

strt_imm.disasm = {
  buffer << "str" << DisasmCondition(cond, "t") << '\t' << DisasmRegister(rd) << ", " << "[" << DisasmRegister(rn) << "], " << DisasmI(imm);
};

strt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.MemWrite32( addr, cpu.GetGPR( rd ) );
};

op strt_reg(cond[4]:0b011[3]:0b0[1]:u[1]:0b0[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

strt_reg.disasm = {
  buffer << "str" << DisasmCondition(cond,"t") << '\t' << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], "
         << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm);
};

strt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( addr, cpu.GetGPR( rd ) );
};

/*
 * end of strt instruction
 *******************************************************************/

/*******************************************************************
 * strht instruction
 * TODO: force user running mode access
 */

op strht_imm(cond[4]:0b0000[4]:u[1]:0b110[3]:rn[4]:rd[4]:shl<4> im1[4]:0b1011[4]:im0[4]);
strht_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

strht_imm.disasm = {
  buffer << "str" << DisasmCondition(cond,"ht") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], " << DisasmI(imm);
};

strht_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.MemWrite16( addr, cpu.GetGPR( rd ) );
};

op strht_reg(cond[4]:0b0000[4]:u[1]:0b010[3]:rn[4]:rd[4]:/*sbz*/0[4]:0b1011[4]:rm[4]);
 
strht_reg.disasm = {
  buffer << "str" << DisasmCondition(cond,"ht") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], "
         << (u?"":"-") << DisasmRegister(rm);
};

strht_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR( rn, oaddr );
  cpu.MemWrite16( addr, cpu.GetGPR( rd ) );
};

/*
 * end of strht instruction
 *******************************************************************/

/*******************************************************************
 * strbt instruction
 * TODO: force user running mode access
 */

op strbt_imm(cond[4]:0b010[3]:0b0[1]:u[1]:0b1[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:offset[12] );
strbt_imm.var imm : {int32_t} = {u?offset:-offset};

strbt_imm.disasm = {
  buffer << "str" << DisasmCondition(cond,"bt") << '\t'
         << DisasmRegister(rd) << ", " << "[" << DisasmRegister(rn) << "], " << DisasmI(imm);
};

strbt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.MemWrite8( addr, cpu.GetGPR( rd ) );
};

op strbt_reg(cond[4]:0b011[3]:0b0[1]:u[1]:0b1[1]:0b1[1]:0b0[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

strbt_reg.disasm = {
  buffer << "str" << DisasmCondition(cond,"bt") << '\t'
         << DisasmRegister(rd) << ", [" << DisasmRegister(rn) << "], "
         << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm);
};

strbt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR( rn, oaddr );
  cpu.MemWrite8( addr, cpu.GetGPR( rd ) );
};

/*
 * end of strbt instruction
 *******************************************************************/

/*******************************************************************
 * pld (Preload Data) instruction
 *
 * PLD signals the memory system that data memory accesses from a
 * specified address are likely in the near future. The memory system
 * can respond by taking actions that are expected to speed up the
 * memory accesses when they do occur, such as pre-loading the cache
 * line containing the specified address into the data cache.
 *
 * TODO: Implement prefetching
 */

op pld_imm(0b1111[4]:0b01[2]:0[1]:1[1]:u[1]:r[1]:0[1]:1[1]:rn[4]:/*sbo*/0b1111[4]:offset[12]);
pld_imm.var imm : {int32_t} = {u?offset:-offset};

pld_imm.disasm = {
  buffer << "pld" << (r?"":"w") << "\t[" << DisasmRegister(rn) << ", " << DisasmI(imm) << "]";
};

pld_imm.execute = { /*ignore for now*/ };

op pld_reg(0b1111[4]:0b01[2]:1[1]:1[1]:u[1]:r[1]:0[1]:1[1]:rn[4]:/*sbo*/0b1111[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

pld_reg.disasm = {
  buffer << "pld" << (r?"":"w") << "\t[" << DisasmRegister(rn) << ", "
         << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm) << "]";
};

pld_reg.execute = { /*ignore for now*/ };

/*
 * end of pld (Preload Data) instruction
 *******************************************************************/

/*******************************************************************
 * pli (Preload Instruction) instruction
 *
 * PLI signals the memory system that instruction memory accesses from
 * a specified address are likely in the near future. The memory
 * system can respond by taking actions that are expected to speed up
 * the memory accesses when they do occur, such as pre-loading the
 * cache line containing the specified address into the instruction
 * cache.
 *
 * TODO: Implement prefetching
 */

op pli_imm(0b1111[4]:0b0100[4]:u[1]:0b101[3]:rn[4]:/*sbo*/0b1111[4]:offset[12]);
pli_imm.var imm : {int32_t} = {u?offset:-offset};

pli_imm.disasm = {
  buffer << "pli" << "\t[" << DisasmRegister(rn) << ", " << DisasmI(imm) << "]";
};

pli_imm.execute = { /*ignore for now*/ };

op pli_reg(0b1111[4]:0b0110[4]:u[1]:0b101[3]:rn[4]:/*sbo*/0b1111[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

pli_reg.disasm = {
  buffer << "pli" << "\t[" << DisasmRegister(rn) << ", "
         << (u?"":"-") << DisasmRegister(rm) << DisasmShImm(shift, imm) << "]";
};

pli_reg.execute = { /*ignore for now*/ };

/*
 * end of pli (Preload Instruction) instruction
 *******************************************************************/

/*******************************************************************
 * ldm (Load Multiple) instruction
 *
 * LDM loads multiple registers from consecutive memory locations
 * using an address from a base register. The end-bound address of
 * those locations can optionally be written back to the base
 * register. The registers loaded can include the PC, causing a branch
 * to a loaded address.
 */

op ldm(cond[4]:0b100[3]:mod[2]:0b0[1]:w[1]:0b1[1]:rn[4]:reglist[16]);

ldm.disasm = {
  buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w==1?"!":"")
         << ", {" << DisasmRegList(reglist) << "}";
};

ldm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  LSMIter itr(mod, reglist, cpu.GetGPR( rn ));
  while (itr.next()) {
    cpu.SetGPR( itr.reg(), cpu.MemRead32( itr.addr() ) );
  }
  
  bool overwritten = (reglist >> rn) & 1;
  if (w and not overwritten) cpu.SetGPR( rn, itr.addr() );
};

/*
 * end of ldm instruction
 *******************************************************************/

/*******************************************************************
 * stm (Store Multiple) instruction
 *
 * STM stores multiple registers to consecutive memory locations using
 * an address from a base register. The end-bound address of those
 * locations can optionally be written back to the base register.
 */

op stm(cond[4]:0b100[3]:mod[2]:0b0[1]:w[1]:0b0[1]:rn[4]:reglist[16]);

stm.disasm = {
  buffer << "stm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w==1?"!":"")
         << ", {" << DisasmRegList(reglist) << "}";
};

stm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  LSMIter itr(mod, reglist, cpu.GetGPR( rn ));
  while (itr.next()) {
    cpu.MemWrite32( itr.addr(), cpu.GetGPR( itr.reg() ) );
  }
  
  if (w) cpu.SetGPR( rn, itr.addr() );
};

/*
 * end of stm instruction
 *******************************************************************/

/*******************************************************************
 * ldm ^ (Load Multiple User Registers) instruction 
 */

op ldm_npcusr(cond[4]:0b100[3]:mod[2]:0b1[1]:0[1]:0b1[1]:rn[4]:0[1]:reglist[15]);
ldm_npcusr.var w : {uint32_t} = {0};
op ldm_pcusr(cond[4]:0b100[3]:mod[2]:0b1[1]:w[1]:0b1[1]:rn[4]:0b1[1]:regnpclist[15]);
ldm_pcusr.var reglist : {uint32_t} = {0x8000|regnpclist};

group ldm_usr( ldm_npcusr, ldm_pcusr );

ldm_usr.disasm = {
  buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w==1?"!":"")
         << ", {" << DisasmRegList(reglist) << "}^";
};

ldm_usr.execute = {
  assert( not "privileged" );
  if (not CheckCondition(cpu, cond)) return;
  
  LSMIter itr(mod, reglist, cpu.GetGPR( rn ));
  while (itr.next()) {
    cpu.SetGPR_usr( itr.reg(), cpu.MemRead32( itr.addr() ) );
  }
  
  // TODO: if (reglist & 0x8000) cpu.MoveSPSRtoCPSR();
  
  bool overwritten = (reglist >> rn) & 1;
  if (w and not overwritten) cpu.SetGPR_usr( rn, itr.addr() );
};

/*
 * end of ldm ^ (Load Multiple User Registers) instruction
 *******************************************************************/

/*******************************************************************
 * stm ^ (Store Multiple User Registers) instruction 
 */

op stm_usr(cond[4]:0b100[3]:mod[2]:0b1[1]:w[1]:0b0[1]:rn[4]:reglist[16]);

stm_usr.disasm = {
  buffer << "stm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w==1?"!":"")
         << ", {" << DisasmRegList(reglist) << "}^";
};

stm_usr.execute = {
  assert( not "privileged" );
  if (not CheckCondition(cpu, cond)) return;
  
  LSMIter itr(mod, reglist, cpu.GetGPR( rn ));
  while (itr.next()) {
    cpu.MemWrite32( itr.addr(), cpu.GetGPR_usr( itr.reg() ) );
  }
  
  if (w) cpu.SetGPR_usr( rn, itr.addr() );
};

/*
 * end of stm ^ (Store Multiple User Registers) instruction
 *******************************************************************/

/**********************************************

           ATOMIC INSTRUCTIONS

**********************************************/

/*******************************************************************
 * swp instruction
 */

op swp(cond[4]:0b00010000[8]:rn[4]:rd[4]:0b0000[4]:0b1001[4]:rm[4])

swp.disasm = {
  buffer << "swp" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
  << DisasmRegister(rm) << ", "
  << "[" << DisasmRegister(rn) << "]";
}

swp.execute = {
	if(not CheckCondition(cpu, cond)) return;
        
        uint32_t value = cpu.GetGPR(rm);
	uint32_t address = cpu.GetGPR(rn);
	cpu.SetGPR( rd, cpu.MemRead32(address) );
	cpu.MemWrite32(address, value);
}

/*
 * end of swp instruction
 *******************************************************************/

/*******************************************************************
 * swpb instruction
 */

op swpb(cond[4]:0b00010100[8]:rn[4]:rd[4]:0b0000[4]:0b1001[4]:rm[4])

swpb.disasm = {
  buffer << "swp" << DisasmCondition(cond,"b") << '\t' << DisasmRegister(rd) << ", "
  << DisasmRegister(rm) << ", "
  << "[" << DisasmRegister(rn) << "]";
}

swpb.execute = {
	if(not CheckCondition(cpu, cond)) return;

	uint8_t value = cpu.GetGPR(rm) & uint32_t( 0x0ff );
	uint32_t address = cpu.GetGPR(rn);
	cpu.SetGPR( rd, cpu.MemRead8(address) );
	cpu.MemWrite8(address, value);
}

/*
 * end of swpb instruction
 *******************************************************************/

/*******************************************************************
 * ldrex (Load Register Exclusive) instruction
 *
 * LDREX calculates an address from a base register value and an
 * immediate offset, loads a word from memory, writes it to a register
 * and: 1. if the address has the Shared Memory attribute, marks the
 * physical address as exclusive access for the executing processor in
 * a monitor, 2. causes the executing processor to indicate an active
 * exclusive access in the local monitor.
 */

op ldrex(cond[4]:0b0001100[7]:1[1]:rn[4]:rt[4]:/*sbo*/0b1111[4]:0b1001[4]:/*sbo*/0b1111[4]);

ldrex.disasm = {
  buffer << "ldrex" << DisasmCondition(cond) << '\t' << DisasmRegister(rt)
         << ", [" << DisasmRegister (rn) << "]";
};

/*
 * end of ldrex instruction
 *******************************************************************/

/*******************************************************************
 * ldrexh (Load Register Exclusive Halfword) instruction
 */

op ldrexh(cond[4]:0b0001111[7]:1[1]:rn[4]:rt[4]:/*sbo*/0b1111[4]:0b1001[4]:/*sbo*/0b1111[4]);

ldrexh.disasm = {
  buffer << "ldrex" << DisasmCondition(cond,"h") << '\t' << DisasmRegister(rt)
         << ", [" << DisasmRegister (rn) << "]";
};

/*
 * end of ldrexh instruction
 *******************************************************************/

/*******************************************************************
 * ldrexb (Load Register Exclusive Byte) instruction
 */

op ldrexb(cond[4]:0b0001110[7]:1[1]:rn[4]:rt[4]:/*sbo*/0b1111[4]:0b1001[4]:/*sbo*/0b1111[4]);

ldrexb.disasm = {
  buffer << "ldrex" << DisasmCondition(cond,"b") << '\t' << DisasmRegister(rt)
         << ", [" << DisasmRegister (rn) << "]";
};

/*
 * end of ldrexb instruction
 *******************************************************************/

/*******************************************************************
 * ldrexd (Load Register Exclusive Doubleword) instruction
 */

op ldrexd(cond[4]:0b0001101[7]:1[1]:rn[4]:rt[4]:/*sbo*/0b1111[4]:0b1001[4]:/*sbo*/0b1111[4]);

ldrexd.disasm = {
  buffer << "ldrex" << DisasmCondition(cond,"d") << '\t' << DisasmRegister(rt)
         << ", [" << DisasmRegister (rn) << "]";
};

/*
 * end of ldrexd instruction
 *******************************************************************/

/*******************************************************************
 * strex (Store Register Exclusive) instruction
 *
 * STREX calculates an address from a base register value and an
 * immediate offset, and stores a word from a register to memory if
 * the executing processor has exclusive access to the memory
 * addressed.
 */

op strex(cond[4]:0b0001100[7]:0[1]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rt[4]);

strex.disasm = {
  buffer << "strex" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
  << DisasmRegister(rt) << ", [" << DisasmRegister (rn) << "]";
};

/*
 * end of strex instruction
 *******************************************************************/

/*******************************************************************
 * strexh (Store Register Exclusive Halfword) instruction
 */

op strexh(cond[4]:0b0001111[7]:0[1]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rt[4]);

strexh.disasm = {
  buffer << "strex" << DisasmCondition(cond,"h") << '\t' << DisasmRegister(rd) << ", "
  << DisasmRegister(rt) << ", [" << DisasmRegister (rn) << "]";
};

/*
 * end of strexh instruction
 *******************************************************************/

/*******************************************************************
 * strexb (Store Register Exclusive Byte) instruction
 */

op strexb(cond[4]:0b0001110[7]:0[1]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rt[4]);

strexb.disasm = {
  buffer << "strex" << DisasmCondition(cond,"b") << '\t' << DisasmRegister(rd) << ", "
  << DisasmRegister(rt) << ", [" << DisasmRegister (rn) << "]";
};

/*
 * end of strexb instruction
 *******************************************************************/

/*******************************************************************
 * strexd (Store Register Exclusive Doubleword) instruction
 */

op strexd(cond[4]:0b0001101[7]:0[1]:rn[4]:rd[4]:/*sbo*/0b1111[4]:0b1001[4]:rt[4]);

strexd.disasm = {
  buffer << "strex" << DisasmCondition(cond,"d") << '\t' << DisasmRegister(rd) << ", "
  << DisasmRegister(rt) << ", [" << DisasmRegister (rn) << "]";
};

/*
 * end of strexd instruction
 *******************************************************************/
