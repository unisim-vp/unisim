/*
 *  Copyright (c) 2007-2013,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

         LOAD AND STORE INSTRUCTIONS

**********************************************/

/*******************************************************************
 * ldr instruction
 */

op ldr_imm( cond[4]: 0b010[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: offset[12] );
ldr_imm.var imm : {int32_t} = {u?offset:-offset};

ldr_imm.disasm = {
  if ((rn == 15) and ((not p) or w)) { buffer << "<undefined>"; return; }
  buffer << "ldr" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldr_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemRead32( p?oaddr:addr ) );
};

op ldr_reg( cond[4]: 0b011[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

ldr_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rt) << ", "
         << DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
};

ldr_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemRead32( p?oaddr:addr ) );
};

/*
 * end of ldr instruction
 *******************************************************************/

/*******************************************************************
 * ldrh instruction
 */

op ldrh_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1011[4]: im0[4] );
ldrh_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrh_imm.disasm = {
  if ((rn == 15) and ((not p) or w)) { buffer << "<undefined>"; return; }
  buffer << "ldrh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrh_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemRead16( p?oaddr:addr ) );
};

op ldrh_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: 0b0000[4]: 0b1011[4]: rm[4] );

ldrh_reg.disasm = {
  buffer << "ldrh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

ldrh_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemRead16( p?oaddr:addr ) );
};

/*
 * end of ldrh instruction
 *******************************************************************/

/*******************************************************************
 * ldrsh instruction
 */

op ldrsh_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1111[4]: im0[4] );
ldrsh_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrsh_imm.disasm = {
  if ((rn == 15) and ((not p) or w)) { buffer << "<undefined>"; return; }
  buffer << "ldrsh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrsh_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemReadS16( p?oaddr:addr ) );
};

op ldrsh_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: 0b0000[4]: 0b1111[4]: rm[4] );

ldrsh_reg.disasm = {
  buffer << "ldrsh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

ldrsh_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemReadS16( p?oaddr:addr ) );
};

/*
 * end of ldrsh instruction
 *******************************************************************/

/*******************************************************************
 * ldrb instruction
 */

op ldrb_imm( cond[4]: 0b010[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: offset[12] );
ldrb_imm.var imm : {int32_t} = {u?offset:-offset};

ldrb_imm.disasm = {
  if ((rn == 15) and ((not p) or w)) { buffer << "<undefined>"; return; }
  buffer << "ldrb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrb_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemRead8( p?oaddr:addr ) );
};

op ldrb_reg( cond[4]: 0b011[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

ldrb_reg.disasm = {
  buffer << "ldrb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
};

ldrb_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemRead8( p?oaddr:addr ) );
};

/*
 * end of ldrb instruction
 *******************************************************************/

/*******************************************************************
 * ldrsb instruction
 */

op ldrsb_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1101[4]: im0[4] );
ldrsb_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrsb_imm.disasm = {
  if ((rn == 15) and ((not p) or w)) { buffer << "<undefined>"; return; }
  buffer << "ldrsb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrsb_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemReadS8( p?oaddr:addr ) );
};

op ldrsb_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: 0b0000[4]: 0b1101[4]: rm[4] );

ldrsb_reg.disasm = {
  buffer << "ldrsb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

ldrsb_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemReadS8( p?oaddr:addr ) );
};

/*
 * end of ldrsb instruction
 *******************************************************************/

/*******************************************************************
 * ldrd instruction
 */

{ CONFIG::insns5E }: \
op ldrd_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1101[4]: im0[4] );
ldrd_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrd_imm.disasm = {
  if ((rn == 15) and ((not p) or w)) { buffer << "<undefined>"; return; }
  buffer << "ldrd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrd_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( (rt+0) & 0xf, cpu.MemRead32( (p?oaddr:addr) + 0 ) );
  cpu.SetGPR_mem( (rt+1) & 0xf, cpu.MemRead32( (p?oaddr:addr) + 4 ) );
};

{ CONFIG::insns5E }: \
op ldrd_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: 0b0000[4]: 0b1101[4]: rm[4] );

ldrd_reg.disasm = {
  buffer << "ldrd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

ldrd_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( (rt+0) & 0xf, cpu.MemRead32( (p?oaddr:addr) + 0 ) );
  cpu.SetGPR_mem( (rt+1) & 0xf, cpu.MemRead32( (p?oaddr:addr) + 4 ) );
};

/*
 * end of ldrd instruction
 *******************************************************************/

/*******************************************************************
 * str instruction
 */

op str_imm( cond[4]: 0b010[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: offset[12] );
str_imm.var imm : {int32_t} = {u?offset:-offset};

str_imm.disasm = {
  buffer << "str" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

str_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( p?oaddr:addr, cpu.GetGPR( rt ) );
};

op str_reg( cond[4]: 0b011[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

str_reg.disasm = {
  buffer << "str" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
};

str_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( p?oaddr:addr, cpu.GetGPR( rt ) );
};

/*
 * end of str instruction
 *******************************************************************/

/*******************************************************************
 * strh instruction
 */

op strh_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1011[4]: im0[4] );
strh_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

strh_imm.disasm = {
  buffer << "strh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

strh_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite16( p?oaddr:addr, cpu.GetGPR( rt ) );
};

op strh_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: 0b0000[4]: 0b1011[4]: rm[4] );
 
strh_reg.disasm = {
  buffer << "strh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

strh_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite16( p?oaddr:addr, cpu.GetGPR( rt ) );
};

/*
 * end of strh instruction
 *******************************************************************/

/*******************************************************************
 * strb instruction
 */

op strb_imm( cond[4]: 0b010[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: offset[12] );
strb_imm.var imm : {int32_t} = {u?offset:-offset};

strb_imm.disasm = {
  buffer << "strb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

strb_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite8( p?oaddr:addr, cpu.GetGPR( rt ) );
};

op strb_reg( cond[4]: 0b011[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

strb_reg.disasm = {
  buffer << "strb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
};

strb_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite8( p?oaddr:addr, cpu.GetGPR( rt ) );
};

/*
 * end of strb instruction
 *******************************************************************/

/*******************************************************************
 * strd instruction
 */

{ CONFIG::insns5E }: \
op strd_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1111[4]: im0[4] );
strd_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

strd_imm.disasm = {
  buffer << "strd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

strd_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn ), oaddr = addr + imm;
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( (p?oaddr:addr) + 0, cpu.GetGPR( (rt+0) & 0xf ) );
  cpu.MemWrite32( (p?oaddr:addr) + 4, cpu.GetGPR( (rt+1) & 0xf ) );
};

{ CONFIG::insns5E }: \
op strd_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: 0b0000[4]: 0b1111[4]: rm[4] );

strd_reg.disasm = {
  buffer << "strd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

strd_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  if (not p or w) cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( (p?oaddr:addr) + 0, cpu.GetGPR( (rt+0) & 0xf ) );
  cpu.MemWrite32( (p?oaddr:addr) + 4, cpu.GetGPR( (rt+1) & 0xf ) );
};

/*
 * end of strd instruction
 *******************************************************************/

/*******************************************************************
 * ldrt instruction
 * TODO: check running mode
 */

op ldrt_imm( cond[4]: 0b0100[4]: u[1]: 0b011[3]: rn[4]: rt[4]: offset[12] );
ldrt_imm.var imm : {int32_t} = {u?offset:-offset};

ldrt_imm.disasm = {
  buffer << "ldrt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR_mem( rt, cpu.MemRead32( addr ) );
};

op ldrt_reg( cond[4]: 0b0110[4]: u[1]: 0b011[3]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

ldrt_reg.disasm = {
  buffer << "ldrt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
};

ldrt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemRead32( addr ) );
};

/*
 * end of ldrt instruction
 *******************************************************************/

/*******************************************************************
 * ldrht instruction
 * TODO: force user running mode access
 */

op ldrht_imm( cond[4]: 0b0000[4]: u[1]: 0b111[3]: rn[4]: rt[4]: shl<4> im1[4]: 0b1011[4]: im0[4] );
ldrht_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrht_imm.disasm = {
  buffer << "ldrht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrht_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR_mem( rt, cpu.MemRead16( addr ) );
};

op ldrht_reg( cond[4]: 0b0000[4]: u[1]: 0b011[3]: rn[4]: rt[4]: 0b0000[4]: 0b1011[4]: rm[4] );

ldrht_reg.disasm = {
  buffer << "ldrht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
};

ldrht_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemRead32( addr ) );
};

/*
 * end of ldrht instruction
 *******************************************************************/

/*******************************************************************
 * ldrsht instruction
 * TODO: force user running mode access
 */

op ldrsht_imm( cond[4]: 0b0000[4]: u[1]: 0b111[3]: rn[4]: rt[4]: shl<4> im1[4]: 0b1111[4]: im0[4] );
ldrsht_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrsht_imm.disasm = {
  buffer << "ldrsht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrsht_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR_mem( rt, cpu.MemReadS16( addr ) );
};

op ldrsht_reg( cond[4]: 0b0000[4]: u[1]: 0b011[3]: rn[4]: rt[4]: 0b0000[4]: 0b1111[4]: rm[4] );

ldrsht_reg.disasm = {
  buffer << "ldrsht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
};

ldrsht_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemReadS16( addr ) );
};

/*
 * end of ldrsht instruction
 *******************************************************************/

/*******************************************************************
 * ldrbt instruction
 * TODO: force user running mode access
 */

op ldrbt_imm( cond[4]: 0b0100[4]: u[1]: 0b111[3]: rn[4]: rt[4]: offset[12] );
ldrbt_imm.var imm : {int32_t} = {u?offset:-offset};

ldrbt_imm.disasm = {
  buffer << "ldrbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrbt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR_mem( rt, cpu.MemRead8( addr ) );
};

op ldrbt_reg( cond[4]: 0b0110[4]: u[1]: 0b111[3]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

ldrbt_reg.disasm = {
  buffer << "ldrbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
};

ldrbt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemRead8( addr ) );
};

/*
 * end of ldrbt instruction
 *******************************************************************/

/*******************************************************************
 * ldrsbt instruction
 * TODO: force user running mode access
 */

op ldrsbt_imm( cond[4]: 0b0000[4]: u[1]: 0b111[3]: rn[4]: rt[4]: shl<4> im1[4]: 0b1101[4]: im0[4] );
ldrsbt_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

ldrsbt_imm.disasm = {
  buffer << "ldrsbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrsbt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.SetGPR_mem( rt, cpu.MemReadS8( addr ) );
};

op ldrsbt_reg( cond[4]: 0b0000[4]: u[1]: 0b011[3]: rn[4]: rt[4]: 0b0000[4]: 0b1101[4]: rm[4] );

ldrsbt_reg.disasm = {
  buffer << "ldrsbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
};

ldrsbt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR( rn, oaddr );
  cpu.SetGPR_mem( rt, cpu.MemReadS8( addr ) );
};

/*
 * end of ldrsbt instruction
 *******************************************************************/

/*******************************************************************
 * strt instruction
 * TODO: force user running mode access
 */

op strt_imm( cond[4]: 0b010[3]: 0b0[1]: u[1]: 0b0[1]: 0b1[1]: 0b0[1]: rn[4]: rt[4]: offset[12] );
strt_imm.var imm : {int32_t} = {u?offset:-offset};

strt_imm.disasm = {
  buffer << "strt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

strt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.MemWrite32( addr, cpu.GetGPR( rt ) );
};

op strt_reg( cond[4]: 0b011[3]: 0b0[1]: u[1]: 0b0[1]: 0b1[1]: 0b0[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

strt_reg.disasm = {
  buffer << "strt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
};

strt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR( rn, oaddr );
  cpu.MemWrite32( addr, cpu.GetGPR( rt ) );
};

/*
 * end of strt instruction
 *******************************************************************/

/*******************************************************************
 * strht instruction
 * TODO: force user running mode access
 */

op strht_imm( cond[4]: 0b0000[4]: u[1]: 0b110[3]: rn[4]: rt[4]: shl<4> im1[4]: 0b1011[4]: im0[4] );
strht_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};

strht_imm.disasm = {
  buffer << "strht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

strht_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.MemWrite16( addr, cpu.GetGPR( rt ) );
};

op strht_reg( cond[4]: 0b0000[4]: u[1]: 0b010[3]: rn[4]: rt[4]: 0b0000[4]: 0b1011[4]: rm[4] );
 
strht_reg.disasm = {
  buffer << "strht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
};

strht_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR( rn, oaddr );
  cpu.MemWrite16( addr, cpu.GetGPR( rt ) );
};

/*
 * end of strht instruction
 *******************************************************************/

/*******************************************************************
 * strbt instruction
 * TODO: force user running mode access
 */

op strbt_imm( cond[4]: 0b010[3]: 0b0[1]: u[1]: 0b1[1]: 0b1[1]: 0b0[1]: rn[4]: rt[4]: offset[12] );
strbt_imm.var imm : {int32_t} = {u?offset:-offset};

strbt_imm.disasm = {
  buffer << "strbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

strbt_imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR( rn, addr + imm );
  cpu.MemWrite8( addr, cpu.GetGPR( rt ) );
};

op strbt_reg( cond[4]: 0b011[3]: 0b0[1]: u[1]: 0b1[1]: 0b1[1]: 0b0[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

strbt_reg.disasm = {
  buffer << "strbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
};

strbt_reg.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR( rn, oaddr );
  cpu.MemWrite8( addr, cpu.GetGPR( rt ) );
};

/*
 * end of strbt instruction
 *******************************************************************/

/*******************************************************************
 * pld (Preload Data) instruction
 *
 * PLD signals the memory system that data memory accesses from a
 * specified address are likely in the near future. The memory system
 * can respond by taking actions that are expected to speed up the
 * memory accesses when they do occur, such as pre-loading the cache
 * line containing the specified address into the data cache.
 *
 * TODO: Implement prefetching
 */

op pld_imm( 0b1111[4]: 0b01[2]: 0b0[1]: 0b1[1]: u[1]: r[1]: 0b0[1]: 0b1[1]: rn[4]: 0b1111[4]: offset[12] );
pld_imm.var imm : {int32_t} = {u?offset:-offset};

pld_imm.disasm = {
  buffer << "pld" << (r?"":"w") << "\t"
         << DisasmMemoryRI(rn,imm,true,false);
};

pld_imm.execute = { /*ignore for now*/ };

op pld_reg( 0b1111[4]: 0b01[2]: 0b1[1]: 0b1[1]: u[1]: r[1]: 0b0[1]: 0b1[1]: rn[4]: 0b1111[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

pld_reg.disasm = {
  buffer << "pld" << (r?"":"w") << "\t" << DisasmMemoryRRI( rn, rm, shift, imm, true, u, false );
};

pld_reg.execute = { /*ignore for now*/ };

/*
 * end of pld (Preload Data) instruction
 *******************************************************************/

/*******************************************************************
 * pli (Preload Instruction) instruction
 *
 * PLI signals the memory system that instruction memory accesses from
 * a specified address are likely in the near future. The memory
 * system can respond by taking actions that are expected to speed up
 * the memory accesses when they do occur, such as pre-loading the
 * cache line containing the specified address into the instruction
 * cache.
 *
 * TODO: Implement prefetching
 */

op pli_imm( 0b1111[4]: 0b0100[4]: u[1]: 0b101[3]: rn[4]: 0b1111[4]: offset[12] );
pli_imm.var imm : {int32_t} = {u?offset:-offset};

pli_imm.disasm = {
  buffer << "pli" << "\t"
         << DisasmMemoryRI(rn,imm,true,false);
};

pli_imm.execute = { /*ignore for now*/ };

op pli_reg( 0b1111[4]: 0b0110[4]: u[1]: 0b101[3]: rn[4]: 0b1111[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

pli_reg.disasm = {
  buffer << "pli" << "\t" << DisasmMemoryRRI( rn, rm, shift, imm, true, u, false );
};

pli_reg.execute = { /*ignore for now*/ };

/*
 * end of pli (Preload Instruction) instruction
 *******************************************************************/

/*******************************************************************
 * ldm (Load Multiple) instruction
 *
 * LDM loads multiple registers from consecutive memory locations
 * using an address from a base register. The end-bound address of
 * those locations can optionally be written back to the base
 * register. The registers loaded can include the PC, causing a branch
 * to a loaded address.
 */

op ldm( cond[4]: 0b100[3]: mod[2]: 0b0[1]: w[1]: 0b1[1]: rn[4]: reglist[16] );

ldm.disasm = {
  buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
         << ", {" << DisasmRegList(reglist) << "}";
};

ldm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  LSMIter itr(mod, reglist, cpu.GetGPR( rn ));
  while (itr.next()) {
    cpu.SetGPR_mem( itr.reg(), cpu.MemRead32( itr.addr() ) );
  }
  
  bool overwritten = (reglist >> rn) & 1;
  if (w and not overwritten) cpu.SetGPR( rn, itr.addr() );
};

/*
 * end of ldm instruction
 *******************************************************************/

/*******************************************************************
 * stm (Store Multiple) instruction
 *
 * STM stores multiple registers to consecutive memory locations using
 * an address from a base register. The end-bound address of those
 * locations can optionally be written back to the base register.
 */

op stm( cond[4]: 0b100[3]: mod[2]: 0b0[1]: w[1]: 0b0[1]: rn[4]: reglist[16] );

stm.disasm = {
  buffer << "stm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
         << ", {" << DisasmRegList(reglist) << "}";
};

stm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  LSMIter itr(mod, reglist, cpu.GetGPR( rn ));
  while (itr.next()) {
    cpu.MemWrite32( itr.addr(), cpu.GetGPR( itr.reg() ) );
  }
  
  if (w) cpu.SetGPR( rn, itr.addr() );
};

/*
 * end of stm instruction
 *******************************************************************/

/*******************************************************************
 * ldm ^ (Load Multiple User Registers) instruction 
 */

op ldm_npcusr( cond[4]: 0b100[3]: mod[2]: 0b1[1]: 0b0[1]: 0b1[1]: rn[4]: 0b0[1]: reglist[15] );
ldm_npcusr.var w : {uint32_t} = {0};
op ldm_pcusr( cond[4]: 0b100[3]: mod[2]: 0b1[1]: w[1]: 0b1[1]: rn[4]: 0b1[1]: regnpclist[15] );
ldm_pcusr.var reglist : {uint32_t} = {0x8000|regnpclist};

group ldm_usr( ldm_npcusr, ldm_pcusr );

ldm_usr.disasm = {
  buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
         << ", {" << DisasmRegList(reglist) << "}^";
};

ldm_usr.execute = {
  assert( not "privileged" );
  if (not CheckCondition(cpu, cond)) return;
  
  LSMIter itr(mod, reglist, cpu.GetGPR( rn ));
  while (itr.next()) {
    cpu.SetGPR_usr( itr.reg(), cpu.MemRead32( itr.addr() ) );
  }
  
  // TODO: if (reglist & 0x8000) cpu.MoveSPSRtoCPSR();
  
  bool overwritten = (reglist >> rn) & 1;
  if (w and not overwritten) cpu.SetGPR_usr( rn, itr.addr() );
};

/*
 * end of ldm ^ (Load Multiple User Registers) instruction
 *******************************************************************/

/*******************************************************************
 * stm ^ (Store Multiple User Registers) instruction 
 */

op stm_usr( cond[4]: 0b100[3]: mod[2]: 0b1[1]: w[1]: 0b0[1]: rn[4]: reglist[16] );

stm_usr.disasm = {
  buffer << "stm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
         << ", {" << DisasmRegList(reglist) << "}^";
};

stm_usr.execute = {
  assert( not "privileged" );
  if (not CheckCondition(cpu, cond)) return;
  
  LSMIter itr(mod, reglist, cpu.GetGPR( rn ));
  while (itr.next()) {
    cpu.MemWrite32( itr.addr(), cpu.GetGPR_usr( itr.reg() ) );
  }
  
  if (w) cpu.SetGPR_usr( rn, itr.addr() );
};

/*
 * end of stm ^ (Store Multiple User Registers) instruction
 *******************************************************************/

/**********************************************

           ATOMIC INSTRUCTIONS

**********************************************/

/*******************************************************************
 * swp instruction
 */

op swp( cond[4]: 0b00010000[8]: rn[4]: rt[4]: 0b0000[4]: 0b1001[4]: rm[4] );

swp.disasm = {
  buffer << "swp" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmRegister(rm) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

swp.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  uint32_t value = cpu.GetGPR(rm);
  uint32_t address = cpu.GetGPR(rn);
  cpu.SetGPR_mem( rt, cpu.MemRead32(address) );
  cpu.MemWrite32(address, value);
};

/*
 * end of swp instruction
 *******************************************************************/

/*******************************************************************
 * swpb instruction
 */

op swpb( cond[4]: 0b00010100[8]: rn[4]: rt[4]: 0b0000[4]: 0b1001[4]: rm[4] );

swpb.disasm = {
  buffer << "swpb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmRegister(rm) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

swpb.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  uint8_t value = cpu.GetGPR(rm) & uint32_t( 0x0ff );
  uint32_t address = cpu.GetGPR(rn);
  cpu.SetGPR_mem( rt, cpu.MemRead8(address) );
  cpu.MemWrite8(address, value);
};

/*
 * end of swpb instruction
 *******************************************************************/

/*******************************************************************
 * ldrex (Load Register Exclusive) instruction
 *
 * LDREX calculates an address from a base register value and an
 * immediate offset, loads a word from memory, writes it to a register
 * and: 1. if the address has the Shared Memory attribute, marks the
 * physical address as exclusive access for the executing processor in
 * a monitor, 2. causes the executing processor to indicate an active
 * exclusive access in the local monitor.
 */

op ldrex( cond[4]: 0b0001100[7]: 0b1[1]: rn[4]: rt[4]: 0b1111[4]: 0b1001[4]: 0b1111[4] );

ldrex.disasm = {
  buffer << "ldrex" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

ldrex.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  cpu.SetGPR_mem( rt , cpu.MemRead32( cpu.GetGPR( rn ) ) );
};

/*
 * end of ldrex instruction
 *******************************************************************/

/*******************************************************************
 * ldrexh (Load Register Exclusive Halfword) instruction
 */

op ldrexh( cond[4]: 0b0001111[7]: 0b1[1]: rn[4]: rt[4]: 0b1111[4]: 0b1001[4]: 0b1111[4] );

ldrexh.disasm = {
  buffer << "ldrexh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

ldrexh.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  cpu.SetGPR_mem( rt, cpu.MemRead16( cpu.GetGPR( rn ) ) );
};

/*
 * end of ldrexh instruction
 *******************************************************************/

/*******************************************************************
 * ldrexb (Load Register Exclusive Byte) instruction
 */

op ldrexb( cond[4]: 0b0001110[7]: 0b1[1]: rn[4]: rt[4]: 0b1111[4]: 0b1001[4]: 0b1111[4] );

ldrexb.disasm = {
  buffer << "ldrexb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

ldrexb.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  cpu.SetGPR_mem( rt, cpu.MemRead8( cpu.GetGPR( rn ) ) );
};

/*
 * end of ldrexb instruction
 *******************************************************************/

/*******************************************************************
 * ldrexd (Load Register Exclusive Doubleword) instruction
 */

op ldrexd( cond[4]: 0b0001101[7]: 0b1[1]: rn[4]: rt[4]: 0b1111[4]: 0b1001[4]: 0b1111[4] );

ldrexd.disasm = {
  buffer << "ldrexd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

ldrexd.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.SetGPR_mem( (rt+0) & 0xf, cpu.MemRead32( addr + 0 ) );
  cpu.SetGPR_mem( (rt+1) & 0xf, cpu.MemRead32( addr + 4 ) );
};

/*
 * end of ldrexd instruction
 *******************************************************************/

/*******************************************************************
 * strex (Store Register Exclusive) instruction
 *
 * STREX calculates an address from a base register value and an
 * immediate offset, and stores a word from a register to memory if
 * the executing processor has exclusive access to the memory
 * addressed.
 */

op strex( cond[4]: 0b0001100[7]: 0b0[1]: rn[4]: rd[4]: 0b1111[4]: 0b1001[4]: rt[4] );

strex.disasm = {
  buffer << "strex" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
         << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

strex.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  cpu.MemWrite32( cpu.GetGPR( rn ), cpu.GetGPR( rt ) );
  cpu.SetGPR( rd, 0 );
};

/*
 * end of strex instruction
 *******************************************************************/

/*******************************************************************
 * strexh (Store Register Exclusive Halfword) instruction
 */

op strexh( cond[4]: 0b0001111[7]: 0b0[1]: rn[4]: rd[4]: 0b1111[4]: 0b1001[4]: rt[4] );

strexh.disasm = {
  buffer << "strexh" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
         << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

strexh.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  cpu.MemWrite16( cpu.GetGPR( rn ), cpu.GetGPR( rt ) );
  cpu.SetGPR( rd, 0 );
};

/*
 * end of strexh instruction
 *******************************************************************/

/*******************************************************************
 * strexb (Store Register Exclusive Byte) instruction
 */

op strexb( cond[4]: 0b0001110[7]: 0b0[1]: rn[4]: rd[4]: 0b1111[4]: 0b1001[4]: rt[4] );

strexb.disasm = {
  buffer << "strexb" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
         << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

strexb.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  cpu.MemWrite8( cpu.GetGPR( rn ), cpu.GetGPR( rt ) );
  cpu.SetGPR( rd, 0 );
};

/*
 * end of strexb instruction
 *******************************************************************/

/*******************************************************************
 * strexd (Store Register Exclusive Doubleword) instruction
 */

op strexd( cond[4]: 0b0001101[7]: 0b0[1]: rn[4]: rd[4]: 0b1111[4]: 0b1001[4]: rt[4] );

strexd.disasm = {
  buffer << "strexd" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
         << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

strexd.execute = {
  if(not CheckCondition(cpu, cond)) return;
  
  uint32_t addr = cpu.GetGPR( rn );
  cpu.MemWrite32( addr + 0, cpu.GetGPR( (rt+0) & 0xf ) );
  cpu.MemWrite32( addr + 4, cpu.GetGPR( (rt+1) & 0xf ) );
  cpu.SetGPR( rd, 0 );
};

/*
 * end of strexd instruction
 *******************************************************************/

/*******************************************************************
 * clrex (Clear Exclusive) instruction
 */

op clrex( 0b1111[4]: 0b01010111[8]: 0b1111[4]: 0b1111[4]: 0b0000[4]: 0b0001[4]: 0b1111[4] );

clrex.disasm = { buffer << "clrex"; };

/*
 * end of strexd instruction
 *******************************************************************/

