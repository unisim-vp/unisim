/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 */
 
/**********************************************

      STATUS REGISTER ACCESS INSTRUCTIONS

**********************************************/

/*******************************************************************
 * mrs instruction
 */
op mrs(cond[4]:0b00010[5]:r[1]:0b0[2]:0b1111[4]:rd[4]:0b0[12])

mrs.disasm = {
	buffer << "mrs";
	cpu.DisasmCondition(cond, buffer);
	buffer << "r" << rd << ", ";
	if(r) buffer << "spsr";
	else buffer << "cpsr";
}

mrs.execute = {
	typename CONFIG::reg_t run_mode;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
	
	if(!cpu.CheckCondition(cond)) return;
	
	/* if rd is the pc register the behavior is unpredictable, 
	 *   we just return */
	if(rd == cpu.PC_reg) {
		return;
	}

	run_mode = cpu.GetCPSR() & cpu.RUNNING_MODE_MASK; /* get running mode */
	if(r) {
		/* check current running mode, if in user or system mode then the behaviour is 
		 *   unpredictable, so we will do a return */
		if((run_mode == cpu.USER_MODE) ||
				(run_mode == cpu.SYSTEM_MODE)) {
			stringstream str;
			this->disasm(cpu, str);

#ifdef SOCLIB
			
			cerr << "Warning("
				<< __FUNCTION__ << ":" << __FILE__ << ":" << __LINE__
				<< "trying to access SPSR while running in "
				<< ((run_mode == cpu.USER_MODE)?"user":"system")
				<< " mode with the following instruction: " 
				<< endl;
			cerr << str.str() << endl;

#else // SOCLIB
			
			if(cpu.logger_import) {
				(*cpu.logger_import) << DebugWarning
					<< Function << __FUNCTION__
					<< File << __FILE__
					<< Line << __LINE__
					<< "trying to access SPSR while running in "
					<< ((run_mode == cpu.USER_MODE)?"user":"system")
					<< " mode with the following instruction: " 
					<< Endl;
				(*cpu.logger_import) << str.str() << Endl << EndDebugWarning;
			}
				
#endif // SOCLIB
				
			return;
		}
		cpu.SetGPR(rd, cpu.GetSPSR());
	} else {
		cpu.SetGPR(rd, cpu.GetCPSR());
	}
}

/*
 * end of mrs instruction
 *******************************************************************/

/*******************************************************************
 * msr instruction
 */

op msr_imm(cond[4]:0b00110[5]:r[1]:0b10[2]:mask[4]:0b1111[4]:rotate_imm[4]:imm[8])

msr_imm.disasm = {
	buffer << "msr";
	cpu.DisasmCondition(cond, buffer);
	buffer << " ";
	if(r) buffer << "spsr_";
	else buffer << "cpsr_";
	cpu.DisasmConditionFieldsMask(mask, buffer);
	buffer << ", ";
	cpu.DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

msr_imm.execute = {
	uint32_t operand;
	typename CONFIG::reg_t reg;
	typename CONFIG::reg_t reg_mask;
	typename CONFIG::reg_t run_mode;
  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;
	
	operand = cpu.ShiftOperand32imm(rotate_imm, 
				 	imm);
	run_mode = cpu.GetCPSR() & cpu.RUNNING_MODE_MASK; /* get running mode */
	if(r) {
		/* check current running mode, if in user or system mode then the behaviour is 
		 *   unpredictable, so we will do a return */
		if((run_mode == cpu.USER_MODE) ||
				(run_mode == cpu.SYSTEM_MODE)) {
			stringstream str;
			this->disasm(cpu, str);

#ifdef SOCLIB
			
			cerr << "Warning(" << __FUNCTION__
				<< ":" << __FILE__ << ":" << __LINE__
				<< "):" << endl
				<< "trying to access SPSR while running in "
				<< ((run_mode == cpu.USER_MODE)?"user":"system")
				<< " mode with the following instruction: " 
				<< endl;
			cerr << str.str() 
				<< endl;

#else // SOCLIB

			if(cpu.logger_import) {
				(*cpu.logger_import) << DebugWarning
					<< Function << __FUNCTION__
					<< File << __FILE__
					<< Line << __LINE__
					<< "trying to access SPSR while running in "
					<< ((run_mode == cpu.USER_MODE)?"user":"system")
					<< " mode with the following instruction: " 
					<< Endl;
				(*cpu.logger_import) << str.str() 
					<< Endl << EndDebugWarning;
			}
			
#endif // SOCLIB
			
			return;
		}
		reg = cpu.GetSPSR();
	} else {
		/* check current running mode, if in user mode then the behaviour is 
		 *   unpredictable, so we will do a return */
		if(mask != 0x08 && run_mode == cpu.USER_MODE) {
			stringstream str;
			this->disasm(cpu, str);

#ifdef SOCLIB
			
			cerr << "Warning(" << __FUNCTION__
				<< ":" << __FILE__ << ":" << __LINE__
				<< "):" << endl
				<< "Warning: trying to execute msr instruction  while running in "
				<< "user"
				<< " mode: " << Endl;
			cerr << str.str() 
				<< endl;

#else // SOCLIB
			
			if(cpu.logger_import) {
				(*cpu.logger_import) << DebugWarning
					<< Function << __FUNCTION__
					<< File << __FILE__
					<< Line << __LINE__
					<< "Warning: trying to execute msr instruction  while running in "
					<< "user"
					<< " mode: " << Endl;
				(*cpu.logger_import) << str.str() 
					<< Endl << EndDebugWarning;
			}
			
#endif // SOCLIB
			
			return;
		}
		reg = cpu.GetCPSR();
	}

	/* creating the register mask */
	reg_mask = 0;
	if((mask & 0x01) == 0x01) reg_mask = reg_mask | 0xFF;
	if((mask & 0x02) == 0x02) reg_mask = reg_mask | 0xFF00;
	if((mask & 0x04) == 0x04) reg_mask = reg_mask | 0xFF0000;
	if((mask & 0x08) == 0x08) reg_mask = reg_mask | 0xFF000000;
	
	/* updating the register */
	reg = (reg & ~reg_mask) | (operand & reg_mask);
	
	if(r) cpu.SetSPSR(reg);
	else {
		cpu.SetCPSR(reg);
		/* check if there has been any change in the running mode,
		 *   and switch registers if so */
		typename CONFIG::reg_t new_run_mode = reg & cpu.RUNNING_MODE_MASK;
		if(run_mode != new_run_mode) {
			cpu.SetGPRMapping(run_mode, new_run_mode);
		}
	}
}

op msr_reg(cond[4]:0b00010[5]:r[1]:0b10[2]:mask[4]:0b1111[4]:0b0[4]:0b0[4]:rm[4])

msr_reg.disasm = {
	buffer << "msr";
	cpu.DisasmCondition(cond, buffer);
	buffer << " ";
	if(r) buffer << "spsr_";
	else buffer << "cpsr_";
	cpu.DisasmConditionFieldsMask(mask, buffer);
	buffer << ", r" << rm;
}

msr_reg.execute = {
	typedef Operation<CONFIG> inherited;

	uint32_t operand;
	typename CONFIG::reg_t reg;
	typename CONFIG::reg_t reg_mask;
	typename CONFIG::reg_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	typename CONFIG::reg_t run_mode;
  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if(!cpu.CheckCondition(cond)) return;

	operand = rm_value;
	run_mode = cpu.GetCPSR() & cpu.RUNNING_MODE_MASK; /* get running mode */
	if(r) {
		/* check current running mode, if in user or system mode then the behaviour is 
		 *   unpredictable, so we will do a return */
		if((run_mode == cpu.USER_MODE) ||
				(run_mode == cpu.SYSTEM_MODE)) {
			stringstream str;
			this->disasm(cpu, str);

#ifdef SOCLIB
			
			cerr << "Warning(" << __FUNCTION__
				<< ":" << __FILE__ << ":" << __LINE__
				<< "):" << endl
				<< "Warning: trying to access SPSR while running in "
				<< ((run_mode == cpu.USER_MODE)?"user":"system")
				<< " mode with the following instruction: " 
				<< endl;
			cerr << str.str() 
				<< endl;

#else // SOCLIB
			
			if(cpu.logger_import) {
				(*cpu.logger_import) << DebugWarning 
					<< Function << __FUNCTION__
					<< File << __FILE__
					<< Line << __LINE__
					<< "Warning: trying to access SPSR while running in "
					<< ((run_mode == cpu.USER_MODE)?"user":"system")
					<< " mode with the following instruction: " 
					<< Endl;
				(*cpu.logger_import) << str.str() 
					<< Endl << EndDebugWarning;
			}
			
#endif // SOCLIB
			
			return;
		}
		reg = cpu.GetSPSR();
	} else {
		/* check current running mode, if in user mode then the behaviour is 
		 * 	 unpredictable, so we will do a return */
		if(mask != 0x08 && run_mode == cpu.USER_MODE) {
			stringstream str;
			this->disasm(cpu, str);

#ifdef SOCLIB
			
			cerr << "Warning(" << __FUNCTION__
				<< ":" << __FILE__ << ":" << __LINE__
				<< "):" << endl
				<< "Warning: trying to execute msr instruction  while running in "
				<< "user"
				<< " mode: " << endl;
			cerr << str.str() 
				<< endl;
			
#else // SOCLIB
			
			if(cpu.logger_import) {
				(*cpu.logger_import) << DebugWarning
					<< Function << __FUNCTION__
					<< File << __FILE__
					<< Line << __LINE__
					<< "Warning: trying to execute msr instruction  while running in "
					<< "user"
					<< " mode: " << Endl;
				(*cpu.logger_import) << str.str() 
					<< Endl << EndDebugWarning;
			}
			
#endif // SOCLIB
			
			return;
		}
		reg = cpu.GetCPSR();
	}

	/* creating the register mask */
	reg_mask = 0;
	if((mask & 0x01) == 0x01) reg_mask = reg_mask | 0xFF;
	if((mask & 0x02) == 0x02) reg_mask = reg_mask | 0xFF00;
	if((mask & 0x04) == 0x04) reg_mask = reg_mask | 0xFF0000;
	if((mask & 0x08) == 0x08) reg_mask = reg_mask | 0xFF000000;

	/* updating the register */
	reg = (reg & ~reg_mask) | (operand & reg_mask);

	if(r) cpu.SetSPSR(reg);
	else {
		cpu.SetCPSR(reg);
		/* check if there has been any change in the running mode,
		 *   and switch registers if so */
		typename CONFIG::reg_t new_run_mode = reg & cpu.RUNNING_MODE_MASK;
		if(run_mode != new_run_mode) {
			cpu.SetGPRMapping(run_mode, new_run_mode);
		}
	}
}

/*
 * end of msr instruction
 *******************************************************************/

group status_register_access_rm_init(msr_reg)
status_register_access_rm_init.initialize_rm_init = {
	typedef Operation<CONFIG> inherited;

	if(rm == 15) inherited::rm_init = 8;
	else inherited::rm_init = 0;
}

