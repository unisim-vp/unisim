/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 */
 
/**********************************************

      STATUS REGISTER ACCESS INSTRUCTIONS

**********************************************/

/*******************************************************************
 * mrs instruction
 */
op mrs(cond[4]:0b00010[5]:r[1]:0b0[2]:0b1111[4]:rd[4]:0b0[12])

mrs.disasm = {
	buffer << "mrs";
	DisasmCondition(cond, buffer);
	buffer << " r" << (unsigned int) rd << ", ";
	if(r) buffer << "spsr";
	else buffer << "cpsr";
}

mrs.execute = {
	uint32_t run_mode;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);
	
	if(!cpu.CheckCondition(cond)) return;
	
	/* if rd is the pc register the behavior is unpredictable, 
	 *   we just return */
	if(rd == cpu.PC_reg)
	{
		return;
	}

	run_mode = cpu.GetCPSR() & RUNNING_MODE_MASK; /* get running mode */
	if (r) 
	{
		/* check current running mode, if in user or system mode then the behaviour is 
		 *   unpredictable, so we will do a return */
		if((run_mode == USER_MODE) ||
				(run_mode == SYSTEM_MODE))
		{
			stringstream str;
			this->disasm(cpu, str);

			cpu.logger << DebugWarning
				<< "trying to access SPSR while running in "
				<< ((run_mode == USER_MODE)?"user":"system")
				<< " mode with the following instruction: " 
				<< endl;
			cpu.logger << str.str() << endl 
				<< "Location: " << __FUNCTION__ 
				<< ":" << __FILE__ 
				<< ":" << __LINE__ 
				<< EndDebugWarning;
				
			return;
		}
		cpu.SetGPR(rd, cpu.GetSPSR());
	} 
	else
	{
		cpu.SetGPR(rd, cpu.GetCPSR());
	}
}

/*
 * end of mrs instruction
 *******************************************************************/

/*******************************************************************
 * msr instruction
 */

op msr_imm(cond[4]:0b00110[5]:r[1]:0b10[2]:mask[4]:0b1111[4]:rotate_imm[4]:imm[8])

msr_imm.disasm = {
	buffer << "msr";
	DisasmCondition(cond, buffer);
	buffer << " ";
	if(r) buffer << "spsr_";
	else buffer << "cpsr_";
	DisasmConditionFieldsMask(mask, buffer);
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

msr_imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t operand;
	uint32_t reg;
	uint32_t byte_mask = 0;
	uint32_t reg_mask = 0;
	uint32_t run_mode;
  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if ( !cpu.CheckCondition(cond) ) return;

	operand = ShiftOperand32imm(rotate_imm, imm);
	if ( operand & inherited::msr_unallocmask ) // unpredictable
		return;

	/* creating the byte mask */
	if ( (mask & 0x01) == 0x01 ) byte_mask = byte_mask | 0xFF;
	if ( (mask & 0x02) == 0x02 ) byte_mask = byte_mask | 0xFF00;
	if ( (mask & 0x04) == 0x04 ) byte_mask = byte_mask | 0xFF0000;
	if ( (mask & 0x08) == 0x08 ) byte_mask = byte_mask | 0xFF000000;

	run_mode = cpu.GetCPSR() & RUNNING_MODE_MASK; /* get running mode */
	if ( r == 0 )
	{
		if ( run_mode != USER_MODE ) // we are in a privileged mode
		{
			if ( operand & inherited::msr_statemask )
				return; // unpredictable
			reg_mask = byte_mask & 
				( inherited::msr_usermask | inherited::msr_privmask );
		}
		else
		{
			reg_mask = byte_mask & inherited::msr_usermask;
		}
		reg = (cpu.GetCPSR() & ~reg_mask) | (operand & reg_mask);
		cpu.SetCPSR(reg);

		/* check if the running mode did change, if so switch registers */
		uint32_t new_run_mode = reg & RUNNING_MODE_MASK;
		if ( run_mode != new_run_mode )
			cpu.SetGPRMapping(run_mode, new_run_mode);
	}
	else // r == 1
	{
		// check that the mode has SPSR
		if ( !((run_mode == USER_MODE) || (run_mode == SYSTEM_MODE)) )
		{
			reg_mask = byte_mask &
				(inherited::msr_usermask | inherited::msr_privmask |
					inherited::msr_statemask);
			reg = (cpu.GetSPSR() & ~reg_mask) | (operand & reg_mask);
			cpu.SetSPSR(reg);
		}
		else
			return; // unpredictable
	}
}

op msr_reg(cond[4]:0b00010[5]:r[1]:0b10[2]:mask[4]:0b1111[4]:0b0[4]:0b0[4]:rm[4])

msr_reg.disasm = {
	buffer << "msr";
	DisasmCondition(cond, buffer);
	buffer << " ";
	if(r) buffer << "spsr_";
	else buffer << "cpsr_";
	DisasmConditionFieldsMask(mask, buffer);
	buffer << ", r" << (unsigned int) rm;
}

msr_reg.execute = {
	typedef Operation<STATE> inherited;

	uint32_t operand;
	uint32_t reg;
	uint32_t byte_mask = 0;
	uint32_t reg_mask = 0;
	uint32_t rm_value = inherited::rm_init + cpu.GetGPR(rm);
	uint32_t run_mode;
  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 4);

	if ( !cpu.CheckCondition(cond) ) return;

	operand = rm_value;
	if ( operand & inherited::msr_unallocmask ) // unpredictable
		return;

	/* creating the byte mask */
	if ( (mask & 0x01) == 0x01 ) byte_mask = byte_mask | 0xFF;
	if ( (mask & 0x02) == 0x02 ) byte_mask = byte_mask | 0xFF00;
	if ( (mask & 0x04) == 0x04 ) byte_mask = byte_mask | 0xFF0000;
	if ( (mask & 0x08) == 0x08 ) byte_mask = byte_mask | 0xFF000000;

	run_mode = cpu.GetCPSR() & RUNNING_MODE_MASK; /* get running mode */
	if ( r == 0 )
	{
		if ( run_mode != USER_MODE )
		{
			if ( operand & inherited::msr_statemask )
				return; // unpredictable
			reg_mask = byte_mask & 
				( inherited::msr_usermask | inherited::msr_privmask );
		}
		else
		{
			reg_mask = byte_mask & inherited::msr_usermask;
		}
		reg = (cpu.GetCPSR() & ~reg_mask) | (operand & reg_mask);
		cpu.SetCPSR(reg);
		
		/* check if the running mode did change, if so switch registers */
		uint32_t new_run_mode = reg & RUNNING_MODE_MASK;
		if ( run_mode != new_run_mode )
			cpu.SetGPRMapping(run_mode, new_run_mode);
	}
	else // r == 1
	{
		if ( !((run_mode == USER_MODE) || (run_mode == SYSTEM_MODE)) )
		{
			reg_mask = byte_mask &
				(inherited::msr_usermask | inherited::msr_privmask |
					inherited::msr_statemask);
			reg = (cpu.GetSPSR() & ~reg_mask) | (operand & reg_mask);
			cpu.SetSPSR(reg);
		}
		else
			return; // unpredictable
	}
}

/*
 * end of msr instruction
 *******************************************************************/

group status_register_access_rm_init(msr_reg)
status_register_access_rm_init.initialize_rm_init = {
	typedef Operation<STATE> inherited;

	if(rm == 15) inherited::rm_init = 8;
	else inherited::rm_init = 0;
}

group status_register_access_masks_init(msr_imm, msr_reg)
status_register_access_masks_init.initialize_msr_masks = {
	typedef Operation<STATE> inherited;

	inherited::msr_unallocmask = 0x06ffff00UL;
	inherited::msr_usermask    = 0xf8000000UL;
	inherited::msr_privmask    = 0x000000dfUL;
	inherited::msr_statemask   = 0x01000020UL;
}
