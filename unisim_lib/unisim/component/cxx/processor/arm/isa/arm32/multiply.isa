/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

           MULTIPLY INSTRUCTIONS

**********************************************/

/*******************************************************************
 * mla instruction
 */

op mla(cond[4]:0b01[7]:s[1]:rd[4]:rn[4]:rs[4]:0b01001[4]:rm[4]);

mla.disasm = {
  buffer << "mla" << DisasmCondition(cond, s?"s":"") << '\t'
  << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", "
  << DisasmRegister(rs) << ", " << DisasmRegister(rn);
};

mla.execute = {
  uint32_t res;
  uint32_t rm_value = cpu.GetGPR(rm);
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rs_value = cpu.GetGPR(rs);
  
  if(not CheckCondition(cpu, cond)) return;

  res = rm_value * rs_value;
  res += rn_value;
  cpu.SetGPR(rd, res);
  
  if(s) {
    cpu.SetCPSR_N(res & 0x80000000);
    cpu.SetCPSR_Z(res == 0);
  }
};

/*
 * end of mla instruction
 *******************************************************************/

/*******************************************************************
 * mls instruction
 */

op mls(cond[4]:0b00000110[8]:rd[4]:ra[4]:rm[4]:0b01001[4]:rn[4]);

mls.disasm = {
  buffer << "mls" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

/*
 * end of mls instruction
 *******************************************************************/

/*******************************************************************
 * mul instruction
 */

op mul(cond[4]:0b0[7]:s[1]:rd[4]:/*sbz*/0[4]:rs[4]:0b01001[4]:rm[4]);

mul.disasm = {
  buffer << "mul" << DisasmCondition(cond, s?"s":"") << '\t'
  << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", "
  << DisasmRegister(rs);
};

mul.execute = {
  uint32_t res;
  uint32_t rm_value = cpu.GetGPR(rm);
  uint32_t rs_value = cpu.GetGPR(rs);
  
  if (not CheckCondition(cpu, cond)) return;

  res = rm_value * rs_value;
  cpu.SetGPR(rd, res);
  
  if(s) {
    cpu.SetCPSR_N(res & 0x80000000);
    cpu.SetCPSR_Z(res == 0);
  }
};

/*
 * end of mul instruction
 *******************************************************************/

/*******************************************************************
 * smlal instruction
 * Note: this instruction is only supported for the M variants, that is:
 *    ARMV4TXM
 *    ARMV5XM
 *    ARMV5TXM
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smlal(cond[4]:0b0111[7]:s[1]:rdhi[4]:rdlo[4]:rm[4]:0b01001[4]:rn[4]);

smlal.disasm = {
  buffer << "smlal" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};
  
smlal.execute = {
  uint64_t res;
  uint64_t res_lo, res_hi;
  uint32_t rdhi_value = cpu.GetGPR(rdhi);
  uint32_t rdlo_value = cpu.GetGPR(rdlo);
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rm_value = cpu.GetGPR(rm);


  if(not CheckCondition(cpu, cond)) return;

  res = rdlo_value + (((uint64_t)rdhi_value) << 32);
  res = (int64_t)res + ((int64_t)(int32_t)rn_value) * ((int64_t)(int32_t)rm_value);
  res_lo = res & (uint64_t)(~(uint32_t)0);
  res_hi = (res >> 32) & (uint64_t)(~(uint32_t)0);
  cpu.SetGPR(rdhi, (uint32_t)res_hi);
  cpu.SetGPR(rdlo, (uint32_t)res_lo);

  if(s) {
    cpu.SetCPSR_N(res_hi & 0x80000000);
    cpu.SetCPSR_Z(res_hi == 0 && res_lo == 0);
  }
};

/*
 * end of smlal instruction
 *******************************************************************/

/*******************************************************************
 * smlald (Signed Multiply Accumulate Long Dual) instruction
 *
 * SMLALD performs two signed 16 * 16-bit multiplications. It adds the
 * products to a 64-bit accumulate operand.
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smlald(cond[4]:0b01110100[8]:rdhi[4]:rdlo[4]:rm[4]:0b00[2]:m[1]:1[1]:rn[4]);

smlald.disasm = {
  buffer << "smlald" << DisasmCondition(cond, m?"x":"") << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of smlald instruction
 *******************************************************************/

/*******************************************************************
 * smlsld (Signed Multiply Accumulate Long Dual) instruction
 *
 * SMLSLD performs two signed 16 * 16-bit multiplications. It adds the
 * products to a 64-bit accumulate operand.
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smlsld(cond[4]:0b01110100[8]:rdhi[4]:rdlo[4]:rm[4]:0b01[2]:m[1]:1[1]:rn[4]);

smlsld.disasm = {
  buffer << "smlsld" << DisasmCondition(cond, m?"x":"") << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of smlsld instruction
 *******************************************************************/

/*******************************************************************
 * smull instruction
 * Note: this instruction is only supported for the M variants, that is:
 *    ARMV4TXM
 *    ARMV5XM
 *    ARMV5TXM
 */

op smull(cond[4]:0b0110[7]:s[1]:rdhi[4]:rdlo[4]:rm[4]:0b1001[4]:rn[4]);

smull.disasm = {
  buffer << "smull" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

smull.execute = {
  uint64_t res;
  uint64_t res_lo, res_hi;
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rm_value = cpu.GetGPR(rm);


  if (not CheckCondition(cpu, cond)) return;

  res = ((int64_t)(int32_t)rn_value) * ((int64_t)(int32_t)rm_value);
  res_lo = res & (uint64_t)(~(uint32_t)0);
  res_hi = (res >> 32) & (uint64_t)(~(uint32_t)0);
  cpu.SetGPR(rdhi, (uint32_t)res_hi);
  cpu.SetGPR(rdlo, (uint32_t)res_lo);
	
  if(s) {
    cpu.SetCPSR_N(res_hi & 0x80000000);
    cpu.SetCPSR_Z(res_hi == 0 && res_lo == 0);
  }
};

/*
 * end of smull instruction
 *******************************************************************/

/*******************************************************************
 * umlal instruction
 * Note: this instruction is only supported for the M variants, that is:
 *    ARMV4TXM
 *    ARMV5XM
 *    ARMV5TXM
 */

op umlal(cond[4]:0b0101[7]:s[1]:rdhi[4]:rdlo[4]:rm[4]:0b1001[4]:rn[4]);

umlal.disasm = {
  buffer << "umlal" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

umlal.execute = {
  uint64_t res;
  uint64_t res_lo, res_hi;
  uint32_t rdhi_value = cpu.GetGPR(rdhi);
  uint32_t rdlo_value = cpu.GetGPR(rdlo);
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rm_value = cpu.GetGPR(rm);

  if (not CheckCondition(cpu, cond)) return;

  res = rdlo_value + (((uint64_t)rdhi_value) << 32);
  res += ((int64_t)rn_value) * ((int64_t)rm_value);
  res_lo = res & (uint64_t)(~(uint32_t)0);
  res_hi = (res >> 32) & (uint64_t)(~(uint32_t)0);
  cpu.SetGPR(rdhi, (uint32_t)res_hi);
  cpu.SetGPR(rdlo, (uint32_t)res_lo);

  if(s) {
    cpu.SetCPSR_N(res_hi & 0x80000000);
    cpu.SetCPSR_Z(res_hi == 0 && res_lo == 0);
  }
};

/*
 * end of umlal instruction
 *******************************************************************/

/*******************************************************************
 * umaal instruction
 * Note: this instruction is only supported for:
 *    ARMV6
 *    ARMV7
 */

op umaal(cond[4]:0b00000100[8]:rdhi[4]:rdlo[4]:rm[4]:0b1001[4]:rn[4]);

umaal.disasm = {
  buffer << "umaal" << DisasmCondition(cond) << '\t'
  << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
  << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of umaal instruction
 *******************************************************************/

/*******************************************************************
 * umull instruction
 * Note: this instruction is only supported for the M variants, that is:
 *    ARMV4TXM
 *    ARMV5XM
 *    ARMV5TXM
 */

op umull(cond[4]:0b0100[7]:s[1]:rdhi[4]:rdlo[4]:rm[4]:0b1001[4]:rn[4]);

umull.disasm = {
  buffer << "umull" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

umull.execute = {
  uint64_t res;
  uint64_t res_lo, res_hi;
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rm_value = cpu.GetGPR(rm);
  
  if (not CheckCondition(cpu, cond)) return;

  res = ((int64_t)rn_value) * ((int64_t)rm_value);
  res_lo = res & (uint64_t)(~(uint32_t)0);
  res_hi = (res >> 32) & (uint64_t)(~(uint32_t)0);
  cpu.SetGPR(rdhi, (uint32_t)res_hi);
  cpu.SetGPR(rdlo, (uint32_t)res_lo);

  if(s) {
    cpu.SetCPSR_N(res_hi & 0x80000000);
    cpu.SetCPSR_Z(res_hi == 0 && res_lo == 0);
  }
};

/*
 * end of umull instruction
 *******************************************************************/

/*******************************************************************
 * smlaxy instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smlaxy(cond[4]:0b00010000[8]:rd[4]:ra[4]:rm[4]:0b1[1]:y[1]:x[1]:0b0[1]:rn[4])

smlaxy.disasm = {
  buffer << "smla" << (x?"t":"b") << (y?"t":"b") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}

smlaxy.execute = {
	int32_t op1;
	int32_t op2;
	uint32_t val_rn;
	uint32_t val_rm;
	uint32_t val_ra;
	uint32_t val_rd;
	

	if(not CheckCondition(cpu, cond)) return;
	
	if(rd == cpu.PC_reg || rn == cpu.PC_reg || ra == cpu.PC_reg || rm == cpu.PC_reg) {
		// unpredictable behavior, we do nothing
		return;
	}
	
	val_rn = cpu.GetGPR(rn);
	val_rm = cpu.GetGPR(rm);
	val_ra = cpu.GetGPR(ra);
	
	if(x)
		val_rn = val_rn >> 16;
	if(val_rn & (uint32_t)0x00008000ULL) {
		val_rn = val_rn | (uint32_t)0xffff0000ULL;
		op1 = (int32_t)val_rn;
	} else {
		val_rn = val_rn & (uint32_t)0x0000ffffULL;
		op1 = (int32_t)val_rn;
	}
	
	if(y)
		val_rm = val_rm >> 16;
	if(val_rm & (uint32_t)0x00008000ULL) {
		val_rm = val_rm | (uint32_t)0xffff0000ULL;
		op2 = (int32_t)val_rm;
	} else {
		val_rm = val_rm & (uint32_t)0x0000ffffULL;
		op2 = (int32_t)val_rm;
	}
	
	uint32_t mul_res = (uint32_t)(op1 * op2);
	//val_rd = op1 + val_ra;
	uint8_t carry_out, overflow_out, sign;
	unisim::util::arithmetic::Add32(val_rd, carry_out, overflow_out, sign, mul_res, val_ra, 0);
	//if(op1 > 0 && (val_rd & (uint32_t)0x80000000ULL) != 0) {
	if(overflow_out) {
		cpu.SetCPSR_Q(true);
	}
	cpu.SetGPR(rd, val_rd);
}

/*
 * end of smlaxy instruction
 *******************************************************************/

/*******************************************************************
 * smlad instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smlad(cond[4]:0b01110000[8]:rd[4]:ra[4]:rm[4]:0b00[2]:m[1]:1[1]:rn[4]);

smlad.disasm = {
  buffer << "smlad" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}

/*
 * end of smlad instruction
 *******************************************************************/

/*******************************************************************
 * smuad instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smuad(cond[4]:0b01110000[8]:rd[4]:0b1111[4]:rm[4]:0b00[2]:m[1]:1[1]:rn[4]);

smuad.disasm = {
  buffer << "smuad" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm);
}

/*
 * end of smuad instruction
 *******************************************************************/

/*******************************************************************
 * smlsd instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smlsd(cond[4]:0b01110000[8]:rd[4]:ra[4]:rm[4]:0b01[2]:m[1]:1[1]:rn[4]);

smlsd.disasm = {
  buffer << "smlsd" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}

/*
 * end of smlsd instruction
 *******************************************************************/

/*******************************************************************
 * smusd instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smusd(cond[4]:0b01110000[8]:rd[4]:0b1111[4]:rm[4]:0b01[2]:m[1]:1[1]:rn[4]);

smusd.disasm = {
  buffer << "smusd" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm);
}

/*
 * end of smusd instruction
 *******************************************************************/

/*******************************************************************
 * smmla instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smmla(cond[4]:0b01110101[8]:rd[4]:ra[4]:rm[4]:0b00[2]:r[1]:1[1]:rn[4]);

smmla.disasm = {
  buffer << "smmla" << (r?"r":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}

/*
 * end of smmla instruction
 *******************************************************************/

/*******************************************************************
 * smmul instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smmul(cond[4]:0b01110101[8]:rd[4]:0b1111[4]:rm[4]:0b00[2]:r[1]:1[1]:rn[4]);

smmul.disasm = {
  buffer << "smmul" << (r?"r":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm);
}

/*
 * end of smmul instruction
 *******************************************************************/

/*******************************************************************
 * smmls instruction
 */

{ STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smmls(cond[4]:0b01110101[8]:rd[4]:ra[4]:rm[4]:0b11[2]:r[1]:1[1]:rn[4]);

smmls.disasm = {
  buffer << "smmls" << (r?"r":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}

/*
 * end of smmls instruction
 *******************************************************************/

/*******************************************************************
 * smlalxy instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smlalxy(cond[4]:0b00010100[8]:rdhi[4]:rdlo[4]:rs[4]:0b1[1]:y[1]:x[1]:0b0[1]:rm[4])

smlalxy.disasm = {
	buffer << "smlal" << (x?"t":"b") << (y?"t":"b") << DisasmCondition(cond) << '\t' << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
}

smlalxy.execute = {
	int32_t op1;
	int32_t op2;
	int32_t mul_res;
	uint32_t val_rm;
	uint32_t val_rs;
	uint64_t val_rd;


	if(not CheckCondition(cpu, cond)) return;
	
	if(rdhi == cpu.PC_reg || rdlo == cpu.PC_reg || rm == cpu.PC_reg || rs == cpu.PC_reg) {
		// unpredictable behavior, we do nothing
		return;
	}
	
	val_rm = cpu.GetGPR(rm);
	val_rs = cpu.GetGPR(rs);
	val_rd = ((uint64_t) cpu.GetGPR(rdhi) << 32) | (uint64_t) cpu.GetGPR(rdlo);
	
	if(x)
		val_rm = val_rm >> 16;
	if(val_rm & (uint32_t)0x00008000ULL) {
		val_rm = val_rm | (uint32_t)0xffff0000ULL;
		op1 = (int32_t)val_rm;
	} else {
		val_rm = val_rm & (uint32_t)0x0000ffffULL;
		op1 = (int32_t)val_rm;
	}
	
	if(y)
		val_rs = val_rs >> 16;
	if(val_rs & (uint32_t)0x00008000ULL) {
		val_rs = val_rs | (uint32_t)0xffff0000ULL;
		op2 = (int32_t)val_rs;
	} else {
		val_rs = val_rs & (uint32_t)0x0000ffffULL;
		op2 = (int32_t)val_rs;
	}
	
	mul_res = op1 * op2;
	val_rd = val_rd + mul_res;
	cpu.SetGPR(rdlo, (uint32_t) val_rd);
	cpu.SetGPR(rdhi, (uint32_t)(val_rd >> 32));
}

/*
 * end of smlalxy instruction
 *******************************************************************/

/*******************************************************************
 * smlawy instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smlawy(cond[4]:0b00010010[8]:rd[4]:rn[4]:rs[4]:0b1[1]:y[1]:0b00[2]:rm[4])

smlawy.disasm = {
	buffer << "smlaw" << (y?"t":"b") << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs) << ", " << DisasmRegister(rn);
}

smlawy.execute = {
	int32_t op;
	uint32_t val_rm;
	uint32_t val_rs;
	uint32_t val_rn;
	uint32_t val_rd;
	

	if(not CheckCondition(cpu, cond)) return;
	
	if(rd == cpu.PC_reg || rm == cpu.PC_reg || rn == cpu.PC_reg || rs == cpu.PC_reg) {
		// unpredictable behavior, we do nothing
		return;
	}
	
	val_rm = cpu.GetGPR(rm);
	val_rs = cpu.GetGPR(rs);
	val_rn = cpu.GetGPR(rn);
	
	if(y)
		val_rs = val_rs >> 16;
	if(val_rs & (uint32_t)0x00008000ULL) {
		val_rs = val_rs | (uint32_t)0xffff0000ULL;
		op = (int32_t)val_rs;
	} else {
		val_rs = val_rs & (uint32_t)0x0000ffffULL;
		op = (int32_t)val_rs;
	}
	
	int64_t op64;
	op64 = (int32_t)val_rm;
	op64 = op64 * op;
	op64 = op64 >> 16;
	op64 = op64 & (uint64_t)0xffffffffULL;
	uint32_t op_tmp = op64;
	//int32_t sval_rd = (int32_t)op_tmp;
	//val_rd = (uint32_t)(sval_rd + (int32_t)val_rn);
	uint8_t carry_out, overflow_out, sign;
	unisim::util::arithmetic::Add32(val_rd, carry_out, overflow_out, sign, op_tmp, val_rn, 0);
// 	if ( (op_tmp & (uint32_t)0x80000000ULL) !=
// 		(val_rn & (uint32_t)0x80000000ULL) )
	if(overflow_out)
	{
//		cpu.SetCPSR_Q(false);
		cpu.SetCPSR_Q(true);
	}
// 	else
// 	{
// 		if ( (op_tmp & (uint32_t)0x80000000ULL) !=
// 			(val_rd & (uint32_t)0x80000000ULL) )
// 		{
// 			cpu.SetCPSR_Q(true);
// 		}
// 		else
// 			cpu.SetCPSR_Q(false);
// 	}
	cpu.SetGPR(rd, val_rd);

}

/*
 * end of smlawy instruction
 *******************************************************************/

/*******************************************************************
 * smulxy instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smulxy(cond[4]:0b00010110[8]:rd[4]:/*sbz*/0[4]:rs[4]:0b1[1]:y[1]:x[1]:0b0[1]:rm[4])

smulxy.disasm = {
  buffer << "smul" << (x?"t":"b") << (y?"t":"b") << DisasmCondition(cond) << '\t'
  << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
}

smulxy.execute = {
	int32_t op1;
	int32_t op2;
	uint32_t val_rm;
	uint32_t val_rs;
	uint32_t val_rd;
	

	if(not CheckCondition(cpu, cond)) return;
	
	if(rd == cpu.PC_reg || rm == cpu.PC_reg || rs == cpu.PC_reg) {
		// unpredictable behavior, we do nothing
		return;
	}
	
	val_rm = cpu.GetGPR(rm);
	val_rs = cpu.GetGPR(rs);
	
	if(x)
		val_rm = val_rm >> 16;
	if(val_rm & (uint32_t)0x00008000ULL) {
		val_rm = val_rm | (uint32_t)0xffff0000ULL;
		op1 = (int32_t)val_rm;
	} else {
		val_rm = val_rm & (uint32_t)0x0000ffffULL;
		op1 = (int32_t)val_rm;
	}
	
	if(y)
		val_rs = val_rs >> 16;
	if(val_rs & (uint32_t)0x00008000ULL) {
		val_rs = val_rs | (uint32_t)0xffff0000ULL;
		op2 = (int32_t)val_rs;
	} else {
		val_rs = val_rs & (uint32_t)0x0000ffffULL;
		op2 = (int32_t)val_rs;
	}
	
	op1 = op1 * op2;
	val_rd = (uint32_t)op1;
	cpu.SetGPR(rd, val_rd);
}

/*
 * end of smulxy instruction
 *******************************************************************/

/*******************************************************************
 * smulwy instruction
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op smulwy(cond[4]:0b00010010[8]:rd[4]:/*sbz*/0[4]:rs[4]:0b1[1]:y[1]:0b10[2]:rm[4])

smulwy.disasm = {
  buffer << "smulw" << (y?"t":"b") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
}

smulwy.execute = {
	int32_t op1;
	int32_t op2;
	uint32_t val_rm;
	uint32_t val_rs;
	uint32_t val_rd;
	

	if(not CheckCondition(cpu, cond)) return;
	
	if(rd == cpu.PC_reg || rm == cpu.PC_reg || rs == cpu.PC_reg) {
		// unpredictable behavior, we do nothing
		return;
	}
	
	val_rm = cpu.GetGPR(rm);
	val_rs = cpu.GetGPR(rs);
	
	if(y)
		val_rs = val_rs >> 16;
	if(val_rs & (uint32_t)0x00008000ULL) {
		val_rs = val_rs | (uint32_t)0xffff0000ULL;
		op2 = (int32_t)val_rs;
	} else {
		val_rs = val_rs & (uint32_t)0x0000ffffULL;
		op2 = (int32_t)val_rs;
	}
	
	op1 = (int32_t)val_rm;
	int64_t op64 = (int64_t)op1 * (int64_t)op2;
	val_rd = (uint32_t)((uint64_t)(op64 >> 16) & (uint64_t)0xffffffffULL);
	cpu.SetGPR(rd, val_rd);
}

/*
 * end of smulwy instruction
 *******************************************************************/


/*******************************************************************
 * sdiv (Signed Divide) instruction
 *
 * SDIV divides a 32-bit signed integer register value by a 32-bit
 * signed integer register value, and writes the result to the
 * destination register. The condition code flags are not affected
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op sdiv(cond[4]:0b01110001[8]:rd[4]:0b1111[4]:rm[4]:0b0001[4]:rn[4]);

sdiv.disasm = {
  buffer << "sdiv" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}

/*
 * end of sdiv instruction
 *******************************************************************/

/*******************************************************************
 * udiv (Unsigned Divide) instruction
 *
 * UDIV divides a 32-bit unsigned integer register value by a 32-bit
 * unsigned integer register value, and writes the result to the
 * destination register. The condition code flags are not affected.
 */

{ STATE::MODEL == ARMV5TE || STATE::MODEL == ARMV5TEJ || STATE::MODEL == ARMV5TEXP || STATE::MODEL == ARMV6 || STATE::MODEL == ARMV7 || STATE::MODEL == ARMEMU }: \
op udiv(cond[4]:0b01110011[8]:rd[4]:0b1111[4]:rm[4]:0b0001[4]:rn[4]);

udiv.disasm = {
  buffer << "udiv" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}

/*
 * end of udiv instruction
 *******************************************************************/
