/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

           MULTIPLY INSTRUCTIONS

**********************************************/

/*******************************************************************
 * mla instruction
 */

op mla( cond[4]: 0b0000001[7]: s[1]: rd[4]: rn[4]: rs[4]: 0b1001[4]: rm[4] );

mla.disasm = {
  buffer << "mla" << (s?"s":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", "
         << DisasmRegister(rs) << ", " << DisasmRegister(rn);
};

mla.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t res;
  uint32_t rm_value = cpu.GetGPR(rm);
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rs_value = cpu.GetGPR(rs);
  
  res = rm_value * rs_value;
  res += rn_value;
  cpu.SetGPR(rd, res);
  
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 31) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/*
 * end of mla instruction
 *******************************************************************/

/*******************************************************************
 * mls instruction
 */

op mls( cond[4]: 0b00000110[8]: rd[4]: ra[4]: rm[4]: 0b1001[4]: rn[4] );
mls.var reject : {Reject} = {(rd == 15) or (rn == 15) or (rm == 15) or (ra == 15)};

mls.disasm = {
  buffer << "mls" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

mls.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;

  cpu.SetGPR( rd, cpu.GetGPR( ra ) - (cpu.GetGPR( rn ) * cpu.GetGPR( rm )) );
};

/*
 * end of mls instruction
 *******************************************************************/

/*******************************************************************
 * mul instruction
 */

op mul( cond[4]: 0b0000000[7]: s[1]: rd[4]: 0b0000[4]: rm[4]: 0b1001[4]: rn[4] );
mul.var reject : {Reject} = {(rd == 15) or (rn == 15) or (rm == 15) or ((CONFIG::MODEL < ARMV6) and (rd == rn))};

mul.disasm = {
  buffer << "mul" << (s?"s":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm);
};

mul.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t res;
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rm_value = cpu.GetGPR(rm);
  
  res = rn_value * rm_value;
  cpu.SetGPR(rd, res);
  
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 31) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/*
 * end of mul instruction
 *******************************************************************/

/*******************************************************************
 * smlal instruction
 */

{ CONFIG::insns5E }:                                                     \
op smlal( cond[4]: 0b0000111[7]: s[1]: rdhi[4]: rdlo[4]: rm[4]: 0b1001[4]: rn[4] );
smlal.var reject : {Reject} = {(rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
                               (rdhi == rdlo) or
                               ((CONFIG::MODEL < ARMV6) and ((rdhi == rn) or (rdlo == rn)))};

smlal.disasm = {
  buffer << "smlal" << (s?"s":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};
  
smlal.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint64_t res;
  uint64_t res_lo, res_hi;
  uint32_t rdhi_value = cpu.GetGPR(rdhi);
  uint32_t rdlo_value = cpu.GetGPR(rdlo);
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rm_value = cpu.GetGPR(rm);

  res = rdlo_value + (((uint64_t)rdhi_value) << 32);
  res = (int64_t)res + ((int64_t)(int32_t)rn_value) * ((int64_t)(int32_t)rm_value);
  res_lo = res & (uint64_t)(~(uint32_t)0);
  res_hi = (res >> 32) & (uint64_t)(~(uint32_t)0);
  cpu.SetGPR(rdhi, (uint32_t)res_hi);
  cpu.SetGPR(rdlo, (uint32_t)res_lo);

  if (s)
    {
      cpu.CPSR().Set( N, (res >> 63) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/*
 * end of smlal instruction
 *******************************************************************/

/*******************************************************************
 * smlald (Signed Multiply Accumulate Long Dual) instruction
 *
 * SMLALD performs two signed 16 * 16-bit multiplications. It adds the
 * products to a 64-bit accumulate operand.
 */

{ CONFIG::insns6 }:                                                      \
op smlald( cond[4]: 0b01110100[8]: rdhi[4]: rdlo[4]: rm[4]: 0b00[2]: m[1]: 0b1[1]: rn[4] );

smlald.disasm = {
  buffer << "smlald" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of smlald instruction
 *******************************************************************/

/*******************************************************************
 * smlsld (Signed Multiply Accumulate Long Dual) instruction
 *
 * SMLSLD performs two signed 16 * 16-bit multiplications. It adds the
 * products to a 64-bit accumulate operand.
 */

{ CONFIG::insns6 }:                                                      \
op smlsld( cond[4]: 0b01110100[8]: rdhi[4]: rdlo[4]: rm[4]: 0b01[2]: m[1]: 0b1[1]: rn[4] );

smlsld.disasm = {
  buffer << "smlsld" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of smlsld instruction
 *******************************************************************/

/*******************************************************************
 * smull instruction
 */

op smull( cond[4]: 0b0000110[7]: s[1]: rdhi[4]: rdlo[4]: rm[4]: 0b1001[4]: rn[4] );
smull.var reject : {Reject} = {(rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
                               (rdhi == rdlo) or
                               ((CONFIG::MODEL < ARMV6) and ((rdhi == rn) or (rdlo == rn)))};

smull.disasm = {
  buffer << "smull" << (s?"s":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

smull.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint64_t res;
  uint64_t res_lo, res_hi;
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rm_value = cpu.GetGPR(rm);

  res = ((int64_t)(int32_t)rn_value) * ((int64_t)(int32_t)rm_value);
  res_lo = res & (uint64_t)(~(uint32_t)0);
  res_hi = (res >> 32) & (uint64_t)(~(uint32_t)0);
  cpu.SetGPR(rdhi, (uint32_t)res_hi);
  cpu.SetGPR(rdlo, (uint32_t)res_lo);
  
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 63) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/*
 * end of smull instruction
 *******************************************************************/

/*******************************************************************
 * umlal instruction
 */

op umlal( cond[4]: 0b0000101[7]: s[1]: rdhi[4]: rdlo[4]: rm[4]: 0b1001[4]: rn[4] );
umlal.var reject : {Reject} = {(rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
                               (rdhi == rdlo) or
                               ((CONFIG::MODEL < ARMV6) and ((rdhi == rn) or (rdlo == rn)))};

umlal.disasm = {
  buffer << "umlal" << (s?"s":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

umlal.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint64_t res;
  uint64_t res_lo, res_hi;
  uint32_t rdhi_value = cpu.GetGPR(rdhi);
  uint32_t rdlo_value = cpu.GetGPR(rdlo);
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rm_value = cpu.GetGPR(rm);

  res = rdlo_value + (((uint64_t)rdhi_value) << 32);
  res += ((int64_t)rn_value) * ((int64_t)rm_value);
  res_lo = res & (uint64_t)(~(uint32_t)0);
  res_hi = (res >> 32) & (uint64_t)(~(uint32_t)0);
  cpu.SetGPR(rdhi, (uint32_t)res_hi);
  cpu.SetGPR(rdlo, (uint32_t)res_lo);

  if (s)
    {
      cpu.CPSR().Set( N, (res >> 63) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/*
 * end of umlal instruction
 *******************************************************************/

/*******************************************************************
 * umaal instruction
 */

{ CONFIG::insns6 }:                                                      \
op umaal( cond[4]: 0b00000100[8]: rdhi[4]: rdlo[4]: rm[4]: 0b1001[4]: rn[4] );
umaal.var reject : {Reject} = {(rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
                               (rdhi == rdlo) or
                               ((CONFIG::MODEL < ARMV6) and ((rdhi == rn) or (rdlo == rn)))};

umaal.disasm = {
  buffer << "umaal" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

umaal.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint64_t res = ((uint64_t)cpu.GetGPR( rn ) * (uint64_t)cpu.GetGPR( rm )) +
                 cpu.GetGPR( rdlo ) + cpu.GetGPR( rdhi );
  cpu.SetGPR( rdlo, res >> 0 );
  cpu.SetGPR( rdhi, res >> 32 );
};

/*
 * end of umaal instruction
 *******************************************************************/

/*******************************************************************
 * umull (Unsigned Multiply Long) instruction
 *
 * UMULL multiplies two 32-bit unsigned values to produce a 64-bit
 * result.
 */

op umull( cond[4]: 0b0000100[7]: s[1]: rdhi[4]: rdlo[4]: rm[4]: 0b1001[4]: rn[4] );
umull.var reject : {Reject} = {(rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
                               (rdhi == rdlo) or
                               ((CONFIG::MODEL < ARMV6) and ((rdhi == rn) or (rdlo == rn)))};

umull.disasm = {
  buffer << "umull" << (s?"s":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

umull.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint64_t res;
  uint64_t res_lo, res_hi;
  uint32_t rn_value = cpu.GetGPR(rn);
  uint32_t rm_value = cpu.GetGPR(rm);
  
  res = ((int64_t)rn_value) * ((int64_t)rm_value);
  res_lo = res & (uint64_t)(~(uint32_t)0);
  res_hi = (res >> 32) & (uint64_t)(~(uint32_t)0);
  cpu.SetGPR(rdhi, (uint32_t)res_hi);
  cpu.SetGPR(rdlo, (uint32_t)res_lo);

  if (s)
    {
      cpu.CPSR().Set( N, (res >> 63) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/*
 * end of umull instruction
 *******************************************************************/

/*******************************************************************
 * smlaxy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smlaxy( cond[4]: 0b00010000[8]: rd[4]: ra[4]: rm[4]: 0b1[1]: y[1]: x[1]: 0b0[1]: rn[4] );
smlaxy.var reject : {Reject} = {(rd == 15) or (rn == 15) or (ra == 15) or (rm == 15)};

smlaxy.disasm = {
  buffer << "smla" << (x?"t":"b") << (y?"t":"b") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

smlaxy.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  int32_t op1;
  int32_t op2;
  uint32_t val_rn;
  uint32_t val_rm;
  uint32_t val_ra;
  uint32_t val_rd;
  
  val_rn = cpu.GetGPR(rn);
  val_rm = cpu.GetGPR(rm);
  val_ra = cpu.GetGPR(ra);
  
  if (x)
    val_rn = val_rn >> 16;
  if (val_rn & (uint32_t)0x00008000ULL) {
    val_rn = val_rn | (uint32_t)0xffff0000ULL;
    op1 = (int32_t)val_rn;
  } else {
    val_rn = val_rn & (uint32_t)0x0000ffffULL;
    op1 = (int32_t)val_rn;
  }
  
  if (y)
    val_rm = val_rm >> 16;
  if (val_rm & (uint32_t)0x00008000ULL) {
    val_rm = val_rm | (uint32_t)0xffff0000ULL;
    op2 = (int32_t)val_rm;
  } else {
    val_rm = val_rm & (uint32_t)0x0000ffffULL;
    op2 = (int32_t)val_rm;
  }
  
  uint32_t mul_res = (uint32_t)(op1 * op2);
  //val_rd = op1 + val_ra;
  uint8_t carry_out, overflow_out, sign;
  unisim::util::arithmetic::SignedAdd32(val_rd, carry_out, overflow_out, sign, mul_res, val_ra, 0);
  //if (op1 > 0 && (val_rd & (uint32_t)0x80000000ULL) != 0) {
  if (overflow_out) {
    cpu.CPSR().Set( Q, 1 );
  }
  cpu.SetGPR(rd, val_rd);
};

/*
 * end of smlaxy instruction
 *******************************************************************/

/*******************************************************************
 * smlad instruction
 */

{ CONFIG::insns6 }:                                                      \
op smlad( cond[4]: 0b01110000[8]: rd[4]: ra[4]: rm[4]: 0b00[2]: m[1]: 0b1[1]: rn[4] );

smlad.disasm = {
  buffer << "smlad" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

/*
 * end of smlad instruction
 *******************************************************************/

/*******************************************************************
 * smuad instruction
 */

{ CONFIG::insns6 }:                                                      \
op smuad( cond[4]: 0b01110000[8]: rd[4]: 0b1111[4]: rm[4]: 0b00[2]: m[1]: 0b1[1]: rn[4] );

smuad.disasm = {
  buffer << "smuad" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm);
};

/*
 * end of smuad instruction
 *******************************************************************/

/*******************************************************************
 * smlsd instruction
 */

{ CONFIG::insns6 }:                                                      \
op smlsd( cond[4]: 0b01110000[8]: rd[4]: ra[4]: rm[4]: 0b01[2]: m[1]: 0b1[1]: rn[4] );

smlsd.disasm = {
  buffer << "smlsd" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

/*
 * end of smlsd instruction
 *******************************************************************/

/*******************************************************************
 * smusd instruction
 */

{ CONFIG::insns6 }:                                                      \
op smusd( cond[4]: 0b01110000[8]: rd[4]: 0b1111[4]: rm[4]: 0b01[2]: m[1]: 0b1[1]: rn[4] );

smusd.disasm = {
  buffer << "smusd" << (m?"x":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm);
};

/*
 * end of smusd instruction
 *******************************************************************/

/*******************************************************************
 * smmla instruction
 */

{ CONFIG::insns6 }:                                                      \
op smmla( cond[4]: 0b01110101[8]: rd[4]: ra[4]: rm[4]: 0b00[2]: r[1]: 0b1[1]: rn[4] );

smmla.disasm = {
  buffer << "smmla" << (r?"r":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

/*
 * end of smmla instruction
 *******************************************************************/

/*******************************************************************
 * smmul instruction
 */

{ CONFIG::insns6 }:                                                      \
op smmul( cond[4]: 0b01110101[8]: rd[4]: 0b1111[4]: rm[4]: 0b00[2]: r[1]: 0b1[1]: rn[4] );

smmul.disasm = {
  buffer << "smmul" << (r?"r":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm);
};

/*
 * end of smmul instruction
 *******************************************************************/

/*******************************************************************
 * smmls instruction
 */

{ CONFIG::insns6 }:                                                      \
op smmls( cond[4]: 0b01110101[8]: rd[4]: ra[4]: rm[4]: 0b11[2]: r[1]: 0b1[1]: rn[4] );

smmls.disasm = {
  buffer << "smmls" << (r?"r":"") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

/*
 * end of smmls instruction
 *******************************************************************/

/*******************************************************************
 * smlalxy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smlalxy( cond[4]: 0b00010100[8]: rdhi[4]: rdlo[4]: rm[4]: 0b1[1]: m[1]: n[1]: 0b0[1]: rn[4] );
smlalxy.var reject : {Reject} = {(rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or (rdhi == rdlo)};

smlalxy.disasm = {
  buffer << "smlal" << (n?"t":"b") << (m?"t":"b") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

smlalxy.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint64_t val_rd = (uint64_t( cpu.GetGPR(rdhi) ) << 32) | uint64_t( cpu.GetGPR(rdlo) );
  int32_t op1 = int32_t( int16_t(cpu.GetGPR(rn) >> (n*16)) );
  int32_t op2 = int32_t( int16_t(cpu.GetGPR(rm) >> (m*16)) );
  val_rd += int64_t( op1 * op2 );
  cpu.SetGPR( rdlo, uint32_t( val_rd ) );
  cpu.SetGPR( rdhi, uint32_t( val_rd >> 32 ) );
};

/*
 * end of smlalxy instruction
 *******************************************************************/

/*******************************************************************
 * smlawy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smlawy( cond[4]: 0b00010010[8]: rd[4]: rn[4]: rs[4]: 0b1[1]: y[1]: 0b00[2]: rm[4] );
smlawy.var reject : {Reject} = {(rd == 15) or (rm == 15) or (rn == 15) or (rs == 15)};

smlawy.disasm = {
  buffer << "smlaw" << (y?"t":"b") << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs) << ", " << DisasmRegister(rn);
};

smlawy.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  int32_t op;
  uint32_t val_rm;
  uint32_t val_rs;
  uint32_t val_rn;
  uint32_t val_rd;
  
  val_rm = cpu.GetGPR(rm);
  val_rs = cpu.GetGPR(rs);
  val_rn = cpu.GetGPR(rn);
  
  if (y)
    val_rs = val_rs >> 16;
  if (val_rs & (uint32_t)0x00008000ULL) {
    val_rs = val_rs | (uint32_t)0xffff0000ULL;
    op = (int32_t)val_rs;
  } else {
    val_rs = val_rs & (uint32_t)0x0000ffffULL;
    op = (int32_t)val_rs;
  }
  
  int64_t op64;
  op64 = (int32_t)val_rm;
  op64 = op64 * op;
  op64 = op64 >> 16;
  op64 = op64 & (uint64_t)0xffffffffULL;
  uint32_t op_tmp = op64;
  //int32_t sval_rd = (int32_t)op_tmp;
  //val_rd = (uint32_t)(sval_rd + (int32_t)val_rn);
  uint8_t carry_out, overflow_out, sign;
  unisim::util::arithmetic::SignedAdd32(val_rd, carry_out, overflow_out, sign, op_tmp, val_rn, 0);
  //   if ( (op_tmp & (uint32_t)0x80000000ULL) !=
  //     (val_rn & (uint32_t)0x80000000ULL) )
  if (overflow_out)
    {
      //    cpu.SetCPSR_Q(false);
      cpu.CPSR().Set( Q, 1 );
    }
  //   else
  //   {
  //     if ( (op_tmp & (uint32_t)0x80000000ULL) !=
  //       (val_rd & (uint32_t)0x80000000ULL) )
  //     {
  //       cpu.SetCPSR_Q(true);
  //     }
  //     else
  //       cpu.SetCPSR_Q(false);
  //   }
  cpu.SetGPR(rd, val_rd);

};

/*
 * end of smlawy instruction
 *******************************************************************/

/*******************************************************************
 * smulxy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smulxy( cond[4]: 0b00010110[8]: rd[4]: 0b0000[4]: rs[4]: 0b1[1]: y[1]: x[1]: 0b0[1]: rm[4] );
smulxy.var reject : {Reject} = {(rd == 15) or (rm == 15) or (rs == 15)};

smulxy.disasm = {
  buffer << "smul" << (x?"t":"b") << (y?"t":"b") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
};

smulxy.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  int32_t op1;
  int32_t op2;
  uint32_t val_rm;
  uint32_t val_rs;
  uint32_t val_rd;
  
  val_rm = cpu.GetGPR(rm);
  val_rs = cpu.GetGPR(rs);
  
  if (x)
    val_rm = val_rm >> 16;
  if (val_rm & (uint32_t)0x00008000ULL) {
    val_rm = val_rm | (uint32_t)0xffff0000ULL;
    op1 = (int32_t)val_rm;
  } else {
    val_rm = val_rm & (uint32_t)0x0000ffffULL;
    op1 = (int32_t)val_rm;
  }
  
  if (y)
    val_rs = val_rs >> 16;
  if (val_rs & (uint32_t)0x00008000ULL) {
    val_rs = val_rs | (uint32_t)0xffff0000ULL;
    op2 = (int32_t)val_rs;
  } else {
    val_rs = val_rs & (uint32_t)0x0000ffffULL;
    op2 = (int32_t)val_rs;
  }
  
  op1 = op1 * op2;
  val_rd = (uint32_t)op1;
  cpu.SetGPR(rd, val_rd);
};

/*
 * end of smulxy instruction
 *******************************************************************/

/*******************************************************************
 * smulwy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smulwy( cond[4]: 0b00010010[8]: rd[4]: 0b0000[4]: rs[4]: 0b1[1]: y[1]: 0b10[2]: rm[4] );
smulwy.var reject : {Reject} = {(rd == 15) or (rm == 15) or (rs == 15)};

smulwy.disasm = {
  buffer << "smulw" << (y?"t":"b") << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
};

smulwy.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  int32_t op1;
  int32_t op2;
  uint32_t val_rm;
  uint32_t val_rs;
  uint32_t val_rd;
  
  val_rm = cpu.GetGPR(rm);
  val_rs = cpu.GetGPR(rs);
  
  if (y)
    val_rs = val_rs >> 16;
  if (val_rs & (uint32_t)0x00008000ULL) {
    val_rs = val_rs | (uint32_t)0xffff0000ULL;
    op2 = (int32_t)val_rs;
  } else {
    val_rs = val_rs & (uint32_t)0x0000ffffULL;
    op2 = (int32_t)val_rs;
  }
  
  op1 = (int32_t)val_rm;
  int64_t op64 = (int64_t)op1 * (int64_t)op2;
  val_rd = (uint32_t)((uint64_t)(op64 >> 16) & (uint64_t)0xffffffffULL);
  cpu.SetGPR(rd, val_rd);
};

/*
 * end of smulwy instruction
 *******************************************************************/


/*******************************************************************
 * sdiv (Signed Divide) instruction
 *
 * SDIV divides a 32-bit signed integer register value by a 32-bit
 * signed integer register value, and writes the result to the
 * destination register. The condition code flags are not affected
 */

{ CONFIG::insnsRM }:                                                     \
op sdiv( cond[4]: 0b01110001[8]: rd[4]: 0b1111[4]: rm[4]: 0b0001[4]: rn[4] );

sdiv.disasm = {
  buffer << "sdiv" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of sdiv instruction
 *******************************************************************/

/*******************************************************************
 * udiv (Unsigned Divide) instruction
 *
 * UDIV divides a 32-bit unsigned integer register value by a 32-bit
 * unsigned integer register value, and writes the result to the
 * destination register. The condition code flags are not affected.
 */

{ CONFIG::insnsRM }:                                                     \
op udiv( cond[4]: 0b01110011[8]: rd[4]: 0b1111[4]: rm[4]: 0b0001[4]: rn[4] );

udiv.disasm = {
  buffer << "udiv" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of udiv instruction
 *******************************************************************/
