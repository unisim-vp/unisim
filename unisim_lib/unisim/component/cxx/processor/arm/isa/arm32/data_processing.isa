/*
 *  Copyright (c) 2007-2013,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

        DATA PROCESSING INSTRUCTIONS

**********************************************/

/*******************************************************************
 * and instruction
 */

op and_32imm(cond[4]:0b00[2]:0b1[1]:0b0000[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
and_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

and_32imm.disasm = {
  buffer << "and" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

and_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
      cpu.CPSR().C().Set( imr == 0 ? cpu.CPSR().C().Get() : (imm >> 31) );
    }
};

op and_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0000[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

and_imm_shift.disasm = {
  buffer << "and" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

and_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op and_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0000[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

and_reg_shift.disasm = {
  buffer << "and" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

and_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of and instruction
 *******************************************************************/

/*******************************************************************
 * eor instruction
 */

op eor_32imm(cond[4]:0b00[2]:0b1[1]:0b0001[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
eor_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

eor_32imm.disasm = {
  buffer << "eor" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

eor_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
      cpu.CPSR().C().Set( imr == 0 ? cpu.CPSR().C().Get() : (imm >> 31) );
    }
};

op eor_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0001[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

eor_imm_shift.disasm = {
  buffer << "eor" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

eor_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op eor_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0001[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

eor_reg_shift.disasm = {
  buffer << "eor" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

eor_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of eor instruction
 *******************************************************************/

/*******************************************************************
 * sub instruction
 */

op sub_32imm(cond[4]:0b00[2]:0b1[1]:0b0010[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
sub_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

sub_32imm.disasm = {
  buffer << "sub" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

sub_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sub_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0010[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

sub_imm_shift.disasm = {
  buffer << "sub" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

sub_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sub_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0010[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

sub_reg_shift.disasm = {
  buffer << "sub" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

sub_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of sub instruction
 *******************************************************************/

/*******************************************************************
 * rsb instruction
 */

op rsb_32imm(cond[4]:0b00[2]:0b1[1]:0b0011[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
rsb_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

rsb_32imm.disasm = {
  buffer << "rsb" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

rsb_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = imm, op2 = cpu.GetGPR( rn ), res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsb_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0011[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

rsb_imm_shift.disasm = {
  buffer << "rsb" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

rsb_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR( rn ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsb_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0011[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

rsb_reg_shift.disasm = {
  buffer << "rsb" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

rsb_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = ComputeRegShift( cpu, rmval, shift, rsval ), op2 = cpu.GetGPR( rn ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of rsb instruction
 *******************************************************************/

/*******************************************************************
 * add instruction
 */

op add_32imm(cond[4]:0b00[2]:0b1[1]:0b0100[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
add_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

add_32imm.disasm = {
  buffer << "add" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

add_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op add_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0100[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

add_imm_shift.disasm = {
  buffer << "add" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

add_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op add_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0100[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

add_reg_shift.disasm = {
  buffer << "add" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

add_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

/*
 * end of add instruction
 *******************************************************************/

/*******************************************************************
 * adc instruction
 */

op adc_32imm(cond[4]:0b00[2]:0b1[1]:0b0101[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
adc_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

adc_32imm.disasm = {
  buffer << "adc" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

adc_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 + op2 + cpu.CPSR().C().Get();
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op adc_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0101[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

adc_imm_shift.disasm = {
  buffer << "adc" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

adc_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 + op2 + cpu.CPSR().C().Get();
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op adc_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0101[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

adc_reg_shift.disasm = {
  buffer << "adc" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

adc_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 + op2 + cpu.CPSR().C().Get();
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

/*
 * end of adc instruction
 *******************************************************************/

/*******************************************************************
 * sbc instruction
 */

op sbc_32imm(cond[4]:0b00[2]:0b1[1]:0b0110[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
sbc_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

sbc_32imm.disasm = {
  buffer << "sbc" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

sbc_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 - op2 - (cpu.CPSR().C().Get() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sbc_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0110[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

sbc_imm_shift.disasm = {
  buffer << "sbc" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

sbc_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 - op2 - (cpu.CPSR().C().Get() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sbc_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0110[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

sbc_reg_shift.disasm = {
  buffer << "sbc" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

sbc_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 - op2 - (cpu.CPSR().C().Get() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of sbc instruction
 *******************************************************************/

/*******************************************************************
 * rsc instruction
 */

op rsc_32imm(cond[4]:0b00[2]:0b1[1]:0b0111[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
rsc_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

rsc_32imm.disasm = {
  buffer << "rsc" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

rsc_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = imm, op2 = cpu.GetGPR( rn ), res = op1 - op2 - (cpu.CPSR().C().Get() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsc_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0111[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

rsc_imm_shift.disasm = {
  buffer << "rsc" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

rsc_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR( rn ),
           res = op1 - op2 - (cpu.CPSR().C().Get() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsc_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0111[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

rsc_reg_shift.disasm = {
  buffer << "rsc" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

rsc_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = ComputeRegShift( cpu, rmval, shift, rsval ), op2 = cpu.GetGPR( rn ),
           res = op1 - op2 - (cpu.CPSR().C().Get() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of rsc instruction
 *******************************************************************/

/*******************************************************************
 * orr instruction
 */

op orr_32imm(cond[4]:0b00[2]:0b1[1]:0b1100[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
orr_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

orr_32imm.disasm = {
  buffer << "orr" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

orr_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
      cpu.CPSR().C().Set( imr == 0 ? cpu.CPSR().C().Get() : (imm >> 31) );
    }
};

op orr_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1100[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

orr_imm_shift.disasm = {
  buffer << "orr" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

orr_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op orr_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1100[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

orr_reg_shift.disasm = {
  buffer << "orr" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

orr_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of orr instruction
 *******************************************************************/

/*******************************************************************
 * bic instruction
 */

op bic_32imm(cond[4]:0b00[2]:0b1[1]:0b1110[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
bic_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

bic_32imm.disasm = {
  buffer << "bic" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

bic_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
      cpu.CPSR().C().Set( imr == 0 ? cpu.CPSR().C().Get() : (imm >> 31) );
    }
};

op bic_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1110[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

bic_imm_shift.disasm = {
  buffer << "bic" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

bic_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op bic_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1110[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

bic_reg_shift.disasm = {
  buffer << "bic" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

bic_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of bic instruction
 *******************************************************************/

/*******************************************************************
 * tst instruction
 */

op tst_32imm(cond[4]:0b00[2]:0b1[1]:0b1000[4]:1[1]:rn[4]:/*sbz*/0[4]:shl<1> imr[4] : imb[8]);
tst_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

tst_32imm.disasm = {
  buffer << "tst" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmI(imm);
};

tst_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 & op2;
  cpu.CPSR().N().Set( (res >> 31) & 1 );
  cpu.CPSR().Z().Set( res == 0 );
  cpu.CPSR().C().Set( imr == 0 ? cpu.CPSR().C().Get() : (imm >> 31) );
};

op tst_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1000[4]:1[1]:rn[4]:/*sbz*/0[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

tst_imm_shift.disasm = {
  buffer << "tst" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

tst_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & op2;
  UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op tst_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1000[4]:0b1[1]:rn[4]:/*sbz*/0[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

tst_reg_shift.disasm = {
  buffer << "tst" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

tst_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 & op2;
  UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of tst instruction
 *******************************************************************/

/*******************************************************************
 * teq instruction
 */

op teq_32imm(cond[4]:0b00[2]:0b1[1]:0b1001[4]:0b1[1]:rn[4]:/*sbz*/0[4]:shl<1> imr[4] : imb[8]);
teq_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

teq_32imm.disasm = {
  buffer << "teq" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmI(imm);
};

teq_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 ^ op2;
  cpu.CPSR().N().Set( (res >> 31) & 1 );
  cpu.CPSR().Z().Set( res == 0 );
  cpu.CPSR().C().Set( imr == 0 ? cpu.CPSR().C().Get() : (imm >> 31) );
};

op teq_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1001[4]:1[1]:rn[4]:/*sbz*/0[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

teq_imm_shift.disasm = {
  buffer << "teq" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

teq_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 ^ op2;
  UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op teq_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1001[4]:0b1[1]:rn[4]:/*sbz*/0[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

teq_reg_shift.disasm = {
  buffer << "teq" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

teq_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 ^ op2;
  UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of teq instruction
 *******************************************************************/

/*******************************************************************
 * cmp instruction
 */

op cmp_32imm(cond[4]:0b00[2]:0b1[1]:0b1010[4]:0b1[1]:rn[4]:/*sbz*/0[4]:shl<1> imr[4] : imb[8]);
cmp_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

cmp_32imm.disasm = {
  buffer << "cmp" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmI(imm);
};

cmp_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

op cmp_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1010[4]:0b1[1]:rn[4]:/*sbz*/0[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

cmp_imm_shift.disasm = {
  buffer << "cmp" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

cmp_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

op cmp_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1010[4]:0b1[1]:rn[4]:/*sbz*/0[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

cmp_reg_shift.disasm = {
  buffer << "cmp" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

cmp_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of cmp instruction
 *******************************************************************/

/*******************************************************************
 * cmn instruction
 */

op cmn_32imm(cond[4]:0b00[2]:0b1[1]:0b1011[4]:0b1[1]:rn[4]:/*sbz*/0[4]:shl<1> imr[4] : imb[8]);
cmn_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

cmn_32imm.disasm = {
  buffer << "cmn" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmI(imm);
};

cmn_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

op cmn_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1011[4]:0b1[1]:rn[4]:/*sbz*/0[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

cmn_imm_shift.disasm = {
  buffer << "cmn" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

cmn_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

op cmn_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1011[4]:0b1[1]:rn[4]:/*sbz*/0[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

cmn_reg_shift.disasm = {
  buffer << "cmn" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

cmn_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

/*
 * end of cmn instruction
 *******************************************************************/

/*******************************************************************
 * mov instruction
 */

op mov_32imm (cond[4]:0b00[2]:0b1[1]:0b1101[4]:s[1]:/*sbz*/0[4]:rd[4]:shl<1> imr[4]:imb[8]);
mov_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

mov_32imm.disasm = {
  buffer << "mov" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmI(imm);
};

mov_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t res = imm;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
      cpu.CPSR().C().Set( imr == 0 ? cpu.CPSR().C().Get() : (imm >> 31) );
    }
};

op mov_imm_shift (cond[4]:0b00[2]:0b0[1]:0b1101[4]:s[1]:/*sbz*/0[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

mov_imm_shift.disasm = {
  DisasmCondition postfix(cond, s?"s":"");
  uint32_t shift_value = imm;
  
  if (imm == 0) {
    char const* mnemonic = shift ? "rrx" : "mov";
    if (shift == 0 or shift == 3) {
      buffer << mnemonic << postfix << '\t'
             << DisasmRegister(rd) << ", " << DisasmRegister(rm);
      return;
    }
    shift_value = 32;
  }
  buffer << DisasmShift(shift) << postfix << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", #" << shift_value;
};

mov_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t rmval = cpu.GetGPR( rm ), res = ComputeImmShift( cpu, rmval, shift, imm );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op mov_reg_shift (cond[4]:0b00[2]:0b0[1]:0b1101[4]:s[1]:/*sbz*/0[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

mov_reg_shift.disasm = {
  buffer << DisasmShift(shift) << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
};

mov_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t
    rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
    res = ComputeRegShift( cpu, rmval, shift, rsval );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of mov instruction
 *******************************************************************/

/*******************************************************************
 * mvn instruction
 */

op mvn_32imm (cond[4]:0b00[2]:0b1[1]:0b1111[4]:s[1]:/*sbz*/0[4]:rd[4]:shl<1> imr[4] : imb[8]);
mvn_32imm.var imm : {uint32_t} = {unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr )};

mvn_32imm.disasm = {
  buffer << "mvn" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmI(imm);
};

mvn_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t res = ~imm;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
      cpu.CPSR().C().Set( imr == 0 ? cpu.CPSR().C().Get() : (imm >> 31) );
    }
};

op mvn_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1111[4]:s[1]:/*sbz*/0[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

mvn_imm_shift.disasm = {
  buffer << "mvn" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

mvn_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t rmval = cpu.GetGPR( rm ), res = ~(ComputeImmShift( cpu, rmval, shift, imm ));
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op mvn_reg_shift (cond[4]:0b00[2]:0b0[1]:0b1111[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

mvn_reg_shift.disasm = {
  buffer << "mvn" << DisasmCondition(cond, s?"s":"") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", "
         << DisasmShReg( shift, rs );
};

mvn_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t
    rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
  res = ~(ComputeRegShift( cpu, rmval, shift, rsval ));
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of mvn instruction
 *******************************************************************/

/*******************************************************************
 * clz (count leading zero) instruction
 */

{ ARCH::insns5T }: \
op clz(cond[4]:0b00010110[8]:/*sbo*/0xf[4]:rd[4]:/*sbo*/0xf[4]:0b0001[4]:rm[4]);

clz.disasm = {
  buffer << "clz" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rm);
};

clz.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  cpu.SetGPR(rd, unisim::util::arithmetic::CountLeadingZeros( cpu.GetGPR(rm) ));
};

/*
 * end of clz (count leading zero) instruction
 *******************************************************************/

/*******************************************************************
 * rbit instruction
 */

{ ARCH::insnsT2 }:                      \
op rbit( cond[4]:0x6ff[12]:rd[4]:0xf3[8]:rm[4] );

rbit.disasm = {
  buffer << "rbit" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm);
};

rbit.execute = {
  uint32_t src = cpu.GetGPR( rm ), dst = 0;
  for (int idx = 0; idx < 32; ++idx) { dst = (dst << 1) | (src & 1); src >>= 1; }
  cpu.SetGPR( rd, dst );
};

/*
 * end of rbit instruction
 *******************************************************************/

/*******************************************************************
 * rev (Byte-Reverse Word) instruction
 *
 * REV reverses the byte order in a 32-bit register.
 */

{ ARCH::insns6 }:                                       \
op rev( cond[4]:0b01101[5]:0[1]:0b11[2]:/*sbo*/0b1111[4]:rd[4]:/*sbo*/0b1111[4]:0b0011[4]:rm[4] );

rev.disasm = {
  buffer << "rev" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm);
};

rev.execute = {
  uint32_t src = cpu.GetGPR( rm ), dst = 0;
  for (int idx = 0; idx < 32; idx += 8) { dst = (dst << 8) | (src & 0xff); src >>= 8; }
  cpu.SetGPR( rd, dst );
};

/*
 * end of rev instruction
 *******************************************************************/

/*******************************************************************
 * revsh (Byte-Reverse Word) instruction
 *
 * REVSH reverses the byte order in a 32-bit register.
 */

{ ARCH::insns6 }:                                       \
op revsh( cond[4]:0b01101[5]:1[1]:0b11[2]:/*sbo*/0b1111[4]:rd[4]:/*sbo*/0b1111[4]:0b1011[4]:rm[4] );

revsh.disasm = {
  buffer << "revsh" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm);
};

/*
 * end of revsh instruction
 *******************************************************************/

/*******************************************************************
 * rev16 (Byte-Reverse Packed Halfword) instruction
 *
 * REV16 reverses the byte order in each16-bit halfword of a 32-bit
 * register.
 */

{ ARCH::insns6 }:                                       \
op rev16( cond[4]:0b01101[5]:0[1]:0b11[2]:/*sbo*/0b1111[4]:rd[4]:/*sbo*/0b1111[4]:0b1011[4]:rm[4] );

rev16.disasm = {
  buffer << "rev16" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rm);
};

rev16.execute = {
  uint32_t src = cpu.GetGPR( rm ), dst = 0;
  for (int idx = 0; idx < 32; idx += 8) { dst = (dst << 8) | (src & 0xff); src >>= 8; }
  cpu.SetGPR( rd, (dst << 16) | (dst >> 16) );
};

/*
 * end of rev16 instruction
 *******************************************************************/

/*******************************************************************
 * movw (Move Wide) instruction
 *
 * MOVW writes a zero-extended 16-bits immediate value to a
 * destination register. In combination with MOVW, this instruction
 * allows to load a 32-bits constants in a destination register.
 */

{ ARCH::insnsT2 }:                              \
op movw( cond[4]:0x30[8]:shl<12> imm1[4]:rd[4]:imm0[12] );
movw.var imm : {uint32_t} = {imm1|imm0};

movw.disasm = {
  buffer << "movw" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmI(imm);
};

movw.execute = {
  cpu.SetGPR( rd, imm );
};

/*
 * end of movw instruction
 *******************************************************************/

/*******************************************************************
 * movt (Move Top) instruction
 *
 * MOVT writes an immediate value to the top halfword of the
 * destination register. It does not affect the contents of the bottom
 * halfword.
 */

{ ARCH::insnsT2 }:                              \
op movt( cond[4]:0x34[8]:shl<12> imm1[4]:rd[4]:imm0[12] );
movt.var imm : {uint32_t} = {imm1|imm0};

movt.disasm = {
  buffer << "movt" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rd) << ", " << DisasmI(imm);
};

movt.execute = {
  cpu.SetGPR( rd, (cpu.GetGPR( rd ) & 0xffff) | (imm << 16) );
};

/*
 * end of movt (Move Top) instruction
 *******************************************************************/
