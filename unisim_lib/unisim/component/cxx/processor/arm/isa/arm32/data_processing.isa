/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 */
 
/**********************************************

        DATA PROCESSING INSTRUCTIONS

**********************************************/

/*******************************************************************
 * and instruction
 */

op and_32imm(cond[4]:0b00[2]:0b1[1]:0b0000[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op and_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0000[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op and_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0000[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op ands_32imm(cond[4]:0b00[2]:0b1[1]:0b0000[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op ands_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0000[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op ands_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0000[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

and_32imm.disasm = {
  buffer << "and";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

and_imm_shift.disasm = {
  buffer << "and";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

and_reg_shift.disasm = {
  buffer << "and";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

ands_32imm.disasm = {
  buffer << "and";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

ands_imm_shift.disasm = {
  buffer << "and";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

ands_reg_shift.disasm = {
  buffer << "and";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

and_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
//	s2 = cpu.ShiftOperand32imm(rotate_imm, imm);
	s2 = ShiftOperand32imm(rotate_imm, imm);
	res = s1 & s2;
	cpu.SetGPR(rd, res);
}

and_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
  	res = s1 & s2;
  	cpu.SetGPR(rd, res);
}

and_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rs_value = cpu.GetGPR(rs);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s1 & s2;
	cpu.SetGPR(rd, res);
}

ands_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 & s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}	
}

ands_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, 
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 & s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

ands_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value,
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 & s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

/*
 * end of and instruction
 *******************************************************************/

/*******************************************************************
 * eor instruction
 */

op eor_32imm(cond[4]:0b00[2]:0b1[1]:0b0001[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op eor_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0001[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op eor_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0001[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op eors_32imm(cond[4]:0b00[2]:0b1[1]:0b0001[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op eors_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0001[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op eors_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0001[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

eor_32imm.disasm = {
  buffer << "eor";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

eor_imm_shift.disasm = {
  buffer << "eor";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

eor_reg_shift.disasm = {
  buffer << "eor";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

eors_32imm.disasm = {
  buffer << "eor";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

eors_imm_shift.disasm = {
  buffer << "eor";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

eors_reg_shift.disasm = {
  buffer << "eor";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

eor_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	res = s1 ^ s2;
	cpu.SetGPR(rd, res);
}

eor_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = s1 ^ s2;
	cpu.SetGPR(rd, res);
}

eor_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rs_value = cpu.GetGPR(rs);
  
  
	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s1 ^ s2;
	cpu.SetGPR(rd, res);
}

eors_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	
	
	if(!cpu.CheckCondition(cond)) return;
	
	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 ^ s2;
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

eors_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, 
				cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 ^ s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

eors_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value, 
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 ^ s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}	
}

/*
 * end of eor instruction
 *******************************************************************/

/*******************************************************************
 * sub instruction
 */

op sub_32imm(cond[4]:0b00[2]:0b1[1]:0b0010[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op sub_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0010[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op sub_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0010[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op subs_32imm(cond[4]:0b00[2]:0b1[1]:0b0010[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op subs_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0010[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op subs_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0010[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

sub_32imm.disasm = {
  buffer << "sub";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

sub_imm_shift.disasm = {
  buffer << "sub";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

sub_reg_shift.disasm = {
  buffer << "sub";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

subs_32imm.disasm = {
  buffer << "sub";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

subs_imm_shift.disasm = {
  buffer << "sub";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

subs_reg_shift.disasm = {
  buffer << "sub";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

sub_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	res = s1 - s2;
	cpu.SetGPR(rd, res);
}

sub_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
  
	
	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = s1 - s2;
	cpu.SetGPR(rd, res);
}

sub_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s1 - s2;
	cpu.SetGPR(rd, res);
}

subs_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	res = s1 - s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s1, s2)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2)); // to check
	}
}

subs_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = s1 - s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s1, s2)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2)); // to check
	}
}

subs_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s1 - s2;
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s1, s2)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2)); // to check
	}
}

/*
 * end of sub instruction
 *******************************************************************/

/*******************************************************************
 * rsb instruction
 */

op rsb_32imm(cond[4]:0b00[2]:0b1[1]:0b0011[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op rsb_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0011[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op rsb_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0011[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op rsbs_32imm(cond[4]:0b00[2]:0b1[1]:0b0011[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op rsbs_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0011[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op rsbs_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0011[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

rsb_32imm.disasm = {
  buffer << "rsb";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

rsb_imm_shift.disasm = {
  buffer << "rsb";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

rsb_reg_shift.disasm = {
  buffer << "rsb";
  DisasmCondition(cond, buffer);
  buffer << " r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

rsbs_32imm.disasm = {
  buffer << "rsb";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

rsbs_imm_shift.disasm = {
  buffer << "rsb";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

rsbs_reg_shift.disasm = {
  buffer << "rsb";
  DisasmCondition(cond, buffer);
  buffer << "s r";
  buffer << (unsigned int) rd;
  buffer << ", r";
  buffer << (unsigned int) rn;
  buffer << ", ";
  DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

rsb_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);

	
	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	res = s2 - s1;
	cpu.SetGPR(rd, res);
}

rsb_imm_shift.execute = {
	typedef Operation<STATE> inherited;
	
	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = s2 - s1;
	cpu.SetGPR(rd, res);
}

rsb_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s2 - s1;
	cpu.SetGPR(rd, res);
}

rsbs_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;
	
	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	res = s2 - s1;
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s2, s1)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s2, s1)); // to check
	}
}

rsbs_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = s2 - s1;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s2, s1)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s2, s1)); // to check
	}
}

rsbs_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;
	
	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s2 - s1;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s2, s1)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s2, s1)); // to check
	}
}

/*
 * end of rsb instruction
 *******************************************************************/

/*******************************************************************
 * add instruction
 */

op add_32imm(cond[4]:0b00[2]:0b1[1]:0b0100[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op add_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0100[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op add_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0100[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op adds_32imm(cond[4]:0b00[2]:0b1[1]:0b0100[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op adds_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0100[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op adds_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0100[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

add_32imm.disasm = {
	buffer << "add";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

add_imm_shift.disasm = {
	buffer << "add";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

add_reg_shift.disasm = {
	buffer << "add";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

adds_32imm.disasm = {
	buffer << "add";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

adds_imm_shift.disasm = {
	buffer << "add";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

adds_reg_shift.disasm = {
	buffer << "add";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

add_32imm.execute = {
	typedef Operation<STATE> inherited;
  
	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
  	res = s1 + s2;
  	cpu.SetGPR(rd, res);
}

add_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = s1 + s2;
	cpu.SetGPR(rd, res);
}

add_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s1 + s2;
	cpu.SetGPR(rd, res);
}

adds_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint8_t carry_out;
	uint8_t overflow_out;
	uint8_t sign;


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	Add32(res, carry_out, overflow_out, sign,
			s1, s2, 0);
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(carry_out); // to check
		cpu.SetCPSR_V(overflow_out); // to check
	}
}

adds_imm_shift.execute = {
	typedef Operation<STATE> inherited;
	
	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint8_t carry_out;
	uint8_t overflow_out;
	uint8_t sign;
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	Add32(res, carry_out, overflow_out, sign,
			s1, s2, 0);
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(carry_out); // to check
		cpu.SetCPSR_V(overflow_out); // to check
	}
}

adds_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
	uint8_t carry_out;
	uint8_t overflow_out;
	uint8_t sign;
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	Add32(res, carry_out, overflow_out, sign,
			s1, s2, 0);
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(carry_out); // to check
		cpu.SetCPSR_V(overflow_out); // to check
	}
}

/*
 * end of add instruction
 *******************************************************************/

/*******************************************************************
 * adc instruction
 */

op adc_32imm(cond[4]:0b00[2]:0b1[1]:0b0101[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op adc_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0101[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op adc_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0101[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op adcs_32imm(cond[4]:0b00[2]:0b1[1]:0b0101[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op adcs_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0101[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op adcs_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0101[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

adc_32imm.disasm = {
	buffer << "adc";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

adc_imm_shift.disasm = {
	buffer << "adc";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

adc_reg_shift.disasm = {
	buffer << "adc";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

adcs_32imm.disasm = {
	buffer << "adc";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

adcs_imm_shift.disasm = {
	buffer << "adc";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

adcs_reg_shift.disasm = {
	buffer << "adc";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

adc_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t carry_in;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	carry_in = (cpu.GetCPSR_C() ? 1 : 0);
	res = s1 + s2 + carry_in;
	cpu.SetGPR(rd, res);
}

adc_imm_shift.execute = {
	typedef Operation<STATE> inherited;
	
	uint32_t s1, s2;
	uint32_t res;
	uint32_t carry_in;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	carry_in = (cpu.GetCPSR_C() ? 1 : 0);
	res = s1 + s2 + carry_in;
	cpu.SetGPR(rd, res);
}

adc_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t carry_in;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	carry_in = (cpu.GetCPSR_C() ? 1 : 0);
	res = s1 + s2 + carry_in;
	cpu.SetGPR(rd, res);
}

adcs_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint8_t carry_in;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint8_t carry_out;
	uint8_t overflow_out;
	uint8_t sign;


	if(!cpu.CheckCondition(cond)) return;
	
	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	carry_in = (cpu.GetCPSR_C() ? 1 : 0);
	Add32(res, carry_out, overflow_out, sign,
			s1, s2, carry_in);
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(carry_out); // to check
		cpu.SetCPSR_V(overflow_out); // to check
	}
}

adcs_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint8_t carry_in;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint8_t carry_out;
	uint8_t overflow_out;
	uint8_t sign;
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	carry_in = (cpu.GetCPSR_C() ? 1 : 0);
	Add32(res, carry_out, overflow_out, sign,
			s1, s2, carry_in);
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(carry_out); // to check
		cpu.SetCPSR_V(overflow_out); // to check
	}
}

adcs_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint8_t carry_in;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
	uint8_t carry_out;
	uint8_t overflow_out;
	uint8_t sign;
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	carry_in = (cpu.GetCPSR_C() ? 1 : 0);
	Add32(res, carry_out, overflow_out, sign,
			s1, s2, carry_in);
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(carry_out); // to check
		cpu.SetCPSR_V(overflow_out); // to check
	}
}

/*
 * end of adc instruction
 *******************************************************************/

/*******************************************************************
 * sbc instruction
 */

op sbc_32imm(cond[4]:0b00[2]:0b1[1]:0b0110[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op sbc_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0110[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op sbc_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0110[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op sbcs_32imm(cond[4]:0b00[2]:0b1[1]:0b0110[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op sbcs_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0110[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op sbcs_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0110[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

sbc_32imm.disasm = {
	buffer << "sbc";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

sbc_imm_shift.disasm = {
	buffer << "sbc";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

sbc_reg_shift.disasm = {
	buffer << "sbc";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

sbcs_32imm.disasm = {
	buffer << "sbc";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

sbcs_imm_shift.disasm = {
	buffer << "sbc";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

sbcs_reg_shift.disasm = {
	buffer << "sbc";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

sbc_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s1 - s2 - in_neg_carry;
	cpu.SetGPR(rd, res);
}

sbc_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR());
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s1 - s2 - in_neg_carry;
	cpu.SetGPR(rd, res);
}

sbc_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s1 - s2 - in_neg_carry;
	cpu.SetGPR(rd, res);
}

sbcs_32imm.execute = {
	typedef Operation<STATE> inherited;
	
	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s1 - s2 - in_neg_carry;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s1, s2, in_neg_carry)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2, in_neg_carry)); // to check
	}
}

sbcs_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s1 - s2 - in_neg_carry;
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s1, s2, in_neg_carry)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2, in_neg_carry)); // to check
	}
}

sbcs_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s1 - s2 - in_neg_carry;;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s1, s2, in_neg_carry)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2, in_neg_carry)); // to check
	}
}

/*
 * end of sbc instruction
 *******************************************************************/

/*******************************************************************
 * rsc instruction
 */

op rsc_32imm(cond[4]:0b00[2]:0b1[1]:0b0111[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op rsc_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0111[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op rsc_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0111[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op rscs_32imm(cond[4]:0b00[2]:0b1[1]:0b0111[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op rscs_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0111[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op rscs_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0111[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

rsc_32imm.disasm = {
	buffer << "rsc";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

rsc_imm_shift.disasm = {
	buffer << "rsc";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

rsc_reg_shift.disasm = {
	buffer << "rsc";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

rscs_32imm.disasm = {
	buffer << "rsc";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

rscs_imm_shift.disasm = {
	buffer << "rsc";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

rscs_reg_shift.disasm = {
	buffer << "rsc";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

rsc_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s2 - s1 - in_neg_carry;
	cpu.SetGPR(rd, res);
}

rsc_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	
	
	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s2 - s1 - in_neg_carry;
	cpu.SetGPR(rd, res);
}

rsc_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s2 - s1 - in_neg_carry;
	cpu.SetGPR(rd, res);
}

rscs_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);

	
	if(!cpu.CheckCondition(cond)) return;
	
	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s2 - s1 - in_neg_carry;
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s2, s1, in_neg_carry)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s2, s1, in_neg_carry)); // to check
	}
}

rscs_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s2 - s1 - in_neg_carry;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s2, s1, in_neg_carry)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s2, s1, in_neg_carry)); // to check
	}
}

rscs_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s2 - s1 - in_neg_carry;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(!BorrowFrom(res, s2, s1, in_neg_carry)); // to check
		cpu.SetCPSR_V(SubtractionOverflowFrom(res, s2, s1, in_neg_carry)); // to check
	}
}

/*
 * end of rsc instruction
 *******************************************************************/

/*******************************************************************
 * tst instruction
 */

op tst_32imm(cond[4]:0b00[2]:0b1[1]:0b1000[4]:0b1[1]:rn[4]:sbz[4]:rotate_imm[4]:imm[8])
op tst_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1000[4]:0b1[1]:rn[4]:sbz[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op tst_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1000[4]:0b1[1]:rn[4]:sbz[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

tst_32imm.disasm = {
	buffer << "tst";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

tst_imm_shift.disasm = {
	buffer << "tst";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

tst_reg_shift.disasm = {
	buffer << "tst";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

tst_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 & s2;

	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(shift_carry_out);
	// nothing to do with overflow (V) flag
}

tst_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, 
				cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 & s2;
  
	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(shift_carry_out);
	// nothing to do with overflow (V) flag
}

tst_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;
	
	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value,
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 & s2;
	
	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(shift_carry_out);
	// nothing to do with overflow (V) flag
}

/*
 * end of tst instruction
 *******************************************************************/

/*******************************************************************
 * teq instruction
 */

op teq_32imm(cond[4]:0b00[2]:0b1[1]:0b1001[4]:0b1[1]:rn[4]:sbz[4]:rotate_imm[4]:imm[8])
op teq_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1001[4]:0b1[1]:rn[4]:sbz[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op teq_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1001[4]:0b1[1]:rn[4]:sbz[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

teq_32imm.disasm = {
	buffer << "teq";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

teq_imm_shift.disasm = {
	buffer << "teq";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

teq_reg_shift.disasm = {
	buffer << "teq";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

teq_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);

	
	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 ^ s2;

	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(shift_carry_out);
	// nothing to do with overflow (V) flag
}

teq_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, 
				cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 ^ s2;
  
	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(shift_carry_out);
	// nothing to do with overflow (V) flag
}

teq_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value, 
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 ^ s2;
  
	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(shift_carry_out);
	// nothing to do with overflow (V) flag
}

/*
 * end of teq instruction
 *******************************************************************/

/*******************************************************************
 * cmp instruction
 */

op cmp_32imm(cond[4]:0b00[2]:0b1[1]:0b1010[4]:0b1[1]:rn[4]:sbz[4]:rotate_imm[4]:imm[8])
op cmp_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1010[4]:0b1[1]:rn[4]:sbz[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op cmp_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1010[4]:0b1[1]:rn[4]:sbz[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

cmp_32imm.disasm = {
	buffer << "cmp";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

cmp_imm_shift.disasm = {
	buffer << "cmp";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}


cmp_reg_shift.disasm = {
	buffer << "cmp";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

cmp_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 - s2;
	
	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2)); // to check
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2)); // to check
}

cmp_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, 
				cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 - s2;
  
	cpu.SetCPSR_N((res & 0x80000000) != 0);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2)); // to check
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2)); // to check
}

cmp_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value,
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 - s2;
  
	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2)); // to check
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2)); // to check
}

/*
 * end of cmp instruction
 *******************************************************************/

/*******************************************************************
 * cmn instruction
 */

op cmn_32imm(cond[4]:0b00[2]:0b1[1]:0b1011[4]:0b1[1]:rn[4]:sbz[4]:rotate_imm[4]:imm[8])
op cmn_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1011[4]:0b1[1]:rn[4]:sbz[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op cmn_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1011[4]:0b1[1]:rn[4]:sbz[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

cmn_32imm.disasm = {
	buffer << "cmn";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

cmn_imm_shift.disasm = {
	buffer << "cmn";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

cmn_reg_shift.disasm = {
	buffer << "cmn";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

cmn_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
  	uint32_t rn_value = cpu.GetGPR(rn);


  	if(!cpu.CheckCondition(cond)) return;

  	s1 = rn_value;
  	s2 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
  	res = s1 + s2;

  	cpu.SetCPSR_N(res & 0x80000000);
  	cpu.SetCPSR_Z(res == 0);
  	cpu.SetCPSR_C(CarryFrom(res, s1, s2)); // to check
  	cpu.SetCPSR_V(AdditionOverflowFrom(res, s1, s2)); // to check
}

cmn_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value,
				cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 + s2;
  
	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(CarryFrom(res, s1, s2)); // to check
	cpu.SetCPSR_V(AdditionOverflowFrom(res, s1, s2)); // to check
}

cmn_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value, 
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 + s2;
	
	cpu.SetCPSR_N(res & 0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(CarryFrom(res, s1, s2)); // to check
	cpu.SetCPSR_V(AdditionOverflowFrom(res, s1, s2)); // to check
}

/*
 * end of cmn instruction
 *******************************************************************/

/*******************************************************************
 * orr instruction
 */

op orr_32imm(cond[4]:0b00[2]:0b1[1]:0b1100[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op orr_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1100[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op orr_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1100[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op orrs_32imm(cond[4]:0b00[2]:0b1[1]:0b1100[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op orrs_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1100[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op orrs_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1100[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

orr_32imm.disasm = {
	buffer << "orr";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

orr_imm_shift.disasm = {
	buffer << "orr";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

orr_reg_shift.disasm = {
	buffer << "orr";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

orrs_32imm.disasm = {
	buffer << "orr";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

orrs_imm_shift.disasm = {
	buffer << "orr";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

orrs_reg_shift.disasm = {
	buffer << "orr";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

orr_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	res = s1 | s2;
	cpu.SetGPR(rd, res);
}

orr_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = s1 | s2;
	cpu.SetGPR(rd, res);
}

orr_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;
	
	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s1 | s2;
	cpu.SetGPR(rd, res);
}

orrs_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 | s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

orrs_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, 
				cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 | s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

orrs_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value,
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 | s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

/*
 * end of orr instruction
 *******************************************************************/

/*******************************************************************
 * mov instruction
 */

op mov_32imm(cond[4]:0b00[2]:0b1[1]:0b1101[4]:0b0[1]:sbz[4]:rd[4]:rotate_imm[4]:imm[8])
op mov_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1101[4]:0b0[1]:sbz[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op mov_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1101[4]:0b0[1]:sbz[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op movs_32imm(cond[4]:0b00[2]:0b1[1]:0b1101[4]:0b1[1]:sbz[4]:rd[4]:rotate_imm[4]:imm[8])
op movs_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1101[4]:0b1[1]:sbz[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op movs_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1101[4]:0b1[1]:sbz[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

group mov(mov_32imm, mov_imm_shift, mov_reg_shift, \
	  movs_32imm, movs_imm_shift, movs_reg_shift)

mov_32imm.disasm = {
	buffer << "mov";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

mov_imm_shift.disasm = {
	buffer << "mov";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

mov_reg_shift.disasm = {
	buffer << "mov";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

movs_32imm.disasm = {
	buffer << "mov";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

movs_imm_shift.disasm = {
	buffer << "mov";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

movs_reg_shift.disasm = {
	buffer << "mov";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

mov_32imm.execute = {
	uint32_t s1;
	uint32_t res;
	

	if(!cpu.CheckCondition(cond)) return;
	
	s1 = ShiftOperand32imm(rotate_imm, imm);
	res = s1;
	cpu.SetGPR(rd, res);
}

mov_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = s1;
	cpu.SetGPR(rd, res);
}

mov_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s1;
	cpu.SetGPR(rd, res);
}

movs_32imm.execute = {
	uint32_t s1;
	uint32_t res;
	bool shift_carry_out = false;


	if(!cpu.CheckCondition(cond)) return;

	s1 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
	res = s1;
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

movs_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rm_value = cpu.GetGPR(rm);
  
	
	if(!cpu.CheckCondition(cond)) return;
	
	s1 = ShiftOperandImmShift(shift_imm, shift, rm_value,
				cpu.GetCPSR_C(), &shift_carry_out);
	res = s1;
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

movs_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);


	if(!cpu.CheckCondition(cond)) return;

	s1 = ShiftOperandRegShift(rs_value, shift, rm_value,
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}	
}

/*
 * end of mov instruction
 *******************************************************************/

/*******************************************************************
 * bic instruction
 */

op bic_32imm(cond[4]:0b00[2]:0b1[1]:0b1110[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op bic_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1110[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op bic_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1110[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op bics_32imm(cond[4]:0b00[2]:0b1[1]:0b1110[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op bics_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1110[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op bics_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1110[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

bic_32imm.disasm = {
	buffer << "bic";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

bic_imm_shift.disasm = {
	buffer << "bic";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

bic_reg_shift.disasm = {
	buffer << "bic";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

bics_32imm.disasm = {
	buffer << "bic";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

bics_imm_shift.disasm = {
	buffer << "bic";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

bics_reg_shift.disasm = {
	buffer << "bic";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", r";
	buffer << (unsigned int) rn;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

bic_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm);
	res = s1 & ~s2;
	cpu.SetGPR(rd, res);
}

bic_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = s1 & ~s2;
	cpu.SetGPR(rd, res);
}

bic_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = s1 & ~s2;
	cpu.SetGPR(rd, res);
}

bics_32imm.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);


	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 & ~s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

bics_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandImmShift(shift_imm, shift, rm_value,
				cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 & ~s2;
	cpu.SetGPR(rd, res);
	
	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

bics_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rn_value = cpu.GetGPR(rn);
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = rn_value;
	s2 = ShiftOperandRegShift(rs_value, shift, rm_value, 
			cpu.GetCPSR_C(), &shift_carry_out);
	res = s1 & ~s2;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

/*
 * end of bic instruction
 *******************************************************************/

/*******************************************************************
 * mvn instruction
 */

op mvn_32imm(cond[4]:0b00[2]:0b1[1]:0b1111[4]:0b0[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op mvn_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1111[4]:0b0[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op mvn_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1111[4]:0b0[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])
op mvns_32imm(cond[4]:0b00[2]:0b1[1]:0b1111[4]:0b1[1]:rn[4]:rd[4]:rotate_imm[4]:imm[8])
op mvns_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1111[4]:0b1[1]:rn[4]:rd[4]:shift_imm[5]:shift[2]:0b0[1]:rm[4])
op mvns_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1111[4]:0b1[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4])

mvn_32imm.disasm = {
	buffer << "mvn";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

mvn_imm_shift.disasm = {
	buffer << "mvn";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

mvn_reg_shift.disasm = {
	buffer << "mvn";
	DisasmCondition(cond, buffer);
	buffer << " r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

mvns_32imm.disasm = {
	buffer << "mvn";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperand32Imm(rotate_imm, imm, buffer);
}

mvns_imm_shift.disasm = {
	buffer << "mvn";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperandImmShift(shift_imm, shift, rm, buffer);
}

mvns_reg_shift.disasm = {
	buffer << "mvn";
	DisasmCondition(cond, buffer);
	buffer << "s r";
	buffer << (unsigned int) rd;
	buffer << ", ";
	DisasmShiftOperandRegShift(rs, shift, rm, buffer);
}

mvn_32imm.execute = {
	uint32_t s1;
	uint32_t res;


	if(!cpu.CheckCondition(cond)) return;

	s1 = ShiftOperand32imm(rotate_imm, imm);
	res = ~s1;
	cpu.SetGPR(rd, res);
}

mvn_imm_shift.execute = {
	typedef Operation<STATE> inherited;
  
	uint32_t s1;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = ShiftOperandImmShift(shift_imm, shift, rm_value, cpu.GetCPSR_C());
	res = ~s1;
	cpu.SetGPR(rd, res);
}

mvn_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1;
	uint32_t res;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;
	
	s1 = ShiftOperandRegShift(rs_value, shift, rm_value);
	res = ~s1;
	cpu.SetGPR(rd, res);
}

mvns_32imm.execute = {
	uint32_t s1;
	uint32_t res;
	bool shift_carry_out = false;


	if(!cpu.CheckCondition(cond)) return;

	s1 = ShiftOperand32imm(rotate_imm, imm, cpu.GetCPSR_C(), &shift_carry_out);
	res = ~s1;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

mvns_imm_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rm_value = cpu.GetGPR(rm);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = ShiftOperandImmShift(shift_imm, shift, rm_value,
				cpu.GetCPSR_C(), &shift_carry_out);
	res = ~s1;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

mvns_reg_shift.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1;
	uint32_t res;
	bool shift_carry_out = false;
	uint32_t rm_value = cpu.GetGPR(rm);
	uint32_t rs_value = cpu.GetGPR(rs);
  

	if(!cpu.CheckCondition(cond)) return;

	s1 = ShiftOperandRegShift(rs_value, shift, rm_value,
			cpu.GetCPSR_C(), &shift_carry_out);
	res = ~s1;
	cpu.SetGPR(rd, res);

	if(rd == cpu.PC_reg) {
		cpu.MoveSPSRtoCPSR();
	} else {
		cpu.SetCPSR_N(res & 0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(shift_carry_out);
		// nothing to do with overflow (V) flag
	}
}

/*
 * end of mvn instruction
 *******************************************************************/
