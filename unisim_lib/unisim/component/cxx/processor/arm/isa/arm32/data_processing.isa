/*
 *  Copyright (c) 2007-2013,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

        DATA PROCESSING INSTRUCTIONS

**********************************************/

/*******************************************************************
 * and instruction
 */

op and_32imm (cond[4]:0b00[2]:0b1[1]:0b0000[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
and_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

and_32imm.disasm = {
  buffer << "and" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

and_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s) cpu.SetCPSR_NZCV( (res >> 31) & 1, res == 0, imr == 0 ? cpu.GetCPSR_C() : (imm >> 31), cpu.GetCPSR_V() );
};

op and_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0000[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

and_imm_shift.disasm = {
  buffer << "and" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

and_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op and_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0000[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

and_reg_shift.disasm = {
  buffer << "and" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

and_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of and instruction
 *******************************************************************/

/*******************************************************************
 * eor instruction
 */

op eor_32imm(cond[4]:0b00[2]:0b1[1]:0b0001[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
eor_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

eor_32imm.disasm = {
  buffer << "eor" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

eor_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s) cpu.SetCPSR_NZCV( (res >> 31) & 1, res == 0, imr == 0 ? cpu.GetCPSR_C() : (imm >> 31), cpu.GetCPSR_V() );
};

op eor_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0001[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

eor_imm_shift.disasm = {
  buffer << "eor" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

eor_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op eor_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0001[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

eor_reg_shift.disasm = {
  buffer << "eor" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

eor_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of eor instruction
 *******************************************************************/

/*******************************************************************
 * sub instruction
 */

op sub_32imm(cond[4]:0b00[2]:0b1[1]:0b0010[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
sub_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

sub_32imm.disasm = {
  buffer << "sub" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

sub_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sub_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0010[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

sub_imm_shift.disasm = {
  buffer << "sub" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

sub_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sub_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0010[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

sub_reg_shift.disasm = {
  buffer << "sub" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

sub_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of sub instruction
 *******************************************************************/

/*******************************************************************
 * rsb instruction
 */

op rsb_32imm(cond[4]:0b00[2]:0b1[1]:0b0011[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
rsb_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

rsb_32imm.disasm = {
  buffer << "rsb" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

rsb_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = imm, op2 = cpu.GetGPR( rn ), res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsb_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0011[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

rsb_imm_shift.disasm = {
  buffer << "rsb" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

rsb_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR( rn ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsb_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0011[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

rsb_reg_shift.disasm = {
  buffer << "rsb" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

rsb_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = ComputeRegShift( cpu, rmval, shift, rsval ), op2 = cpu.GetGPR( rn ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of rsb instruction
 *******************************************************************/

/*******************************************************************
 * add instruction
 */

op add_32imm(cond[4]:0b00[2]:0b1[1]:0b0100[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
add_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

add_32imm.disasm = {
  buffer << "add" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

add_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op add_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0100[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

add_imm_shift.disasm = {
  buffer << "add" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

add_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op add_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0100[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

add_reg_shift.disasm = {
  buffer << "add" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

add_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

/*
 * end of add instruction
 *******************************************************************/

/*******************************************************************
 * adc instruction
 */

op adc_32imm(cond[4]:0b00[2]:0b1[1]:0b0101[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
adc_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

adc_32imm.disasm = {
  buffer << "adc" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

adc_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 + op2 + cpu.GetCPSR_C();
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op adc_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0101[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

adc_imm_shift.disasm = {
  buffer << "adc" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

adc_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 + op2 + cpu.GetCPSR_C();
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op adc_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0101[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

adc_reg_shift.disasm = {
  buffer << "adc" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

adc_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 + op2 + cpu.GetCPSR_C();
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

/*
 * end of adc instruction
 *******************************************************************/

/*******************************************************************
 * sbc instruction
 */

op sbc_32imm(cond[4]:0b00[2]:0b1[1]:0b0110[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
sbc_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

sbc_32imm.disasm = {
  buffer << "sbc" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

sbc_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 - op2 - (cpu.GetCPSR_C() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sbc_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0110[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

sbc_imm_shift.disasm = {
  buffer << "sbc" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

sbc_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 - op2 - (cpu.GetCPSR_C() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sbc_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0110[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

sbc_reg_shift.disasm = {
  buffer << "sbc" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

sbc_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 - op2 - (cpu.GetCPSR_C() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of sbc instruction
 *******************************************************************/

/*******************************************************************
 * rsc instruction
 */

op rsc_32imm(cond[4]:0b00[2]:0b1[1]:0b0111[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
rsc_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

rsc_32imm.disasm = {
  buffer << "rsc" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

rsc_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = imm, op2 = cpu.GetGPR( rn ), res = op1 - op2 - (cpu.GetCPSR_C() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsc_imm_shift(cond[4]:0b00[2]:0b0[1]:0b0111[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

rsc_imm_shift.disasm = {
  buffer << "rsc" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

rsc_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR( rn ),
           res = op1 - op2 - (cpu.GetCPSR_C() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsc_reg_shift(cond[4]:0b00[2]:0b0[1]:0b0111[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

rsc_reg_shift.disasm = {
  buffer << "rsc" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

rsc_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = ComputeRegShift( cpu, rmval, shift, rsval ), op2 = cpu.GetGPR( rn ),
           res = op1 - op2 - (cpu.GetCPSR_C() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of rsc instruction
 *******************************************************************/

/*******************************************************************
 * orr instruction
 */

op orr_32imm(cond[4]:0b00[2]:0b1[1]:0b1100[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
orr_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

orr_32imm.disasm = {
  buffer << "orr" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

orr_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s) cpu.SetCPSR_NZCV( (res >> 31) & 1, res == 0, imr == 0 ? cpu.GetCPSR_C() : (imm >> 31), cpu.GetCPSR_V() );
};

op orr_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1100[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

orr_imm_shift.disasm = {
  buffer << "orr" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

orr_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op orr_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1100[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

orr_reg_shift.disasm = {
  buffer << "orr" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

orr_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of orr instruction
 *******************************************************************/

/*******************************************************************
 * bic instruction
 */

op bic_32imm(cond[4]:0b00[2]:0b1[1]:0b1110[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
bic_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

bic_32imm.disasm = {
  buffer << "bic" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

bic_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s) cpu.SetCPSR_NZCV( (res >> 31) & 1, res == 0, imr == 0 ? cpu.GetCPSR_C() : (imm >> 31), cpu.GetCPSR_V() );
};

op bic_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1110[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

bic_imm_shift.disasm = {
  buffer << "bic" << DisasmCondition(cond) << (s?"s":"") << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

bic_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op bic_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1110[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

bic_reg_shift.disasm = {
  buffer << "bic" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

bic_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of bic instruction
 *******************************************************************/

/*******************************************************************
 * tst instruction
 */

op tst_32imm(cond[4]:0b00[2]:0b1[1]:0b1000[4]:0b1[1]:rn[4]:sbz[4]:shl<1> imr[4] : imb[8]);
tst_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

tst_32imm.disasm = {
  buffer << "tst" << DisasmCondition(cond) << DisasmRegister(rn) << ", #" << imm;
};

tst_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 & op2;
  cpu.SetCPSR_NZCV( (res >> 31) & 1, res == 0, imr == 0 ? cpu.GetCPSR_C() : (imm >> 31), cpu.GetCPSR_V() );
};

op tst_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1000[4]:0b1[1]:rn[4]:sbz[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

tst_imm_shift.disasm = {
  buffer << "tst" << DisasmCondition(cond) << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

tst_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & op2;
  UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op tst_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1000[4]:0b1[1]:rn[4]:sbz[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

tst_reg_shift.disasm = {
  buffer << "tst" << DisasmCondition(cond) << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

tst_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 & op2;
  UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of tst instruction
 *******************************************************************/

/*******************************************************************
 * teq instruction
 */

op teq_32imm(cond[4]:0b00[2]:0b1[1]:0b1001[4]:0b1[1]:rn[4]:sbz[4]:shl<1> imr[4] : imb[8]);
teq_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

teq_32imm.disasm = {
  buffer << "teq" << DisasmCondition(cond) << DisasmRegister(rn) << ", #" << imm;
};

teq_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 ^ op2;
  cpu.SetCPSR_NZCV( (res >> 31) & 1, res == 0, imr == 0 ? cpu.GetCPSR_C() : (imm >> 31), cpu.GetCPSR_V() );
};

op teq_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1001[4]:0b1[1]:rn[4]:sbz[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

teq_imm_shift.disasm = {
  buffer << "teq" << DisasmCondition(cond) << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

teq_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 ^ op2;
  UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op teq_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1001[4]:0b1[1]:rn[4]:sbz[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

teq_reg_shift.disasm = {
  buffer << "teq" << DisasmCondition(cond) << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

teq_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 ^ op2;
  UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of teq instruction
 *******************************************************************/

/*******************************************************************
 * cmp instruction
 */

op cmp_32imm(cond[4]:0b00[2]:0b1[1]:0b1010[4]:0b1[1]:rn[4]:sbz[4]:shl<1> imr[4] : imb[8]);
cmp_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

cmp_32imm.disasm = {
  buffer << "cmp" << DisasmCondition(cond) << DisasmRegister(rn) << ", #" << imm;
};

cmp_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

op cmp_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1010[4]:0b1[1]:rn[4]:sbz[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

cmp_imm_shift.disasm = {
  buffer << "cmp" << DisasmCondition(cond) << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

cmp_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

op cmp_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1010[4]:0b1[1]:rn[4]:sbz[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

cmp_reg_shift.disasm = {
  buffer << "cmp" << DisasmCondition(cond) << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

cmp_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

/*
 * end of cmp instruction
 *******************************************************************/

/*******************************************************************
 * cmn instruction
 */

op cmn_32imm(cond[4]:0b00[2]:0b1[1]:0b1011[4]:0b1[1]:rn[4]:sbz[4]:shl<1> imr[4] : imb[8]);
cmn_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

cmn_32imm.disasm = {
  buffer << "cmn" << DisasmCondition(cond) << "\t" << DisasmRegister(rn) << ", #" << imm;
};

cmn_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t op1 = cpu.GetGPR( rn ), op2 = imm, res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

op cmn_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1011[4]:0b1[1]:rn[4]:sbz[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

cmn_imm_shift.disasm = {
  buffer << "cmn" << DisasmCondition(cond) << "\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

cmn_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t rmval = cpu.GetGPR( rm ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

op cmn_reg_shift(cond[4]:0b00[2]:0b0[1]:0b1011[4]:0b1[1]:rn[4]:sbz[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

cmn_reg_shift.disasm = {
  buffer << "cmn" << DisasmCondition(cond) << "\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
};

cmn_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
           op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
           res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

/*
 * end of cmn instruction
 *******************************************************************/

/*******************************************************************
 * mov instruction
 */

op mov_32imm (cond[4]:0b00[2]:0b1[1]:0b1101[4]:s[1]:sbz[4]:rd[4]:shl<1> imr[4]:imb[8]);
mov_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

mov_32imm.disasm = {
  buffer << "mov" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", #" << imm;
};

mov_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t res = imm;
  cpu.SetGPR( rd, res );
  if (s) cpu.SetCPSR_NZCV( (res >> 31) & 1, res == 0, imr == 0 ? cpu.GetCPSR_C() : (imm >> 31), cpu.GetCPSR_V() );
};

op mov_imm_shift (cond[4]:0b00[2]:0b0[1]:0b1101[4]:s[1]:sbz[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

mov_imm_shift.disasm = {
  buffer << "mov" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

mov_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t rmval = cpu.GetGPR( rm ), res = ComputeImmShift( cpu, rmval, shift, imm );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op mov_reg_shift (cond[4]:0b00[2]:0b0[1]:0b1101[4]:s[1]:sbz[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

mov_reg_shift.disasm = {
  buffer << "mov" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", "
         << DisasmShReg( shift, rs );
};

mov_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t
    rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
    res = ComputeRegShift( cpu, rmval, shift, rsval );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of mov instruction
 *******************************************************************/

/*******************************************************************
 * mvn instruction
 */

op mvn_32imm (cond[4]:0b00[2]:0b1[1]:0b1111[4]:s[1]:rn[4]:rd[4]:shl<1> imr[4] : imb[8]);
mvn_32imm.var imm : {uint32_t} = {DecodeRotImm( imr, imb )};

mvn_32imm.disasm = {
  buffer << "mvn" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", #" << imm;
};

mvn_32imm.execute = {
  if (not CheckCondition(cpu, cond)) return;

  uint32_t res = ~imm;
  cpu.SetGPR( rd, res );
  if (s) cpu.SetCPSR_NZCV( (res >> 31) & 1, res == 0, imr == 0 ? cpu.GetCPSR_C() : (imm >> 31), cpu.GetCPSR_V() );
};

op mvn_imm_shift(cond[4]:0b00[2]:0b0[1]:0b1111[4]:s[1]:rn[4]:rd[4]:imm[5]:shift[2]:0b0[1]:rm[4]);

mvn_imm_shift.disasm = {
  buffer << "mvn" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
};

mvn_imm_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t rmval = cpu.GetGPR( rm ), res = ~(ComputeImmShift( cpu, rmval, shift, imm ));
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op mvn_reg_shift (cond[4]:0b00[2]:0b0[1]:0b1111[4]:s[1]:rn[4]:rd[4]:rs[4]:0b0[1]:shift[2]:0b1[1]:rm[4]);

mvn_reg_shift.disasm = {
  buffer << "mvn" << DisasmCondition(cond) << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", "
         << DisasmShReg( shift, rs );
};

mvn_reg_shift.execute = {
  if (not CheckCondition(cpu, cond)) return;
  
  uint32_t
    rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
  res = ~(ComputeRegShift( cpu, rmval, shift, rsval ));
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
};

/*
 * end of mvn instruction
 *******************************************************************/

/**********************************************

       ARMV5E DATA PROCESSING INSTRUCTIONS

**********************************************/

impl {
#include "unisim/util/arithmetic/arithmetic.hh"

using unisim::util::arithmetic::SignedSatAdd32;
using unisim::util::arithmetic::SignedSatSub32;

};

/*******************************************************************
 * qadd instruction
 */

{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMV7 ||
  STATE::MODEL == ARMEMU
}:op qadd(cond[4]:0b00010000[8]:rn[4]:rd[4]:sbz[4]:0b0101[4]:rm[4]);

qadd.disasm = {
  buffer << "qadd" << DisasmCondition(cond) << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qadd.execute = {
  uint8_t does_sat;
  uint32_t result;
  
  if (not CheckCondition(cpu, cond)) return;
  
  if(rd == cpu.PC_reg || rm == cpu.PC_reg || rn == cpu.PC_reg) {
    // unpredictable behavior, we do nothing
    return;
  }
  
  SignedSatAdd32(result, does_sat, cpu.GetGPR(rn) , cpu.GetGPR(rm));
  cpu.SetCPSR_Q(does_sat == 1 ? true : false);
  cpu.SetGPR(rd, result);
};

/*
 * end of qadd instruction
 *******************************************************************/

/*******************************************************************
 * qsub instruction
 */

{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMV7 ||
  STATE::MODEL == ARMEMU
}:op qsub(cond[4]:0b00010010[8]:rn[4]:rd[4]:sbz[4]:0b0101[4]:rm[4]);

qsub.disasm = {
  buffer << "qsub" << DisasmCondition(cond) << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qsub.execute = {
  uint8_t does_sat;
  uint32_t result;
  
  if (not CheckCondition(cpu, cond)) return;
  
  if(rd == cpu.PC_reg || rm == cpu.PC_reg || rn == cpu.PC_reg) {
    // unpredictable behavior, we do nothing
    return;
  }
  
  SignedSatSub32(result, does_sat, cpu.GetGPR(rm) , cpu.GetGPR(rn));
  cpu.SetCPSR_Q(does_sat == 1 ? true : false);
  cpu.SetGPR(rd, result);
};

/*
 * end of qsub instruction
 *******************************************************************/

/*******************************************************************
 * qdadd instruction
 */

{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMV7 ||
  STATE::MODEL == ARMEMU
}:op qdadd(cond[4]:0b00010100[8]:rn[4]:rd[4]:sbz[4]:0b0101[4]:rm[4]);

qdadd.disasm = {
  buffer << "qdadd" << DisasmCondition(cond) << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qdadd.execute = {
  uint8_t does_sat, does_sat_tmp;
  uint32_t result;
  
  if (not CheckCondition(cpu, cond)) return;
  
  if(rd == cpu.PC_reg || rm == cpu.PC_reg || rn == cpu.PC_reg) {
    // unpredictable behavior, we do nothing
    return;
  }
  
  SignedSatAdd32(result, does_sat_tmp, cpu.GetGPR(rn) , cpu.GetGPR(rn));
  SignedSatAdd32(result, does_sat, cpu.GetGPR(rm) , result);
  cpu.SetCPSR_Q(does_sat == 1 || does_sat_tmp == 1? true : false);
  cpu.SetGPR(rd, result);
};

/*
 * end of qdadd instruction
 *******************************************************************/

/*******************************************************************
 * qdsub instruction
 */

{ STATE::MODEL == ARMV5TE ||
  STATE::MODEL == ARMV5TEJ ||
  STATE::MODEL == ARMV5TEXP ||
  STATE::MODEL == ARMV6 ||
  STATE::MODEL == ARMV7 ||
  STATE::MODEL == ARMEMU
}:op qdsub(cond[4]:0b00010110[8]:rn[4]:rd[4]:sbz[4]:0b0101[4]:rm[4]);

qdsub.disasm = {
  buffer << "qdsub" << DisasmCondition(cond) << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qdsub.execute = {
  uint8_t does_sat, does_sat_tmp;
  uint32_t result;
  
  if (not CheckCondition(cpu, cond)) return;
  
  if(rd == cpu.PC_reg || rm == cpu.PC_reg || rn == cpu.PC_reg) {
    // unpredictable behavior, we do nothing
    return;
  }
  
  SignedSatAdd32(result, does_sat_tmp, cpu.GetGPR(rn) , cpu.GetGPR(rn));
  SignedSatSub32(result, does_sat, cpu.GetGPR(rm) , result);
  cpu.SetCPSR_Q(does_sat == 1 ? true : false);
  cpu.SetGPR(rd, result);
};

/*
 * end of qdsub instruction
 *******************************************************************/

/*******************************************************************
 * mov[wt] instructions
 */

{ STATE::MODEL == ARMV7
}:op movw( cond[4]:0x30[8]:shl<12> imm1[4]:rd[4]:imm0[12] );
movw.var imm : {uint32_t} = {imm1|imm0};

movw.disasm = { buffer << "movw" << DisasmCondition(cond) << "\t" << DisasmRegister(rd) << ", #" << imm; };

movw.execute = { cpu.SetGPR( rd, imm ); };

{ STATE::MODEL == ARMV7
}:op movt( cond[4]:0x34[8]:shl<12> imm1[4]:rsd[4]:imm0[12] );
movt.var imm : {uint32_t} = {imm1|imm0};

movt.disasm = { buffer << "movt" << DisasmCondition(cond) << "\t" << DisasmRegister(rsd) << ", #" << imm; };

movt.execute = { cpu.SetGPR( rsd, (cpu.GetGPR( rsd ) & 0xffff) | (imm << 16) ); };

/*
 * end of mov[wt] instruction
 *******************************************************************/

