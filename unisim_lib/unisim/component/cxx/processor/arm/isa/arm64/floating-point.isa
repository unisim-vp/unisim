/*
 *  Copyright (c) 2007-2021,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Yves Lhuillier (yves.lhuillier@cea.fr)
 */

/*******************************************************************
 * FABD
 *
 * Floating-point Absolute Difference
 */

op fabd_s( 0b01111110101[11] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

fabd_s.disasm = {
  sink << "fabd\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fabd_s.execute = {
  cpu.SetVF32(rd, fabs(cpu.GetVF32(rn,0) - cpu.GetVF32(rm,0)));
};

op fabd_d( 0b01111110111[11] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

fabd_d.disasm = {
  sink << "fabd\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fabd_d.execute = {
  cpu.SetVF64(rd, fabs(cpu.GetVF64(rn,0) - cpu.GetVF64(rm,0)));
};

op fabd_vs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

fabd_vs.disasm = {
  sink << "fabd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op fabd_v2d( 0b01101110111[11] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

fabd_v2d.disasm = {
  sink << "fabd\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

/*
 * end of FABS
 *******************************************************************/

/*******************************************************************
 * FABS
 *
 * Floating-point absolute value: Vd = abs(Vn)
 */

op fabs_s( 0b0001111000100000110000[22] : rn[5] : rd[5] );

fabs_s.disasm = {
  sink << "fabs\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fabs_s.execute = {
  cpu.SetVF32(rd, fabs(cpu.GetVF32(rn,0)));
};

op fabs_d( 0b0001111001100000110000[22] : rn[5] : rd[5] );

fabs_d.disasm = {
  sink << "fabs\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fabs_d.execute = {
  cpu.SetVF64(rd, fabs(cpu.GetVF64(rn,0)));
};

op fabs_vs( 0b0[1] : q[1] : 0b00111010100000111110[20] : rn[5] : rd[5] );

fabs_vs.disasm = {
  sink << "fabs\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

fabs_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, fabs(cpu.GetVF32(rn, idx)));
  cpu.ClearHighV(rd, 8<<q);
};

op fabs_v2d( 0b0100111011100000111110[22] : rn[5] : rd[5] );

fabs_v2d.disasm = {
  sink << "fabs\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

fabs_v2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVF64(rd, idx, fabs(cpu.GetVF64(rn, idx)));
};

/*
 * end of FABS
 *******************************************************************/

op facge_s( 0b01111110001[11] : rm[5] : 0b111011[6] : rn[5] : rd[5] );

facge_s.disasm = {
  sink << "facge\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

op facge_d( 0b01111110011[11] : rm[5] : 0b111011[6] : rn[5] : rd[5] );

facge_d.disasm = {
  sink << "facge\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

op facge_vs( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b111011[6] : rn[5] : rd[5] );

facge_vs.disasm = {
  sink << "facge\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op facge_v2d( 0b01101110011[11] : rm[5] : 0b111011[6] : rn[5] : rd[5] );

facge_v2d.disasm = {
  sink << "facge\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

op facgt_s( 0b01111110101[11] : rm[5] : 0b111011[6] : rn[5] : rd[5] );

facgt_s.disasm = {
  sink << "facgt\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

op facgt_d( 0b01111110111[11] : rm[5] : 0b111011[6] : rn[5] : rd[5] );

facgt_d.disasm = {
  sink << "facgt\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

op facgt_vs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b111011[6] : rn[5] : rd[5] );

facgt_vs.disasm = {
  sink << "facgt\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op facgt_v2d( 0b01101110111[11] : rm[5] : 0b111011[6] : rn[5] : rd[5] );

facgt_v2d.disasm = {
  sink << "facgt\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

/*******************************************************************
 * FADD
 *
 * Floating-point add (scalar): Vd = Vn + Vm
 */

op fadd_s( 0b00011110001[11] : rm[5] : 0b001010[6] : rn[5] : rd[5] );

fadd_s.disasm = {
  sink << "fadd\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fadd_s.execute = {
  cpu.SetVF32(rd, cpu.GetVF32(rn,0) + cpu.GetVF32(rm,0));
};

op fadd_d( 0b00011110011[11] : rm[5] : 0b001010[6] : rn[5] : rd[5] );

fadd_d.disasm = {
  sink << "fadd\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fadd_d.execute = {
  cpu.SetVF64(rd, cpu.GetVF64(rn,0) + cpu.GetVF64(rm,0));
};

op fadd_vs( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

fadd_vs.disasm = {
  sink << "fadd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fadd_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, cpu.GetVF32(rn, idx) + cpu.GetVF32(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op fadd_v2d( 0b01001110011[11] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

fadd_v2d.disasm = {
  sink << "fadd\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fadd_v2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVF64(rd, idx, cpu.GetVF64(rn, idx) + cpu.GetVF64(rm, idx));
};

/*
 * end of FADD
 *******************************************************************/

/*******************************************************************
 * FADDP (scalar)
 *
 * Floating-point Add Pair of elements (scalar).
 */

op faddp_s( 0b0111111000110000110110[22] : rn[5] : rd[5] );

faddp_s.disasm = {
  sink << "faddp\t" << DisasmS(rd) << ", " << DisasmTV(rn,2,2);
};

faddp_s.execute = {
  cpu.SetVF32(rd, cpu.GetVF32(rn, 0) + cpu.GetVF32(rn, 1));
};

op faddp_d( 0b0111111001110000110110[22] : rn[5] : rd[5] );

faddp_d.disasm = {
  sink << "faddp\t" << DisasmD(rd) << ", " << DisasmTV(rn,2,3);
};

faddp_d.execute = {
  cpu.SetVF64(rd, cpu.GetVF64(rn, 0) + cpu.GetVF64(rn, 1));
};

/*
 * end of FADDP (scalar)
 *******************************************************************/

/*******************************************************************
 * FADDP (vector)
 *
 * Floating-point Add Pair of elements (vector).
 */

op faddp_vs( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

faddp_vs.disasm = {
  sink << "faddp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

faddp_vs.execute = {
  unsigned const elements = 2<<q;

  typename ARCH::F32 res[elements];

  for (unsigned e=0, end=elements/2; e < end; ++e)
    {
      res[  0+e] = cpu.GetVF32(rn, 2*e) + cpu.GetVF32(rn, 2*e+1);
      res[end+e] = cpu.GetVF32(rm, 2*e) + cpu.GetVF32(rm, 2*e+1);
    }

  for (unsigned e=0; e < elements; ++e)
    cpu.SetVF32(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

op faddp_v2d( 0b01101110011[11] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

faddp_v2d.disasm = {
  sink << "faddp\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

faddp_v2d.execute = {
  unsigned const elements = 2;

  typename ARCH::F64 res[elements];

  for (unsigned e=0, end=elements/2; e < end; ++e)
    {
      res[  0+e] = cpu.GetVF64(rn, 2*e) + cpu.GetVF64(rn, 2*e+1);
      res[end+e] = cpu.GetVF64(rm, 2*e) + cpu.GetVF64(rm, 2*e+1);
    }

  for (unsigned e=0; e < elements; ++e)
    cpu.SetVF64(rd, e, res[e]);
};

/*
 * end of FADDP (vector)
 *******************************************************************/

/*******************************************************************
 * FCCMP
 *
 * Floating-point Conditional quiet compare (scalar)
 */

op fccmp_s( 0b00011110001[11] : rm[5] : cond[4] : 0b01[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );

fccmp_s.disasm = {
  sink << "fccmp\t" << DisasmS(rn) << ", " << DisasmS(rm) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

fccmp_s.execute = {
  typedef typename ARCH::BOOL BOOL;

  if (CheckCondition(cpu, cond))
    {
      typedef typename ARCH::F32 F32;

      F32 a = cpu.GetVF32(rn,0), b = cpu.GetVF32(rm,0);
      BOOL le = a <= b, ge = a >= b;
      cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

op fccmp_d( 0b00011110011[11] : rm[5] : cond[4] : 0b01[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );

fccmp_d.disasm = {
  sink << "fccmp\t" << DisasmD(rn) << ", " << DisasmD(rm) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

fccmp_d.execute = {
  typedef typename ARCH::BOOL BOOL;

  if (CheckCondition(cpu, cond))
    {
      typedef typename ARCH::F64 F64;

      F64 a = cpu.GetVF64(rn,0), b = cpu.GetVF64(rm,0);
      BOOL le = a <= b, ge = a >= b;
      cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

/*
 * end of FCCMP
 *******************************************************************/

op fccmpe_d( 0b00011110011[11] : rm[5] : cond[4] : 0b01[2] : rn[5] : 0b1[1] : n[1] : z[1] : c[1] : v[1] );

fccmpe_d.disasm = {
  sink << "fccmpe\t" << DisasmD(rn) << ", " << DisasmD(rm) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

op fccmpe_s( 0b00011110001[11] : rm[5] : cond[4] : 0b01[2] : rn[5] : 0b1[1] : n[1] : z[1] : c[1] : v[1] );

fccmpe_s.disasm = {
  sink << "fccmpe\t" << DisasmS(rn) << ", " << DisasmS(rm) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

/*******************************************************************
 * FCMEQ
 *
 * Floating-point Compare Equal
 */

op fcmeq_s( 0b01011110001[11] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmeq_s.disasm = {
  sink << "fcmeq\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fcmeq_s.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  F32 op1 = cpu.GetVF32(rn, 0), op2 = cpu.GetVF32(rm, 0);
  cpu.SetVS32(rd, -S32(op1 == op2));
};

op fcmeq_d( 0b01011110011[11] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmeq_d.disasm = {
  sink << "fcmeq\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fcmeq_d.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  F64 op1 = cpu.GetVF64(rn, 0), op2 = cpu.GetVF64(rm, 0);
  cpu.SetVS64(rd, -S64(op1 == op2));
};

op fcmeq_vs( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmeq_vs.disasm = {
  sink << "fcmeq\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fcmeq_vs.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      F32 op1 = cpu.GetVF32(rn, e), op2 = cpu.GetVF32(rm, e);
      cpu.SetVS32(rd, e, -S32(op1 == op2));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op fcmeq_v2d( 0b01001110011[11] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmeq_v2d.disasm = {
  sink << "fcmeq\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fcmeq_v2d.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      F64 op1 = cpu.GetVF64(rn, e), op2 = cpu.GetVF64(rm, e);
      cpu.SetVS64(rd, e, -S64(op1 == op2));
    }
};

op fcmeq_sz( 0b0101111010100000110110[22] : rn[5] : rd[5] );

fcmeq_sz.disasm = {
  sink << "fcmeq\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", #0.0";
};

fcmeq_sz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  F32 op1 = cpu.GetVF32(rn, 0), op2( 0 );
  cpu.SetVS32(rd, -S32(op1 == op2));
};

op fcmeq_dz( 0b0101111011100000110110[22] : rn[5] : rd[5] );

fcmeq_dz.disasm = {
  sink << "fcmeq\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0.0";
};

fcmeq_dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  F64 op1 = cpu.GetVF64(rn, 0), op2( 0 );
  cpu.SetVS64(rd, -S64(op1 == op2));
};

op fcmeq_vsz( 0b0[1] : q[1] : 0b00111010100000110110[20] : rn[5] : rd[5] );

fcmeq_vsz.disasm = {
  sink << "fcmeq\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0.0";
};

fcmeq_vsz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      F32 op1 = cpu.GetVF32(rn, e), op2( 0 );
      cpu.SetVS32(rd, e, -S32(op1 == op2));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op fcmeq_v2dz( 0b0100111011100000110110[22] : rn[5] : rd[5] );

fcmeq_v2dz.disasm = {
  sink << "fcmeq\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", #0.0";
};

fcmeq_v2dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      F64 op1 = cpu.GetVF64(rn, e), op2( 0 );
      cpu.SetVS64(rd, e, -S64(op1 == op2));
    }
};

/*
 * end of FCMEQ
 *******************************************************************/

/*******************************************************************
 * FCMGE
 *
 * Floating-point Compare Greater or Equal
 */

op fcmge_s( 0b01111110001[11] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmge_s.disasm = {
  sink << "fcmge\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fcmge_s.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  F32 op1 = cpu.GetVF32(rn, 0), op2 = cpu.GetVF32(rm, 0);
  cpu.SetVS32(rd, -S32(op1 >= op2));
};

op fcmge_d( 0b01111110011[11] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmge_d.disasm = {
  sink << "fcmge\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fcmge_d.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  F64 op1 = cpu.GetVF64(rn, 0), op2 = cpu.GetVF64(rm, 0);
  cpu.SetVS64(rd, -S64(op1 >= op2));
};

op fcmge_vs( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmge_vs.disasm = {
  sink << "fcmge\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fcmge_vs.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      F32 op1 = cpu.GetVF32(rn, e), op2 = cpu.GetVF32(rm, e);
      cpu.SetVS32(rd, e, -S32(op1 >= op2));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op fcmge_v2d( 0b01101110011[11] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmge_v2d.disasm = {
  sink << "fcmge\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fcmge_v2d.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      F64 op1 = cpu.GetVF64(rn, e), op2 = cpu.GetVF64(rm, e);
      cpu.SetVS64(rd, e, -S64(op1 >= op2));
    }
};

op fcmge_sz( 0b0111111010100000110010[22] : rn[5] : rd[5] );

fcmge_sz.disasm = {
  sink << "fcmge\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", #0.0";
};

fcmge_sz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  F32 op1 = cpu.GetVF32(rn, 0), op2( 0 );
  cpu.SetVS32(rd, -S32(op1 >= op2));
};

op fcmge_dz( 0b0111111011100000110010[22] : rn[5] : rd[5] );

fcmge_dz.disasm = {
  sink << "fcmge\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0.0";
};

fcmge_dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  F64 op1 = cpu.GetVF64(rn, 0), op2( 0 );
  cpu.SetVS64(rd, -S64(op1 >= op2));
};

op fcmge_vsz( 0b0[1] : q[1] : 0b10111010100000110010[20] : rn[5] : rd[5] );

fcmge_vsz.disasm = {
  sink << "fcmge\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0.0";
};

fcmge_vsz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      F32 op1 = cpu.GetVF32(rn, e), op2( 0 );
      cpu.SetVS32(rd, e, -S32(op1 >= op2));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op fcmge_v2dz( 0b0110111011100000110010[22] : rn[5] : rd[5] );

fcmge_v2dz.disasm = {
  sink << "fcmge\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", #0.0";
};

fcmge_v2dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      F64 op1 = cpu.GetVF64(rn, e), op2( 0 );
      cpu.SetVS64(rd, e, -S64(op1 >= op2));
    }
};

/*
 * end of FCMGE
 *******************************************************************/

/*******************************************************************
 * FCMGT
 *
 * Floating-point Compare Greater Than
 */

op fcmgt_s( 0b01111110101[11] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmgt_s.disasm = {
  sink << "fcmgt\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fcmgt_s.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  F32 op1 = cpu.GetVF32(rn, 0), op2 = cpu.GetVF32(rm, 0);
  cpu.SetVS32(rd, -S32(op1 > op2));
};

op fcmgt_d( 0b01111110111[11] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmgt_d.disasm = {
  sink << "fcmgt\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fcmgt_d.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  F64 op1 = cpu.GetVF64(rn, 0), op2 = cpu.GetVF64(rm, 0);
  cpu.SetVS64(rd, -S64(op1 > op2));
};

op fcmgt_vs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmgt_vs.disasm = {
  sink << "fcmgt\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fcmgt_vs.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      F32 op1 = cpu.GetVF32(rn, e), op2 = cpu.GetVF32(rm, e);
      cpu.SetVS32(rd, e, -S32(op1 > op2));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op fcmgt_v2d( 0b01101110111[11] : rm[5] : 0b111001[6] : rn[5] : rd[5] );

fcmgt_v2d.disasm = {
  sink << "fcmgt\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fcmgt_v2d.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      F64 op1 = cpu.GetVF64(rn, e), op2 = cpu.GetVF64(rm, e);
      cpu.SetVS64(rd, e, -S64(op1 > op2));
    }
};

op fcmgt_sz( 0b0101111010100000110010[22] : rn[5] : rd[5] );

fcmgt_sz.disasm = {
  sink << "fcmgt\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", #0.0";
};

fcmgt_sz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  F32 op1 = cpu.GetVF32(rn, 0), op2( 0 );
  cpu.SetVS32(rd, -S32(op1 > op2));
};

op fcmgt_dz( 0b0101111011100000110010[22] : rn[5] : rd[5] );

fcmgt_dz.disasm = {
  sink << "fcmgt\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0.0";
};

fcmgt_dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  F64 op1 = cpu.GetVF64(rn, 0), op2( 0 );
  cpu.SetVS64(rd, -S64(op1 > op2));
};

op fcmgt_vsz( 0b0[1] : q[1] : 0b00111010100000110010[20] : rn[5] : rd[5] );

fcmgt_vsz.disasm = {
  sink << "fcmgt\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0.0";
};

fcmgt_vsz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      F32 op1 = cpu.GetVF32(rn, e), op2( 0 );
      cpu.SetVS32(rd, e, -S32(op1 > op2));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op fcmgt_v2dz( 0b0100111011100000110010[22] : rn[5] : rd[5] );

fcmgt_v2dz.disasm = {
  sink << "fcmgt\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", #0.0";
};

fcmgt_v2dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      F64 op1 = cpu.GetVF64(rn, e), op2( 0 );
      cpu.SetVS64(rd, e, -S64(op1 > op2));
    }
};

/*
 * end of FCMGT
 *******************************************************************/

/*******************************************************************
 * FCMLE
 *
 * Floating-point Compare Less or Equal
 */

op fcmle_sz( 0b0111111010100000110110[22] : rn[5] : rd[5] );

fcmle_sz.disasm = {
  sink << "fcmle\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", #0.0";
};

fcmle_sz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  F32 op1 = cpu.GetVF32(rn, 0), op2( 0 );
  cpu.SetVS32(rd, -S32(op1 <= op2));
};

op fcmle_dz( 0b0111111011100000110110[22] : rn[5] : rd[5] );

fcmle_dz.disasm = {
  sink << "fcmle\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0.0";
};

fcmle_dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  F64 op1 = cpu.GetVF64(rn, 0), op2( 0 );
  cpu.SetVS64(rd, -S64(op1 <= op2));
};

op fcmle_vsz( 0b0[1] : q[1] : 0b10111010100000110110[20] : rn[5] : rd[5] );

fcmle_vsz.disasm = {
  sink << "fcmle\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0.0";
};

fcmle_vsz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      F32 op1 = cpu.GetVF32(rn, e), op2( 0 );
      cpu.SetVS32(rd, e, -S32(op1 <= op2));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op fcmle_v2dz( 0b0110111011100000110110[22] : rn[5] : rd[5] );

fcmle_v2dz.disasm = {
  sink << "fcmle\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", #0.0";
};

fcmle_v2dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      F64 op1 = cpu.GetVF64(rn, e), op2( 0 );
      cpu.SetVS64(rd, e, -S64(op1 <= op2));
    }
};

/*
 * end of FCMLE
 *******************************************************************/

/*******************************************************************
 * FCMLT
 *
 * Floating-point Compare Less Than
 */

op fcmlt_sz( 0b0101111010100000111010[22] : rn[5] : rd[5] );

fcmlt_sz.disasm = {
  sink << "fcmlt\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", #0.0";
};

fcmlt_sz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  F32 op1 = cpu.GetVF32(rn, 0), op2( 0 );
  cpu.SetVS32(rd, -S32(op1 < op2));
};

op fcmlt_dz( 0b0101111011100000111010[22] : rn[5] : rd[5] );

fcmlt_dz.disasm = {
  sink << "fcmlt\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0.0";
};

fcmlt_dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  F64 op1 = cpu.GetVF64(rn, 0), op2( 0 );
  cpu.SetVS64(rd, -S64(op1 < op2));
};

op fcmlt_vsz( 0b0[1] : q[1] : 0b00111010100000111010[20] : rn[5] : rd[5] );

fcmlt_vsz.disasm = {
  sink << "fcmlt\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0.0";
};

fcmlt_vsz.execute = {
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      F32 op1 = cpu.GetVF32(rn, e), op2( 0 );
      cpu.SetVS32(rd, e, -S32(op1 < op2));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op fcmlt_v2dz( 0b0100111011100000111010[22] : rn[5] : rd[5] );

fcmlt_v2dz.disasm = {
  sink << "fcmlt\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", #0.0";
};

fcmlt_v2dz.execute = {
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      F64 op1 = cpu.GetVF64(rn, e), op2( 0 );
      cpu.SetVS64(rd, e, -S64(op1 < op2));
    }
};

/*
 * end of FCMLT
 *******************************************************************/

/*******************************************************************
 * FCMP
 *
 * Floating-point quiet compare (scalar): flags = compareSignaling(Vn, Vm) // with register
 */

op fcmp_s( 0b00011110001[11] : rm[5] : 0b001000[6] : rn[5] : 0b00000[5] );

fcmp_s.disasm = {
  sink << "fcmp\t" << DisasmS(rn) << ", " << DisasmS(rm);
};

fcmp_s.execute =
{
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::BOOL BOOL;

  F32 a = cpu.GetVF32(rn,0), b = cpu.GetVF32(rm,0);
  BOOL le = a <= b, ge = a >= b;
  cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
};

op fcmp_d( 0b00011110011[11] : rm[5] : 0b001000[6] : rn[5] : 0b00000[5] );

fcmp_d.disasm = {
  sink << "fcmp\t" << DisasmD(rn) << ", " << DisasmD(rm);
};

fcmp_d.execute =
{
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::BOOL BOOL;

  F64 a = cpu.GetVF64(rn,0), b = cpu.GetVF64(rm,0);
  BOOL le = a <= b, ge = a >= b;
  cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
};

op fcmp_sz( 0b00011110001[11] : rm[5] : 0b001000[6] : rn[5] : 0b01000[5] );
fcmp_sz.var reject : {Reject} = {rm != 0};

fcmp_sz.disasm = {
  sink << "fcmp\t" << DisasmS(rn) << ", #0.0";
};

fcmp_sz.execute =
{
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::BOOL BOOL;

  F32 a = cpu.GetVF32(rn,0), b = F32(0);
  BOOL le = a <= b, ge = a >= b;
  cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
};

op fcmp_dz( 0b00011110011[11] : rm[5] : 0b001000[6] : rn[5] : 0b01000[5] );
fcmp_dz.var reject : {Reject} = {rm != 0};

fcmp_dz.disasm = {
  sink << "fcmp\t" << DisasmD(rn) << ", #0.0";
};

fcmp_dz.execute =
{
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::BOOL BOOL;

  F64 a = cpu.GetVF64(rn,0), b = F64(0);
  BOOL le = a <= b, ge = a >= b;
  cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
};

/*
 * end of FCMP
 *******************************************************************/

/*******************************************************************
 * FCMPE
 *
 * Floating-point signaling compare (scalar): flags = compareSignaling(Vn, Vm) // with register
 */

op fcmpe_s( 0b00011110001[11] : rm[5] : 0b001000[6] : rn[5] : 0b10000[5] );

fcmpe_s.disasm = {
  sink << "fcmpe\t" << DisasmS(rn) << ", " << DisasmS(rm);
};

fcmpe_s.execute =
{
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::BOOL BOOL;

  F32 a = cpu.GetVF32(rn,0), b = cpu.GetVF32(rm,0);
  BOOL le = a <= b, ge = a >= b;
  cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
};

op fcmpe_d( 0b00011110011[11] : rm[5] : 0b001000[6] : rn[5] : 0b10000[5] );

fcmpe_d.disasm = {
  sink << "fcmpe\t" << DisasmD(rn) << ", " << DisasmD(rm);
};

fcmpe_d.execute =
{
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::BOOL BOOL;

  F64 a = cpu.GetVF64(rn,0), b = cpu.GetVF64(rm,0);
  BOOL le = a <= b, ge = a >= b;
  cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
};

op fcmpe_sz( 0b00011110001[11] : rm[5] : 0b001000[6] : rn[5] : 0b11000[5] );
fcmpe_sz.var reject : {Reject} = {rm != 0};

fcmpe_sz.disasm = {
  sink << "fcmpe\t" << DisasmS(rn) << ", #0.0";
};

fcmpe_sz.execute =
{
  typedef typename ARCH::F32 F32;
  typedef typename ARCH::BOOL BOOL;

  F32 a = cpu.GetVF32(rn,0), b = F32(0);
  BOOL le = a <= b, ge = a >= b;
  cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
};

op fcmpe_dz( 0b00011110011[11] : rm[5] : 0b001000[6] : rn[5] : 0b11000[5] );
fcmpe_dz.var reject : {Reject} = {rm != 0};

fcmpe_dz.disasm = {
  sink << "fcmpe\t" << DisasmD(rn) << ", #0.0";
};

fcmpe_dz.execute =
{
  typedef typename ARCH::F64 F64;
  typedef typename ARCH::BOOL BOOL;

  F64 a = cpu.GetVF64(rn,0), b = F64(0);
  BOOL le = a <= b, ge = a >= b;
  cpu.SetNZCV(not ge and le, ge and le, ge or not le, not le and not ge);
};

/*
 * end of FCMPE
 *******************************************************************/

/*******************************************************************
 * FCSEL
 *
 * Floating-point conditional select (scalar): Vd = if cond then Vn else Vm
 */

op fcsel_s( 0b00011110001[11] : rm[5] : cond[4] : 0b11[2] : rn[5] : rd[5] );

fcsel_s.disasm = {
  sink << "fcsel\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm) << ", " << DisasmCond(cond);
};

fcsel_s.execute = {
  cpu.SetVF32(rd, cpu.GetVF32(CheckCondition(cpu, cond) ? rn : rm, 0));
};

op fcsel_d( 0b00011110011[11] : rm[5] : cond[4] : 0b11[2] : rn[5] : rd[5] );

fcsel_d.disasm = {
  sink << "fcsel\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm) << ", " << DisasmCond(cond);
};

fcsel_d.execute = {
  cpu.SetVF64(rd, cpu.GetVF64(CheckCondition(cpu, cond) ? rn : rm, 0));
};

/*
 * end of FCSEL
 *******************************************************************/

op fcvt_hs( 0b0001111000100011110000[22] : rn[5] : rd[5] );

fcvt_hs.disasm = {
  sink << "fcvt\t" << DisasmH(rd) << ", " << DisasmS(rn);
};

op fcvt_hd( 0b0001111001100011110000[22] : rn[5] : rd[5] );

fcvt_hd.disasm = {
  sink << "fcvt\t" << DisasmH(rd) << ", " << DisasmD(rn);
};

op fcvt_sh( 0b0001111011100010010000[22] : rn[5] : rd[5] );

fcvt_sh.disasm = {
  sink << "fcvt\t" << DisasmS(rd) << ", " << DisasmH(rn);
};

op fcvt_sd( 0b0001111001100010010000[22] : rn[5] : rd[5] );

fcvt_sd.disasm = {
  sink << "fcvt\t" << DisasmS(rd) << ", " << DisasmD(rn);
};

fcvt_sd.execute = {
  cpu.SetVF32(rd, typename ARCH::F32(cpu.GetVF64(rn,0)));
};

op fcvt_dh( 0b0001111011100010110000[22] : rn[5] : rd[5] );

fcvt_dh.disasm = {
  sink << "fcvt\t" << DisasmD(rd) << ", " << DisasmH(rn);
};

op fcvt_ds( 0b0001111000100010110000[22] : rn[5] : rd[5] );

fcvt_ds.disasm = {
  sink << "fcvt\t" << DisasmD(rd) << ", " << DisasmS(rn);
};

fcvt_ds.execute = {
  cpu.SetVF64(rd, typename ARCH::F64(cpu.GetVF32(rn,0)));
};

/*******************************************************************
 * FCVTAS
 *
 * Floating-point Convert to Signed integer, rounding to nearest with ties to Away
 */

op fcvtas_ss( 0b0101111000100001110010[22] : rn[5] : rd[5] );

fcvtas_ss.disasm = {
  sink << "fcvtas\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtas_ss.execute = {
  cpu.SetVS32(rd, typename ARCH::S32(round(cpu.GetVF32(rn,0))));
};

op fcvtas_dd( 0b0101111001100001110010[22] : rn[5] : rd[5] );

fcvtas_dd.disasm = {
  sink << "fcvtas\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtas_dd.execute = {
  cpu.SetVS64(rd, typename ARCH::S64(round(cpu.GetVF64(rn,0))));
};

op fcvtas_ws( 0b0001111000100100000000[22] : rn[5] : rd[5] );

fcvtas_ws.disasm = {
  sink << "fcvtas\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtas_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(round(cpu.GetVF32(rn,0))));
};

op fcvtas_wd( 0b0001111001100100000000[22] : rn[5] : rd[5] );

fcvtas_wd.disasm = {
  sink << "fcvtas\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtas_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(round(cpu.GetVF64(rn,0))));
};

op fcvtas_xs( 0b1001111000100100000000[22] : rn[5] : rd[5] );

fcvtas_xs.disasm = {
  sink << "fcvtas\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtas_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(round(cpu.GetVF32(rn,0))));
};

op fcvtas_xd( 0b1001111001100100000000[22] : rn[5] : rd[5] );

fcvtas_xd.disasm = {
  sink << "fcvtas\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtas_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(round(cpu.GetVF64(rn,0))));
};

op fcvtas_vss( 0b0[1] : q[1] : 0b00111000100001110010[20] : rn[5] : rd[5] );

fcvtas_vss.disasm = {
  sink << "fcvtas\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op fcvtas_v2d2d( 0b0100111001100001110010[22] : rn[5] : rd[5] );

fcvtas_v2d2d.disasm = {
  sink << "fcvtas\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FCVTAS
 *******************************************************************/

/*******************************************************************
 * FCVTAU
 *
 * Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away
 */

op fcvtau_ss( 0b0111111000100001110010[22] : rn[5] : rd[5] );

fcvtau_ss.disasm = {
  sink << "fcvtau\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtau_ss.execute = {
  cpu.SetVU32(rd, typename ARCH::U32(round(cpu.GetVF32(rn,0))));
};

op fcvtau_dd( 0b0111111001100001110010[22] : rn[5] : rd[5] );

fcvtau_dd.disasm = {
  sink << "fcvtau\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtau_dd.execute = {
  cpu.SetVU64(rd, typename ARCH::U64(round(cpu.GetVF64(rn,0))));
};

op fcvtau_ws( 0b0001111000100101000000[22] : rn[5] : rd[5] );

fcvtau_ws.disasm = {
  sink << "fcvtau\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtau_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(round(cpu.GetVF32(rn,0))));
};

op fcvtau_wd( 0b0001111001100101000000[22] : rn[5] : rd[5] );

fcvtau_wd.disasm = {
  sink << "fcvtau\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtau_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(round(cpu.GetVF64(rn,0))));
};

op fcvtau_xs( 0b1001111000100101000000[22] : rn[5] : rd[5] );

fcvtau_xs.disasm = {
  sink << "fcvtau\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtau_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(round(cpu.GetVF32(rn,0))));
};

op fcvtau_xd( 0b1001111001100101000000[22] : rn[5] : rd[5] );

fcvtau_xd.disasm = {
  sink << "fcvtau\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtau_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(round(cpu.GetVF64(rn,0))));
};

op fcvtau_vss( 0b0[1] : q[1] : 0b10111000100001110010[20] : rn[5] : rd[5] );

fcvtau_vss.disasm = {
  sink << "fcvtau\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op fcvtau_v2d2d( 0b0110111001100001110010[22] : rn[5] : rd[5] );

fcvtau_v2d2d.disasm = {
  sink << "fcvtau\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FCVTAU
 *******************************************************************/

op fcvtl2_v2d4s( 0b0100111001100001011110[22] : rn[5] : rd[5] );

fcvtl2_v2d4s.disasm = {
  sink << "fcvtl2\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,4,2);
};

op fcvtl2_v4s8h( 0b0100111000100001011110[22] : rn[5] : rd[5] );

fcvtl2_v4s8h.disasm = {
  sink << "fcvtl2\t" << DisasmTV(rd,4,2) << ", " << DisasmTV(rn,8,1);
};

op fcvtl_v2d2s( 0b0000111001100001011110[22] : rn[5] : rd[5] );

fcvtl_v2d2s.disasm = {
  sink << "fcvtl\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,2);
};

op fcvtl_v4s4h( 0b0000111000100001011110[22] : rn[5] : rd[5] );

fcvtl_v4s4h.disasm = {
  sink << "fcvtl\t" << DisasmTV(rd,4,2) << ", " << DisasmTV(rn,4,1);
};

/*******************************************************************
 * FCVTMS (scalar)
 *
 * Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar).
 */

op fcvtms_ss( 0b0101111000100001101110[22] : rn[5] : rd[5] );

fcvtms_ss.disasm = {
  sink << "fcvtms\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtms_ss.execute = {
  cpu.SetVS32(rd, typename ARCH::S32(floor(cpu.GetVF32(rn,0))));
};

op fcvtms_dd( 0b0101111001100001101110[22] : rn[5] : rd[5] );

fcvtms_dd.disasm = {
  sink << "fcvtms\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtms_dd.execute = {
  cpu.SetVS64(rd, typename ARCH::S64(floor(cpu.GetVF64(rn,0))));
};

op fcvtms_ws( 0b0001111000110000000000[22] : rn[5] : rd[5] );

fcvtms_ws.disasm = {
  sink << "fcvtms\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtms_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(floor(cpu.GetVF32(rn,0))));
};

op fcvtms_wd( 0b0001111001110000000000[22] : rn[5] : rd[5] );

fcvtms_wd.disasm = {
  sink << "fcvtms\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtms_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(floor(cpu.GetVF64(rn,0))));
};

op fcvtms_xs( 0b1001111000110000000000[22] : rn[5] : rd[5] );

fcvtms_xs.disasm = {
  sink << "fcvtms\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtms_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(floor(cpu.GetVF32(rn,0))));
};

op fcvtms_xd( 0b1001111001110000000000[22] : rn[5] : rd[5] );

fcvtms_xd.disasm = {
  sink << "fcvtms\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtms_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(floor(cpu.GetVF64(rn,0))));
};

op fcvtms_vss( 0b0[1] : q[1] : 0b00111000100001101110[20] : rn[5] : rd[5] );

fcvtms_vss.disasm = {
  sink << "fcvtms\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op fcvtms_v2d2d( 0b0100111001100001101110[22] : rn[5] : rd[5] );

fcvtms_v2d2d.disasm = {
  sink << "fcvtms\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FCVTMS (scalar)
 *******************************************************************/

/*******************************************************************
 * FCVTMU
 *
 * Floating-point Convert to Unsigned integer, rounding toward Minus infinity
 */

op fcvtmu_ss( 0b0111111000100001101110[22] : rn[5] : rd[5] );

fcvtmu_ss.disasm = {
  sink << "fcvtmu\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtmu_ss.execute = {
  cpu.SetVU32(rd, typename ARCH::U32(floor(cpu.GetVF32(rn,0))));
};

op fcvtmu_dd( 0b0111111001100001101110[22] : rn[5] : rd[5] );

fcvtmu_dd.disasm = {
  sink << "fcvtmu\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtmu_dd.execute = {
  cpu.SetVU64(rd, typename ARCH::U64(floor(cpu.GetVF64(rn,0))));
};

op fcvtmu_ws( 0b0001111000110001000000[22] : rn[5] : rd[5] );

fcvtmu_ws.disasm = {
  sink << "fcvtmu\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtmu_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(floor(cpu.GetVF32(rn,0))));
};

op fcvtmu_wd( 0b0001111001110001000000[22] : rn[5] : rd[5] );

fcvtmu_wd.disasm = {
  sink << "fcvtmu\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtmu_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(floor(cpu.GetVF64(rn,0))));
};

op fcvtmu_xs( 0b1001111000110001000000[22] : rn[5] : rd[5] );

fcvtmu_xs.disasm = {
  sink << "fcvtmu\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtmu_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(floor(cpu.GetVF32(rn,0))));
};

op fcvtmu_xd( 0b1001111001110001000000[22] : rn[5] : rd[5] );

fcvtmu_xd.disasm = {
  sink << "fcvtmu\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtmu_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(floor(cpu.GetVF64(rn,0))));
};

op fcvtmu_vss( 0b0[1] : q[1] : 0b10111000100001101110[20] : rn[5] : rd[5] );

fcvtmu_vss.disasm = {
  sink << "fcvtmu\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op fcvtmu_v2d2d( 0b0110111001100001101110[22] : rn[5] : rd[5] );

fcvtmu_v2d2d.disasm = {
  sink << "fcvtmu\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FCVTMU
 *******************************************************************/

op fcvtn2_v4s2d( 0b0100111001100001011010[22] : rn[5] : rd[5] );

fcvtn2_v4s2d.disasm = {
  sink << "fcvtn2\t" << DisasmTV(rd,4,2) << ", " << DisasmTV(rn,2,3);
};

op fcvtn2_v8h4s( 0b0100111000100001011010[22] : rn[5] : rd[5] );

fcvtn2_v8h4s.disasm = {
  sink << "fcvtn2\t" << DisasmTV(rd,8,1) << ", " << DisasmTV(rn,4,2);
};

op fcvtn_v2s2d( 0b0000111001100001011010[22] : rn[5] : rd[5] );

fcvtn_v2s2d.disasm = {
  sink << "fcvtn\t" << DisasmTV(rd,2,2) << ", " << DisasmTV(rn,2,3);
};

op fcvtn_v4h4s( 0b0000111000100001011010[22] : rn[5] : rd[5] );

fcvtn_v4h4s.disasm = {
  sink << "fcvtn\t" << DisasmTV(rd,4,1) << ", " << DisasmTV(rn,4,2);
};

/*******************************************************************
 * FCVTNS
 *
 * Floating-point Convert to Signed integer, rounding to Nearest with ties to even
 */

op fcvtns_ss( 0b0101111000100001101010[22] : rn[5] : rd[5] );

fcvtns_ss.disasm = {
  sink << "fcvtns\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtns_ss.execute = {
  cpu.SetVS32(rd, typename ARCH::S32(round(cpu.GetVF32(rn,0))));
};

op fcvtns_dd( 0b0101111001100001101010[22] : rn[5] : rd[5] );

fcvtns_dd.disasm = {
  sink << "fcvtns\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtns_dd.execute = {
  cpu.SetVS64(rd, typename ARCH::S64(round(cpu.GetVF64(rn,0))));
};

op fcvtns_ws( 0b0001111000100000000000[22] : rn[5] : rd[5] );

fcvtns_ws.disasm = {
  sink << "fcvtns\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtns_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(round(cpu.GetVF32(rn,0))));
};

op fcvtns_wd( 0b0001111001100000000000[22] : rn[5] : rd[5] );

fcvtns_wd.disasm = {
  sink << "fcvtns\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtns_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(round(cpu.GetVF64(rn,0))));
};

op fcvtns_xs( 0b1001111000100000000000[22] : rn[5] : rd[5] );

fcvtns_xs.disasm = {
  sink << "fcvtns\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtns_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(round(cpu.GetVF32(rn,0))));
};

op fcvtns_xd( 0b1001111001100000000000[22] : rn[5] : rd[5] );

fcvtns_xd.disasm = {
  sink << "fcvtns\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtns_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(round(cpu.GetVF64(rn,0))));
};

op fcvtns_vss( 0b0[1] : q[1] : 0b00111000100001101010[20] : rn[5] : rd[5] );

fcvtns_vss.disasm = {
  sink << "fcvtns\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op fcvtns_v2d2d( 0b0100111001100001101010[22] : rn[5] : rd[5] );

fcvtns_v2d2d.disasm = {
  sink << "fcvtns\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FCVTNS
 *******************************************************************/

/*******************************************************************
 * FCVTNU
 *
 * Floating-point Convert to Unsigned integer, rounding to Nearest with ties to even
 */

op fcvtnu_ss( 0b0111111000100001101010[22] : rn[5] : rd[5] );

fcvtnu_ss.disasm = {
  sink << "fcvtnu\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtnu_ss.execute = {
  cpu.SetVU32(rd, typename ARCH::U32(round(cpu.GetVF32(rn,0))));
};

op fcvtnu_dd( 0b0111111001100001101010[22] : rn[5] : rd[5] );

fcvtnu_dd.disasm = {
  sink << "fcvtnu\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtnu_dd.execute = {
  cpu.SetVU64(rd, typename ARCH::U64(round(cpu.GetVF64(rn,0))));
};

op fcvtnu_ws( 0b0001111000100001000000[22] : rn[5] : rd[5] );

fcvtnu_ws.disasm = {
  sink << "fcvtnu\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtnu_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(round(cpu.GetVF32(rn,0))));
};

op fcvtnu_wd( 0b0001111001100001000000[22] : rn[5] : rd[5] );

fcvtnu_wd.disasm = {
  sink << "fcvtnu\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtnu_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(round(cpu.GetVF64(rn,0))));
};

op fcvtnu_xs( 0b1001111000100001000000[22] : rn[5] : rd[5] );

fcvtnu_xs.disasm = {
  sink << "fcvtnu\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtnu_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(round(cpu.GetVF32(rn,0))));
};

op fcvtnu_xd( 0b1001111001100001000000[22] : rn[5] : rd[5] );

fcvtnu_xd.disasm = {
  sink << "fcvtnu\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtnu_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(round(cpu.GetVF64(rn,0))));
};

op fcvtnu_vss( 0b0[1] : q[1] : 0b10111000100001101010[20] : rn[5] : rd[5] );

fcvtnu_vss.disasm = {
  sink << "fcvtnu\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op fcvtnu_v2d2d( 0b0110111001100001101010[22] : rn[5] : rd[5] );

fcvtnu_v2d2d.disasm = {
  sink << "fcvtnu\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FCVTNU (scalar)
 *******************************************************************/

/*******************************************************************
 * FCVTPS
 *
 * Floating-point Convert to Signed integer, rounding toward Plus infinity
 */

op fcvtps_ss( 0b0101111010100001101010[22] : rn[5] : rd[5] );

fcvtps_ss.disasm = {
  sink << "fcvtps\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtps_ss.execute = {
  cpu.SetVS32(rd, typename ARCH::S32(ceil(cpu.GetVF32(rn,0))));
};

op fcvtps_dd( 0b0101111011100001101010[22] : rn[5] : rd[5] );

fcvtps_dd.disasm = {
  sink << "fcvtps\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtps_dd.execute = {
  cpu.SetVS64(rd, typename ARCH::S64(ceil(cpu.GetVF64(rn,0))));
};

op fcvtps_ws( 0b0001111000101000000000[22] : rn[5] : rd[5] );

fcvtps_ws.disasm = {
  sink << "fcvtps\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtps_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(ceil(cpu.GetVF32(rn,0))));
};

op fcvtps_wd( 0b0001111001101000000000[22] : rn[5] : rd[5] );

fcvtps_wd.disasm = {
  sink << "fcvtps\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtps_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(ceil(cpu.GetVF64(rn,0))));
};

op fcvtps_xs( 0b1001111000101000000000[22] : rn[5] : rd[5] );

fcvtps_xs.disasm = {
  sink << "fcvtps\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtps_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(ceil(cpu.GetVF32(rn,0))));
};

op fcvtps_xd( 0b1001111001101000000000[22] : rn[5] : rd[5] );

fcvtps_xd.disasm = {
  sink << "fcvtps\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtps_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(ceil(cpu.GetVF64(rn,0))));
};

op fcvtps_vss( 0b0[1] : q[1] : 0b00111010100001101010[20] : rn[5] : rd[5] );

fcvtps_vss.disasm = {
  sink << "fcvtps\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op fcvtps_v2d2d( 0b0100111011100001101010[22] : rn[5] : rd[5] );

fcvtps_v2d2d.disasm = {
  sink << "fcvtps\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FCVTPS
 *******************************************************************/

/*******************************************************************
 * FCVTPU
 *
 * Floating-point Convert to Unsigned integer, rounding toward Plus infinity
 */

op fcvtpu_ss( 0b0111111010100001101010[22] : rn[5] : rd[5] );

fcvtpu_ss.disasm = {
  sink << "fcvtpu\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtpu_ss.execute = {
  cpu.SetVU32(rd, typename ARCH::U32(ceil(cpu.GetVF32(rn,0))));
};

op fcvtpu_dd( 0b0111111011100001101010[22] : rn[5] : rd[5] );

fcvtpu_dd.disasm = {
  sink << "fcvtpu\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtpu_dd.execute = {
  cpu.SetVU64(rd, typename ARCH::U64(ceil(cpu.GetVF64(rn,0))));
};

op fcvtpu_ws( 0b0001111000101001000000[22] : rn[5] : rd[5] );

fcvtpu_ws.disasm = {
  sink << "fcvtpu\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtpu_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(ceil(cpu.GetVF32(rn,0))));
};

op fcvtpu_wd( 0b0001111001101001000000[22] : rn[5] : rd[5] );

fcvtpu_wd.disasm = {
  sink << "fcvtpu\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtpu_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(ceil(cpu.GetVF64(rn,0))));
};

op fcvtpu_xs( 0b1001111000101001000000[22] : rn[5] : rd[5] );

fcvtpu_xs.disasm = {
  sink << "fcvtpu\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtpu_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(ceil(cpu.GetVF32(rn,0))));
};

op fcvtpu_xd( 0b1001111001101001000000[22] : rn[5] : rd[5] );

fcvtpu_xd.disasm = {
  sink << "fcvtpu\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtpu_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(ceil(cpu.GetVF64(rn,0))));
};

op fcvtpu_vss( 0b0[1] : q[1] : 0b10111010100001101010[20] : rn[5] : rd[5] );

fcvtpu_vss.disasm = {
  sink << "fcvtpu\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op fcvtpu_v2d2d( 0b0110111011100001101010[22] : rn[5] : rd[5] );

fcvtpu_v2d2d.disasm = {
  sink << "fcvtpu\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FCVTPU
 *******************************************************************/

op fcvtxn2_v4s2d( 0b0110111001100001011010[22] : rn[5] : rd[5] );

fcvtxn2_v4s2d.disasm = {
  sink << "fcvtxn2\t" << DisasmTV(rd,4,2) << ", " << DisasmTV(rn,2,3);
};

op fcvtxn_sd( 0b0111111001100001011010[22] : rn[5] : rd[5] );

fcvtxn_sd.disasm = {
  sink << "fcvtxn\t" << DisasmS(rd) << ", " << DisasmD(rn);
};

op fcvtxn_v2s2d( 0b0010111001100001011010[22] : rn[5] : rd[5] );

fcvtxn_v2s2d.disasm = {
  sink << "fcvtxn\t" << DisasmTV(rd,2,2) << ", " << DisasmTV(rn,2,3);
};

/*******************************************************************
 * FCVTZS (integer)
 *
 * Floating-point convert to signed integer, rounding toward zero
 */

op fcvtzs_ss( 0b0101111010100001101110[22] : rn[5] : rd[5] );

fcvtzs_ss.disasm = {
  sink << "fcvtzs\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtzs_ss.execute = {
  cpu.SetVS32(rd, typename ARCH::S32(trunc(cpu.GetVF32(rn,0))));
};

op fcvtzs_dd( 0b0101111011100001101110[22] : rn[5] : rd[5] );

fcvtzs_dd.disasm = {
  sink << "fcvtzs\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtzs_dd.execute = {
  cpu.SetVS64(rd, typename ARCH::S64(trunc(cpu.GetVF64(rn,0))));
};

op fcvtzs_ws( 0b0001111000111000000000[22] : rn[5] : rd[5] );

fcvtzs_ws.disasm = {
  sink << "fcvtzs\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtzs_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(trunc(cpu.GetVF32(rn,0))));
};

op fcvtzs_wd( 0b0001111001111000000000[22] : rn[5] : rd[5] );

fcvtzs_wd.disasm = {
  sink << "fcvtzs\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtzs_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::S32(trunc(cpu.GetVF64(rn,0))));
};

op fcvtzs_xs( 0b1001111000111000000000[22] : rn[5] : rd[5] );

fcvtzs_xs.disasm = {
  sink << "fcvtzs\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtzs_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(trunc(cpu.GetVF32(rn,0))));
};

op fcvtzs_xd( 0b1001111001111000000000[22] : rn[5] : rd[5] );

fcvtzs_xd.disasm = {
  sink << "fcvtzs\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtzs_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::S64(trunc(cpu.GetVF64(rn,0))));
};

op fcvtzs_vss( 0b0[1] : q[1] : 0b00111010100001101110[20] : rn[5] : rd[5] );

fcvtzs_vss.disasm = {
  sink << "fcvtzs\t" << DisasmTV(rd,2<<q,2) << ", " << DisasmTV(rn,2<<q,2);
};

fcvtzs_vss.execute = {
  typedef typename ARCH::S32 S32;

  for (unsigned idx = 0, end=2<<q; idx < end; ++idx)
    cpu.SetVS32(rd, idx, S32(trunc(cpu.GetVF32(rn,idx))));
  cpu.ClearHighV(rd,8<<q);
};

op fcvtzs_v2d2d( 0b0100111011100001101110[22] : rn[5] : rd[5] );

fcvtzs_v2d2d.disasm = {
  sink << "fcvtzs\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

fcvtzs_v2d2d.execute = {
  typedef typename ARCH::S64 S64;

  for (unsigned idx = 0, end=1<<1; idx < end; ++idx)
    cpu.SetVS64(rd, idx, S64(trunc(cpu.GetVF64(rn,idx))));
  cpu.ClearHighV(rd,8<<1);
};

/*
 * end of FCVTZS (integer)
 *******************************************************************/

/*******************************************************************
 * FCVTZS (fixed-point)
 *
 * Floating-point convert to signed fixed-point, rounding toward zero:
 * Rd = signed_convertToIntegerExactTowardZero(Vn*(2^fbits))
 */

op fcvtzs_wsi( 0b00011110000110001[17] : scale[5] : rn[5] : rd[5] );
fcvtzs_wsi.var fbits : {unsigned} = {32-scale};

fcvtzs_wsi.disasm = {
  sink << "fcvtzs\t" << DisasmGZWR(rd) << ", " << DisasmS(rn) << ", " << DisasmI(fbits);
};

op fcvtzs_wdi( 0b00011110010110001[17] : scale[5] : rn[5] : rd[5] );
fcvtzs_wdi.var fbits : {unsigned} = {32-scale};

fcvtzs_wdi.disasm = {
  sink << "fcvtzs\t" << DisasmGZWR(rd) << ", " << DisasmD(rn) << ", " << DisasmI(fbits);
};

op fcvtzs_xsi( 0b1001111000011000[16] : scale[6] : rn[5] : rd[5] );
fcvtzs_xsi.var fbits : {unsigned} = {64-scale};

fcvtzs_xsi.disasm = {
  sink << "fcvtzs\t" << DisasmGZXR(rd) << ", " << DisasmS(rn) << ", " << DisasmI(fbits);
};

op fcvtzs_xdi( 0b1001111001011000[16] : scale[6] : rn[5] : rd[5] );
fcvtzs_xdi.var fbits : {unsigned} = {64-scale};

fcvtzs_xdi.disasm = {
  sink << "fcvtzs\t" << DisasmGZXR(rd) << ", " << DisasmD(rn) << ", " << DisasmI(fbits);
};

op fcvtzs_ssi( 0b01011111001[11] : lro[5] : 0b111111[6] : rn[5] : rd[5] );
fcvtzs_ssi.var shift : {unsigned} = {32 - lro};

fcvtzs_ssi.disasm = {
  sink << "fcvtzs\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

op fcvtzs_ddi( 0b0101111101[10] : lro[6] : 0b111111[6] : rn[5] : rd[5] );
fcvtzs_ddi.var shift : {unsigned} = {64 - lro};

fcvtzs_ddi.disasm = {
  sink << "fcvtzs\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

op fcvtzs_vssi( 0b0[1] : q[1] : 0b001111001[9] : lro[5] : 0b111111[6] : rn[5] : rd[5] );
fcvtzs_vssi.var shift : {unsigned} = {32 - lro};

fcvtzs_vssi.disasm = {
  sink << "fcvtzs\t" << DisasmTV(rd,2<<q,2) << ", " << DisasmTV(rn,2<<q,2) << ", " << DisasmI(shift);
};

op fcvtzs_v2d2di( 0b0100111101[10] : lro[6] : 0b111111[6] : rn[5] : rd[5] );
fcvtzs_v2d2di.var shift : {unsigned} = {64 - lro};

fcvtzs_v2d2di.disasm = {
  sink << "fcvtzs\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmI(shift);
};

/*
 * end of FCVTZS (fixed-point)
 *******************************************************************/

/*******************************************************************
 * FCVTZU
 *
 * Floating-point convert to unsigned integer, rounding toward zero
 */

op fcvtzu_ss( 0b0111111010100001101110[22] : rn[5] : rd[5] );

fcvtzu_ss.disasm = {
  sink << "fcvtzu\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fcvtzu_ss.execute = {
  cpu.SetVU32(rd, typename ARCH::U32(trunc(cpu.GetVF32(rn,0))));
};

op fcvtzu_dd( 0b0111111011100001101110[22] : rn[5] : rd[5] );

fcvtzu_dd.disasm = {
  sink << "fcvtzu\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fcvtzu_dd.execute = {
  cpu.SetVU64(rd, typename ARCH::U64(trunc(cpu.GetVF64(rn,0))));
};

op fcvtzu_ws( 0b0001111000111001000000[22] : rn[5] : rd[5] );

fcvtzu_ws.disasm = {
  sink << "fcvtzu\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fcvtzu_ws.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(trunc(cpu.GetVF32(rn,0))));
};

op fcvtzu_wd( 0b0001111001111001000000[22] : rn[5] : rd[5] );

fcvtzu_wd.disasm = {
  sink << "fcvtzu\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

fcvtzu_wd.execute = {
  cpu.SetGZR(rd, typename ARCH::U32(trunc(cpu.GetVF64(rn,0))));
};

op fcvtzu_xs( 0b1001111000111001000000[22] : rn[5] : rd[5] );

fcvtzu_xs.disasm = {
  sink << "fcvtzu\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

fcvtzu_xs.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(trunc(cpu.GetVF32(rn,0))));
};

op fcvtzu_xd( 0b1001111001111001000000[22] : rn[5] : rd[5] );

fcvtzu_xd.disasm = {
  sink << "fcvtzu\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fcvtzu_xd.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(trunc(cpu.GetVF64(rn,0))));
};

op fcvtzu_vss( 0b0[1] : q[1] : 0b10111010100001101110[20] : rn[5] : rd[5] );

fcvtzu_vss.disasm = {
  sink << "fcvtzu\t" << DisasmTV(rd,2<<q,2) << ", " << DisasmTV(rn,2<<q,2);
};

fcvtzu_vss.execute = {
  for (unsigned idx = 0, end=2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, typename ARCH::U32(trunc(cpu.GetVF32(rn,idx))));
  cpu.ClearHighV(rd,8<<q);
};

op fcvtzu_v2d2d( 0b0110111011100001101110[22] : rn[5] : rd[5] );

fcvtzu_v2d2d.disasm = {
  sink << "fcvtzu\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

fcvtzu_v2d2d.execute = {
  for (unsigned idx = 0, end=1<<1; idx < end; ++idx)
    cpu.SetVU64(rd, idx, typename ARCH::U64(trunc(cpu.GetVF64(rn,idx))));
  cpu.ClearHighV(rd,8<<1);
};

/*
 * end of FCVTZU (scalar)
 *******************************************************************/

/*******************************************************************
 * FCVTZU (fixed-point)
 *
 * Floating-point convert to unsigned fixed-point, rounding toward zero: Rd = unsigned_convertToIntegerExactTowardZero(Vn*(2^fbits))
 */

op fcvtzu_wsi( 0b00011110000110011[17] : scale[5] : rn[5] : rd[5] );
fcvtzu_wsi.var fbits : {unsigned} = {32-scale};

fcvtzu_wsi.disasm = {
  sink << "fcvtzu\t" << DisasmGZWR(rd) << ", " << DisasmS(rn) << ", " << DisasmI(fbits);
};

op fcvtzu_xsi( 0b1001111000011001[16] : scale[6] : rn[5] : rd[5] );
fcvtzu_xsi.var fbits : {unsigned} = {64-scale};

fcvtzu_xsi.disasm = {
  sink << "fcvtzu\t" << DisasmGZXR(rd) << ", " << DisasmS(rn) << ", " << DisasmI(fbits);
};

op fcvtzu_wdi( 0b00011110010110011[17] : scale[5] : rn[5] : rd[5] );
fcvtzu_wdi.var fbits : {unsigned} = {32-scale};

fcvtzu_wdi.disasm = {
  sink << "fcvtzu\t" << DisasmGZWR(rd) << ", " << DisasmD(rn) << ", " << DisasmI(fbits);
};

op fcvtzu_xdi( 0b1001111001011001[16] : scale[6] : rn[5] : rd[5] );
fcvtzu_xdi.var fbits : {unsigned} = {64-scale};

fcvtzu_xdi.disasm = {
  sink << "fcvtzu\t" << DisasmGZXR(rd) << ", " << DisasmD(rn) << ", " << DisasmI(fbits);
};

op fcvtzu_ssi( 0b01111111001[11] : lro[5] : 0b111111[6] : rn[5] : rd[5] );
fcvtzu_ssi.var shift : {unsigned} = {32 - lro};

fcvtzu_ssi.disasm = {
  sink << "fcvtzu\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

op fcvtzu_ddi( 0b0111111101[10] : lro[6] : 0b111111[6] : rn[5] : rd[5] );
fcvtzu_ddi.var shift : {unsigned} = {64 - lro};

fcvtzu_ddi.disasm = {
  sink << "fcvtzu\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

op fcvtzu_vssi( 0b0[1] : q[1] : 0b101111001[9] : lro[5] : 0b111111[6] : rn[5] : rd[5] );
fcvtzu_vssi.var shift : {unsigned} = {32 - lro};

fcvtzu_vssi.disasm = {
  sink << "fcvtzu\t" << DisasmTV(rd,2<<q,2) << ", " << DisasmTV(rn,2<<q,2) << ", " << DisasmI(shift);
};

op fcvtzu_v2d2di( 0b0110111101[10] : lro[6] : 0b111111[6] : rn[5] : rd[5] );
fcvtzu_v2d2di.var shift : {unsigned} = {64 - lro};

fcvtzu_v2d2di.disasm = {
  sink << "fcvtzu\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmI(shift);
};

/*
 * end of FCVTZU (scalar, fixed-point)
 *******************************************************************/

/*******************************************************************
 * FDIV
 * Floating-point divide: Vd = Vn / Vm
 */

op fdiv_s( 0b00011110001[11] : rm[5] : 0b000110[6] : rn[5] : rd[5] );

fdiv_s.disasm = {
  sink << "fdiv\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fdiv_s.execute = {
  cpu.SetVF32(rd, cpu.GetVF32(rn,0) / cpu.GetVF32(rm,0));
};

op fdiv_d( 0b00011110011[11] : rm[5] : 0b000110[6] : rn[5] : rd[5] );

fdiv_d.disasm = {
  sink << "fdiv\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fdiv_d.execute = {
  cpu.SetVF64(rd, cpu.GetVF64(rn,0) / cpu.GetVF64(rm,0));
};

op fdiv_vs( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

fdiv_vs.disasm = {
  sink << "fdiv\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op fdiv_v2d( 0b01101110011[11] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

fdiv_v2d.disasm = {
  sink << "fdiv\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

/*
 * end of FDIV
 *******************************************************************/

/*******************************************************************
 * FMADD
 *
 * Floating-point fused Multiply-Add (scalar)
 */

op fmadd_s( 0b00011111000[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );

fmadd_s.disasm = {
  sink << "fmadd\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm) << ", " << DisasmS(ra);
};

fmadd_s.execute = {
  cpu.SetVF32(rd, FPMulAdd(cpu, cpu.GetVF32(ra, 0), cpu.GetVF32(rn, 0), cpu.GetVF32(rm, 0)));
};

op fmadd_d( 0b00011111010[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );

fmadd_d.disasm = {
  sink << "fmadd\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm) << ", " << DisasmD(ra);
};

fmadd_d.execute = {
  cpu.SetVF64(rd, FPMulAdd(cpu, cpu.GetVF64(ra, 0), cpu.GetVF64(rn, 0), cpu.GetVF64(rm, 0)));
};

/*
 * end of FMADD
 *******************************************************************/

/*******************************************************************
 * FMAX
 *
 * Floating-point maximum
 */

op fmax_s( 0b00011110001[11] : rm[5] : 0b010010[6] : rn[5] : rd[5] );

fmax_s.disasm = {
  sink << "fmax\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fmax_s.execute = {
  cpu.SetVF32(rd, FPMax(cpu, cpu.GetVF32(rn, 0), cpu.GetVF32(rm, 0)));
};

op fmax_d( 0b00011110011[11] : rm[5] : 0b010010[6] : rn[5] : rd[5] );

fmax_d.disasm = {
  sink << "fmax\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fmax_d.execute = {
  cpu.SetVF64(rd, FPMax(cpu, cpu.GetVF64(rn, 0), cpu.GetVF64(rm, 0)));
};

op fmax_vs( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b111101[6] : rn[5] : rd[5] );

fmax_vs.disasm = {
  sink << "fmax\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fmax_vs.execute = {
  for (unsigned e=0, end=2<<q; e < end; ++e)
    cpu.SetVF32(rd, e, FPMax(cpu, cpu.GetVF32(rn, e), cpu.GetVF32(rm, e)));
  cpu.ClearHighV(rd, 8<<q);
};

op fmax_v2d( 0b01001110011[11] : rm[5] : 0b111101[6] : rn[5] : rd[5] );

fmax_v2d.disasm = {
  sink << "fmax\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fmax_v2d.execute = {
  for (unsigned e=0, end=2; e < end; ++e)
    cpu.SetVF64(rd, e, FPMax(cpu, cpu.GetVF64(rn, e), cpu.GetVF64(rm, e)));
};

/*
 * end of FMAX
 *******************************************************************/

op fmaxnm_s( 0b00011110001[11] : rm[5] : 0b011010[6] : rn[5] : rd[5] );

fmaxnm_s.disasm = {
  sink << "fmaxnm\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

op fmaxnm_d( 0b00011110011[11] : rm[5] : 0b011010[6] : rn[5] : rd[5] );

fmaxnm_d.disasm = {
  sink << "fmaxnm\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

op fmaxnm_vs( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b110001[6] : rn[5] : rd[5] );

fmaxnm_vs.disasm = {
  sink << "fmaxnm\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op fmaxnm_v2d( 0b01001110011[11] : rm[5] : 0b110001[6] : rn[5] : rd[5] );

fmaxnm_v2d.disasm = {
  sink << "fmaxnm\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

op fmaxnmp_dv2d( 0b0111111001110000110010[22] : rn[5] : rd[5] );

fmaxnmp_dv2d.disasm = {
  sink << "fmaxnmp\t" << DisasmD(rd) << ", " << DisasmTV(rn,2,3);
};

op fmaxnmp_sv2s( 0b0111111000110000110010[22] : rn[5] : rd[5] );

fmaxnmp_sv2s.disasm = {
  sink << "fmaxnmp\t" << DisasmS(rd) << ", " << DisasmTV(rn,2,2);
};

op fmaxnmp_vsvsvs( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b110001[6] : rn[5] : rd[5] );

fmaxnmp_vsvsvs.disasm = {
  sink << "fmaxnmp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op fmaxnmp_v2dv2dv2d( 0b01101110011[11] : rm[5] : 0b110001[6] : rn[5] : rd[5] );

fmaxnmp_v2dv2dv2d.disasm = {
  sink << "fmaxnmp\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

op fmaxnmv_sv4s( 0b0110111000110000110010[22] : rn[5] : rd[5] );

fmaxnmv_sv4s.disasm = {
  sink << "fmaxnmv\t" << DisasmS(rd) << ", " << DisasmTV(rn,4,2);
};

op fmaxp_dv2d( 0b0111111001110000111110[22] : rn[5] : rd[5] );

fmaxp_dv2d.disasm = {
  sink << "fmaxp\t" << DisasmD(rd) << ", " << DisasmTV(rn,2,3);
};

op fmaxp_sv2s( 0b0111111000110000111110[22] : rn[5] : rd[5] );

fmaxp_sv2s.disasm = {
  sink << "fmaxp\t" << DisasmS(rd) << ", " << DisasmTV(rn,2,2);
};

op fmaxp_vsvsvs( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b111101[6] : rn[5] : rd[5] );

fmaxp_vsvsvs.disasm = {
  sink << "fmaxp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op fmaxp_v2dv2dv2d( 0b01101110011[11] : rm[5] : 0b111101[6] : rn[5] : rd[5] );

fmaxp_v2dv2dv2d.disasm = {
  sink << "fmaxp\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

op fmaxv_sv4s( 0b0110111000110000111110[22] : rn[5] : rd[5] );

fmaxv_sv4s.disasm = {
  sink << "fmaxv\t" << DisasmS(rd) << ", " << DisasmTV(rn,4,2);
};

/*******************************************************************
 * FMIN
 *
 * Floating-point minimum 
 */

op fmin_s( 0b00011110001[11] : rm[5] : 0b010110[6] : rn[5] : rd[5] );

fmin_s.disasm = {
  sink << "fmin\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fmin_s.execute = {
  cpu.SetVF32(rd, FPMin(cpu, cpu.GetVF32(rn, 0), cpu.GetVF32(rm, 0)));
};

op fmin_d( 0b00011110011[11] : rm[5] : 0b010110[6] : rn[5] : rd[5] );

fmin_d.disasm = {
  sink << "fmin\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fmin_d.execute = {
  cpu.SetVF64(rd, FPMin(cpu, cpu.GetVF64(rn, 0), cpu.GetVF64(rm, 0)));
};

op fmin_vs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b111101[6] : rn[5] : rd[5] );

fmin_vs.disasm = {
  sink << "fmin\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fmin_vs.execute = {
  for (unsigned e=0, end=2<<q; e < end; ++e)
    cpu.SetVF32(rd, e, FPMin(cpu, cpu.GetVF32(rn, e), cpu.GetVF32(rm, e)));
  cpu.ClearHighV(rd, 8<<q);
};

op fmin_v2d( 0b01001110111[11] : rm[5] : 0b111101[6] : rn[5] : rd[5] );

fmin_v2d.disasm = {
  sink << "fmin\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fmin_v2d.execute = {
  for (unsigned e=0, end=2; e < end; ++e)
    cpu.SetVF64(rd, e, FPMin(cpu, cpu.GetVF64(rn, e), cpu.GetVF64(rm, e)));
};

/*
 * end of FMIN
 *******************************************************************/

op fminnm_s( 0b00011110001[11] : rm[5] : 0b011110[6] : rn[5] : rd[5] );

fminnm_s.disasm = {
  sink << "fminnm\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

op fminnm_d( 0b00011110011[11] : rm[5] : 0b011110[6] : rn[5] : rd[5] );

fminnm_d.disasm = {
  sink << "fminnm\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

op fminnm_vs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b110001[6] : rn[5] : rd[5] );

fminnm_vs.disasm = {
  sink << "fminnm\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op fminnm_v2d( 0b01001110111[11] : rm[5] : 0b110001[6] : rn[5] : rd[5] );

fminnm_v2d.disasm = {
  sink << "fminnm\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

op fminnmp_sv2s( 0b0111111010110000110010[22] : rn[5] : rd[5] );

fminnmp_sv2s.disasm = {
  sink << "fminnmp\t" << DisasmS(rd) << ", " << DisasmTV(rn,2,2);
};

op fminnmp_dv2d( 0b0111111011110000110010[22] : rn[5] : rd[5] );

fminnmp_dv2d.disasm = {
  sink << "fminnmp\t" << DisasmD(rd) << ", " << DisasmTV(rn,2,3);
};

op fminnmp_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b110001[6] : rn[5] : rd[5] );

fminnmp_vsvsvs.disasm = {
  sink << "fminnmp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op fminnmp_v2dv2dv2d( 0b01101110111[11] : rm[5] : 0b110001[6] : rn[5] : rd[5] );

fminnmp_v2dv2dv2d.disasm = {
  sink << "fminnmp\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

op fminnmv_sv4s( 0b0110111010110000110010[22] : rn[5] : rd[5] );

fminnmv_sv4s.disasm = {
  sink << "fminnmv\t" << DisasmS(rd) << ", " << DisasmTV(rn,4,2);
};

op fminp_sv2s( 0b0111111010110000111110[22] : rn[5] : rd[5] );

fminp_sv2s.disasm = {
  sink << "fminp\t" << DisasmS(rd) << ", " << DisasmTV(rn,2,2);
};

op fminp_dv2d( 0b0111111011110000111110[22] : rn[5] : rd[5] );

fminp_dv2d.disasm = {
  sink << "fminp\t" << DisasmD(rd) << ", " << DisasmTV(rn,2,3);
};

op fminp_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b111101[6] : rn[5] : rd[5] );

fminp_vsvsvs.disasm = {
  sink << "fminp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op fminp_v2dv2dv2d( 0b01101110111[11] : rm[5] : 0b111101[6] : rn[5] : rd[5] );

fminp_v2dv2dv2d.disasm = {
  sink << "fminp\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

op fminv_sv4s( 0b0110111010110000111110[22] : rn[5] : rd[5] );

fminv_sv4s.disasm = {
  sink << "fminv\t" << DisasmS(rd) << ", " << DisasmTV(rn,4,2);
};

/*******************************************************************
 * FMLA
 *
 * Floating-point fused Multiply-Add to accumulator
 */

op fmla_si( 0b0101111110[10] : index0[1] : rm[5] : 0b0001[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
fmla_si.var index : {uint8_t} = {index1|index0};

fmla_si.disasm = {
  sink << "fmla\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm,0,2) << DisasmSubscript(index);
};

fmla_si.execute = {
  typename ARCH::F32 element = cpu.GetVF32(rm, index);
  cpu.SetVF32(rd, FPMulAdd(cpu, cpu.GetVF32(rd, 0), cpu.GetVF32(rn, 0), element));
};

op fmla_di( 0b01011111110[11] : rm[5] : 0b0001[4] : index[1] : 0b0[1] : rn[5] : rd[5] );

fmla_di.disasm = {
  sink << "fmla\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmTV(rm,0,3) << DisasmSubscript(index);
};

fmla_di.execute = {
  typename ARCH::F64 element = cpu.GetVF64(rm, index);
  cpu.SetVF64(rd, FPMulAdd(cpu, cpu.GetVF64(rd, 0), cpu.GetVF64(rn, 0), element));
};

op fmla_vsi( 0b0[1] : q[1] : 0b00111110[8] : index0[1] : rm[5] : 0b0001[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
fmla_vsi.var index : {uint8_t} = {index1|index0};

fmla_vsi.disasm = {
  sink << "fmla\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

fmla_vsi.execute = {
  typename ARCH::F32 element = cpu.GetVF32(rm, index);
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, FPMulAdd(cpu, cpu.GetVF32(rd, idx), cpu.GetVF32(rn, idx), element));
  cpu.ClearHighV(rd, 8<<q);
};

op fmla_v2di( 0b01001111110[11] : rm[5] : 0b0001[4] : index[1] : 0b0[1] : rn[5] : rd[5] );

fmla_v2di.disasm = {
  sink << "fmla\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,0,3) << DisasmSubscript(index);
};

fmla_v2di.execute = {
  typename ARCH::F64 element = cpu.GetVF64(rm, index);
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    cpu.SetVF64(rd, idx, FPMulAdd(cpu, cpu.GetVF64(rd, idx), cpu.GetVF64(rn, idx), element));
};

op fmla_vs( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b110011[6] : rn[5] : rd[5] );

fmla_vs.disasm = {
  sink << "fmla\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fmla_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, FPMulAdd(cpu, cpu.GetVF32(rd, idx), cpu.GetVF32(rn, idx), cpu.GetVF32(rm, idx)));
  cpu.ClearHighV(rd, 8<<q);
};

op fmla_v2d( 0b01001110011[11] : rm[5] : 0b110011[6] : rn[5] : rd[5] );

fmla_v2d.disasm = {
  sink << "fmla\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fmla_v2d.execute = {
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    cpu.SetVF64(rd, idx, FPMulAdd(cpu, cpu.GetVF64(rd, idx), cpu.GetVF64(rn, idx), cpu.GetVF64(rm, idx)));
};

/*
 * end of FMLA
 *******************************************************************/

/*******************************************************************
 * FMLS
 *
 * Floating-point fused Multiply-Substract to accumulator
 */

op fmls_si( 0b0101111110[10] : index0[1] : rm[5] : 0b0101[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
fmls_si.var index : {uint8_t} = {index1|index0};

fmls_si.disasm = {
  sink << "fmls\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm,0,2) << DisasmSubscript(index);
};

fmls_si.execute = {
  typename ARCH::F32 element = cpu.GetVF32(rm, index);
  cpu.SetVF32(rd, FPMulSub(cpu, cpu.GetVF32(rd, 0), cpu.GetVF32(rn, 0), element));
};

op fmls_di( 0b01011111110[11] : rm[5] : 0b0101[4] : index[1] : 0b0[1] : rn[5] : rd[5] );

fmls_di.disasm = {
  sink << "fmls\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmTV(rm,0,3) << DisasmSubscript(index);
};

fmls_di.execute = {
  typename ARCH::F64 element = cpu.GetVF64(rm, index);
  cpu.SetVF64(rd, FPMulSub(cpu, cpu.GetVF64(rd, 0), cpu.GetVF64(rn, 0), element));
};

op fmls_vsi( 0b0[1] : q[1] : 0b00111110[8] : index0[1] : rm[5] : 0b0101[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
fmls_vsi.var index : {uint8_t} = {index1|index0};

fmls_vsi.disasm = {
  sink << "fmls\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

fmls_vsi.execute = {
  typename ARCH::F32 element = cpu.GetVF32(rm, index);
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, FPMulSub(cpu, cpu.GetVF32(rd, idx), cpu.GetVF32(rn, idx), element));
  cpu.ClearHighV(rd, 8<<q);
};

op fmls_v2di( 0b01001111110[11] : rm[5] : 0b0101[4] : index[1] : 0b0[1] : rn[5] : rd[5] );

fmls_v2di.disasm = {
  sink << "fmls\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,0,3) << DisasmSubscript(index);
};

fmls_v2di.execute = {
  typename ARCH::F64 element = cpu.GetVF64(rm, index);
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    cpu.SetVF64(rd, idx, FPMulSub(cpu, cpu.GetVF64(rd, idx), cpu.GetVF64(rn, idx), element));
};

op fmls_vs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b110011[6] : rn[5] : rd[5] );

fmls_vs.disasm = {
  sink << "fmls\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fmls_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, FPMulSub(cpu, cpu.GetVF32(rd, idx), cpu.GetVF32(rn, idx), cpu.GetVF32(rm, idx)));
  cpu.ClearHighV(rd, 8<<q);
};

op fmls_v2d( 0b01001110111[11] : rm[5] : 0b110011[6] : rn[5] : rd[5] );

fmls_v2d.disasm = {
  sink << "fmls\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fmls_v2d.execute = {
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    cpu.SetVF64(rd, idx, FPMulSub(cpu, cpu.GetVF64(rd, idx), cpu.GetVF64(rn, idx), cpu.GetVF64(rm, idx)));
};

/*
 * end of FMLA
 *******************************************************************/

/*******************************************************************
 * FMOV (register)
 *
 * Floating-point move register without conversion: Vd = Vn
 */

op fmov_ss( 0b0001111000100000010000[22] : rn[5] : rd[5] );

fmov_ss.disasm = {
  sink << "fmov\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fmov_ss.execute = {
  cpu.SetVF32(rd, cpu.GetVF32(rn,0));
};

op fmov_dd( 0b0001111001100000010000[22] : rn[5] : rd[5] );

fmov_dd.disasm = {
  sink << "fmov\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fmov_dd.execute = {
  cpu.SetVF64( rd, cpu.GetVF64(rn,0));
};

/*
 * end of FMOV (register)
 *******************************************************************/

/*******************************************************************
 * FMOV (immediate)
 *
 * Floating-point move immediate (scalar): Vd=#imm
 */

op fmov_sf( 0b00011110001[11] : fpimm[8] : 0b10000000[8] : rd[5] );
fmov_sf.var imm : {FPImm} = {fpimm};

fmov_sf.disasm = {
  sink << "fmov\t" << DisasmD(rd) << ", " << DisasmF(imm);
};

fmov_sf.execute = {
  typedef typename ARCH::F32 F32;

  cpu.SetVF32(rd, F32(imm.toFP<float>()));
};

op fmov_df( 0b00011110011[11] : fpimm[8] : 0b10000000[8] : rd[5] );
fmov_df.var imm : {FPImm} = {fpimm};

fmov_df.disasm = {
  sink << "fmov\t" << DisasmD(rd) << ", " << DisasmF(imm);
};

fmov_df.execute = {
  typedef typename ARCH::F64 F64;

  cpu.SetVF64(rd, F64(imm.toFP<double>()));
};

op fmov_vsf( 0b0[1] : q[1] : 0b00111100000[11] : shl<5> imm1[3] : 0b111101[6] : imm0[5] : rd[5] );
fmov_vsf.var imm : {FPImm} = {imm1|imm0};

fmov_vsf.disasm = {
  sink << "fmov\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmF(imm);
};

fmov_vsf.execute = {
  typedef typename ARCH::F32 F32;
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, F32(imm.toFP<float>()));
  cpu.ClearHighV(rd, 8<<q);
};

op fmov_v2df( 0b0110111100000[13] : shl<5> imm1[3] : 0b111101[6] : imm0[5] : rd[5] );
fmov_v2df.var imm : {FPImm} = {imm1|imm0};

fmov_v2df.disasm = {
  sink << "fmov\t" << DisasmTV(rd,2,3) << ", " << DisasmF(imm);
};

fmov_v2df.execute = {
  typedef typename ARCH::F64 F64;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    cpu.SetVF64(rd, idx, F64(imm.toFP<double>()));
};

/*
 * end of FMOV (immediate)
 *******************************************************************/

/*******************************************************************
 * FMOV (general)
 *
 * Floating-point move to or from general-purpose register without conversion
 */

op fmov_sw( 0b0001111000100111000000[22] : rn[5] : rd[5] );

fmov_sw.disasm = {
  sink << "fmov\t" << DisasmS(rd) << ", " << DisasmGZWR(rn);
};

fmov_sw.execute = {
  typedef typename ARCH::U32 U32;
  U32 data = U32(cpu.GetGZR(rn));
  cpu.SetVU32(rd,data);
};

op fmov_dw( 0b0001111001100111000000[22] : rn[5] : rd[5] );

fmov_dw.disasm = {
  sink << "fmov\t" << DisasmD(rd) << ", " << DisasmGZWR(rn);
};

op fmov_ws( 0b0001111000100110000000[22] : rn[5] : rd[5] );

fmov_ws.disasm = {
  sink << "fmov\t" << DisasmGZWR(rd) << ", " << DisasmS(rn);
};

fmov_ws.execute = {
  typedef typename ARCH::U32 U32;
  U32 data = cpu.GetVU32(rn,0);
  cpu.SetGZR(rd,data);
};

op fmov_wd( 0b0001111001100110000000[22] : rn[5] : rd[5] );

fmov_wd.disasm = {
  sink << "fmov\t" << DisasmGZWR(rd) << ", " << DisasmD(rn);
};

op fmov_sx( 0b1001111000100111000000[22] : rn[5] : rd[5] );

fmov_sx.disasm = {
  sink << "fmov\t" << DisasmS(rd) << ", " << DisasmGZXR(rn);
};

op fmov_dx( 0b1001111001100111000000[22] : rn[5] : rd[5] );

fmov_dx.disasm = {
  sink << "fmov\t" << DisasmD(rd) << ", " << DisasmGZXR(rn);
};

fmov_dx.execute = {
  typedef typename ARCH::U64 U64;
  U64 data = cpu.GetGZR(rn);
  cpu.SetVU64(rd,data);
};

op fmov_dix( 0b1001111010101111000000[22] : rn[5] : rd[5] );

fmov_dix.disasm = {
  sink << "fmov\t" << DisasmTV(rd,0,3) << "[1], " << DisasmGZXR(rn);
};

fmov_dix.execute = {
  typedef typename ARCH::U64 U64;
  U64 data = cpu.GetGZR(rn);
  cpu.SetVU64(rd,1,data);
};

op fmov_xs( 0b1001111000100110000000[22] : rn[5] : rd[5] );

fmov_xs.disasm = {
  sink << "fmov\t" << DisasmGZXR(rd) << ", " << DisasmS(rn);
};

op fmov_xd( 0b1001111001100110000000[22] : rn[5] : rd[5] );

fmov_xd.disasm = {
  sink << "fmov\t" << DisasmGZXR(rd) << ", " << DisasmD(rn);
};

fmov_xd.execute = {
  typedef typename ARCH::U64 U64;
  U64 data = cpu.GetVU64(rn,0);
  cpu.SetGZR(rd,data);
};

op fmov_xdi( 0b1001111010101110000000[22] : rn[5] : rd[5] );

fmov_xdi.disasm = {
  sink << "fmov\t" << DisasmGZXR(rd) << ", " << DisasmTV(rn,0,3) << "[1]";
};

fmov_xdi.execute = {
  typedef typename ARCH::U64 U64;
  U64 data = cpu.GetVU64(rn,1);
  cpu.SetGZR(rd,data);
};

/*
 * end of FMOV (general)
 *******************************************************************/

/*******************************************************************
 * FMSUB
 *
 * Floating-point fused Multiply-Substract (scalar)
 */

op fmsub_s( 0b00011111000[11] : rm[5] : 0b1[1] : ra[5] : rn[5] : rd[5] );

fmsub_s.disasm = {
  sink << "fmsub\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm) << ", " << DisasmS(ra);
};

fmsub_s.execute = {
  cpu.SetVF32(rd, FPMulSub(cpu, cpu.GetVF32(ra, 0), cpu.GetVF32(rn, 0), cpu.GetVF32(rm, 0)));
};

op fmsub_d( 0b00011111010[11] : rm[5] : 0b1[1] : ra[5] : rn[5] : rd[5] );

fmsub_d.disasm = {
  sink << "fmsub\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm) << ", " << DisasmD(ra);
};

fmsub_d.execute = {
  cpu.SetVF64(rd, FPMulSub(cpu, cpu.GetVF64(ra, 0), cpu.GetVF64(rn, 0), cpu.GetVF64(rm, 0)));
};

/*
 * end of FMSUB
 *******************************************************************/

/*******************************************************************
 * FMUL (scalar)
 *
 * Floating-point multiply (scalar): Vd = Vn * Vm
 */

op fmul_s( 0b00011110001[11] : rm[5] : 0b000010[6] : rn[5] : rd[5] );

fmul_s.disasm = {
  sink << "fmul\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fmul_s.execute = {
  cpu.SetVF32(rd, cpu.GetVF32(rn, 0) * cpu.GetVF32(rm, 0));
};

op fmul_d( 0b00011110011[11] : rm[5] : 0b000010[6] : rn[5] : rd[5] );

fmul_d.disasm = {
  sink << "fmul\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fmul_d.execute = {
  cpu.SetVF64(rd, cpu.GetVF64(rn, 0) * cpu.GetVF64(rm, 0));
};

op fmul_vs( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b110111[6] : rn[5] : rd[5] );

fmul_vs.disasm = {
  sink << "fmul\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fmul_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, cpu.GetVF32(rn, idx) * cpu.GetVF32(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op fmul_v2d( 0b01101110011[11] : rm[5] : 0b110111[6] : rn[5] : rd[5] );

fmul_v2d.disasm = {
  sink << "fmul\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fmul_v2d.execute = {
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    cpu.SetVF64(rd, idx, cpu.GetVF64(rn, idx) * cpu.GetVF64(rm, idx));
};

op fmul_si( 0b0101111110[10] : index0[1] : rm[5] : 0b1001[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
fmul_si.var index : {uint8_t} = {index1|index0};

fmul_si.disasm = {
  sink << "fmul\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm,0,2) << DisasmSubscript(index);
};

fmul_si.execute = {
  cpu.SetVF32(rd, cpu.GetVF32(rn, 0) * cpu.GetVF32(rm, index));
};

op fmul_di( 0b01011111110[11] : rm[5] : 0b1001[4] : index[1] : 0b0[1] : rn[5] : rd[5] );

fmul_di.disasm = {
  sink << "fmul\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmTV(rm,0,3) << DisasmSubscript(index);
};

fmul_di.execute = {
  cpu.SetVF64(rd, cpu.GetVF64(rn, 0) * cpu.GetVF64(rm, index));
};

op fmul_vsi( 0b0[1] : q[1] : 0b00111110[8] : index0[1] : rm[5] : 0b1001[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
fmul_vsi.var index : {uint8_t} = {index1|index0};

fmul_vsi.disasm = {
  sink << "fmul\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

fmul_vsi.execute = {
  typename ARCH::F32 element = cpu.GetVF32(rm, index);
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, cpu.GetVF32(rn, idx) * element);
  cpu.ClearHighV(rd, 8<<q);
};

op fmul_v2di( 0b01001111110[11] : rm[5] : 0b1001[4] : index[1] : 0b0[1] : rn[5] : rd[5] );

fmul_v2di.disasm = {
  sink << "fmul\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,0,3) << DisasmSubscript(index);
};

fmul_v2di.execute = {
  typename ARCH::F64 element = cpu.GetVF64(rm, index);
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    cpu.SetVF64(rd, idx, cpu.GetVF64(rn, idx) * element);
};

/*
 * end of FMUL (scalar)
 *******************************************************************/

op fmulx_s( 0b01011110001[11] : rm[5] : 0b110111[6] : rn[5] : rd[5] );

fmulx_s.disasm = {
  sink << "fmulx\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

op fmulx_d( 0b01011110011[11] : rm[5] : 0b110111[6] : rn[5] : rd[5] );

fmulx_d.disasm = {
  sink << "fmulx\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

op fmulx_vs( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b110111[6] : rn[5] : rd[5] );

fmulx_vs.disasm = {
  sink << "fmulx\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op fmulx_v2d( 0b01001110011[11] : rm[5] : 0b110111[6] : rn[5] : rd[5] );

fmulx_v2d.disasm = {
  sink << "fmulx\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

op fmulx_si( 0b0111111110[10] : index0[1] : rm[5] : 0b1001[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
fmulx_si.var index : {uint8_t} = {index1|index0};

fmulx_si.disasm = {
  sink << "fmulx\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm,0,2) << DisasmSubscript(index);
};

op fmulx_di( 0b01111111110[11] : rm[5] : 0b1001[4] : index[1] : 0b0[1] : rn[5] : rd[5] );

fmulx_di.disasm = {
  sink << "fmulx\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmTV(rm,0,3) << DisasmSubscript(index);
};

op fmulx_vsi( 0b0[1] : q[1] : 0b10111110[8] : index0[1] : rm[5] : 0b1001[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
fmulx_vsi.var index : {uint8_t} = {index1|index0};

fmulx_vsi.disasm = {
  sink << "fmulx\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

op fmulx_v2di( 0b01101111110[11] : rm[5] : 0b1001[4] : index[1] : 0b0[1] : rn[5] : rd[5] );

fmulx_v2di.disasm = {
  sink << "fmulx\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,0,3) << DisasmSubscript(index);
};

/*******************************************************************
 * FNEG
 *
 * Floating-point Negate
 */

op fneg_ss( 0b0001111000100001010000[22] : rn[5] : rd[5] );

fneg_ss.disasm = {
  sink << "fneg\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fneg_ss.execute = {
  cpu.SetVF32(rd, -cpu.GetVF32(rn,0));
};

op fneg_dd( 0b0001111001100001010000[22] : rn[5] : rd[5] );

fneg_dd.disasm = {
  sink << "fneg\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fneg_dd.execute = {
  cpu.SetVF64(rd, -cpu.GetVF64(rn,0));
};

op fneg_vss( 0b0[1] : q[1] : 0b10111010100000111110[20] : rn[5] : rd[5] );

fneg_vss.disasm = {
  sink << "fneg\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op fneg_v2d2d( 0b0110111011100000111110[22] : rn[5] : rd[5] );

fneg_v2d2d.disasm = {
  sink << "fneg\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FNEG
 *******************************************************************/

/*******************************************************************
 * FNMADD
 *
 * Floating-point Negated fused Multiply-Add (scalar)
 */

op fnmadd_s( 0b00011111001[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );

fnmadd_s.disasm = {
  sink << "fnmadd\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm) << ", " << DisasmS(ra);
};

fnmadd_s.execute = {
  cpu.SetVF32(rd, FPMulAdd(cpu, -cpu.GetVF32(ra, 0), -cpu.GetVF32(rn, 0), cpu.GetVF32(rm, 0)));
};

op fnmadd_d( 0b00011111011[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );

fnmadd_d.disasm = {
  sink << "fnmadd\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm) << ", " << DisasmD(ra);
};

fnmadd_d.execute = {
  cpu.SetVF64(rd, FPMulAdd(cpu, -cpu.GetVF64(ra, 0), -cpu.GetVF64(rn, 0), cpu.GetVF64(rm, 0)));
};

/*
 * end of FNMADD
 *******************************************************************/

/*******************************************************************
 * FNMSUB
 *
 * Floating-point Negated fused Multiply-Substract (scalar)
 */

op fnmsub_s( 0b00011111001[11] : rm[5] : 0b1[1] : ra[5] : rn[5] : rd[5] );

fnmsub_s.disasm = {
  sink << "fnmsub\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm) << ", " << DisasmS(ra);
};

fnmsub_s.execute = {
  cpu.SetVF32(rd, FPMulSub(cpu, -cpu.GetVF32(ra, 0), -cpu.GetVF32(rn, 0), cpu.GetVF32(rm, 0)));
};

op fnmsub_d( 0b00011111011[11] : rm[5] : 0b1[1] : ra[5] : rn[5] : rd[5] );

fnmsub_d.disasm = {
  sink << "fnmsub\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm) << ", " << DisasmD(ra);
};

fnmsub_d.execute = {
  cpu.SetVF64(rd, FPMulSub(cpu, -cpu.GetVF64(ra, 0), -cpu.GetVF64(rn, 0), cpu.GetVF64(rm, 0)));
};

/*
 * end of FNMSUB
 *******************************************************************/

op fnmul_sss( 0b00011110001[11] : rm[5] : 0b100010[6] : rn[5] : rd[5] );

fnmul_sss.disasm = {
  sink << "fnmul\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

op fnmul_ddd( 0b00011110011[11] : rm[5] : 0b100010[6] : rn[5] : rd[5] );

fnmul_ddd.disasm = {
  sink << "fnmul\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

op frecpe_s( 0b0101111010100001110110[22] : rn[5] : rd[5] );

frecpe_s.disasm = {
  sink << "frecpe\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

op frecpe_d( 0b0101111011100001110110[22] : rn[5] : rd[5] );

frecpe_d.disasm = {
  sink << "frecpe\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

op frecpe_vs( 0b0[1] : q[1] : 0b00111010100001110110[20] : rn[5] : rd[5] );

frecpe_vs.disasm = {
  sink << "frecpe\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op frecpe_v2d( 0b0100111011100001110110[22] : rn[5] : rd[5] );

frecpe_v2d.disasm = {
  sink << "frecpe\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

op frecps_s( 0b01011110001[11] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

frecps_s.disasm = {
  sink << "frecps\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

op frecps_d( 0b01011110011[11] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

frecps_d.disasm = {
  sink << "frecps\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

op frecps_vs( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

frecps_vs.disasm = {
  sink << "frecps\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op frecps_v2d( 0b01001110011[11] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

frecps_v2d.disasm = {
  sink << "frecps\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

op frecpx_dd( 0b0101111011100001111110[22] : rn[5] : rd[5] );

frecpx_dd.disasm = {
  sink << "frecpx\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

op frecpx_ss( 0b0101111010100001111110[22] : rn[5] : rd[5] );

frecpx_ss.disasm = {
  sink << "frecpx\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

/*******************************************************************
 * FRINTA (scalar)
 *
 * Floating-point Round to Integral, to nearest with ties to Away (scalar)
 */

op frinta_s( 0b0001111000100110010000[22] : rn[5] : rd[5] );

frinta_s.disasm = {
  sink << "frinta\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

frinta_s.execute = {
  cpu.SetVF32(rd, round(cpu.GetVF32(rn,0)));
};

op frinta_d( 0b0001111001100110010000[22] : rn[5] : rd[5] );

frinta_d.disasm = {
  sink << "frinta\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

frinta_d.execute = {
  cpu.SetVF64(rd, round(cpu.GetVF64(rn,0)));
};

op frinta_vs( 0b0[1] : q[1] : 0b10111000100001100010[20] : rn[5] : rd[5] );

frinta_vs.disasm = {
  sink << "frinta\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op frinta_v2d( 0b0110111001100001100010[22] : rn[5] : rd[5] );

frinta_v2d.disasm = {
  sink << "frinta\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FRINTA (scalar)
 *******************************************************************/

/*******************************************************************
 * FRINTI (scalar)
 *
 * Floating-point Round to Integral, using current rounding mode (scalar)
 */

op frinti_d( 0b0001111001100111110000[22] : rn[5] : rd[5] );

frinti_d.disasm = {
  sink << "frinti\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

op frinti_s( 0b0001111000100111110000[22] : rn[5] : rd[5] );

frinti_s.disasm = {
  sink << "frinti\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

op frinti_vs( 0b0[1] : q[1] : 0b10111010100001100110[20] : rn[5] : rd[5] );

frinti_vs.disasm = {
  sink << "frinti\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op frinti_v2d( 0b0110111011100001100110[22] : rn[5] : rd[5] );

frinti_v2d.disasm = {
  sink << "frinti\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FRINTI (scalar)
 *******************************************************************/

/*******************************************************************
 * FRINTM (scalar)
 *
 * Floating-point round to integral, toward minus infinity (scalar)
 */

op frintm_s( 0b0001111000100101010000[22] : rn[5] : rd[5] );

frintm_s.disasm = {
  sink << "frintm\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

frintm_s.execute = {
  cpu.SetVF32(rd, floor(cpu.GetVF32(rn,0)));
};

op frintm_d( 0b0001111001100101010000[22] : rn[5] : rd[5] );

frintm_d.disasm = {
  sink << "frintm\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

frintm_d.execute = {
  cpu.SetVF64(rd, floor(cpu.GetVF64(rn,0)));
};

op frintm_vs( 0b0[1] : q[1] : 0b00111000100001100110[20] : rn[5] : rd[5] );

frintm_vs.disasm = {
  sink << "frintm\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op frintm_v2d( 0b0100111001100001100110[22] : rn[5] : rd[5] );

frintm_v2d.disasm = {
  sink << "frintm\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FRINTM (scalar)
 *******************************************************************/

/*******************************************************************
 * FRINTN
 *
 * Floating-point Round to Integral, to nearest with ties to even
 */

op frintn_s( 0b0001111000100100010000[22] : rn[5] : rd[5] );

frintn_s.disasm = {
  sink << "frintn\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

frintn_s.execute = {
  cpu.SetVF32(rd, round(cpu.GetVF32(rn,0)));
};

op frintn_d( 0b0001111001100100010000[22] : rn[5] : rd[5] );

frintn_d.disasm = {
  sink << "frintn\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

frintn_d.execute = {
  cpu.SetVF64(rd, round(cpu.GetVF64(rn,0)));
};

op frintn_vs( 0b0[1] : q[1] : 0b00111000100001100010[20] : rn[5] : rd[5] );

frintn_vs.disasm = {
  sink << "frintn\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op frintn_v2d( 0b0100111001100001100010[22] : rn[5] : rd[5] );

frintn_v2d.disasm = {
  sink << "frintn\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FRINTN
 *******************************************************************/

/*******************************************************************
 * FRINTP
 *
 * Floating-point round to integral, toward plus infinity
 */

op frintp_s( 0b0001111000100100110000[22] : rn[5] : rd[5] );

frintp_s.disasm = {
  sink << "frintp\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

frintp_s.execute = {
  cpu.SetVF32(rd, ceil(cpu.GetVF32(rn,0)));
};

op frintp_d( 0b0001111001100100110000[22] : rn[5] : rd[5] );

frintp_d.disasm = {
  sink << "frintp\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

frintp_d.execute = {
  cpu.SetVF64(rd, ceil(cpu.GetVF64(rn,0)));
};

op frintp_vs( 0b0[1] : q[1] : 0b00111010100001100010[20] : rn[5] : rd[5] );

frintp_vs.disasm = {
  sink << "frintp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op frintp_v2d( 0b0100111011100001100010[22] : rn[5] : rd[5] );

frintp_v2d.disasm = {
  sink << "frintp\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FRINTP (scalar)
 *******************************************************************/

/*******************************************************************
 * FRINTX
 *
 * Floating-point round to Integral exact, using current rounding mode
 */

op frintx_s( 0b0001111000100111010000[22] : rn[5] : rd[5] );

frintx_s.disasm = {
  sink << "frintx\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

op frintx_d( 0b0001111001100111010000[22] : rn[5] : rd[5] );

frintx_d.disasm = {
  sink << "frintx\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

op frintx_vs( 0b0[1] : q[1] : 0b10111000100001100110[20] : rn[5] : rd[5] );

frintx_vs.disasm = {
  sink << "frintx\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op frintx_v2d( 0b0110111001100001100110[22] : rn[5] : rd[5] );

frintx_v2d.disasm = {
  sink << "frintx\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FRINTX
 *******************************************************************/

/*******************************************************************
 * FRINTZ
 *
 * Floating-point Round to Integral, toward Zero
 */

op frintz_s( 0b0001111000100101110000[22] : rn[5] : rd[5] );

frintz_s.disasm = {
  sink << "frintz\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

frintz_s.execute = {
  cpu.SetVF32(rd, trunc(cpu.GetVF32(rn,0)));
};

op frintz_d( 0b0001111001100101110000[22] : rn[5] : rd[5] );

frintz_d.disasm = {
  sink << "frintz\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

frintz_d.execute = {
  cpu.SetVF64(rd, trunc(cpu.GetVF64(rn,0)));
};

op frintz_vs( 0b0[1] : q[1] : 0b00111010100001100110[20] : rn[5] : rd[5] );

frintz_vs.disasm = {
  sink << "frintz\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op frintz_v2d( 0b0100111011100001100110[22] : rn[5] : rd[5] );

frintz_v2d.disasm = {
  sink << "frintz\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

/*
 * end of FRINTZ
 *******************************************************************/

op frsqrte_s( 0b0111111010100001110110[22] : rn[5] : rd[5] );

frsqrte_s.disasm = {
  sink << "frsqrte\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

op frsqrte_d( 0b0111111011100001110110[22] : rn[5] : rd[5] );

frsqrte_d.disasm = {
  sink << "frsqrte\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

op frsqrte_vs( 0b0[1] : q[1] : 0b10111010100001110110[20] : rn[5] : rd[5] );

frsqrte_vs.disasm = {
  sink << "frsqrte\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op frsqrte_v2d( 0b0110111011100001110110[22] : rn[5] : rd[5] );

frsqrte_v2d.disasm = {
  sink << "frsqrte\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

op frsqrts_s( 0b01011110101[11] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

frsqrts_s.disasm = {
  sink << "frsqrts\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

op frsqrts_d( 0b01011110111[11] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

frsqrts_d.disasm = {
  sink << "frsqrts\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

op frsqrts_vs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

frsqrts_vs.disasm = {
  sink << "frsqrts\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

op frsqrts_v2d( 0b01001110111[11] : rm[5] : 0b111111[6] : rn[5] : rd[5] );

frsqrts_v2d.disasm = {
  sink << "frsqrts\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

/*******************************************************************
 * FSQRT
 *
 * Floating-point Square Root
 */

op fsqrt_s( 0b0001111000100001110000[22] : rn[5] : rd[5] );

fsqrt_s.disasm = {
  sink << "fsqrt\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

fsqrt_s.execute = {
  cpu.SetVF32(rd, sqrt(cpu.GetVF32(rn, 0)));
};

op fsqrt_d( 0b0001111001100001110000[22] : rn[5] : rd[5] );

fsqrt_d.disasm = {
  sink << "fsqrt\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

fsqrt_d.execute = {
  cpu.SetVF64(rd, sqrt(cpu.GetVF64(rn, 0)));
};

op fsqrt_vs( 0b0[1] : q[1] : 0b10111010100001111110[20] : rn[5] : rd[5] );

fsqrt_vs.disasm = {
  sink << "fsqrt\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

fsqrt_vs.execute = {
  for (unsigned e=0, end=2<<q; e < end; ++e)
    cpu.SetVF32(rd, e, sqrt(cpu.GetVF32(rn, e)));
  cpu.ClearHighV(rd, 8<<q);
};

op fsqrt_v2d( 0b0110111011100001111110[22] : rn[5] : rd[5] );

fsqrt_v2d.disasm = {
  sink << "fsqrt\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

fsqrt_v2d.execute = {
  for (unsigned e=0, end=2; e < end; ++e)
    cpu.SetVF64(rd, e, sqrt(cpu.GetVF64(rn, e)));
};

/*
 * end of FSQRT
 *******************************************************************/

/*******************************************************************
 * FSUB (scalar)
 *
 * Floating-point subtract (scalar): Vd = Vn - Vm
 */

op fsub_s( 0b00011110001[11] : rm[5] : 0b001110[6] : rn[5] : rd[5] );

fsub_s.disasm = {
  sink << "fsub\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

fsub_s.execute = {
  cpu.SetVF32(rd, cpu.GetVF32(rn,0) - cpu.GetVF32(rm,0));
};

op fsub_d( 0b00011110011[11] : rm[5] : 0b001110[6] : rn[5] : rd[5] );

fsub_d.disasm = {
  sink << "fsub\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

fsub_d.execute = {
  cpu.SetVF64(rd, cpu.GetVF64(rn,0) - cpu.GetVF64(rm,0));
};

op fsub_vs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

fsub_vs.disasm = {
  sink << "fsub\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

fsub_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, cpu.GetVF32(rn, idx) - cpu.GetVF32(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op fsub_v2d( 0b01001110111[11] : rm[5] : 0b110101[6] : rn[5] : rd[5] );

fsub_v2d.disasm = {
  sink << "fsub\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmTV(rm,2,3);
};

fsub_v2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVF64(rd, idx, cpu.GetVF64(rn, idx) - cpu.GetVF64(rm, idx));
};

/*
 * end of FSUB (scalar)
 *******************************************************************/

/*******************************************************************
 * SCVTF (integer)
 *
 * Signed integer convert to floating-point
 */

op scvtf_sw( 0b0001111000100010000000[22] : rn[5] : rd[5] );

scvtf_sw.disasm = {
  sink << "scvtf\t" << DisasmS(rd) << ", " << DisasmGZWR(rn);
};

scvtf_sw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::F32 F32;

  F32 res = F32(S32(cpu.GetGZR(rn)));

  cpu.SetVF32( rd, res );
};

op scvtf_sx( 0b1001111000100010000000[22] : rn[5] : rd[5] );

scvtf_sx.disasm = {
  sink << "scvtf\t" << DisasmS(rd) << ", " << DisasmGZXR(rn);
};

scvtf_sx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::F32 F32;

  F32 res = F32(S64(cpu.GetGZR(rn)));

  cpu.SetVF32( rd, res );
};

op scvtf_dw( 0b0001111001100010000000[22] : rn[5] : rd[5] );

scvtf_dw.disasm = {
  sink << "scvtf\t" << DisasmD(rd) << ", " << DisasmGZWR(rn);
};

scvtf_dw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::F64 F64;

  F64 res = F64(S32(cpu.GetGZR(rn)));

  cpu.SetVF64( rd, res );
};

op scvtf_dx( 0b1001111001100010000000[22] : rn[5] : rd[5] );

scvtf_dx.disasm = {
  sink << "scvtf\t" << DisasmD(rd) << ", " << DisasmGZXR(rn);
};

scvtf_dx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::F64 F64;

  F64 res = F64(S64(cpu.GetGZR(rn)));

  cpu.SetVF64( rd, res );
};

op scvtf_s( 0b0101111000100001110110[22] : rn[5] : rd[5] );

scvtf_s.disasm = {
  sink << "scvtf\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

scvtf_s.execute = {
  cpu.SetVF32( rd, typename ARCH::F32(cpu.GetVS32(rn,0)) );
};

op scvtf_d( 0b0101111001100001110110[22] : rn[5] : rd[5] );

scvtf_d.disasm = {
  sink << "scvtf\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

scvtf_d.execute = {
  cpu.SetVF64( rd, typename ARCH::F64(cpu.GetVS64(rn,0)) );
};

op scvtf_vs( 0b0[1] : q[1] : 0b00111000100001110110[20] : rn[5] : rd[5] );

scvtf_vs.disasm = {
  sink << "scvtf\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

scvtf_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, typename ARCH::F32(cpu.GetVS32(rn, idx)));
  cpu.ClearHighV(rd, 8<<q);
}

op scvtf_v2d( 0b0100111001100001110110[22] : rn[5] : rd[5] );

scvtf_v2d.disasm = {
  sink << "scvtf\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

scvtf_v2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVF64(rd, idx, typename ARCH::F64(cpu.GetVS64(rn, idx)));
};

/*
 * end of SCVTF (vector, integer)
 *******************************************************************/

/*******************************************************************
 * SCVTF (fixed-point)
 *
 * Signed fixed-point Convert to Floating-point 
 */

op scvtf_ssi( 0b01011111001[11] : lro[5] : 0b111001[6] : rn[5] : rd[5] );
scvtf_ssi.var shift : {unsigned} = {32 - lro};

scvtf_ssi.disasm = {
  sink << "scvtf\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

op scvtf_ddi( 0b0101111101[10] : lro[6] : 0b111001[6] : rn[5] : rd[5] );
scvtf_ddi.var shift : {unsigned} = {64 - lro};

scvtf_ddi.disasm = {
  sink << "scvtf\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

op scvtf_swi( 0b00011110000000101[17] : scale[5] : rn[5] : rd[5] );
scvtf_swi.var fbits : {unsigned} = {32-scale};

scvtf_swi.disasm = {
  sink << "scvtf\t" << DisasmS(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(fbits);
};

op scvtf_sxi( 0b1001111000000010[16] : scale[6] : rn[5] : rd[5] );
scvtf_sxi.var fbits : {unsigned} = {64-scale};

scvtf_sxi.disasm = {
  sink << "scvtf\t" << DisasmS(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(fbits);
};

op scvtf_dwi( 0b00011110010000101[17] : scale[5] : rn[5] : rd[5] );
scvtf_dwi.var fbits : {unsigned} = {32-scale};

scvtf_dwi.disasm = {
  sink << "scvtf\t" << DisasmD(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(fbits);
};

op scvtf_dxi( 0b1001111001000010[16] : scale[6] : rn[5] : rd[5] );
scvtf_dxi.var fbits : {unsigned} = {64-scale};

scvtf_dxi.disasm = {
  sink << "scvtf\t" << DisasmD(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(fbits);
};

op scvtf_vssi( 0b0[1] : q[1] : 0b001111001[9] : lro[5] : 0b111001[6] : rn[5] : rd[5] );
scvtf_vssi.var shift : {unsigned} = {32 - lro};

scvtf_vssi.disasm = {
  sink << "scvtf\t" << DisasmTV(rd,2<<q,2) << ", " << DisasmTV(rn,2<<q,2) << ", " << DisasmI(shift);
};

op scvtf_v2d2di( 0b0100111101[10] : lro[6] : 0b111001[6] : rn[5] : rd[5] );
scvtf_v2d2di.var shift : {unsigned} = {64 - lro};

scvtf_v2d2di.disasm = {
  sink << "scvtf\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmI(shift);
};

/*
 * end of SCVTF (fixed-point)
 *******************************************************************/

/*******************************************************************
 * UCVTF (integer)
 *
 * Unsigned integer convert to floating-point: Vd = unsigned_convertFromInt(Rn)
 */

op ucvtf_sw( 0b0001111000100011000000[22] : rn[5] : rd[5] );

ucvtf_sw.disasm = {
  sink << "ucvtf\t" << DisasmS(rd) << ", " << DisasmGZWR(rn);
};

ucvtf_sw.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::F32 F32;

  F32 res = F32(U32(cpu.GetGZR(rn)));

  cpu.SetVF32( rd, res );
};

op ucvtf_sx( 0b1001111000100011000000[22] : rn[5] : rd[5] );

ucvtf_sx.disasm = {
  sink << "ucvtf\t" << DisasmS(rd) << ", " << DisasmGZXR(rn);
};

ucvtf_sx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::F32 F32;

  F32 res = F32(U64(cpu.GetGZR(rn)));

  cpu.SetVF32( rd, res );
};

op ucvtf_dw( 0b0001111001100011000000[22] : rn[5] : rd[5] );

ucvtf_dw.disasm = {
  sink << "ucvtf\t" << DisasmD(rd) << ", " << DisasmGZWR(rn);
};

ucvtf_dw.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::F64 F64;

  F64 res = F64(U32(cpu.GetGZR(rn)));

  cpu.SetVF64( rd, res );
};

op ucvtf_dx( 0b1001111001100011000000[22] : rn[5] : rd[5] );

ucvtf_dx.disasm = {
  sink << "ucvtf\t" << DisasmD(rd) << ", " << DisasmGZXR(rn);
};

ucvtf_dx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::F64 F64;

  F64 res = F64(U64(cpu.GetGZR(rn)));

  cpu.SetVF64( rd, res );
};

op ucvtf_s( 0b0111111000100001110110[22] : rn[5] : rd[5] );

ucvtf_s.disasm = {
  sink << "ucvtf\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

ucvtf_s.execute = {
  cpu.SetVF32( rd, typename ARCH::F32(cpu.GetVU32(rn,0)) );
};

op ucvtf_d( 0b0111111001100001110110[22] : rn[5] : rd[5] );

ucvtf_d.disasm = {
  sink << "ucvtf\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

ucvtf_d.execute = {
  cpu.SetVF64( rd, typename ARCH::F64(cpu.GetVU64(rn,0)) );
};

op ucvtf_vs( 0b0[1] : q[1] : 0b10111000100001110110[20] : rn[5] : rd[5] );

ucvtf_vs.disasm = {
  sink << "ucvtf\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

ucvtf_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVF32(rd, idx, typename ARCH::F32(cpu.GetVU32(rn, idx)));
  cpu.ClearHighV(rd, 8<<q);
}

op ucvtf_v2d( 0b0110111001100001110110[22] : rn[5] : rd[5] );

ucvtf_v2d.disasm = {
  sink << "ucvtf\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3);
};

ucvtf_v2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVF64(rd, idx, typename ARCH::F64(cpu.GetVU64(rn, idx)));
};

/*
 * end of UCVTF
 *******************************************************************/

/*******************************************************************
 * UCVTF (fixed-point)
 *
 * Unsigned fixed-point Convert to Floating-point 
 */

op ucvtf_ssi( 0b01111111001[11] : lro[5] : 0b111001[6] : rn[5] : rd[5] );
ucvtf_ssi.var shift : {unsigned} = {32 - lro};

ucvtf_ssi.disasm = {
  sink << "ucvtf\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

op ucvtf_ddi( 0b0111111101[10] : lro[6] : 0b111001[6] : rn[5] : rd[5] );
ucvtf_ddi.var shift : {unsigned} = {64 - lro};

ucvtf_ddi.disasm = {
  sink << "ucvtf\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

op ucvtf_swi( 0b00011110000000111[17] : scale[5] : rn[5] : rd[5] );
ucvtf_swi.var fbits : {unsigned} = {32-scale};

ucvtf_swi.disasm = {
  sink << "ucvtf\t" << DisasmS(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(fbits);
};

op ucvtf_sxi( 0b1001111000000011[16] : scale[6] : rn[5] : rd[5] );
ucvtf_sxi.var fbits : {unsigned} = {64-scale};

ucvtf_sxi.disasm = {
  sink << "ucvtf\t" << DisasmS(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(fbits);
};

op ucvtf_dwi( 0b00011110010000111[17] : scale[5] : rn[5] : rd[5] );
ucvtf_dwi.var fbits : {unsigned} = {32-scale};

ucvtf_dwi.disasm = {
  sink << "ucvtf\t" << DisasmD(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(fbits);
};

op ucvtf_dxi( 0b1001111001000011[16] : scale[6] : rn[5] : rd[5] );
ucvtf_dxi.var fbits : {unsigned} = {64-scale};

ucvtf_dxi.disasm = {
  sink << "ucvtf\t" << DisasmD(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(fbits);
};

op ucvtf_vssi( 0b0[1] : q[1] : 0b101111001[9] : lro[5] : 0b111001[6] : rn[5] : rd[5] );
ucvtf_vssi.var shift : {unsigned} = {32 - lro};

ucvtf_vssi.disasm = {
  sink << "ucvtf\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmI(shift);
};

op ucvtf_v2d2di( 0b0110111101[10] : lro[6] : 0b111001[6] : rn[5] : rd[5] );
ucvtf_v2d2di.var shift : {unsigned} = {64 - lro};

ucvtf_v2d2di.disasm = {
  sink << "ucvtf\t" << DisasmTV(rd,2,3) << ", " << DisasmTV(rn,2,3) << ", " << DisasmI(shift);
};

/*
 * end of UCVTF (fixed-point)
 *******************************************************************/

