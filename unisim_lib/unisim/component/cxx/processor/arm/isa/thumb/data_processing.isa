/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 */
 
/**********************************************

      THUMB DATA PROCESSING INSTRUCTIONS

**********************************************/


/*******************************************************************
 * adc (add with carry) instruction
 */

op adc(0b010000[6]:0b0101[4]:rm[3]:rd[3])

adc.disasm = {
	buffer << "adc r" << rd << ", r" << rm;
}

adc.execute = {
	uint32_t res;
	uint32_t s1, s2;
	uint8_t carry_in, carry_out, overflow_out, sign;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	carry_in = (cpu.GetCPSR_C() ? 1 : 0);
	s1 = cpu.GetGPR(rd);
	s2 = cpu.GetGPR(rm);
	Add32(res, carry_out, overflow_out, sign,
			s1, s2, carry_in);
	cpu.SetGPR(rd, res);

	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(carry_out); // to check
	cpu.SetCPSR_V(overflow_out); // to check
}

/*
 * end of adc (add with carry) instruction
 *******************************************************************/

/*******************************************************************
 * add(1) (add immediate) instruction
 * NOTE: mov(2) is equivalent to add(1)
 */

op add_1(0b0001110[7]:imm[3]:rn[3]:rd[3])

add_1.disasm = {
		buffer << "add r" << rd << ", r" << rn << ", #" << dec << imm;
}

add_1.execute = {
		uint32_t res;
		uint32_t s1;
		uint8_t carry_in, carry_out, overflow_out, sign;
		
		cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
		
		s1 = cpu.GetGPR(rn);
		carry_in = 0;
		Add32(res, carry_out, overflow_out, sign,
				s1, imm, carry_in);
		cpu.SetGPR(rd, res);

		cpu.SetCPSR_N(res & (uint32_t)0x80000000);
		cpu.SetCPSR_Z(res == 0);
		cpu.SetCPSR_C(carry_out); // to check
		cpu.SetCPSR_V(overflow_out); // to check
}

/*
 * end of add(1) (add immediate) instruction
 *******************************************************************/

/*******************************************************************
 * add (add large immediate) instruction
 */

op add_2(0b00110[5]:rd[3]:imm[8])

add_2.disasm = {
	buffer << "add r" << rd << ", #" << dec << imm;
}

add_2.execute = {
	uint32_t res;
	uint32_t s1;
	uint8_t carry_in, carry_out, overflow_out, sign;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rd);
	carry_in = 0;
	Add32(res, carry_out, overflow_out, sign,
			s1, imm, carry_in);

	cpu.SetGPR(rd, res);
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(carry_out); // to check
	cpu.SetCPSR_V(overflow_out); // to check
}

/*
 * end of add (add large immediate) instruction
 *******************************************************************/

/*******************************************************************
 * add (add register) instruction
 */

op add_3(0b0001100[7]:rm[3]:rn[3]:rd[3])

add_3.disasm = {
	buffer << "add r" << rd << ", r" << rn << ", r" << rm;
}

add_3.execute = {
	uint32_t res;
	uint32_t s1, s2;
	uint8_t carry_in, carry_out, overflow_out, sign;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rm);
	s2 = cpu.GetGPR(rn);
	
	carry_in = 0;
	Add32(res, carry_out, overflow_out, sign,
			s1, s2, carry_in);

	cpu.SetGPR(rd, res);
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(carry_out); // to check
	cpu.SetCPSR_V(overflow_out); // to check
}

/*
 * end of add (add register) instruction
 *******************************************************************/

/*******************************************************************
 * add (add high registers) instruction
 */

op add_4(0b01000100[8]:h1[1]:h2[1]:rm[3]:rd[3])

add_4.initialize_rm_index = {
	typedef Operation<STATE> inherited;

	inherited::rm_index = (h2 << 3) + rm;
}

add_4.initialize_rd_index = {
	typedef Operation<STATE> inherited;

	inherited::rd_index = (h1 << 3) + rd;
}

add_4.initialize_rm_init = {
	typedef Operation<STATE> inherited;

	if((h2 << 3) + rm == STATE::PC_reg)
		inherited::rm_init = 4;
}

add_4.initialize_rd_init = {
	typedef Operation<STATE> inherited;

	if((h1 << 3) + rd == STATE::PC_reg)
		inherited::rd_init = 4;
}

add_4.disasm = {
	typedef Operation<STATE> inherited;
	
	buffer << "add r" << inherited::rd_index << ", r" << inherited::rm_index;
}

add_4.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2, res;
	s1 = cpu.GetGPR(inherited::rd_index) + inherited::rd_init;
	s2 = cpu.GetGPR(inherited::rm_index) + inherited::rm_init;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);

	res = s1 + s2;
	cpu.SetGPR(inherited::rd_index, res);
}

/*
 * end of add (add high registers) instruction
 *******************************************************************/

/*******************************************************************
 * add (add immediate to program counter) instruction
 */

op add_5(0b10100[5]:rd[3]:imm[8])

add_5.disasm = {
	buffer << "add r" << rd << ", PC, #" << dec << ((unsigned int)imm * 4);
}

add_5.execute = {
	uint32_t s1, s2, res;
	uint32_t pc;
	
	pc = cpu.GetGPR(cpu.PC_reg);
	cpu.SetGPR(cpu.PC_reg, pc + 2);
	
	s1 = pc & (uint32_t)0xfffffffc;
	s2 = ((uint32_t)imm) << 2;
	res = s1 + s2;
	
	cpu.SetGPR(rd, res);
}

/*
 * end of add (add immediate to program counter) instruction
 *******************************************************************/

/*******************************************************************
 * add (add immediate to stack pointer) instruction
 */

op add_6(0b10101[5]:rd[3]:imm[8])

add_6.disasm = {
	buffer << "add r" << rd << ", SP, #" << dec << ((unsigned int)imm * 4);
}

add_6.execute = {
	uint32_t s1, s2, res;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(cpu.SP_reg) & (uint32_t)0xfffffffc;
	s2 = ((uint32_t)imm) << 2;
	res = s1 + s2;
	
	cpu.SetGPR(rd, res);
}

/*
 * end of add (add immediate to stack pointer) instruction
 *******************************************************************/

/*******************************************************************
 * add (increment stack pointer) instruction
 */

op add_7(0b101100000[9]:imm[7])

add_7.disasm = {
	buffer << "add SP, #" << (unsigned int)imm * 4;
}

add_7.execute = {
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	cpu.SetGPR(cpu.SP_reg, cpu.GetGPR(cpu.SP_reg) + ((uint32_t)imm * 4));
}

/*
 * end of add (increment stack pointer) instruction
 *******************************************************************/

/*******************************************************************
 * and (logical and) instruction
 */

op and(0b010000[6]:0b0000[4]:rm[3]:rd[3])

and.disasm = {
	buffer << "and r" << rd << ", r" << rm;
}

and.execute = {
	uint32_t res;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);

	res = cpu.GetGPR(rd) & cpu.GetGPR(rm);
	cpu.SetGPR(rd,res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of and (logical and) instruction
 *******************************************************************/

/*******************************************************************
 * asr(1) (arithmetic shift right immediate) instruction
 */

op asr_1(0b00010[5]:imm[5]:rm[3]:rd[3])

asr_1.disasm = {
	buffer << "asr r" << rd << ", r" << rm << ", #" << dec << imm;
}

asr_1.execute = {
	uint32_t res, s1;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);

	s1 = cpu.GetGPR(rm);
	if(imm == 0) {
		if(s1 & (uint32_t)0x80000000) {
			cpu.SetCPSR_C(true);
			res = (uint32_t)0xffffffff;
		} else {
			cpu.SetCPSR_C(false);
			res = 0;
		}
	} else {
		cpu.SetCPSR_C((s1 >> (imm - 1)) & (uint32_t)0x01);
		res = ((int32_t)s1) >> imm;
	}
	
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of asr(1) (arithmetic shift right immediate) instruction
 *******************************************************************/

/*******************************************************************
 * asr(2) (arithmetic shift right register) instruction
 */

op asr_2(0b010000[6]:0b0100[4]:rs[3]:rd[3])

asr_2.disasm = {
	buffer << "asr r" << rd << ", r" << rs;
}

asr_2.execute = {
	uint32_t res, s1;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rs) & (uint32_t)0x0ff;
	
	res = cpu.GetGPR(rd);
	if(s1 == 0) {
	} else if(s1 < 32) {
		cpu.SetCPSR_C((res >> (s1 - 1)) & (uint32_t)0x01);
		res = ((int32_t)res) >> s1;
		cpu.SetGPR(rd,res);
	} else {
		bool res31;
		
		res31 = (res & (uint32_t)0x80000000) != 0;
		cpu.SetCPSR_C(res31);
		if(res31)
			res = (uint32_t)0xffffffff;
		else
			res = 0;
		cpu.SetGPR(rd,res);
	}
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of asr(2) (arithmetic shift right register) instruction
 *******************************************************************/

/*******************************************************************
 * bic (bit clear) instruction
 */

op bic(0b010000[6]:0b1110[4]:rm[3]:rd[3])

bic.disasm = {
	buffer << "bic r" << rd << ", r" << rm;
}

bic.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rd);
	s2 = cpu.GetGPR(rm);
	
	res = s1 & ~s2;
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of bic (bit clear) instruction
 *******************************************************************/

/*******************************************************************
 * cmn (compare negative) instruction
 */

op cmn(0b010000[6]:0b1011[4]:rm[3]:rn[3])

cmn.disasm = {
	buffer << "cmn r" << rn << ", r" << rm;
}

cmn.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	uint8_t carry_in, carry_out, overflow_out, sign;
	
	s1 = cpu.GetGPR(rn);
	s2 = cpu.GetGPR(rm);
	
	carry_in = 0;
	Add32(res, carry_out, overflow_out, sign,
			s1, s2, carry_in);

	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(carry_out); // to check
	cpu.SetCPSR_V(overflow_out); // to check
}
/*
 * end of cmn (compare negative) instruction
 *******************************************************************/

/*******************************************************************
 * cmp(1) (compare immediate) instruction
 */

op cmp_1(0b00101[5]:rn[3]:imm[8])

cmp_1.disasm = {
	buffer << "cmp r" << rn << ", #" << dec << imm;
}

cmp_1.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rn);
	s2 = imm;
	
	res = s1 - s2;

	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2));
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2));
}
/*
 * end of cmp(1) (compare immediate) instruction
 *******************************************************************/

/*******************************************************************
 * cmp(2) (compare register) instruction
 */

op cmp_2(0b010000[6]:0b1010[4]:rm[3]:rn[3])

cmp_2.disasm = {
	buffer << "cmp r" << rn << ", r" << rm;
}

cmp_2.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rn);
	s2 = cpu.GetGPR(rm);
	
	res = s1 - s2;

	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2));
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2));
}

/*
 * end of cmp(2) (compare register) instruction
 *******************************************************************/

/*******************************************************************
 * cmp(3) (compare high registers) instruction
 */

op cmp_3(0b01000101[8]:h1[1]:h2[1]:rm[3]:rn[3])

cmp_3.initialize_rm_index = {
	typedef Operation<STATE> inherited;

	inherited::rm_index = (h2 << 3) + rm;
}

cmp_3.initialize_rn_index = {
	typedef Operation<STATE> inherited;

	inherited::rn_index = (h1 << 3) + rn;
}

cmp_3.initialize_rm_init = {
	typedef Operation<STATE> inherited;

	if((h2 << 3) + rm == STATE::PC_reg)
		inherited::rm_init = 4;
	else
		inherited::rm_init = 0;
}

cmp_3.initialize_rn_init = {
	typedef Operation<STATE> inherited;

	if((h1 << 3) + rn == STATE::PC_reg)
		inherited::rn_init = 4;
	else
		inherited::rn_init = 0;
}

cmp_3.disasm = {
	typedef Operation<STATE> inherited;

	buffer << "cmp r" << inherited::rn_index << ", r" << inherited::rm_index;
}

cmp_3.execute = {
	typedef Operation<STATE> inherited;
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(inherited::rn_index) + inherited::rn_init;
	s2 = cpu.GetGPR(inherited::rm_index) + inherited::rm_init;
	
	res = s1 - s2;

	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2));
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2));
}

/*
 * end of cmp(3) (compare high registers) instruction
 *******************************************************************/

/*******************************************************************
 * eor (exclusive or) instruction
 */

op eor(0b010000[6]:0b0001[4]:rm[3]:rd[3])

eor.disasm = {
	buffer << "eor r" << rd << ", r" << rm;
}

eor.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rd);
	s2 = cpu.GetGPR(rm);
	
	res = s1 ^ s2;

	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}
/*
 * end of eor (exclusive or) instruction
 *******************************************************************/

/*******************************************************************
 * lsl(1) (logical shift left immediate) instruction
 */

op lsl_1(0b00000[5]:imm[5]:rm[3]:rd[3])

lsl_1.disasm = {
	buffer << "lsl r" << rd << ", r" << rm << ", #" << dec << imm;
}

lsl_1.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rm);
	s2 = imm;
	
	if(imm == 0) {
		res = s1;
	} else {
		cpu.SetCPSR_C((s1 >> (32 - imm)) & (uint32_t)0x01);
		res = s1 << imm;
	}
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of lsl(1) (logical shift left immediate) instruction
 *******************************************************************/

/*******************************************************************
 * lsl(2) (logical shift left register) instruction
 */

op lsl_2(0b010000[6]:0b0010[4]:rs[3]:rd[3])

lsl_2.disasm = {
	buffer << "lsl r" << rd << ", r" << rs;
}

lsl_2.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rd);
	s2 = cpu.GetGPR(rs) & (uint32_t)0x0ff;
	
	if(rs == 0) {
		res = s1;
	} else if(rs < 32) {
		cpu.SetCPSR_C((s1 >> (32 - rs)) & 0x01);
		res = s1 << s2;
	} else if(rs == 32) {
		cpu.SetCPSR_C(s1 & 0x01);
		res = 0;
	} else {
		cpu.SetCPSR_C(false);
		res = 0;
	}
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of lsl(2) (logical shift left register) instruction
 *******************************************************************/

/*******************************************************************
 * lsr(1) (logical shift right immediate) instruction
 */

op lsr_1(0b00001[5]:imm[5]:rm[3]:rd[3])

lsr_1.disasm = {
	buffer << "lsr r" << rd << ", r" << rm << ", #" << dec << imm;
}

lsr_1.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rm);
	s2 = imm;
	
	if(s2 == 0) {
		cpu.SetCPSR_C(s1 & (uint32_t)0x80000000);
		res = 0;
	} else {
		cpu.SetCPSR_C((s1 >> (imm - 1)) & 0x01);
		res = s1 >> imm;
	}
	cpu.SetCPSR_N(false);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of lsr(1) (logical shift right immediate) instruction
 *******************************************************************/

/*******************************************************************
 * lsr(2) (logical shift right register) instruction
 */

op lsr_2(0b010000[6]:0b0011[4]:rs[3]:rd[3])

lsr_2.disasm = {
	buffer << "lsr r" << rd << ", r" << rs;
}

lsr_2.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rd);
	s2 = cpu.GetGPR(rs) & 0x0ff;
	
	if(s2 == 0) {
		res = s1;
	} else if(s2 < 32) {
		cpu.SetCPSR_C((s1 >> (s2 - 1)) & 0x01);
		res = s1 >> s2;
	} else if(s2 == 32) {
		cpu.SetCPSR_C((s1 >> 31) & 0x01);
		res = 0;
	} else {
		cpu.SetCPSR_C(false);
		res = 0;
	}
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of lsr(2) (logical shift right register) instruction
 *******************************************************************/

/*******************************************************************
 * mov(1) (move immediate) instruction
 */

op mov_1(0b00100[5]:rd[3]:imm[8])

mov_1.disasm = {
	buffer << "mov r" << rd << ", #" << dec << imm;
}

mov_1.execute = {
	uint32_t res;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	res = imm;
	
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(false);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of mov(1) (move immediate) instruction
 *******************************************************************/

///*******************************************************************
//op mov_2(0b0001110[7]:0b000[3]:rn[3]:rd[3])
// * mov(2) (move a low register to another low register) instruction
// */
//
//
///*
// * end of mov(2) (move register a low register to another low register) instruction
// *******************************************************************/

/*******************************************************************
 * mov(3) (move high registers) instruction
 */

op mov_3(0b01000110[8]:h1[1]:h2[1]:rm[3]:rd[3])

mov_3.initialize_rm_index = {
	typedef Operation<STATE> inherited;

	inherited::rm_index = (h2 << 3) + rm;
}

mov_3.initialize_rd_index = {
	typedef Operation<STATE> inherited;
	
	inherited::rd_index = (h1 << 3) + rd;
}

mov_3.initialize_rm_init = {
	typedef Operation<STATE> inherited;
	
	if((h2 << 3) + rm == STATE::PC_reg)
		inherited::rm_init = 4;
	else
		inherited::rm_init = 0;
}

mov_3.disasm = {
	typedef Operation<STATE> inherited;

	buffer << "mov r" << inherited::rd_index << ", r" << inherited::rm_index;
}

mov_3.execute = {
	typedef Operation<STATE> inherited;
	uint32_t res;
	
	res = inherited::rm_init + cpu.GetGPR(inherited::rm_index);
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	cpu.SetGPR(inherited::rd_index, res);
}
/*
 * end of mov(3) (move high registers) instruction
 *******************************************************************/

/*******************************************************************
 * mul (multiply) instruction
 */

op mul(0b010000[6]:0b1101[4]:rm[3]:rd[3])

mul.disasm = {
	buffer << "mul r" << rd << ", r" << rm;
}

mul.execute = {
	uint32_t res;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	res = cpu.GetGPR(rd) * cpu.GetGPR(rm);
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of mul (multiply) instruction
 *******************************************************************/

/*******************************************************************
 * mvn (move not register) instruction
 */

op mvn(0b010000[6]:0b1111[4]:rm[3]:rd[3])

mvn.disasm = {
	buffer << "mvn r" << rd << ", r" << rm;
}

mvn.execute = {
	uint32_t res;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	res = ~(cpu.GetGPR(rm));
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of mvn (move not register) instruction
 *******************************************************************/

/*******************************************************************
 * neg (negate register) instruction
 */

op neg(0b010000[6]:0b1001[4]:rm[3]:rd[3])

neg.disasm = {
	buffer << "neg r" << rd << ", r" << rm;
}

neg.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = 0;
	s2 = cpu.GetGPR(rm);
	res = s1 - s2;
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2));
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2));
}

/*
 * end of neg (negate register) instruction
 *******************************************************************/

/*******************************************************************
 * orr (logical or) instruction
 */

op orr(0b010000[6]:0b1100[4]:rm[3]:rd[3])

orr.disasm = {
	buffer << "orr r" << rd << ", r" << rm;
}

orr.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rd);
	s2 = cpu.GetGPR(rm);
	res = s1 | s2;
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of orr (logical or) instruction
 *******************************************************************/

/*******************************************************************
 * ror (rotate right register) instruction
 */

op ror(0b010000[6]:0b0111[4]:rs[3]:rd[3])

ror.disasm = {
	buffer << "ror r" << rd << ", r" << rs;
}

ror.execute = {
	uint32_t res, s1, s2;
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rd);
	s2 = cpu.GetGPR(rs) & 0x0ff;
	
	if(s2 == 0) {
		res = s1;
	} else if((s2 & 0x01f) == 0) {
		cpu.SetCPSR_C(s1 & (uint32_t)0x80000000);
		res = s1;
	} else {
		cpu.SetCPSR_C((s1 >> ((s2 & 0x01f) - 1)) & 0x01);
		res = RotateRight(s1, s2);
	}
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}

/*
 * end of ror (rotate right register) instruction
 *******************************************************************/

/*******************************************************************
 * sbc (subtract with carry register) instruction
 */

op sbc(0b010000[6]:0b0110[4]:rm[3]:rd[3])

sbc.disasm = {
	buffer << "sbc r" << rd << ", r" << rm;
}

sbc.execute = {
	uint32_t s1, s2;
	uint32_t res;
	uint32_t in_neg_carry;
	  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);

	s1 = cpu.GetGPR(rd);
	s2 = cpu.GetGPR(rm);
	in_neg_carry = (cpu.GetCPSR_C() ? 0 : 1);
	res = s1 - s2 - in_neg_carry;
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2, in_neg_carry));
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2, in_neg_carry));
}

/*
 * end of sbc (subtract with carry register) instruction
 *******************************************************************/

/*******************************************************************
 * sub(1) (subtract immediate) instruction
 */

op sub_1(0b0001111[7]:imm[3]:rn[3]:rd[3])

sub_1.disasm = {
	buffer << "sub r" << rd << ", r" << rn << ", #" << dec << imm;
}

sub_1.execute = {
	uint32_t s1, s2;
	uint32_t res;
	  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);

	s1 = cpu.GetGPR(rn);
	s2 = imm;
	res = s1 - s2;
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2));
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2));
}

/*
 * end of sub(1) (subtract immediate) instruction
 *******************************************************************/

/*******************************************************************
 * sub(2) (subtract large immediate) instruction
 */

op sub_2(0b00111[5]:rd[3]:imm[8])

sub_2.disasm = {
	buffer << "sub r" << rd << ", #" << dec << imm;
}

sub_2.execute = {
	typedef Operation<STATE> inherited;

	uint32_t s1, s2;
	uint32_t res;
	  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);

	s1 = cpu.GetGPR(rd);
	s2 = imm;
	res = s1 - s2;
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2));
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2));
}

/*
 * end of sub(2) (subtract large immediate) instruction
 *******************************************************************/

/*******************************************************************
 * sub(3) (subtract register) instruction
 */

op sub_3(0b0001101[7]:rm[3]:rn[3]:rd[3])

sub_3.disasm = {
	buffer << "sub r" << rd << ", r" << rn << ", r" << rm;
}

sub_3.execute = {
	uint32_t s1, s2;
	uint32_t res;
	  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);

	s1 = cpu.GetGPR(rn);
	s2 = cpu.GetGPR(rm);
	res = s1 - s2;
	cpu.SetGPR(rd, res);
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
	cpu.SetCPSR_C(!BorrowFrom(res, s1, s2));
	cpu.SetCPSR_V(SubtractionOverflowFrom(res, s1, s2));
}

/*
 * end of sub(3) (subtract register) instruction
 *******************************************************************/

/*******************************************************************
 * sub(4) (decrement stack pointer) instruction
 */

op sub_4(0b101100001[9]:imm[7])

sub_4.disasm = {
	buffer << "sub sp, #" << (imm * 4);
}

sub_4.execute = {
	uint32_t s1, s2;
	uint32_t res;
	  
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);

	s1 = cpu.GetGPR(cpu.SP_reg);
	s2 = imm * 4;
	res = s1 - s2;
	cpu.SetGPR(cpu.SP_reg, res);
}

/*
 * end of sub(4) (decrement stack pointer) instruction
 *******************************************************************/

/*******************************************************************
 * tst (test register) instruction
 */

op tst(0b010000[6]:0b1000[4]:rm[3]:rn[3])

tst.disasm = {
	buffer << "tst r" << rn << ", r" << rm;
}

tst.execute = {
	uint32_t res, s1, s2;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	s1 = cpu.GetGPR(rn);
	s2 = cpu.GetGPR(rm);
	res = s1 & s2;
	
	cpu.SetCPSR_N(res & (uint32_t)0x80000000);
	cpu.SetCPSR_Z(res == 0);
}
/*
 * end of tst (test register) instruction
 *******************************************************************/

