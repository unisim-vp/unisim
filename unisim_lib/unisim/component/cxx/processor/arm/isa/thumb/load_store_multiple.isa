/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 */
 
/**********************************************

    THUMB LOAD STORE MULTIPLE INSTRUCTIONS

**********************************************/

/*******************************************************************
 * ldmia (load multiple) instruction
 */

op ldmia(0b11001[5]:rn[3]:<32> reg_list[8])

ldmia.disasm = {
	unsigned int mask = 1;
	bool prev = false;
	
	buffer << "ldmia r" << rn << ", {";
	for(unsigned int i = 0; i < 8; i++) {
		if((reg_list & mask) == mask) {
			if(prev) buffer << ", ";
			else prev = true;
			buffer << "r" << i;
		}
		mask = mask << 1;
	}
	buffer << "}";
}

ldmia.execute = {
	typename CONFIG::reg_t rn_value, rn_new_val, value;
	typename CONFIG::address_t start_address, end_address;
	typename CONFIG::address_t cur_address;
	uint32_t num_regs;
	unsigned int mask = 1;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	rn_value = cpu.GetGPR(rn);
	
	num_regs = cpu.LSMia(rn_value, reg_list,
						&start_address, &end_address,
						&rn_new_val);

	cpu.SetGPR(rn, rn_new_val);

	cur_address = start_address;
	for(unsigned int i = 0; i < 8; i++) {
		if((reg_list & mask) == mask) {
			if(!cpu.Read32(cur_address & ~(0x3), value)) { // address must be aligned 
				cerr << "ERROR(load_store_multiple.isa::ldmia): "
					<< "Couldn't read data" << endl;
				exit(-1);
			}
			cpu.SetGPR(i, value);
			cur_address += 4;
		}
		mask = mask << 1;
	}
}

/*
 * end of ldmia (load multiple) instruction
 *******************************************************************/

/*******************************************************************
* pop (pop multiple) instruction
 */

op pop(0b1011110[7]:r[1]:<32> reg_list[8])

pop.disasm = {
	unsigned int mask = 1;
	bool prev = false;
	
	buffer << "pop {";
	for(unsigned int i = 0; i < 8; i++) {
		if((reg_list & mask) == mask) {
			if(prev) buffer << ", ";
			else prev = true;
			buffer << "r" << i;
		}
		mask = mask << 1;
	}
	buffer << "}";
}

pop.execute = {
	typename CONFIG::reg_t sp_value, sp_new_val, value;
	typename CONFIG::address_t start_address, end_address;
	typename CONFIG::address_t cur_address;
	uint32_t num_regs;
	unsigned int mask = 1;
	
	if(r == 0)
		cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	sp_value = cpu.GetGPR(cpu.SP_reg);
	
	num_regs = cpu.LSMia(sp_value, reg_list,
						&start_address, &end_address,
						&sp_new_val);

	cur_address = start_address;
	for(unsigned int i = 0; i < 8; i++) {
		if((reg_list & mask) == mask) {
			if(!cpu.Read32(cur_address & ~(0x3), value)) { // address must be aligned 
				cerr << "ERROR(load_store_multiple.isa::pop): "
					<< "Couldn't read data" << endl;
				exit(-1);
			}
			cpu.SetGPR(i, value);
			cur_address += 4;
		}
		mask = mask << 1;
	}
	
	if(r) {
		if(!cpu.Read32(cur_address & ~(0x3), value)) { // address must be aligned 
			cerr << "ERROR(load_store_multiple.isa::pop): "
				<< "Couldn't read data" << endl;
			exit(-1);
		}
		if(CONFIG::ARCHITECTURE == ARMV5T ||
			CONFIG::ARCHITECTURE == ARMV5TXM ||
			CONFIG::ARCHITECTURE == ARMV5TE ||
			CONFIG::ARCHITECTURE == ARMV5TEXP) {
			cpu.SetCPSR_T((value & 0x01) != 0);
		}
		cur_address += 4;
	}

	cpu.SetGPR(cpu.SP_reg, cur_address);
}

/*
 * end of pop (pop multiple) instruction
 *******************************************************************/

/*******************************************************************
 * push (push multiple) instruction
 */

op push(0b1011010[7]:r[1]:reg_list[8])

push.disasm = {
	unsigned int mask = 1;
	bool prev = false;
		
	buffer << "push {";
	for(unsigned int i = 0; i < 8; i++) {
		if((reg_list & mask) == mask) {
			if(prev) buffer << ", ";
			else prev = true;
			buffer << "r" << i;
		}
		mask = mask << 1;
	}
	if(r) {
		if(prev) buffer << ", lr";
		else buffer << "lr";
	}
	buffer << "}";
}

push.execute = {
	typename CONFIG::reg_t sp_value, sp_new_val, value;
	typename CONFIG::address_t start_address, end_address;
	typename CONFIG::address_t cur_address;
	uint32_t num_regs;
	unsigned int mask = 1;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	sp_value = cpu.GetGPR(cpu.SP_reg);

	num_regs = cpu.LSMdb(sp_value, reg_list,
			&start_address, &end_address,
			&sp_new_val);
	if(r)
		start_address -= 4;

	cur_address = start_address;
	for(unsigned int i = 0; i < 8; i++) {
		if((reg_list & mask) == mask) {
			value = cpu.GetGPR(i);
			if(!cpu.Write32(cur_address & ~(0x3), value)) { // address must be aligned 
				cerr << "ERROR(load_store_multiple.isa::push): "
					<< "Couldn't write data" << endl;
				exit(-1);
			}
			cur_address += 4;
		}
		mask = mask << 1;
	}
	
	if(r) {
		value = cpu.GetGPR(cpu.LR_reg);
		if(!cpu.Write32(cur_address & ~(0x3), value)) { // address must be aligned 
			cerr << "ERROR(load_store_multiple.isa::push): "
				<< "Couldn't write data" << endl;
			exit(-1);
		}
		cur_address += 4;
	}

	cpu.SetGPR(cpu.SP_reg, start_address);
}

/*
 * end of push (push multiple) instruction
 *******************************************************************/

/*******************************************************************
 * stmia (store multiple) instruction
 */

op stmia(0b11000[5]:rn[3]:reg_list[8])

stmia.disasm = {
	unsigned int mask = 1;
	bool prev = false;
			
	buffer << "stmia r" << rn << "!, {";
	for(unsigned int i = 0; i < 8; i++) {
		if((reg_list & mask) == mask) {
			if(prev) buffer << ", ";
			else prev = true;
			buffer << "r" << i;
		}
		mask = mask << 1;
	}
	buffer << "}";
}

stmia.execute = {
	typename CONFIG::reg_t rn_value, rn_new_val, value;
	typename CONFIG::address_t start_address, end_address;
	typename CONFIG::address_t cur_address;
	uint32_t num_regs;
	unsigned int mask = 1;
	
	cpu.SetGPR(cpu.PC_reg, cpu.GetGPR(cpu.PC_reg) + 2);
	
	rn_value = cpu.GetGPR(rn);

	num_regs = cpu.LSMia(rn_value, reg_list,
			&start_address, &end_address,
			&rn_new_val);

	cur_address = start_address;
	for(unsigned int i = 0; i < 8; i++) {
		if((reg_list & mask) == mask) {
			value = cpu.GetGPR(i);
			if(!cpu.Write32(cur_address & ~(0x3), value)) { // address must be aligned 
				cerr << "ERROR(load_store_multiple.isa::push): "
					<< "Couldn't write data" << endl;
				exit(-1);
			}
			cur_address += 4;
		}
		mask = mask << 1;
	}
		
	cpu.SetGPR(rn, end_address + 4);
}

/*
 * end of stmia (store multiple) instruction
 *******************************************************************/

