/*
 *  Copyright (c) 2007-2014,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

        THUMB2 MULTIPLY INSTRUCTIONS

**********************************************/

/* MUL, MLA, MLS instructions */

op mul_w( 0b111110110000[12]: rm[4]:> <: 0b1111[4]: rd[4]: 0b0000[4]: rs[4] );

mul_w.disasm = { buffer << "mul.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs); };

mul_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, cpu.GetGPR_npc( rm ) * cpu.GetGPR_npc( rs ) );
};

op mla( 0b111110110000[12]: rm[4]:> <: rn[4]: rd[4]: 0b0000[4]: rs[4] );

mla.disasm = {
  buffer << "mla\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs) << ", " << DisasmRegister(rn);
};

mla.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, cpu.GetGPR_npc( rn ) + (cpu.GetGPR_npc( rm ) * cpu.GetGPR_npc( rs )) );
};

op mls( 0b111110110000[12]: rm[4]:> <: rn[4]: rd[4]: 0b0001[4]: rs[4] );

mls.disasm = {
  buffer << "mls\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs) << ", " << DisasmRegister(rn);
};

mls.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, cpu.GetGPR_npc( rn ) - (cpu.GetGPR_npc( rm ) * cpu.GetGPR_npc( rs )) );
};

/* UMULL, UMLAL, UMAAL instructions */

op umull( 0b111110111010[12]: rm[4]:> <: rdlo[4]: rdhi[4]: 0b0000[4]: rs[4] );

umull.disasm = {
  buffer << "umull\t" << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
};

umull.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint64_t res = (uint64_t)cpu.GetGPR_npc( rm ) * (uint64_t)cpu.GetGPR_npc( rs );
  cpu.SetGPR( rdlo, res >> 0 );
  cpu.SetGPR( rdhi, res >> 32 );
};

op umlal( 0b111110111110[12]: rm[4]:> <: rdlo[4]: rdhi[4]: 0b0000[4]: rs[4] );
umlal.disasm = {
  buffer << "umlal\t" << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
};

umlal.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint64_t res = (((uint64_t)cpu.GetGPR_npc( rdlo )) <<  0) |
                 (((uint64_t)cpu.GetGPR_npc( rdhi )) << 32);
  res += (uint64_t)cpu.GetGPR_npc( rm ) * (uint64_t)cpu.GetGPR_npc( rs );
  cpu.SetGPR( rdlo, res >> 0 );
  cpu.SetGPR( rdhi, res >> 32 );
};

op umaal( 0b111110111110[12]: rm[4]:> <: rdlo[4]: rdhi[4]: 0b0110[4]: rs[4] );
umaal.disasm = {
  buffer << "umaal\t" << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
};

umaal.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint64_t res = ((uint64_t)cpu.GetGPR_npc( rm ) * (uint64_t)cpu.GetGPR_npc( rs )) +
                 cpu.GetGPR_npc( rdlo ) + cpu.GetGPR_npc( rdhi );
  cpu.SetGPR( rdlo, res >> 0 );
  cpu.SetGPR( rdhi, res >> 32 );
};

op smull( 0b111110111000[12]: rm[4]:> <: rdlo[4]: rdhi[4]: 0b0000[4]: rs[4] );

smull.disasm = {
  buffer << "smull\t" << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rs);
};

smull.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint64_t res = (int64_t)(int32_t)cpu.GetGPR_npc( rm ) * (int64_t)(int32_t)cpu.GetGPR_npc( rs );
  cpu.SetGPR( rdlo, res >> 0 );
  cpu.SetGPR( rdhi, res >> 32 );
};

/*******************************************************************
 * sdiv (Signed Divide) instruction
 *
 * SDIV divides a 32-bit signed integer register value by a 32-bit
 * signed integer register value, and writes the result to the
 * destination register. The condition code flags are not affected
 */

{ CONFIG::insnsRM }:                                                      \
op sdiv( 0b111110111001[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b1111[4]: rm[4] );

sdiv.disasm = {
  buffer << "sdiv\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of sdiv instruction
 *******************************************************************/

/*******************************************************************
 * udiv (Unsigned Divide) instruction
 *
 * UDIV divides a 32-bit unsigned integer register value by a 32-bit
 * unsigned integer register value, and writes the result to the
 * destination register. The condition code flags are not affected.
 */

{ CONFIG::insnsRM }:                                                      \
op udiv( 0b111110111011[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b1111[4]: rm[4] );

udiv.disasm = {
  buffer << "udiv\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

/*
 * end of udiv instruction
 *******************************************************************/

/*******************************************************************
 * smlalxy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smlalxy( 0b11111[5]: 0b0111[4]: 0b100[3]: rn[4]:> <: rdlo[4]: rdhi[4]: 0b10[2]: n[1]: m[1]: rm[4] );

smlalxy.disasm = {
  buffer << "smlal" << (n?"t":"b") << (m?"t":"b") << '\t'
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

smlalxy.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  if ((rdhi == cpu.PC_reg) or (rdlo == cpu.PC_reg) or (rn == cpu.PC_reg) or (rm == cpu.PC_reg))
    { cpu.UnpredictableInsnBehaviour(); return; }
  
  int64_t res = (int64_t( cpu.GetGPR(rdhi) ) << 32) | int64_t( cpu.GetGPR(rdlo) );
  int64_t op1 = int16_t(cpu.GetGPR(rn) >> (n*16));
  int64_t op2 = int16_t(cpu.GetGPR(rm) >> (m*16));
  res += op1 * op2;
  cpu.SetGPR( rdlo, uint32_t( res ) );
  cpu.SetGPR( rdhi, uint32_t( res >> 32 ) );
};

/*
 * end of smlalxy instruction
 *******************************************************************/

/*******************************************************************
 * smlal instruction
 */

{ CONFIG::insns5E }:                                                     \
op smlal( 0b11111[5]: 0b0111[4]: 0b100[3]: rn[4]:> <: rdlo[4]: rdhi[4]: 0b0000[4]: rm[4] );

smlal.disasm = {
  buffer << "smlal\t"
         << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
         << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};
  
smlal.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;

  int64_t res = (int64_t( cpu.GetGPR(rdhi) ) << 32) | int64_t( cpu.GetGPR(rdlo) );
  int64_t op1 = int32_t( cpu.GetGPR(rn) );
  int64_t op2 = int32_t( cpu.GetGPR(rm) );
  res += op1 * op2;
  cpu.SetGPR( rdlo, uint32_t( res >> 0 ) );
  cpu.SetGPR( rdhi, uint32_t( res >> 32 ) );
};

/*
 * end of smlal instruction
 *******************************************************************/

/*******************************************************************
 * smlaxy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smlaxy( 0b11111[5]: 0b0110[4]: 0b001[3]: rn[4]:> <: ra[4]: rd[4]: 0b00[2]: n[1]: m[1]: rm[4] );

smlaxy.disasm = {
  buffer << "smla" << (n?"t":"b") << (m?"t":"b") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

smlaxy.execute = {
  int32_t op1;
  int32_t op2;
  uint32_t val_rn;
  uint32_t val_rm;
  uint32_t val_ra;
  uint32_t val_rd;
  

  if(not CheckCondition(cpu, cpu.itcond())) return;
  
  if (rd == cpu.PC_reg || rn == cpu.PC_reg || ra == cpu.PC_reg || rm == cpu.PC_reg)
    {
      cpu.UnpredictableInsnBehaviour();
      return;
    }
  
  val_rn = cpu.GetGPR(rn);
  val_rm = cpu.GetGPR(rm);
  val_ra = cpu.GetGPR(ra);
  
  if(n)
    val_rn = val_rn >> 16;
  if(val_rn & (uint32_t)0x00008000ULL) {
    val_rn = val_rn | (uint32_t)0xffff0000ULL;
    op1 = (int32_t)val_rn;
  } else {
    val_rn = val_rn & (uint32_t)0x0000ffffULL;
    op1 = (int32_t)val_rn;
  }
  
  if(m)
    val_rm = val_rm >> 16;
  if(val_rm & (uint32_t)0x00008000ULL) {
    val_rm = val_rm | (uint32_t)0xffff0000ULL;
    op2 = (int32_t)val_rm;
  } else {
    val_rm = val_rm & (uint32_t)0x0000ffffULL;
    op2 = (int32_t)val_rm;
  }
  
  uint32_t mul_res = (uint32_t)(op1 * op2);
  //val_rd = op1 + val_ra;
  uint8_t carry_out, overflow_out, sign;
  unisim::util::arithmetic::SignedAdd32(val_rd, carry_out, overflow_out, sign, mul_res, val_ra, 0);
  //if(op1 > 0 && (val_rd & (uint32_t)0x80000000ULL) != 0) {
  if (overflow_out) {
    cpu.CPSR().Set( Q, 1 );
  }
  cpu.SetGPR(rd, val_rd);
};

/*
 * end of smlaxy instruction
 *******************************************************************/

/*******************************************************************
 * smlald (Signed Multiply Accumulate Long Dual) instruction
 *
 * SMLALD performs two signed 16 * 16-bit multiplications. It adds the
 * products to a 64-bit accumulate operand.
 */

{ CONFIG::insns6 }:                                                      \
op smlald( 0b11111[5]: 0b0111[4]: 0b100[3]: rd[4]:> <: rc[4]: rb[4]: 0b110[3]: m[1]: ra[4] );

smlald.disasm = {
  buffer << "smlald" << (m?"x":"") << "\t"
         << DisasmRegister(rc) << ", " << DisasmRegister(rb) << ", "
         << DisasmRegister(rd) << ", " << DisasmRegister(ra); };

/*
 * end of smlald instruction
 *******************************************************************/

/*******************************************************************
 * smlsld (Signed Multiply Accumulate Long Dual) instruction
 *
 * SMLSLD performs two signed 16 * 16-bit multiplications. It adds the
 * products to a 64-bit accumulate operand.
 */

{ CONFIG::insns6 }:                                                      \
op smlsld( 0b11111[5]: 0b0111[4]: 0b101[3]: rd[4]:> <: rc[4]: rb[4]: 0b110[3]: m[1]: ra[4] );

smlsld.disasm = {
  buffer << "smlsld" << (m?"x":"") << "\t"
         << DisasmRegister(rc) << ", " << DisasmRegister(rb) << ", "
         << DisasmRegister(rd) << ", " << DisasmRegister(ra);
};

/*
 * end of smlsld instruction
 *******************************************************************/

/*******************************************************************
 * smlad instruction
 */

{ CONFIG::insns6 }:                                                       \
op smlad( 0b11111[5]: 0b0110[4]: 0b010[3]: rd[4]:> <: rc[4]: rb[4]: 0b000[3]: m[1]: ra[4] );

smlad.disasm = {
  buffer << "smlad" << (m?"x":"") << "\t"
         << DisasmRegister(rb) << ", " << DisasmRegister(rd) << ", "
         << DisasmRegister(ra) << ", " << DisasmRegister(rc);
};

/*
 * end of smlad instruction
 *******************************************************************/

/*******************************************************************
 * smuad instruction
 */

{ CONFIG::insns6 }:                                                      \
op smuad( 0b111110110010[12]: rd[4]:> <: 0b1111[4]: rb[4]: 0b000[3]: m[1]: ra[4] );

smuad.disasm = {
  buffer << "smuad" << (m?"x":"") << "\t" << DisasmRegister(rb) << ", " << DisasmRegister(rd) << ", " << DisasmRegister(ra);
};

/*
 * end of smuad instruction
 *******************************************************************/

/*******************************************************************
 * smlsd instruction
 */

{ CONFIG::insns6 }:                                                      \
op smlsd( 0b111110110100[12]: rd[4]:> <: rc[4]: rb[4]: 0b000[3]: m[1]: ra[4] );

smlsd.disasm = {
  buffer << "smlsd" << (m?"x":"") << "\t" << DisasmRegister(rb) << ", " << DisasmRegister(rd) << ", " << DisasmRegister(ra) << ", " << DisasmRegister(rc);
};

/*
 * end of smlsd instruction
 *******************************************************************/

/*******************************************************************
 * smusd instruction
 */

{ CONFIG::insns6 }:                                                      \
op smusd( 0b111110110100[12]: rd[4]:> <: 0b1111[4]: rb[4]: 0b000[3]: m[1]: ra[4] );

smusd.disasm = {
  buffer << "smusd" << (m?"x":"") << "\t" << DisasmRegister(rb) << ", " << DisasmRegister(rd) << ", " << DisasmRegister(ra);
};

/*
 * end of smusd instruction
 *******************************************************************/

/*******************************************************************
 * smmla instruction
 */

{ CONFIG::insns6 }:                                                      \
op smmla( 0b111110110101[12]: rd[4]:> <: rc[4]: rb[4]: 0b000[3]: r[1]: ra[4] );

smmla.disasm = {
  buffer << "smmla" << (r?"r":"") << "\t" << DisasmRegister(rb) << ", " << DisasmRegister(rd) << ", " << DisasmRegister(ra) << ", " << DisasmRegister(rc);
};

/*
 * end of smmla instruction
 *******************************************************************/

/*******************************************************************
 * smmul instruction
 */

{ CONFIG::insns6 }:                                                       \
op smmul( 0b111110110101[12]: rd[4]:> <: 0b1111[4]: rb[4]: 0b000[3]: r[1]: ra[4] );

smmul.disasm = {
  buffer << "smmul" << (r?"r":"") << "\t" << DisasmRegister(rb) << ", " << DisasmRegister(rd) << ", " << DisasmRegister(ra);
};

/*
 * end of smmul instruction
 *******************************************************************/

/*******************************************************************
 * smmls instruction
 */

{ CONFIG::insns6 }:                                                      \
op smmls( 0b111110110110[12]: rd[4]:> <: rc[4]: rb[4]: 0b000[3]: r[1]: ra[4] );

smmls.disasm = {
  buffer << "smmls" << (r?"r":"") << "\t" << DisasmRegister(rb) << ", " << DisasmRegister(rd) << ", " << DisasmRegister(ra) << ", " << DisasmRegister(rc);
};

/*
 * end of smmls instruction
 *******************************************************************/

/*******************************************************************
 * smulxy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smulxy( 0b111110110001[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b00[2]: n[1]: m[1]: rm[4] );

smulxy.disasm = {
  buffer << "smul" << (n?"t":"b") << (m?"t":"b") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

smulxy.execute = {
  int32_t op1;
  int32_t op2;
  uint32_t val_rn;
  uint32_t val_rm;
  uint32_t val_rd;
  

  if(not CheckCondition(cpu, cpu.itcond())) return;
  
  if (rd == cpu.PC_reg || rn == cpu.PC_reg || rm == cpu.PC_reg)
    {
      cpu.UnpredictableInsnBehaviour();
      return;
    }
  
  val_rn = cpu.GetGPR(rn);
  val_rm = cpu.GetGPR(rm);
  
  if(n)
    val_rn = val_rn >> 16;
  if(val_rn & (uint32_t)0x00008000ULL) {
    val_rn = val_rn | (uint32_t)0xffff0000ULL;
    op1 = (int32_t)val_rn;
  } else {
    val_rn = val_rn & (uint32_t)0x0000ffffULL;
    op1 = (int32_t)val_rn;
  }
  
  if(m)
    val_rm = val_rm >> 16;
  if(val_rm & (uint32_t)0x00008000ULL) {
    val_rm = val_rm | (uint32_t)0xffff0000ULL;
    op2 = (int32_t)val_rm;
  } else {
    val_rm = val_rm & (uint32_t)0x0000ffffULL;
    op2 = (int32_t)val_rm;
  }
  
  op1 = op1 * op2;
  val_rd = (uint32_t)op1;
  cpu.SetGPR(rd, val_rd);
};

/*
 * end of smulxy instruction
 *******************************************************************/

/*******************************************************************
 * smlawy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smlawy( 0b111110110011[12]: rn[4]:> <: ra[4]: rd[4]: 0b000[3]: m[1]: rm[4] );

smlawy.disasm = {
  buffer << "smlaw" << (m?"t":"b") << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
};

smlawy.execute = {
  int32_t op;
  uint32_t val_rn;
  uint32_t val_rm;
  uint32_t val_ra;
  uint32_t val_rd;
  

  if(not CheckCondition(cpu, cpu.itcond())) return;
  
  if (rd == cpu.PC_reg || rn == cpu.PC_reg || ra == cpu.PC_reg || rm == cpu.PC_reg)
    {
      cpu.UnpredictableInsnBehaviour();
      return;
    }
  
  val_rn = cpu.GetGPR(rn);
  val_rm = cpu.GetGPR(rm);
  val_ra = cpu.GetGPR(ra);
  
  if(m)
    val_rm = val_rm >> 16;
  if(val_rm & (uint32_t)0x00008000ULL) {
    val_rm = val_rm | (uint32_t)0xffff0000ULL;
    op = (int32_t)val_rm;
  } else {
    val_rm = val_rm & (uint32_t)0x0000ffffULL;
    op = (int32_t)val_rm;
  }
  
  int64_t op64;
  op64 = (int32_t)val_rn;
  op64 = op64 * op;
  op64 = op64 >> 16;
  op64 = op64 & (uint64_t)0xffffffffULL;
  uint32_t op_tmp = op64;
  //int32_t sval_rd = (int32_t)op_tmp;
  //val_rd = (uint32_t)(sval_rd + (int32_t)val_ra);
  uint8_t carry_out, overflow_out, sign;
  unisim::util::arithmetic::SignedAdd32(val_rd, carry_out, overflow_out, sign, op_tmp, val_ra, 0);
  //   if ( (op_tmp & (uint32_t)0x80000000ULL) !=
  //     (val_ra & (uint32_t)0x80000000ULL) )
  if(overflow_out)
    {
      //    cpu.SetCPSR_Q(false);
      cpu.CPSR().Set( Q, 1 );
    }
  //   else
  //   {
  //     if ( (op_tmp & (uint32_t)0x80000000ULL) !=
  //       (val_rd & (uint32_t)0x80000000ULL) )
  //     {
  //       cpu.SetCPSR_Q(true);
  //     }
  //     else
  //       cpu.SetCPSR_Q(false);
  //   }
  cpu.SetGPR(rd, val_rd);

};

/*
 * end of smlawy instruction
 *******************************************************************/

/*******************************************************************
 * smulwy instruction
 */

{ CONFIG::insns5E }:                                                     \
op smulwy( 0b111110110011[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b000[3]: m[1]: rm[4] );

smulwy.disasm = {
  buffer << "smulw" << (m?"t":"b") << "\t"
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

smulwy.execute = {
  int32_t op1;
  int32_t op2;
  uint32_t val_rn;
  uint32_t val_rm;
  uint32_t val_rd;
  

  if(not CheckCondition(cpu, cpu.itcond())) return;
  
  if(rd == cpu.PC_reg || rn == cpu.PC_reg || rm == cpu.PC_reg) {
    cpu.UnpredictableInsnBehaviour();
    return;
  }
  
  val_rn = cpu.GetGPR(rn);
  val_rm = cpu.GetGPR(rm);
  
  if(m)
    val_rm = val_rm >> 16;
  if(val_rm & (uint32_t)0x00008000ULL) {
    val_rm = val_rm | (uint32_t)0xffff0000ULL;
    op2 = (int32_t)val_rm;
  } else {
    val_rm = val_rm & (uint32_t)0x0000ffffULL;
    op2 = (int32_t)val_rm;
  }
  
  op1 = (int32_t)val_rn;
  int64_t op64 = (int64_t)op1 * (int64_t)op2;
  val_rd = (uint32_t)((uint64_t)(op64 >> 16) & (uint64_t)0xffffffffULL);
  cpu.SetGPR(rd, val_rd);
};

/*
 * end of smulwy instruction
 *******************************************************************/

