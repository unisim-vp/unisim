/*
 *  Copyright (c) 2007-2014,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Yves Lhuillier (yves.lhuillier@cea.fr), Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 */

/*******************************************************************
 * qadd (Saturating Add) instruction
 *
 * QADD adds two register values, saturates the result to the 32-bit
 * signed integer range -2^31 to 2^31-1, and writes the result to the
 * destination register. If saturation occurs, it sets the Q flag in
 * the APSR.
 */

{ ARCH::Config::insns5E }: \
op qadd( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b1000[4]: rm[4] );
qadd.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15)};

qadd.disasm = {
  buffer << "qadd\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qadd.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm), res = op1 + op2;
  
  U32 saturation = SignedSat( res, ~op1 & ~op2 & res, op1 & op2 & ~res, SWP<32>() );
  
  cpu.CPSR().Set( Q, saturation | cpu.CPSR().Get( Q ) );
  
  cpu.SetGPR( rd, U32(res) );
};

/*
 * end of qadd instruction
 *******************************************************************/

/*******************************************************************
 * qadd16 (Saturating Add 16) instruction
 * 
 * QADD16 performs two 16-bit integer additions, saturates the results
 * to the 16-bit signed integer range -2^15 <= x <= 2^15-1, and writes
 * the results to the destination register.
 */

{ ARCH::Config::insns6 }:                                       \
op qadd16( 0b111110101001[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0001[4]: rm[4] );
qadd16.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15)};

qadd16.disasm = {
  buffer << "qadd16\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

qadd16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<16>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs));
  
  SignedSat( res, ~op1 & ~op2 & res, op1 & op2 & ~res, SWP<16>() );
  
  cpu.SetGPR( rd, U32(res) );
};

/*
 * end of qadd16 instruction
 *******************************************************************/

/*******************************************************************
 * qadd8 (Saturating Add 8) instruction
 *
 * QADD8 performs four 8-bit integer additions, saturates the results
 * to the 8-bit signed integer range -2^7 <= x <= 2^7-1, and writes
 * the results to the destination register.

 */

{ ARCH::Config::insns6 }:                                       \
op qadd8( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0001[4]: rm[4] );
qadd8.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15)};

qadd8.disasm = {
  buffer << "qadd8\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

qadd8.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<8>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs));
  
  SignedSat( res, ~op1 & ~op2 & res, op1 & op2 & ~res, SWP<8>() );
  
  cpu.SetGPR( rd, U32(res) );
};

/*
 * end of qadd8 instruction
 *******************************************************************/

/*******************************************************************
 * qsub (Saturating Subtract) instruction
 * 
 * QSUB subtracts one register value from another register value,
 * saturates the result to the 32-bit signed integer range -2^31 <= x
 * <= 2^31-1, and writes the result to the destination register. If
 * saturation occurs, it sets the Q flag in the APSR.
 */

{ ARCH::Config::insns5E }: \
op qsub( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b1010[4]: rm[4] );
qsub.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15)};

qsub.disasm = {
  buffer << "qsub\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qsub.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 op1 = cpu.GetGPR(rm), op2 = cpu.GetGPR(rn), res = op1 - op2;
  
  U32 saturation = SignedSat( res, ~op1 & op2 & res, op1 & ~op2 & ~res, SWP<32>() );
  
  cpu.CPSR().Set( Q, saturation | cpu.CPSR().Get( Q ) );
  
  cpu.SetGPR( rd, U32(res) );
};

/*
 * end of qsub instruction
 *******************************************************************/

/*******************************************************************
 * qsub16 (Saturating Subtract 16) instruction
 *
 * QSUB16 performs two 16-bit integer subtractions, saturates the
 * results to the 16-bit signed integer range -2^15 <= x <= 2^15-1, and
 * writes the results to the destination register.
 */

{ ARCH::Config::insns6 }:                                       \
op qsub16( 0b111110101101[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0001[4]: rm[4] );
qsub16.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15)};

qsub16.disasm = {
  buffer << "qsub16\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

qsub16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<16>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs));

  U32 saturation = SignedSat( res, ~op1 & op2 & res, op1 & ~op2 & ~res, SWP<16>() );
  
  cpu.CPSR().Set( Q, saturation | cpu.CPSR().Get( Q ) );
  
  cpu.SetGPR( rd, U32(res) );
};

/*
 * end of qsub16 instruction
 *******************************************************************/

/*******************************************************************
 * qsub8 (Saturating Subtract 8) instruction
 *
 * QSUB8 performs four 8-bit integer subtractions, saturates the
 * results to the 8-bit signed integer range -2^7 <= x <= 2^7-1, and
 * writes the results to the destination register.
 */

{ ARCH::Config::insns6 }:                                       \
op qsub8( 0b111110101100[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0001[4]: rm[4] );
qsub8.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15)};

qsub8.disasm = {
  buffer << "qsub8\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

qsub8.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<8>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs));

  U32 saturation = SignedSat( res, ~op1 & op2 & res, op1 & ~op2 & ~res, SWP<8>() );
  
  cpu.SetGPR( rd, U32(res) );
};

/*
 * end of qsub8 instruction
 *******************************************************************/

/*******************************************************************
 * qdadd instruction
 */

{ ARCH::Config::insns5E }: \
op qdadd( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b1001[4]: rm[4] );
qdadd.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15)};

qdadd.disasm = {
  buffer << "qdadd\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qdadd.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 saturation = cpu.CPSR().Get( Q );
  
  U32 op1 = cpu.GetGPR(rn), tmp = op1 + op1;
  saturation |= SignedSat( tmp, ~op1 & tmp, op1 & ~tmp, SWP<32>() );
  
  U32 op2 = U32(cpu.GetGPR(rm)), res = op2 + tmp;
  saturation |= SignedSat( res, ~op2 & ~tmp & res, op2 & tmp & ~res, SWP<32>() );
  
  cpu.CPSR().Set( Q, saturation );
  
  cpu.SetGPR( rd, U32(res) );
};

/*
 * end of qdadd instruction
 *******************************************************************/

/*******************************************************************
 * qdsub instruction
 */

{ ARCH::Config::insns5E }: \
op qdsub( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b1011[4]: rm[4] );
qdsub.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15)};

qdsub.disasm = {
  buffer << "qdsub\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
};

qdsub.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 saturation = cpu.CPSR().Get( Q );
  
  U32 op1 = cpu.GetGPR(rn), tmp = op1 + op1;
  saturation |= SignedSat( tmp, ~op1 & tmp, op1 & ~tmp, SWP<32>() );
  
  U32 op2 = cpu.GetGPR(rm), res = op2 - tmp;
  saturation |= SignedSat( res, ~op2 & tmp & res, op2 & ~tmp & ~res, SWP<32>() );
  
  cpu.CPSR().Set( Q, saturation );
  
  cpu.SetGPR( rd, U32(res) );
};

/*
 * end of qdsub instruction
 *******************************************************************/

/*******************************************************************
 * pkh (Pack Halfword) instruction
 *
 * PKH combines one halfword of its first operand with the other
 * halfword of its shifted second operand.
 */

op pkh( 0b111010101100[12]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shl<1> tb[1]: 0b0[1]: rm[4] );
pkh.var imm : {uint32_t} = {imm1|imm0}

pkh.disasm = {
  buffer << "pkh" << (tb?"tb":"bt") << '\t'
         << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
         << DisasmRegister(rm) << DisasmShImm( tb, imm );
};

/*
 * end of pkh instruction
 *******************************************************************/

op qasx( 0b111110101010[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0001[4]: rm[4] );
qasx.disasm = { buffer << "qasx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op qsax( 0b111110101110[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0001[4]: rm[4] );
qsax.disasm = { buffer << "qsax\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

/*******************************************************************
 * rev (Byte-Reverse Word) instruction
 *
 * REV reverses the byte order in a 32-bit register.
 */

op rev_w( 0b111110101001[12]: rm[4]:> <: 0b1111[4]: rd[4]: 0b1000[4]: rm_[4] );
rev_w.var reject : {Reject} = {(rm != rm_)};

rev_w.disasm = { buffer << "rev.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm); };

rev_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  U32 rmval = cpu.GetGPR( rm ), rdval = ByteSwap( rmval );
	
  cpu.SetGPR( rd, rdval );
};

/*
 * end of rev instruction
 *******************************************************************/

/*******************************************************************
 * revsh (Byte-Reverse Signed Halfword) instruction
 *
 * REVSH reverses the byte order in the lower 16-bit halfword of a
 * 32-bit register, and sign-extends the result to 32 bits.
 */

{ ARCH::Config::insns6 }:                               \
op revsh_w( 0b111110101001[12]: rm[4]:> <: 0b1111[4]: rd[4]: 0b1011[4]: rm_[4] );
revsh_w.var reject : {Reject} = {(rm != rm_) or (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15)};

revsh_w.disasm = {
  buffer << "revsh.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
};

revsh_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::U16 U16;
  
  U16 src( cpu.GetGPR(rm) );
  cpu.SetGPR( rd, U32(S32(S16((src >> 8) | (src << 8)))) );
};

/*
 * end of revsh instruction
 *******************************************************************/

op sasx( 0b111110101010[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0000[4]: rm[4] );
sasx.disasm = { buffer << "sasx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

/*******************************************************************
 * sel (Select Bytes) instruction
 *
 * SEL selects each byte of its result from either its first operand
 * or its second operand, according to the values of the GE flags.
 */

op sel( 0b111110101010[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b1000[4]: rm[4] );
sel.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15)};

sel.disasm = {
  buffer << "sel\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

sel.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U8  U8;
  
  U32 rnval = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm );
  U32 word_mask(0);
  
  {
    U8 cpsr_ge( cpu.CPSR().Get( GE ) );
    for (unsigned byte_index = 0; byte_index < 4; byte_index++) {
      U8 byte_mask = ((cpsr_ge >> byte_index) & U8(1)) - U8(1);
      word_mask |= U32(byte_mask) << (8*byte_index);
    }
  }

  U32 res = (rnval & ~word_mask) | (rmval & word_mask);
  
  cpu.SetGPR( rd, res );
};

/*
 * end of sel instruction
 *******************************************************************/

op shadd8( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0010[4]: rm[4] );
shadd8.disasm = { buffer << "shadd8\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op shadd16( 0b111110101001[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0010[4]: rm[4] );
shadd16.disasm = { buffer << "shadd16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op shasx( 0b111110101010[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0010[4]: rm[4] );
shasx.disasm = { buffer << "shasx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op shsax( 0b111110101110[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0010[4]: rm[4] );
shsax.disasm = { buffer << "shsax\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op shsub8( 0b111110101100[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0010[4]: rm[4] );
shsub8.disasm = { buffer << "shsub8\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op shsub16( 0b111110101101[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0010[4]: rm[4] );
shsub16.disasm = { buffer << "shsub16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op ssat_rir( 0b1111001100[10]: sht[1]: 0b0[1]: rn[4]:> <: 0b0[1]: shl<2> shv1[3]: rd[4]: shv0[2]: 0b0[1]: imm[5] );
ssat_rir.var shv : {uint32_t} = {shv1|shv0};

ssat_rir.disasm = {
  buffer << "ssat\t" << DisasmRegister(rd) << ", " << DisasmI(imm) << ", " << DisasmRegister(rn);
  if (shv) buffer << ", " << (sht?"asr":"lsl") << " " << DisasmI(shv);
};

op ssat16_rir( 0b1111001100[10]: 0b1[1]: 0b0[1]: rn[4]:> <: 0b0[1]: 0b000[3]: rd[4]: 0b00[2]: 0b0[1]: imm[5] );

ssat16_rir.disasm = {
  buffer << "ssat16\t" << DisasmRegister(rd) << ", " << DisasmI(imm) << ", " << DisasmRegister(rn);
};

op ssax( 0b111110101110[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0000[4]: rm[4] );
ssax.disasm = { buffer << "ssax\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

/*******************************************************************
 * uadd16 (Unsigned Add 16) instruction
 * 
 * UADD16 performs two 16-bit unsigned integer additions, and writes
 * the results to the dest ination register.  It sets the APSR.GE bits
 * according to the results of the additions.
 */

{ ARCH::Config::insns6 }:                                              \
op uadd16( 0b111110101001[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0100[4]: rm[4] );
uadd16.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15)};

uadd16.disasm = {
  buffer << "uadd16\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};


uadd16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<16>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
      gev = ((op1 & op2) | (~res & (op1 | op2))) & U32(msbs); //< GE vector
  
  cpu.SetGPR( rd, res );
  cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
};

/*
 * end of uadd16 instruction
 *******************************************************************/

/*******************************************************************
 * uadd8 (unsigned add 8) instruction
 * 
 * UADD8 performs four unsigned 8-bit integer additions, and writes
 * the results to the destination register. It sets the APSR.GE bits
 * according to the results of the additions.
 */

{ ARCH::Config::insns6 }:                                              \
op uadd8( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0100[4]: rm[4] );
uadd8.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15)};

uadd8.disasm = {
  buffer << "uadd8\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

uadd8.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<8>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
      gev = ((op1 & op2) | (~res & (op1 | op2))) & U32(msbs); //< GE vector
  
  cpu.SetGPR( rd, res );
  cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
};

/*
 * end of uadd8 instruction
 *******************************************************************/

/*******************************************************************
 * usub16 (Unsigned Subtract 16) instruction
 * 
 * USUB16 performs two 16-bit unsigned integer subtractions, and
 * writes the results to the destination register. It sets the APSR.GE
 * bits according to the results of the subtractions.
 */

{ ARCH::Config::insns6 }:                                              \
op usub16( 0b111110101101[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0100[4]: rm[4] );
usub16.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15)};

usub16.disasm = {
  buffer << "usub16\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

usub16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<16>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
      gev = ((op1 & ~op2) | (~res & (op1 | ~op2))) & U32(msbs); //< GE vector
  
  cpu.SetGPR( rd, U32(res) );
  cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
};

/*
 * end of usub16 instruction
 *******************************************************************/

/*******************************************************************
 * usub8 (Unsigned Subtract 8) instruction
 *
 * USUB8 performs four 8-bit unsigned integer subtractions, and writes
 * the results to the destination register. It sets the APSR.GE bits
 * according to the results of the subtractions.
 */

{ ARCH::Config::insns6 }:                                       \
op usub8( 0b111110101100[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0100[4]: rm[4] );
usub8.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15)};

usub8.disasm = {
  buffer << "usub8\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

usub8.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<8>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
      gev = ((op1 & ~op2) | (~res & (op1 | ~op2))) & U32(msbs); //< GE vector
  
  cpu.SetGPR( rd, U32(res) );
  cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
};

/*
 * end of usub8 instruction
 *******************************************************************/

/*******************************************************************
 * sadd16 (Signed Add 16) instruction
 *
 * SADD16 performs two 16-bit signed integer additions, and writes the
 * results to the destination register. It sets the APSR.GE bits
 * according to the results of the additions.
 */

{ ARCH::Config::insns6 }:                                       \
op sadd16( 0b111110101001[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0000[4]: rm[4] );
sadd16.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15)};

sadd16.disasm = {
  buffer << "sadd16\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

sadd16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<16>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
      gev = (((op1 & op2 & ~res) | (~op1 & ~op2 & res)) ^ ~res) & U32(msbs); //< GE vector
  
  cpu.SetGPR( rd, res );
  cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
};

/*
 * end of sadd16 instruction
 *******************************************************************/

/*******************************************************************
 * sadd8 (Signed Add 8) instruction
 *
 * SADD8 performs four 8-bit signed integer additions, and writes the
 * results to the destination register. It sets the APSR.GE bits
 * according to the results of the additions
 */

{ ARCH::Config::insns6 }:                                       \
op sadd8( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0000[4]: rm[4] );
sadd8.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15)};

sadd8.disasm = {
  buffer << "sadd8\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

sadd8.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<8>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
      gev = (((op1 & op2 & ~res) | (~op1 & ~op2 & res)) ^ ~res) & U32(msbs); //< GE vector
  
  cpu.SetGPR( rd, res );
  cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
};

/*
 * end of sadd8 instruction
 *******************************************************************/

/*******************************************************************
 * ssub16 (Signed Substract 16) instruction
 *
 * SSUB16 performs two 16-bit signed integer subtract ions, and writes
 * the results to the destination register.  It sets the APSR.GE bits
 * according to the results of the subtractions.
 */

{ ARCH::Config::insns6 }:                                       \
op ssub16( 0b111110101101[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0000[4]: rm[4] );
ssub16.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15)};

ssub16.disasm = {
  buffer << "ssub16\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

ssub16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<16>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
      gev = (((op1 & ~op2 & ~res) | (~op1 & op2 & res)) ^ ~res) & U32(msbs); //< GE vector
  
  cpu.SetGPR( rd, U32(res) );
  cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
};

/*
 * end of ssub16 instruction
 *******************************************************************/

/*******************************************************************
 * ssub8 (Signed Substract 8) instruction
 *
 * SSUB8 performs four 8-bit signed integer subtractions, and writes
 * the results to the destination register.  It sets the APSR.GE bits
 * according to the results of the subtractions.
 */

{ ARCH::Config::insns6 }:                                       \
op ssub8( 0b111110101100[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0000[4]: rm[4] );
ssub8.var reject : {Reject} = {(rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15)};

ssub8.disasm = {
  buffer << "ssub8\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

ssub8.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  uint32_t const msbs(SWP<8>::msbmask);
  
  U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
      res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
      gev = (((op1 & ~op2 & ~res) | (~op1 & op2 & res)) ^ ~res) & U32(msbs); //< GE vector
  
  cpu.SetGPR( rd, U32(res) );
  cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
};

/*
 * end of ssub8 instruction
 *******************************************************************/

op uasx( 0b111110101010[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0100[4]: rm[4] );
uasx.disasm = { buffer << "uasx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uhadd8( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0110[4]: rm[4] );
uhadd8.disasm = { buffer << "uhadd8\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uhadd16( 0b111110101001[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0110[4]: rm[4] );
uhadd16.disasm = { buffer << "uhadd16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uhasx( 0b111110101010[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0110[4]: rm[4] );
uhasx.disasm = { buffer << "uhasx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uhsax( 0b111110101110[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0110[4]: rm[4] );
uhsax.disasm = { buffer << "uhsax\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uhsub8( 0b111110101100[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0110[4]: rm[4] );
uhsub8.disasm = { buffer << "uhsub8\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uhsub16( 0b111110101101[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0110[4]: rm[4] );
uhsub16.disasm = { buffer << "uhsub16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uqadd8( 0b111110101000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0101[4]: rm[4] );
uqadd8.disasm = { buffer << "uqadd8\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uqadd16( 0b111110101001[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0101[4]: rm[4] );
uqadd16.disasm = { buffer << "uqadd16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uqasx( 0b111110101010[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0101[4]: rm[4] );
uqasx.disasm = { buffer << "uqasx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op uqsax( 0b111110101110[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0101[4]: rm[4] );
uqsax.disasm = { buffer << "uqsax\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

/*******************************************************************
 * uqsub8 (Unsigned Saturating Subtract 8) instruction
 * 
 * UQSUB8 performs four unsigned 8-bit integer
 * subtractions, saturates the results to the 8-bit unsigned integer
 * range 0 <= x < 255, and writes the results to the destination
 * register.
 */

{ ARCH::Config::insns6 }: \
op uqsub8( 0b111110101100[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0101[4]: rm[4] );

uqsub8.disasm = {
  buffer << "uqsub8\t" << DisasmRegister(rd)
         << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

uqsub8.execute = {
  if(not CheckCondition(cpu, cpu.itcond())) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 rnval = cpu.GetGPR(rn), rmval = cpu.GetGPR(rm), res(0), flags(0);
  U32 const low_byte(0xff);
  
  for(unsigned int byte_index = 0; byte_index < 4; byte_index++, rnval >>= 8, rmval >>= 8)
    {
      U32 lhb(rnval & low_byte), rhb(rmval & low_byte), sum = lhb - rhb;
      sum = (sum & ~(sum >> 8)) & low_byte; // saturate/truncate
      res |= sum << (8*byte_index);
    }
  
  cpu.SetGPR( rd, res );
};

/*
 * end of uqsub8 instruction
 *******************************************************************/

op uqsub16( 0b111110101101[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0101[4]: rm[4] );
uqsub16.disasm = { buffer << "uqsub16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op usad8( 0b111110110111[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0000[4]: rm[4] );
usad8.disasm = { buffer << "usad8\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

op usada8( 0b111110110111[12]: rn[4]:> <: ra[4]: rd[4]: 0b0000[4]: rm[4] );
usada8.disasm = { buffer << "usada8\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra); };

op usat_rir( 0b1111001110[10]: sht[1]: 0b0[1]: rn[4]:> <: 0b0[1]: shl<2> shv1[3]: rd[4]: shv0[2]: 0b0[1]: imm[5] );
usat_rir.var shv : {uint32_t} = {shv1|shv0};

usat_rir.disasm = {
  buffer << "usat\t" << DisasmRegister(rd) << ", " << DisasmI(imm) << ", " << DisasmRegister(rn);
  if (shv) buffer << ", " << (sht?"asr":"lsl") << " " << DisasmI(shv);
};

op usat16_rir( 0b1111001110[10]: 0b1[1]: 0b0[1]: rn[4]:> <: 0b0[1]: 0b000[3]: rd[4]: 0b00[2]: 0b0[1]: imm[5] );

usat16_rir.disasm = {
  buffer << "usat16\t" << DisasmRegister(rd) << ", " << DisasmI(imm) << ", " << DisasmRegister(rn);
};

op usax( 0b111110101110[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0100[4]: rm[4] );
usax.disasm = { buffer << "usax\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); };

