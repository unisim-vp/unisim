/*
 *  Copyright (c) 2007-2014,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

        THUMB2 INTEGER INSTRUCTIONS

**********************************************/

impl {
namespace unisim {
namespace component {
namespace cxx {
namespace processor {
namespace arm {
namespace isa {
namespace thumb2 {
  /* decoding method for imm[1:3:8] */
static
uint32_t
ThumbExpandImm( uint32_t code )
{
  if        (code >= 0x400)
    return ((code & 0x7f) | 0x80) << ((32 - (code >> 7))  & 0x1f);
  else if (code >= 0x300)
    return 0x1010101 * (code & 0xff);
  else if (code >= 0x200)
    return 0x1000100 * (code & 0xff);
  else if (code >= 0x100)
    return 0x0010001 * (code & 0xff);
  else /* if (code < 0x100) */
    return code & 0xff;
}

} // end of namespace thumb2
} // end of namespace isa
} // end of namespace arm
} // end of namespace processor
} // end of namespace cxx
} // end of namespace component
} // end of namespace unisim

}

/* MOV instructions */

op mov_wri( 0b11110[5]: shl <11> imm2[1]: 0b00[2]: 0b010[3]: s[1]: 0b1111[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
mov_wri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

mov_wri.disasm = { buffer << "mov" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", #" << imm; };

mov_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t res = imm;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 31) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

op mov_w( 0b11101010[8]: 0b010[3]: s[1]: 0b1111[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
mov_w.var imm : {uint32_t} = {imm1|imm0}

mov_w.disasm = {
  buffer << "mov" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

mov_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ), res = ComputeImmShift( cpu, rmval, shift, imm );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op movt( 0b11110[5]: shl <11> imm2[1]: 0b101100[6]: shl<12> imm3[4]:> <: 0b0[1]: shl<8> imm1[3]: rsd[4]: imm0[8] );
movt.var imm : {uint32_t} = {imm3|imm2|imm1|imm0};

movt.disasm = { buffer << "movt\t" << DisasmRegister(rsd) << ", #" << imm; };

movt.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rsd, (cpu.GetGPR_npc( rsd ) & 0xffff) | (imm << 16) );
};

op movw( 0b11110[5]: shl <11> imm2[1]: 0b100100[6]: shl<12> imm3[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
movw.var imm : {uint32_t} = {imm3|imm2|imm1|imm0};

movw.disasm = { buffer << "movw\t" << DisasmRegister(rd) << ", #" << imm; };

movw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, imm );
};

/* MVN instructions */

op mvn_w( 0b11101010[8]: 0b011[3]: s[1]: 0b1111[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
mvn_w.var imm : {uint32_t} = {imm1|imm0}

mvn_w.disasm = {
  buffer << "mvn" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

mvn_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ), res = ~(ComputeImmShift( cpu, rmval, shift, imm ));
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op mvn_wri( 0b11110[5]: shl <11> imm2[1]: 0b00[2]: 0b011[3]: s[1]: 0b1111[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
mvn_wri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

mvn_wri.disasm = { buffer << "mvn" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", #" << imm; };

mvn_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t res = ~imm;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 31) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/* LSL, LSR, ASR, ROR shift instructions */

op shift_w( 0b11111010[8]: 0b0[1]: shift[2]: s[1]: rn[4]:> <: 0b1111[4]: rd[4]: 0b0000[4]: rm[4] );

shift_w.disasm = {
  buffer << "" << DisasmShift(shift) << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

shift_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
           res = ComputeRegShift( cpu, rnval, shift, rmval );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rnval, shift, rmval );
};

/* SUB instructions */

op sub_w( 0b11101011[8]: 0b101[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
sub_w.var imm : {uint32_t} = {imm1|imm0}

sub_w.disasm = {
  buffer << "sub" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

sub_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sub_wrri( 0b1111[4]: 0b0[1]: shl <11> imm2[1]: 0b01[2]: 0b101[3]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
sub_wrri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

sub_wrri.disasm = { buffer << "sub" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

sub_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op subs_pclri( 0b1111001111011110[16]:> <: 0b10001111[8]: imm[8] );
subs_pclri.disasm = { buffer << "subs\tpc, lr, #" << imm; };

subs_pclri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  assert( not "sure" );
  uint32_t op1 = cpu.GetGPR_npc( 14 ), op2 = imm, res = op1 - op2;
  cpu.SetGPR( 15, res );
  if (not cpu.itblock()) UpdateStatusSub( cpu, res, op1, op2 );
};

op subw( 0b11110[5]: shl<11> imm2[1]: 0b101010[6]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
subw.var imm : {uint32_t} = {imm2|imm1|imm0};

subw.disasm = {
  buffer << "subw\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

subw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, cpu.GetGPR(rn) - imm );
};

op adr_subw( 0b11110[5]: shl<11> imm2[1]: 0b101010[6]: 0b1111[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
adr_subw.var imm : {uint32_t} = {imm2|imm1|imm0};

adr_subw.disasm = {
  buffer << "subw\t" << DisasmRegister(rd) << ", pc, " << DisasmI(imm);
};

adr_subw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (cpu.GetGPR(cpu.PC_reg) & -4) - imm );
};

/* SBC instructions */

op sbc_w( 0b11101011[8]: 0b011[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
sbc_w.var imm : {uint32_t} = {imm1|imm0}

sbc_w.disasm = {
  buffer << "sbc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

sbc_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 - op2 - (cpu.CPSR().Get( C ) ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sbc_wrri( 0b11110[5]: shl <11> imm2[1]: 0b01[2]: 0b011[3]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
sbc_wrri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

sbc_wrri.disasm = { buffer << "sbc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

sbc_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 - op2 - (cpu.CPSR().Get( C ) ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/* RSB instructions */

op rsb( 0b11101011[8]: 0b110[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
rsb.var imm : {uint32_t} = {imm1|imm0}

rsb.disasm = {
  buffer << "rsb" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

rsb.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR_npc( rn ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsb_rri( 0b1111[4]: 0b0[1]: shl <11> imm2[1]: 0b01[2]: 0b110[3]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
rsb_rri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

rsb_rri.disasm = {
  buffer << "rsb" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

rsb_rri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = imm, op2 = cpu.GetGPR_npc( rn ), res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/* ADD instructions */

op add_w( 0b11101011[8]: 0b000[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
add_w.var imm : {uint32_t} = {imm1|imm0}

add_w.disasm = {
  buffer << "add" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

add_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op add_wrri( 0b1111[4]: 0b0[1]: shl <11> imm2[1]: 0b01[2]: 0b000[3]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
add_wrri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

add_wrri.disasm = { buffer << "add" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

add_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op addw( 0b11110[5]: shl<11> imm2[1]: 0b100000[6]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
addw.var imm : {uint32_t} = {imm2|imm1|imm0};

addw.disasm = {
  buffer << "addw\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

addw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, cpu.GetGPR(rn) + imm );
};

op adr_addw( 0b11110[5]: shl<11> imm2[1]: 0b100000[6]: 0b1111[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
adr_addw.var imm : {uint32_t} = {imm2|imm1|imm0};

adr_addw.disasm = {
  buffer << "addw\t" << DisasmRegister(rd) << ", pc, " << DisasmI(imm);
};

adr_addw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (cpu.GetGPR(cpu.PC_reg) & -4) + imm );
};

/* ADC instructions */

op adc_w( 0b11101011[8]: 0b010[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
adc_w.var imm : {uint32_t} = {imm1|imm0}

adc_w.disasm = {
  buffer << "adc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

adc_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 + op2 + cpu.CPSR().Get( C );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op adc_wrri( 0b11110[5]: shl <11> imm2[1]: 0b01[2]: 0b010[3]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
adc_wrri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

adc_wrri.disasm = { buffer << "adc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

adc_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 + op2 + cpu.CPSR().Get( C );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

/* EOR instructions */
op eor_w( 0b11101010[8]: 0b100[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
eor_w.var imm : {uint32_t} = {imm1|imm0}

eor_w.disasm = {
  buffer << "eor" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

eor_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op eor_wrri( 0b11110[5]: shl <11> imm2[1]: 0b00[2]: 0b100[3]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
eor_wrri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

eor_wrri.disasm = { buffer << "eor" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

eor_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 31) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/* ORN instructions */

op orn( 0b11101010[8]: 0b011[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
orn.var imm : {uint32_t} = {imm1|imm0}

orn.disasm = {
  buffer << "orn" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

orn.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 | ~op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op orn_rri( 0b11110[5]: shl <11> imm2[1]: 0b00[2]: 0b011[3]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
orn_rri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

orn_rri.disasm = { buffer << "orn" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

orn_rri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 | ~op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 31) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};


/* ORR instructions */

op orr_w( 0b11101010[8]: 0b010[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
orr_w.var  imm : {uint32_t} = {imm1|imm0}

orr_w.disasm = {
  buffer << "orr" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

orr_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op orr_wrri( 0b11110[5]: shl <11> imm2[1]: 0b00[2]: 0b010[3]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
orr_wrri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

orr_wrri.disasm = {
  buffer << "orr" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

orr_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 31) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/* NEGS instruction */

/* BIC instructions */

op bic_w( 0b11101010[8]: 0b001[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
bic_w.var imm : {uint32_t} = {imm1|imm0}

bic_w.disasm = {
  buffer << "bic" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

bic_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op bic_wrri( 0b11110[5]: shl <11> imm2[1]: 0b0[1]: 0b0001[4]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
bic_wrri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

bic_wrri.disasm = {
  buffer << "bic" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

bic_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 31) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/* AND instructions */

op and_w( 0b11101010[8]: 0b000[3]: s[1]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: rd[4]: imm0[2]: shift[2]: rm[4] );
and_w.var imm : {uint32_t} = {imm1|imm0}

and_w.disasm = {
  buffer << "and" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

and_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op and_wrri( 0b11110[5]: shl <11> imm2[1]: 0b00[2]: 0b000[3]: s[1]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: rd[4]: imm0[8] );
and_wrri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

and_wrri.disasm = {
  buffer << "and" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

and_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().Set( N, (res >> 31) & 1 );
      cpu.CPSR().Set( Z, res == 0 );
    }
};

/* CMP instructions */

op cmp_w( 0b111010111011[12]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: 0b1111[4]: imm0[2]: shift[2]: rm[4] );
cmp_w.var imm : {uint32_t} = {imm1|imm0}

cmp_w.disasm = {
  buffer << "cmp.w\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

cmp_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

op cmp_wri( 0b11110[5]: shl <11> imm2[1]: 0b011011[6]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: 0b1111[4]: imm0[8] );
cmp_wri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

cmp_wri.disasm = {
  buffer << "cmp.w\t" << DisasmRegister(rn) << ", " << DisasmI(imm);
};

cmp_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

/* CMN instructions */

op cmn_w( 0b111010110001[12]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: 0b1111[4]: imm0[2]: shift[2]: rm[4] );
cmn_w.var imm : {uint32_t} = {imm1|imm0}

cmn_w.disasm = {
  buffer << "cmn.w\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

cmn_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

op cmn_wri( 0b11110[5]: shl <11> imm2[1]: 0b010001[6]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: 0b1111[4]: imm0[8] );
cmn_wri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

cmn_wri.disasm = { buffer << "cmn.w\t" << DisasmRegister(rn) << ", #" << imm; };

cmn_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

/* TEQ instruction */

op teq( 0b111010101001[12]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: 0b1111[4]: imm0[2]: shift[2]: rm[4] );
teq.var imm : {uint32_t} = {imm1|imm0}

teq.disasm = {
  buffer << "teq\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

teq.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 ^ op2;
  UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op teq_wri( 0b11110[5]: shl <11> imm2[1]: 0b001001[6]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: 0b1111[4]: imm0[8] );
teq_wri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

teq_wri.disasm = { buffer << "teq\t" << DisasmRegister(rn) << ", #" << imm; };

teq_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 ^ op2;
  cpu.CPSR().Set( N, (res >> 31) & 1 );
  cpu.CPSR().Set( Z, res == 0 );
};

/* TST instructions */

op tst_w( 0b111010100001[12]: rn[4]:> <: 0b0[1]: shl<2> imm1[3]: 0b1111[4]: imm0[2]: shift[2]: rm[4] );
tst_w.var imm : {uint32_t} = {imm1|imm0}

tst_w.disasm = {
  buffer << "tst.w\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

tst_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 & op2;
  cpu.CPSR().Set( N, (res >> 31) & 1 );
  cpu.CPSR().Set( Z, res == 0 );
};

op tst_wri( 0b11110[5]: shl <11> imm2[1]: 0b000001[6]: rn[4]:> <: 0b0[1]: shl<8> imm1[3]: 0b1111[4]: imm0[8] );
tst_wri.var imm : {uint32_t} = {ThumbExpandImm( imm2|imm1|imm0 )};

tst_wri.disasm = { buffer << "tst.w\t" << DisasmRegister(rn) << ", #" << imm; };

tst_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 & op2;
  cpu.CPSR().Set( N, (res >> 31) & 1 );
  cpu.CPSR().Set( Z, res == 0 );
};

/* CLZ instructions */

op clz( 0b111110101011[12]: rm[4]:> <: 0b1111[4]: rd[4]: 0b1000[4]: ?[4] );

clz.disasm = { buffer << "clz\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm); };

clz.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  // TODO: Use a portable function...
  cpu.SetGPR( rd, __builtin_clz( cpu.GetGPR_npc( rm ) ) );
};

/* UXTA instructions */

op uxtab16( 0b111110100011[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
uxtab16.var ror : {uint32_t} = {8*ror0};

uxtab16.disasm = {
  buffer << "uxtab16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtab16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  uint16_t lo = rmval << 8, hi = rmval >> 8;
  lo >>= 8; hi >>= 8;
  lo += rnval; hi += rnval >> 16;
  cpu.SetGPR( rd, ((uint32_t)lo) | (((uint32_t)hi) << 16) );
};

op uxtab( 0b111110100101[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
uxtab.var ror : {uint32_t} = {8*ror0};

uxtab.disasm = {
  buffer << "uxtab\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtab.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rnval + ((uint32_t)((uint8_t)rmval)) );
};

op uxtah( 0b111110100001[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
uxtah.var ror : {uint32_t} = {8*ror0};
uxtah.disasm = {
  buffer << "uxtah\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtah.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rnval + ((uint32_t)((uint16_t)rmval)) );
};

/* UXT instructions */

op uxtb16( 0b1111101000111111[16]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
uxtb16.var ror : {uint32_t} = {8*ror0};
uxtb16.disasm = {
  buffer << "uxtb16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtb16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rmval & 0x00ff00ff );
};

op uxtb_w( 0b1111101001011111[16]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
uxtb_w.var ror : {uint32_t} = {8*ror0};
uxtb_w.disasm = {
  buffer << "uxtb.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtb_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, ((uint32_t)((uint8_t)rmval)) );
};

op uxth_w( 0b1111101000011111[16]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
uxth_w.var ror : {uint32_t} = {8*ror0};
uxth_w.disasm = {
  buffer << "uxth.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxth_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, (uint32_t)((uint16_t)rmval) );
};

/* STXA instructions */

op sxtab16( 0b111110100010[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
sxtab16.var ror : {uint32_t} = {8*ror0};

sxtab16.disasm = {
  buffer << "sxtab16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtab16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  int16_t lo = rmval << 8, hi = rmval >> 8;
  lo >>= 8; hi >>= 8;
  lo += rnval; hi += rnval >> 16;
  cpu.SetGPR( rd, ((uint32_t)lo) | (((uint32_t)hi) << 16) );
};

op sxtab( 0b111110100100[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
sxtab.var ror : {uint32_t} = {8*ror0};

sxtab.disasm = {
  buffer << "sxtab\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtab.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rnval + ((int32_t)((int8_t)rmval)) );
};

op sxtah( 0b111110100000[12]: rn[4]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
sxtah.var ror : {uint32_t} = {8*ror0};

sxtah.disasm = {
  buffer << "sxtah\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtah.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rnval + ((int32_t)((int16_t)rmval)) );
};

/* STX instructions */

op sxtb16( 0b1111101000101111[16]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
sxtb16.var ror : {uint32_t} = {8*ror0};

sxtb16.disasm = {
  buffer << "sxtb16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtb16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  int16_t lo = rmval << 8, hi = rmval >> 8;
  lo >>= 8; hi >>= 8;
  cpu.SetGPR( rd, (((uint32_t)hi) << 16) | ((uint32_t)hi) );
};

op sxtb_w( 0b1111101001001111[16]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
sxtb_w.var ror : {uint32_t} = {8*ror0};
sxtb_w.disasm = {
  buffer << "sxtb.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtb_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, ((int32_t)((int8_t)rmval)) );
};

op sxth_w( 0b1111101000001111[16]:> <: 0b1111[4]: rd[4]: 0b10[2]: ror0[2]: rm[4] );
sxth_w.var ror : {uint32_t} = {8*ror0};
sxth_w.disasm = {
  buffer << "sxth.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxth_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, (int32_t)((int16_t)rmval) );
};

/* UBFX instructions */

op ubfx_rrii( 0b111100111100[12]: rn[4]:> <: 0b0[1]: shl<2> lsb1[3]: rd[4]: lsb0[2]: 0b0[1]: width0[5] );
ubfx_rrii.var lsb : {uint32_t} = {lsb1|lsb0}, width : {uint32_t} = {width0+1};

ubfx_rrii.disasm = {
  buffer << "ubfx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << lsb << ", #" << width;
};

ubfx_rrii.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (((uint32_t)cpu.GetGPR_npc( rn )) << (32 - width - lsb)) >> (32 - width) );
};

/* SBFX instructions */

op sbfx_rrii( 0b111100110100[12]: rn[4]:> <: 0b0[1]: shl<2> lsb1[3]: rd[4]: lsb0[2]: 0b0[1]: width0[5] );
sbfx_rrii.var lsb : {uint32_t} = {lsb1|lsb0}, width : {uint32_t} = {width0+1};

sbfx_rrii.disasm = {
  buffer << "sbfx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << lsb << ", #" << width;
};

sbfx_rrii.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (((int32_t)cpu.GetGPR_npc( rn )) << (32 - width - lsb)) >> (32 - width) );
};

/* BF[IC] instructions (bit field insertion/clear) */

op bfi( 0b111100110110[12]: rn[4]:> <: 0b0[1]: shl<2> lsb1[3]: rd[4]: lsb0[2]: 0b0[1]: msb[5] );
op bfc( 0b111100110110[12]: 0b1111[4]:> <: 0b0[1]: shl<2> lsb1[3]: rd[4]: lsb0[2]: 0b0[1]: msb[5] );
group bf( bfi, bfc );

bf.var lsb : {uint32_t} = {lsb1|lsb0};
bf.var width : {uint32_t} = {msb-(lsb1|lsb0)+1};
bf.var clear : {uint32_t} = {~(((1 << (msb-(lsb1|lsb0)+1))-1) << (lsb1|lsb0))};

bfc.disasm = { buffer << "bfc\t" << DisasmRegister(rd) << ", #" << lsb << ", #" << width; };
bfi.disasm = { buffer << "bfi\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << lsb << ", #" << width; };

bfc.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (cpu.GetGPR( rd ) & clear) );
};

bfi.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (cpu.GetGPR( rd ) & clear) | ((cpu.GetGPR( rn ) << lsb) & ~clear) );
};

/* RBIT instruction */

op rbit( 0b111110101001[12]: rm[4]:> <: 0b1111[4]: rd[4]: 0b1010[4]: ?[4] );

rbit.disasm = { buffer << "rbit\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm); };

rbit.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t src = cpu.GetGPR( rm ), dst = 0;
  for (int idx = 0; idx < 32; ++idx) { dst = (dst << 1) | (src & 1); src >>= 1; }
  cpu.SetGPR( rd, dst );
}
