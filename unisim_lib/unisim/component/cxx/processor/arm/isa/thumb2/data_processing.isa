/*
 *  Copyright (c) 2007-2014,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr), Yves Lhuillier (yves.lhuillier@cea.fr)
 */
 
/**********************************************

        THUMB2 INTEGER INSTRUCTIONS

**********************************************/

/* MOV instructions */

op mov_wri( 0b11110[5] : shl <11> imm2[1] : 0[2] : 2[3] : s[1] : 0xf[4] :> <: 0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
mov_wri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

mov_wri.disasm = { buffer << "mov" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", #" << imm; };

mov_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t res = imm;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
    }
};

op mov_w( 0xea[8] : 2[3] : s[1] : 0xf[4] :> <: 0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
mov_w.var imm : {uint32_t} = {imm1|imm0}

mov_w.disasm = {
  buffer << "mov" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

mov_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ), res = ComputeImmShift( cpu, rmval, shift, imm );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op movt( 0b11110[5] : shl <11> imm2[1] : 0x2c[6] : shl<12> imm3[4] :> <: 0[1] : shl<8> imm1[3] : rsd[4] : imm0[8] );
movt.var imm : {uint32_t} = {imm3|imm2|imm1|imm0};

movt.disasm = { buffer << "movt\t" << DisasmRegister(rsd) << ", #" << imm; };

movt.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rsd, (cpu.GetGPR_npc( rsd ) & 0xffff) | (imm << 16) );
};

op movw( 0b11110[5] : shl <11> imm2[1] : 0x24[6] : shl<12> imm3[4] :> <: 0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
movw.var imm : {uint32_t} = {imm3|imm2|imm1|imm0};

movw.disasm = { buffer << "movw\t" << DisasmRegister(rd) << ", #" << imm; };

movw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, imm );
};

/* MVN instructions */

op mvn_w( 0xea[8] : 3[3] : s[1] : 0xf[4] :> <: 0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
mvn_w.var imm : {uint32_t} = {imm1|imm0}

mvn_w.disasm = {
  buffer << "mvn" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

mvn_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ), res = ~(ComputeImmShift( cpu, rmval, shift, imm ));
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op mvn_wri( 0b11110[5] : shl <11> imm2[1] : 0[2] : 3[3] : s[1] : 0xf[4] :> <: \
            0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
mvn_wri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

mvn_wri.disasm = { buffer << "mvn" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", #" << imm; };

mvn_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t res = ~imm;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
    }
};

/* LSL, LSR, ASR, ROR shift instructions */

op shift_w( 0xfa[8] : shift[3] : s[1] : rn[4] :> <: 0xf[4] : rd[4] : 0x0[4] : rm[4] );

shift_w.disasm = {
  buffer << "" << (sornames[shift]) << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
};

shift_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
           res = ComputeRegShift( cpu, rnval, shift, rmval );
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusRegShift( cpu, res, rnval, shift, rmval );
};

/* SUB instructions */

op sub_w( 0xeb[8] : 5[3] : s[1] : rn[4] :> <: \
          0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
sub_w.var imm : {uint32_t} = {imm1|imm0}

sub_w.disasm = {
  buffer << "sub" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

sub_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sub_wrri( 0xf[4] : 0[1] : shl <11> imm2[1] : 1[2] : 5[3] : s[1] : rn[4] :> <: 0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
sub_wrri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

sub_wrri.disasm = { buffer << "sub" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

sub_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op subs_pclri( 0xf3de[16] :> <: 0x8f[8] : imm[8] );
subs_pclri.disasm = { buffer << "subs\tpc, lr, #" << imm; };

subs_pclri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  assert( not "sure" );
  uint32_t op1 = cpu.GetGPR_npc( 14 ), op2 = imm, res = op1 - op2;
  cpu.SetGPR( 15, res );
  if (not cpu.itblock()) UpdateStatusSub( cpu, res, op1, op2 );
};

op subw( 0b11110[5]:shl<11> imm2[1]:0b101010[6]:rn[4]:> <:0[1]:shl<8> imm1[3]:rd[4]:imm0[8] );
subw.var imm : {uint32_t} = {imm2|imm1|imm0};

subw.disasm = {
  buffer << "subw\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

subw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, cpu.GetGPR(rn) - imm );
};

op adr_subw( 0b11110[5]:shl<11> imm2[1]:0b101010[6]:0b1111[4]:> <:0[1]:shl<8> imm1[3]:rd[4]:imm0[8] );
adr_subw.var imm : {uint32_t} = {imm2|imm1|imm0};

adr_subw.disasm = {
  buffer << "subw\t" << DisasmRegister(rd) << ", pc, " << DisasmI(imm);
};

adr_subw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (cpu.GetGPR(cpu.PC_reg) & -4) - imm );
};

/* SBC instructions */

op sbc_w( 0xeb[8] : 3[3] : s[1] : rn[4] :> <: \
          0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
sbc_w.var imm : {uint32_t} = {imm1|imm0}

sbc_w.disasm = {
  buffer << "sbc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

sbc_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 - op2 - (cpu.CPSR().C().Get() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op sbc_wrri( 0b11110[5] : shl <11> imm2[1] : 1[2] : 3[3] : s[1] : rn[4] :> <: \
             0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
sbc_wrri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

sbc_wrri.disasm = { buffer << "sbc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

sbc_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 - op2 - (cpu.CPSR().C().Get() ^ 1);
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/* RSB instructions */

op rsb ( 0xeb[8] : 6[3] : s[1] : rn[4] :> <: 0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
rsb.var imm : {uint32_t} = {imm1|imm0}

rsb.disasm = {
  buffer << "rsb" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

rsb.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR_npc( rn ),
           res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

op rsb_rri ( 0xf[4] : 0[1] : shl <11> imm2[1] : 1[2] : 6[3] : s[1] : rn[4] :> <: 0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
rsb_rri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

rsb_rri.disasm = {
  buffer << "rsb" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

rsb_rri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = imm, op2 = cpu.GetGPR_npc( rn ), res = op1 - op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusSub( cpu, res, op1, op2 );
};

/* ADD instructions */

op add_w( 0xeb[8] : 0[3] : s[1] : rn[4] :> <: 0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
add_w.var imm : {uint32_t} = {imm1|imm0}

add_w.disasm = {
  buffer << "add" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

add_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op add_wrri( 0xf[4] : 0[1] : shl <11> imm2[1] : 1[2]: 0[3] : s[1] : rn[4] :> <: 0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
add_wrri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

add_wrri.disasm = { buffer << "add" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

add_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 + op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op addw( 0b11110[5]:shl<11> imm2[1]:0b100000[6]:rn[4]:> <:0[1]:shl<8> imm1[3]:rd[4]:imm0[8] );
addw.var imm : {uint32_t} = {imm2|imm1|imm0};

addw.disasm = {
  buffer << "addw\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
};

addw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, cpu.GetGPR(rn) + imm );
};

op adr_addw( 0b11110[5]:shl<11> imm2[1]:0b100000[6]:0b1111[4]:> <:0[1]:shl<8> imm1[3]:rd[4]:imm0[8] );
adr_addw.var imm : {uint32_t} = {imm2|imm1|imm0};

adr_addw.disasm = {
  buffer << "addw\t" << DisasmRegister(rd) << ", pc, " << DisasmI(imm);
};

adr_addw.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (cpu.GetGPR(cpu.PC_reg) & -4) + imm );
};

/* ADC instructions */

op adc_w( 0xeb[8] : 2[3] : s[1] : rn[4] :> <: 0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
adc_w.var imm : {uint32_t} = {imm1|imm0}

adc_w.disasm = {
  buffer << "adc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

adc_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 + op2 + cpu.CPSR().C().Get();
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

op adc_wrri( 0b11110[5] : shl <11> imm2[1] : 1[2] : 2[3] : s[1] : rn[4] :> <: \
             0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
adc_wrri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

adc_wrri.disasm = { buffer << "adc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

adc_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 + op2 + cpu.CPSR().C().Get();
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusAdd( cpu, res, op1, op2 );
};

/* EOR instructions */
op eor_w( 0xea[8] : 4[3] : s[1] : rn[4] :> <: 0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
eor_w.var imm : {uint32_t} = {imm1|imm0}

eor_w.disasm = {
  buffer << "eor" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

eor_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op eor_wrri( 0b11110[5] : shl <11> imm2[1] : 0[2] : 4[3] : s[1] : rn[4] :> <: 0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
eor_wrri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

eor_wrri.disasm = { buffer << "eor" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

eor_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 ^ op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
    }
};

/* ORN instructions */

op orn( 0xea[8] : 3[3] : s[1] : rn[4] :> <: 0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
orn.var imm : {uint32_t} = {imm1|imm0}

orn.disasm = {
  buffer << "orn" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

orn.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 | ~op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op orn_rri( 0b11110[5] : shl <11> imm2[1] : 0[2] : 3[3] : s[1] : rn[4] :> <: \
            0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
orn_rri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

orn_rri.disasm = { buffer << "orn" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm; };

orn_rri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 | ~op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
    }
};


/* ORR instructions */

op orr_w( 0xea[8] : 2[3] : s[1] : rn[4] :> <: 0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
orr_w.var  imm : {uint32_t} = {imm1|imm0}

orr_w.disasm = {
  buffer << "orr" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

orr_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op orr_wrri(  0b11110[5] : shl <11> imm2[1] : 0[2] : 2[3] : s[1] : rn[4] :> <: 0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
orr_wrri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

orr_wrri.disasm = {
  buffer << "orr" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

orr_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 | op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
    }
};

/* NEGS instruction */

/* BIC instructions */

op bic_w( 0xea[8] : 1[3] : s[1] : rn[4] :> <: \
          0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
bic_w.var imm : {uint32_t} = {imm1|imm0}

bic_w.disasm = {
  buffer << "bic" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

bic_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op bic_wrri( 0b11110[5] : shl <11> imm2[1] : 0[2] : 1[3] : s[1] : rn[4] :> <: \
             0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
bic_wrri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

bic_wrri.disasm = {
  buffer << "bic.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

bic_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 & ~op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
    }
};

/* AND instructions */

op and_w( 0xea[8] : 0[3] : s[1] : rn[4] :> <: 0[1] : shl<2> imm1[3] : rd[4] : imm0[2] : shift[2] : rm[4] );
and_w.var imm : {uint32_t} = {imm1|imm0}

and_w.disasm = {
  buffer << "and" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

and_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op and_wrri( 0b11110[5] : shl <11> imm2[1] : 0[2] : 0[3] : s[1] : rn[4] :> <: \
             0[1] : shl<8> imm1[3] : rd[4] : imm0[8] );
and_wrri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

and_wrri.disasm = {
  buffer << "and" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << imm;
};

and_wrri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 & op2;
  cpu.SetGPR( rd, res );
  if (s)
    {
      cpu.CPSR().N().Set( (res >> 31) & 1 );
      cpu.CPSR().Z().Set( res == 0 );
    }
};

/* CMP instructions */

op cmp_w( 0xebb[12] : rn[4] :> <: 0[1] : shl<2> imm1[3] : 0xf[4] : imm0[2] : shift[2] : rm[4] );
cmp_w.var imm : {uint32_t} = {imm1|imm0}

cmp_w.disasm = {
  buffer << "cmp.w\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

cmp_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

op cmp_wri( 0b11110[5] : shl <11> imm2[1] : 0x1b[6] : rn[4] :> <: 0[1] : shl<8> imm1[3] : 0xf[4] : imm0[8] );
cmp_wri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

cmp_wri.disasm = {
  buffer << "cmp.w\t" << DisasmRegister(rn) << ", " << DisasmI(imm);
};

cmp_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 - op2;
  UpdateStatusSub( cpu, res, op1, op2 );
};

/* CMN instructions */

op cmn_w( 0xeb1[12] : rn[4] :> <: 0[1] : shl<2> imm1[3] : 0xf[4] : imm0[2] : shift[2] : rm[4] );
cmn_w.var imm : {uint32_t} = {imm1|imm0}

cmn_w.disasm = {
  buffer << "cmn.w\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

cmn_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

op cmn_wri( 0b11110[5] : shl <11> imm2[1] : 0x11[6] : rn[4] :> <: 0[1] : shl<8> imm1[3] : 0xf[4] : imm0[8] );
cmn_wri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

cmn_wri.disasm = { buffer << "cmn.w\t" << DisasmRegister(rn) << ", #" << imm; };

cmn_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 + op2;
  UpdateStatusAdd( cpu, res, op1, op2 );
};

/* TEQ instruction */

op teq( 0xea9[12] : rn[4] :> <: 0[1] : shl<2> imm1[3] : 0xf[4] : imm0[2] : shift[2] : rm[4] );
teq.var imm : {uint32_t} = {imm1|imm0}

teq.disasm = {
  buffer << "teq\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

teq.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm ),
           op1 = cpu.GetGPR_npc( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
           res = op1 ^ op2;
  UpdateStatusImmShift( cpu, res, rmval, shift, imm );
};

op teq_wri( 0b11110[5] : shl <11> imm2[1] : 0x09[6] : rn[4] :> <: 0[1] : shl<8> imm1[3] : 0xf[4] : imm0[8] );
teq_wri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

teq_wri.disasm = { buffer << "teq\t" << DisasmRegister(rn) << ", #" << imm; };

teq_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 ^ op2;
  cpu.CPSR().N().Set( (res >> 31) & 1 );
  cpu.CPSR().Z().Set( res == 0 );
};

/* TST instructions */

op tst_w( 0xea1[12] : rn[4] :> <: 0[1] : shl<2> imm1[3] : 0xf[4] : imm0[2] : shift[2] : rm[4] );
tst_w.var imm : {uint32_t} = {imm1|imm0}

tst_w.disasm = {
  buffer << "tst.w\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  buffer << DisasmShImm( shift, imm );
};

tst_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t
    op1 = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm ),
    op2 = ComputeImmShift( cpu, rmval, shift, imm ),
    res = op1 & op2;
  cpu.CPSR().N().Set( (res >> 31) & 1 );
  cpu.CPSR().Z().Set( res == 0 );
};

op tst_wri( 0b11110[5] : shl <11> imm2[1] : 0x01[6] : rn[4] :> <: 0[1] : shl<8> imm1[3] : 0xf[4] : imm0[8] );
tst_wri.var imm : {uint32_t} = {imm_w( imm2|imm1|imm0 )};

tst_wri.disasm = { buffer << "tst.w\t" << DisasmRegister(rn) << ", #" << imm; };

tst_wri.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t op1 = cpu.GetGPR_npc( rn ), op2 = imm, res = op1 & op2;
  cpu.CPSR().N().Set( (res >> 31) & 1 );
  cpu.CPSR().Z().Set( res == 0 );
};

/* CLZ instructions */

op clz( 0xfab[12] : rm[4] :> <: 0xf[4] : rd[4] : 0x8[4] : ?[4] );

clz.disasm = { buffer << "clz\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm); };

clz.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, __builtin_clzl( cpu.GetGPR_npc( rm ) ) );
};

/* UXTA instructions */

op uxtab16( 0xfa3[12] : rn[4] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
uxtab16.var ror : {uint32_t} = {8*ror0};

uxtab16.disasm = {
  buffer << "uxtab16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtab16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  uint16_t lo = rmval << 8, hi = rmval >> 8;
  lo >>= 8; hi >>= 8;
  lo += rnval; hi += rnval >> 16;
  cpu.SetGPR( rd, ((uint32_t)lo) | (((uint32_t)hi) << 16) );
};

op uxtab( 0xfa5[12] : rn[4] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
uxtab.var ror : {uint32_t} = {8*ror0};

uxtab.disasm = {
  buffer << "uxtab\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtab.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rnval + ((uint32_t)((uint8_t)rmval)) );
};

op uxtah( 0xfa1[12] : rn[4] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
uxtah.var ror : {uint32_t} = {8*ror0};
uxtah.disasm = {
  buffer << "uxtah\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtah.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rnval + ((uint32_t)((uint16_t)rmval)) );
};

/* UXT instructions */

op uxtb16( 0xfa3f[16] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
uxtb16.var ror : {uint32_t} = {8*ror0};
uxtb16.disasm = {
  buffer << "uxtb16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtb16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rmval & 0x00ff00ff );
};

op uxtb_w( 0xfa5f[16] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
uxtb_w.var ror : {uint32_t} = {8*ror0};
uxtb_w.disasm = {
  buffer << "uxtb.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxtb_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, ((uint32_t)((uint8_t)rmval)) );
};

op uxth_w( 0xfa1f[16] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
uxth_w.var ror : {uint32_t} = {8*ror0};
uxth_w.disasm = {
  buffer << "uxth.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

uxth_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, (uint32_t)((uint16_t)rmval) );
};

/* STXA instructions */

op sxtab16( 0xfa2[12] : rn[4] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
sxtab16.var ror : {uint32_t} = {8*ror0};

sxtab16.disasm = {
  buffer << "sxtab16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtab16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  int16_t lo = rmval << 8, hi = rmval >> 8;
  lo >>= 8; hi >>= 8;
  lo += rnval; hi += rnval >> 16;
  cpu.SetGPR( rd, ((uint32_t)lo) | (((uint32_t)hi) << 16) );
};

op sxtab( 0xfa4[12] : rn[4] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
sxtab.var ror : {uint32_t} = {8*ror0};

sxtab.disasm = {
  buffer << "sxtab\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtab.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rnval + ((int32_t)((int8_t)rmval)) );
};

op sxtah( 0xfa0[12] : rn[4] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
sxtah.var ror : {uint32_t} = {8*ror0};

sxtah.disasm = {
  buffer << "sxtah\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtah.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rnval = cpu.GetGPR_npc( rn ), rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, rnval + ((int32_t)((int16_t)rmval)) );
};

/* STX instructions */

op sxtb16( 0xfa2f[16] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
sxtb16.var ror : {uint32_t} = {8*ror0};

sxtb16.disasm = {
  buffer << "sxtb16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtb16.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  int16_t lo = rmval << 8, hi = rmval >> 8;
  lo >>= 8; hi >>= 8;
  cpu.SetGPR( rd, (((uint32_t)hi) << 16) | ((uint32_t)hi) );
};

op sxtb_w( 0xfa4f[16] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
sxtb_w.var ror : {uint32_t} = {8*ror0};
sxtb_w.disasm = {
  buffer << "sxtb.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxtb_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, ((int32_t)((int8_t)rmval)) );
};

op sxth_w( 0xfa0f[16] :> <: 0xf[4] : rd[4] : 2[2] : ror0[2] : rm[4] );
sxth_w.var ror : {uint32_t} = {8*ror0};
sxth_w.disasm = {
  buffer << "sxth.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
  if (ror) buffer << ", ror #" << ror;
};

sxth_w.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t rmval = cpu.GetGPR_npc( rm );
  rmval = (rmval >> ror) | (rmval << (32-ror));
  cpu.SetGPR( rd, (int32_t)((int16_t)rmval) );
};

/* UBFX instructions */

op ubfx_rrii( 0xf3c[12] : rn[4] :> <: 0[1] : shl<2> lsb1[3] : rd[4] : lsb0[2] : 0[1] : width0[5] );
ubfx_rrii.var lsb : {uint32_t} = {lsb1|lsb0}, width : {uint32_t} = {width0+1};

ubfx_rrii.disasm = {
  buffer << "ubfx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << lsb << ", #" << width;
};

ubfx_rrii.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (((uint32_t)cpu.GetGPR_npc( rn )) << (32 - width - lsb)) >> (32 - width) );
};

/* SBFX instructions */

op sbfx_rrii( 0xf34[12] : rn[4] :> <: 0[1] : shl<2> lsb1[3] : rd[4] : lsb0[2] : 0[1] : width0[5] );
sbfx_rrii.var lsb : {uint32_t} = {lsb1|lsb0}, width : {uint32_t} = {width0+1};

sbfx_rrii.disasm = {
  buffer << "sbfx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << lsb << ", #" << width;
};

sbfx_rrii.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (((int32_t)cpu.GetGPR_npc( rn )) << (32 - width - lsb)) >> (32 - width) );
};

/* BF[IC] instructions (bit field insertion/clear) */

op bfi( 0xf36[12] : rn[4] :> <: 0[1] : shl<2> lsb1[3] : rd[4] : lsb0[2] : 0[1] : msb[5] );
op bfc( 0xf36[12] : 0xf[4] :> <: 0[1] : shl<2> lsb1[3] : rd[4] : lsb0[2] : 0[1] : msb[5] );
group bf( bfi, bfc );

bf.var lsb : {uint32_t} = {lsb1|lsb0};
bf.var width : {uint32_t} = {msb-(lsb1|lsb0)+1};
bf.var clear : {uint32_t} = {~(((1 << (msb-(lsb1|lsb0)+1))-1) << (lsb1|lsb0))};

bfc.disasm = { buffer << "bfc\t" << DisasmRegister(rd) << ", #" << lsb << ", #" << width; };
bfi.disasm = { buffer << "bfi\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", #" << lsb << ", #" << width; };

bfc.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (cpu.GetGPR( rd ) & clear) );
};

bfi.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  cpu.SetGPR( rd, (cpu.GetGPR( rd ) & clear) | ((cpu.GetGPR( rn ) << lsb) & ~clear) );
};

/* RBIT instruction */

op rbit( 0xfa9[12] : rm[4] :> <: 0xf[4] : rd[4] : 0xa[4] : ?[4] );

rbit.disasm = { buffer << "rbit\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm); };

rbit.execute = {
  if (not CheckCondition(cpu, cpu.itcond())) return;
  
  uint32_t src = cpu.GetGPR( rm ), dst = 0;
  for (int idx = 0; idx < 32; ++idx) { dst = (dst << 1) | (src & 1); src >>= 1; }
  cpu.SetGPR( rd, dst );
}
