/*
 *  Copyright (c) 2007-2020,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, 
 *     this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific 
 *     prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 *  ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY 
 *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Yves Lhuillier (yves.lhuillier@cea.fr)
 */

/* Read State Register Instructions */

op rdasr( 0b10[2]:rd[5]:0b101000[6]:rs1[5]:?[1]:?[13] )

rdasr.disasm = {
  if (rs1 == 0)                    sink << "rd %y, %r" << rd;
  else if (rs1 == 15 and rd == 0)  sink << "stbar";
  else                             sink << "rd %asr" << rs1 << ", %r" << rd;
}

rdasr.execute = {
  if (rs1 == 0) // unpriviledged
    {
      cpu.m_gpr[rd] = cpu.m_y;
      return;
    }
  if (rs1 >= 16 )
    {
      if (not cpu.asr_perm( rs1 ))
        cpu.abort( Trap_t::privileged_instruction );
      cpu.m_gpr[rd] = cpu.rdasr( rs1 );
      return;
    }
  if (rs1 == 15 and rd == 0) // TODO: stbar
    {
      cpu.abort( Trap_t::illegal_instruction );
      return;
    }
  cpu.abort( Trap_t::illegal_instruction );
}

op rdpsr( 0b10[2]:rd[5]:0b101001[6]:?[5]:?[1]:?[13] )

rdpsr.disasm = {
  sink << "rd %psr, %r" << rd;
}

rdpsr.execute = {
  if (not cpu.super())
    cpu.abort( Trap_t::privileged_instruction );
  
  cpu.m_gpr[rd] = cpu.m_psr;
}

op rdwim( 0b10[2]:rd[5]:0b101010[6]:?[5]:?[1]:?[13] )

rdwim.disasm = {
  sink << "rd %wim, %r" << rd;
}

rdwim.execute = {
  if (not cpu.super())
     cpu.abort( Trap_t::privileged_instruction );

  cpu.m_gpr[rd] = cpu.m_wim & uint32_t((uint64_t( 1 ) << cpu.nwindows())-1);
}

op rdtbr( 0b10[2]:rd[5]:0b101011[6]:?[5]:?[1]:?[13] )

rdtbr.disasm = {
  sink << "rd %tbr, %r" << rd;
}

rdtbr.execute = {
  if (not cpu.super())
     cpu.abort( Trap_t::privileged_instruction );

  cpu.m_gpr[rd] = cpu.m_tbr;
}

/* Write State Register Instructions */

op wrasr( 0b10[2]:rd[5]:0b110000[6]:rs1[5]:0b0[1]:?[8]:rs2[5] )

wrasr.disasm = {
  if( rd == 0 )  sink << "wr %r" << rs1 << ", %r" << rs2 << ", %y";
  else           sink << "wr %r" << rs1 << ", %r" << rs2 << ", %asr" << rd;
}

wrasr.execute = {
  if (rd == 0) // unpriviledged
    {
      cpu.m_y = cpu.m_gpr[rs1] ^ cpu.m_gpr[rs2];
      return;
    }
  else if( rd >= 16 )
    {
      if (not cpu.asr_perm( rd ))
        cpu.abort( Trap_t::privileged_instruction );
      cpu.wrasr( rd, cpu.m_gpr[rs1] ^ cpu.m_gpr[rs2] );
      return;
    }
  cpu.abort( Trap_t::illegal_instruction );    
}

op wrasri( 0b10[2]:rd[5]:0b110000[6]:rs1[5]:0b1[1]:sext<32> simm13[13] )

wrasri.disasm = {
  if( rd == 0 )  sink << "wr %r" << rs1 << ", " << simm13 << ", %y";
  else           sink << "wr %r" << rs1 << ", " << simm13 << ", %asr" << rd;
}

wrasri.execute = {
  if (rd == 0) // unpriviledged
    {
      cpu.m_y = cpu.m_gpr[rs1] ^ simm13;
      return;
    }
  if (rd >= 16)
    {
      if (not cpu.asr_perm( rd ))
        cpu.abort( Trap_t::privileged_instruction );
      cpu.wrasr( rd, cpu.m_gpr[rs1] ^ simm13 );
      return;
    }
  cpu.abort( Trap_t::illegal_instruction );
}

op wrpsr( 0b10[2]:?[5]:0b110001[6]:rs1[5]:0b0[1]:?[8]:rs2[5] )

wrpsr.disasm = {
  sink << "wr %r" << rs1 << ", %r" << rs2 << ", %psr";
}

wrpsr.execute = {
  if (not cpu.super())
     cpu.abort( Trap_t::privileged_instruction );

  uint32_t res = cpu.m_gpr[rs1] ^ cpu.m_gpr[rs2];
  
  if ((res & 0x1f) >= cpu.nwindows())
    cpu.abort( Trap_t::illegal_instruction );
  
  cpu.m_psr = res;
}

op wrpsri( 0b10[2]:?[5]:0b110001[6]:rs1[5]:0b1[1]:sext<32> simm13[13] )

wrpsri.disasm = {
  sink << "wr %r" << rs1 << ", " << simm13 << ", %psr";
}

wrpsri.execute = {
  if (not cpu.super())
     cpu.abort( Trap_t::privileged_instruction );

  uint32_t res = cpu.m_gpr[rs1] ^ simm13;
  if ((res & 0x1f) >= cpu.nwindows())
    cpu.abort( Trap_t::illegal_instruction );
  
  cpu.m_psr = res;
}

op wrwim( 0b10[2]:?[5]:0b110010[6]:rs1[5]:0b0[1]:?[8]:rs2[5] )

wrwim.disasm = {
  sink << "wr %r" << rs1 << ", %r" << rs2 << ", %wim";
}

wrwim.execute = {
  if (not cpu.super())
     cpu.abort( Trap_t::privileged_instruction );

  cpu.m_wim = (cpu.m_gpr[rs1] ^ cpu.m_gpr[rs2]) & uint32_t((uint64_t( 1 ) << cpu.nwindows())-1);
}

op wrwimi( 0b10[2]:?[5]:0b110010[6]:rs1[5]:0b1[1]:sext<32> simm13[13] )

wrwimi.disasm = {
  sink << "wr %r" << rs1 << ", " << simm13 << ", %wim";
}

wrwimi.execute = {
  if (not cpu.super())
     cpu.abort( Trap_t::privileged_instruction );

  cpu.m_wim = (cpu.m_gpr[rs1] ^ simm13) & uint32_t((uint64_t( 1 ) << cpu.nwindows())-1);
}

op wrtbr( 0b10[2]:?[5]:0b110011[6]:rs1[5]:0b0[1]:?[8]:rs2[5] )

wrtbr.disasm = {
  sink << "wr %r" << rs1 << ", %r" << rs2 << ", %tbr";
}

wrtbr.execute = {
  if (not cpu.super())
     cpu.abort( Trap_t::privileged_instruction );

  cpu.m_tbr = (cpu.m_gpr[rs1] ^ cpu.m_gpr[rs2]);
}

op wrtbri( 0b10[2]:?[5]:0b110011[6]:rs1[5]:0b1[1]:sext<32> simm13[13] )

wrtbri.disasm = {
  sink << "wr %r" << rs1 << ", " << simm13 << ", %tbr";
}

wrtbri.execute = {
  if (not cpu.super())
     cpu.abort( Trap_t::privileged_instruction );

  cpu.m_tbr = (cpu.m_gpr[rs1] ^ simm13) & uint32_t((uint64_t( 1 ) << cpu.nwindows())-1);
}

/* Unimplemented Instruction */

op unimp( 0b00[2]:?[5]:0b000[3]:const22[22] )

unimp.disasm = {
  sink << "unimp " << const22;
}

unimp.execute = {
  cpu.abort( Trap_t::illegal_instruction );
}
