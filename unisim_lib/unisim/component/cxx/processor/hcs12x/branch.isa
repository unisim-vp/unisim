/*
 *  Copyright (c) 2008,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
 */


// TODO: Very Important
// relied to instruction Queue  
// Do not forgot to perform three program word fetches to refill the queue after a branch or subroutine call

/* ********* Short Branch Instructions ******** */

op sbr(0x2[4]:sel[4]:sext<8> rel8[8])

sbr.var branch : { bool } = { false }

sbr.getCycles = { 

	if (branch) return 3; else return 1;

}

sbr.disasm = {
	
	switch (sel) {
		case 0x0: sink << "BRA ";break;
		case 0x1: sink << "BRN ";break;
		case 0x2: sink << "BHI ";break;
		case 0x3: sink << "BLS ";break;
		case 0x4: sink << "BCC "; /* same opcode for BHS */ break;
		case 0x5: sink << "BCS "; /* same opcode for BLO */ break;
		case 0x6: sink << "BNE ";break;
		case 0x7: sink << "BEQ ";break;
		case 0x8: sink << "BVC ";break;
		case 0x9: sink << "BVS ";break;
		case 0xA: sink << "BPL ";break;
		case 0xB: sink << "BMI ";break;
		case 0xC: sink << "BGE ";break;
		case 0xD: sink << "BLT ";break;
		case 0xE: sink << "BGT ";break;
		case 0xF: sink << "BLE ";break;
	}
	sink << std::dec << rel8;
}

sbr.execute = {
	
	branch = false;
	
	switch (sel) {
		case 0x0: // BRA: branch always
			branch = true;
			break;
		case 0x1: // BRN: branch never
			// Nothing to do
			branch = false;
			break;
		case 0x2: // BHI: branch if higher (C+Z=0)
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 0) branch = true; 
			break;
		case 0x3: // BLS: branch if lower or same 
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 1) branch = true;
			break;
		case 0x4: // BCC: branch if carel8y clear or BHS: branch if higher or same
			if (cpu->ccr->getC() == 0) branch = true;
			break;
		case 0x5: // BCS: branch if carel8y set or BLO: branch if lower 
			if (cpu->ccr->getC() == 1) branch = true;
			break;
		case 0x6: // BNE: branch if not equal
			if (cpu->ccr->getZ() == 0) branch = true;
			break;
		case 0x7: // BEQ: branch if equal
			if (cpu->ccr->getZ() == 1) branch = true; 
			break;
		case 0x8: // BVC: branch if overflow clear
			if (cpu->ccr->getV() == 0) branch = true; 
			break;
		case 0x9: // BVS: branch if overflow set
			if (cpu->ccr->getV() == 1) branch = true; 
			break;
		case 0xA: // BPL: branch if plus
			if (cpu->ccr->getN() == 0) branch = true;
			break;
		case 0xB: // BMI: branch if minus
			if (cpu->ccr->getN() == 1) branch = true; 
			break;
		case 0xC: // BGE: branch if greater than or equal
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 0) branch = true; 
			break;
		case 0xD: // BLT: branch if less than
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 1) branch = true; 
			break;
		case 0xE: { // BGT: branch if greater than 
				if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 0) branch = true; 
			}
			break;
		case 0xF: // BLE: branch if less than or equal
			if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 1) branch = true; 
			break;
	}
	
	if (branch) {
		cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
		
	 	// TODO: Refill the instruction queue with three program words from the new address
	}
}

/* ******** Long Branch Instructions ******* */

op lbr(0x18[8]:0x2[4]:sel[4]:sext<16> rel16[16])

lbr.var branch : { bool } = { false }

lbr.getCycles = { if (branch) return 4; else return 3; }

lbr.disasm = {
	
	switch (sel) {
		case 0x0: sink << "LBRA ";break;
		case 0x1: sink << "LBRN ";break;
		case 0x2: sink << "LBHI ";break;
		case 0x3: sink << "LBLS ";break;
		case 0x4: sink << "LBCC "; /* same opcode for LBHS */ break;
		case 0x5: sink << "LBCS "; /* same opcode for LBLO */ break;
		case 0x6: sink << "LBNE ";break;
		case 0x7: sink << "LBEQ ";break;
		case 0x8: sink << "LBVC ";break;
		case 0x9: sink << "LBVS ";break;
		case 0xA: sink << "LBPL ";break;
		case 0xB: sink << "LBMI ";break;
		case 0xC: sink << "LBGE ";break;
		case 0xD: sink << "LBLT ";break;
		case 0xE: sink << "LBGT ";break;
		case 0xF: sink << "LBLE ";break;
	}
	sink << std::dec << rel16;
}

lbr.execute = {
	
	branch = false;
	
	switch (sel) {
		case 0x0: // LBRA: branch always
			branch = true;
			break;
		case 0x1: // LBRN: branch never
			// Nothing to do
			branch = false;
			break;
		case 0x2: // LBHI: branch if higher (C+Z=0)
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 0) branch = true; 
			break;
		case 0x3: // LBLS: branch if lower or same 
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 1) branch = true;
			break;
		case 0x4: // LBCC: branch if carel8y clear or LBHS: branch if higher or same
			if (cpu->ccr->getC() == 0) branch = true;
			break;
		case 0x5: // LBCS: branch if carel8y set or LBLO: branch if lower 
			if (cpu->ccr->getC() == 1) branch = true;
			break;
		case 0x6: // LBNE: branch if not equal
			if (cpu->ccr->getZ() == 0) branch = true;
			break;
		case 0x7: // LBEQ: branch if equal
			if (cpu->ccr->getZ() == 1) branch = true; 
			break;
		case 0x8: // LBVC: branch if overflow clear
			if (cpu->ccr->getV() == 0) branch = true; 
			break;
		case 0x9: // LBVS: branch if overflow set
			if (cpu->ccr->getV() == 1) branch = true; 
			break;
		case 0xA: // LBPL: branch if plus
			if (cpu->ccr->getN() == 0) branch = true;
			break;
		case 0xB: // LBMI: branch if minus
			if (cpu->ccr->getN() == 1) branch = true; 
			break;
		case 0xC: // LBGE: branch if greater than or equal
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 0) branch = true; 
			break;
		case 0xD: // LBLT: branch if less than
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 1) branch = true; 
			break;
		case 0xE: // LBGT: branch if greater than
			if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 0) branch = true; 
			break;
		case 0xF: // LBLE: branch if less than or equal
			if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 1) branch = true; 
			break;
	}
	
	if (branch) {
		cpu->setRegPC((int16_t) cpu->getRegPC() + rel16);
		
	 	// TODO: Refill the instruction queue with three program words from the new address		
	}
}

/* ******** Bit Condition Branch instructions *********** */

// if (b==1) BRCLR_instruction else BRSET_instruction;

op br_clr_set_dir(0x27[7]:b[1]:opr8a[8]:msk8[8]:sext<8> rel8[8])

br_clr_set_dir.getCycles = { return 4; }

br_clr_set_dir.disasm = {
	if (b==1) {
		sink << "BRCLR 0x"; 
	} else {
		sink << "BRSET 0x";
	}
	
	sink << std::hex << opr8a << ", 0x" << std::hex << msk8 << ", " << std::dec << rel8;
}

br_clr_set_dir.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	uint8_t opr8aVal = cpu->memRead8(addr);
	
	if (b==0) {
		opr8aVal = ~opr8aVal;
	}
	
	if ((opr8aVal & msk8) == 0) {
		cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
		
	 	// TODO: Refill the instruction queue with three program words from the new address		
	}
}

op br_clr_set_ext(0xF[7]:b[1]:> <:opr16a[16]:msk8[8]:sext<8> rel8[8])

br_clr_set_ext.getCycles = { return 5; }

br_clr_set_ext.disasm = {
	if (b==1) {
		sink << "BRCLR 0x"; 
	} else {
		sink << "BRSET 0x";
	}
	
	sink << std::hex << opr16a << ", 0x" << std::hex << msk8 << ", " << std::dec << rel8;
}

br_clr_set_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t opr16aVal = cpu->memRead8(addr);
	
	if (b==0) {
		opr16aVal = ~opr16aVal;
	}
	
	if ((opr16aVal & msk8) == 0) {
		cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
		
	 	// TODO: Refill the instruction queue with three program words from the new address		
	}
}

op br_clr_set_idx(0x07[7]:b[1]:> <:*xb[XB]:> <:msk8[8]:sext<8> rel8[8])

br_clr_set_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 0, 0); }

br_clr_set_idx.disasm = {
	if (b==1) {
		sink << "BRCLR "; 
	} else {
		sink << "BRSET ";
	}
	
	xb->disasm(sink);
	sink << ", 0x" << std::hex << msk8 << ", " << std::dec << rel8;
}

br_clr_set_idx.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t xbVal = cpu->memRead8(addr);
	
	if (b==0) {
		xbVal = ~xbVal;
	}
	
	if ((xbVal & msk8) == 0) {
		cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
		
	 	// TODO: Refill the instruction queue with three program words from the new address		
	}
}

/* ********** Jump and subroutine instructions ******** */

// BSR: Branch to subroutine
op bsr(0x07[8]:rel8[8])

bsr.getCycles = { return 4; }

bsr.disasm = {
	sink << "BSR " << std::dec << rel8;
}

bsr.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * Subroutine address fi PC
	 */
	physical_address_t addr;	
	
	cpu->setRegSP(cpu->getRegSP()-2);
	
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
	
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
	
 	// TODO: Refill the instruction queue with three program words from the new address	
}

// CALL: Call subroutine in Expanded Memory
op call_ext(0x4A[8]:opr16a[16]:page[8])

call_ext.getCycles = { return 7; }

call_ext.disasm = {
	sink << "CALL 0x" << std::hex << opr16a << ", 0x" << std::hex << page;
}

call_ext.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * (SP)-1 => SP
	 * (PPAGE) => M[SP]
	 * page => PPAGE
	 * Subroutine address => PC
	 * TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
	 */
	physical_address_t addr;
		 
	cpu->setRegSP(cpu->getRegSP()-2);
	
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));

	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));

	cpu->setRegSP(cpu->getRegSP()-1);
	
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, cpu->mmc->getPpage());

	cpu->mmc->setPpage(page);
	cpu->setRegPC(opr16a);

	// TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
}

// I have to decode indexed-indirect addressing here, 
// because in the case of indexed-indirect the value of PPAGE is stored in memory after the subroutine address
// XB decoder return only one address

op call_16offset_idx_ind(0x4B[8]:> <:0b111[3]:rr[2]:0b0[1]:0b11[2]:> <:sext<16> n16[16])

call_16offset_idx_ind.getCycles = { return 10; }

call_16offset_idx_ind.disasm = {

	sink << "CALL ";
	sink << "[" << std::dec << n16 << "," << CPU::xb_getAddrRegLabel(rr) << "]";
}

call_16offset_idx_ind.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * (SP)-1 => SP
	 * (PPAGE) => M[SP]
	 * page => PPAGE
	 * Subroutine address => PC
 	 * TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
	 */

	physical_address_t addr;
		 
	cpu->setRegSP(cpu->getRegSP()-2);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegSP(cpu->getRegSP()-1);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, cpu->mmc->getPpage());

	physical_address_t idxAddr = cpu->mmc->getPhysicalAddress(cpu->xb_getAddrRegValue(rr) + n16, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

	address_t subAddr = cpu->memRead16(idxAddr);
	uint8_t   ppageVal = cpu->memRead16(idxAddr+2);

	cpu->mmc->setPpage(ppageVal);
	cpu->setRegPC(subAddr);

	// TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
}

op call_accD_offset_idx_ind(0x4B[8]:> <:0b111[3]:rr[2]:0b111[3])

call_accD_offset_idx_ind.getCycles = { return 10; }

call_accD_offset_idx_ind.disasm = {

	sink << "CALL ";
	sink << "[D," << CPU::xb_getAddrRegLabel(rr) << "]";
}

call_accD_offset_idx_ind.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * (SP)-1 => SP
	 * (PPAGE) => M[SP]
	 * page => PPAGE
	 * Subroutine address => PC
 	 * TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
	 */

	physical_address_t addr;
		 
	cpu->setRegSP(cpu->getRegSP()-2);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegSP(cpu->getRegSP()-1);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, cpu->mmc->getPpage());

	physical_address_t idxAddr = cpu->mmc->getPhysicalAddress(cpu->getRegD() + cpu->xb_getAddrRegValue(rr), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

	address_t subAddr = cpu->memRead16(idxAddr);
	uint8_t   ppageVal = cpu->memRead16(idxAddr+2);

	cpu->mmc->setPpage(ppageVal);
	cpu->setRegPC(subAddr);

	// TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
}

op call_idx(0x4B[8]:> <:*xb[XB]:> <:page[8])

call_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 7, 7, 8, 0, 0); }

call_idx.disasm = {
	sink << "CALL ";
	xb->disasm(sink);
	sink << ", 0x" << std::hex << page;
}

call_idx.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * (SP)-1 => SP
	 * (PPAGE) => M[SP]
	 * page => PPAGE
	 * Subroutine address => PC
 	 * TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
	 */
	physical_address_t addr;
		 
	cpu->setRegSP(cpu->getRegSP()-2);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegSP(cpu->getRegSP()-1);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, cpu->mmc->getPpage());

	cpu->mmc->setPpage(page);
	cpu->setRegPC(xb->getEAddr(cpu));

	// TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
}

// JMP: JUMP
op jmp_ext(0x06[8]:> <:opr16a[16])

jmp_ext.getCycles = { return 3; }

jmp_ext.disasm = {
	sink << "JMP 0x" << std::hex << opr16a;
}

jmp_ext.execute = {
	cpu->setRegPC(opr16a);
	
 	// TODO: Refill the instruction queue with three program words from the new address
}

op jmp_idx(0x05[8]:> <:*xb[XB])

jmp_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }

jmp_idx.disasm = {
	sink << "JMP ";
	xb->disasm(sink);
}

jmp_idx.execute = {
	cpu->setRegPC(xb->getEAddr(cpu));

 	// TODO: Refill the instruction queue with three program words from the new address
}

// JSR: Jump to subroutine
op jsr_dir(0x17[8]:opr8a[8])

jsr_dir.getCycles = { return 4; }

jsr_dir.disasm = {
	sink << "JSR 0x" << std::hex << opr8a;
}

jsr_dir.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * subroutine address => PC
	 */
	physical_address_t addr;
		 
	cpu->setRegSP(cpu->getRegSP()-2);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	cpu->setRegPC((address_t) addr);

 	// TODO: Refill the instruction queue with three program words from the new address
}

op jsr_ext(0x16[8]:> <:opr16a[16])

jsr_ext.getCycles = { return 4; }

jsr_ext.disasm = {
	sink << "JSR 0x" << std::hex << opr16a;
}

jsr_ext.execute = {
	physical_address_t addr;

	cpu->setRegSP(cpu->getRegSP()-2);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegPC(opr16a);

 	// TODO: Refill the instruction queue with three program words from the new address
}

op jsr_idx(0x15[8]:> <:*xb[XB])

jsr_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }

jsr_idx.disasm = {
	sink << "JSR ";
	xb->disasm(sink);
}

jsr_idx.execute = {
	physical_address_t addr;
	
	cpu->setRegSP(cpu->getRegSP()-2);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegPC(xb->getEAddr(cpu));

 	// TODO: Refill the instruction queue with three program words from the new address
}

// RTC: Return from call
op rtc(0x0A[8])

rtc.getCycles = { return 7; }

rtc.disasm = {
	sink << "RTC";
}

rtc.execute = {
	/*
	 * (M[SP]) => PPage
	 * (SP)+1 => SP
	 * (M[SP]):(M[SP+1]) => PCh:PCl
	 * (SP)+2 => SP
 	 * TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)	 
	 */

	 uint8_t hByte, lByte;
	 physical_address_t addr;
	 
	 addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	 cpu->mmc->setPpage(cpu->memRead8(addr));
	 cpu->setRegSP(cpu->getRegSP() + 1);
	 
	 addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	 hByte = cpu->memRead8(addr);
	 addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
	 lByte = cpu->memRead8(addr);
	 cpu->setRegPC(((uint16_t) hByte << 8) | (0x00FF & lByte));
	 
	 cpu->setRegSP(cpu->getRegSP() + 2);
	 
 	 // TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)	 
}

// RTS: Return from subroutine
op rts(0x3D[8])

rts.getCycles = { return 5; }

rts.disasm = {
	sink << "RTS";
}

rts.execute = {
	uint8_t hByte, lByte;
	physical_address_t addr;

	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS); 
	hByte = cpu->memRead8(addr);
	addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS); 
	lByte = cpu->memRead8(addr);
	cpu->setRegPC(((uint16_t) hByte << 8) | (0x00FF & lByte));
	 
	cpu->setRegSP(cpu->getRegSP() + 2);
}


/* ************ Loop Primitive ********* */

op loop(0x04[8]:b765[3]:b4[1]:b3[1]:b210[3]:> <:sext<8> rel9[8])

loop.var isBranch : { bool } = { false }

loop.getCycles = { if (isBranch) return 3; else return 3; }

loop.disasm = {
/*
Encoding for lb is summarized in the following table. 
Bit 3 is not used (don’t care), 
Bit 5 selects branch on zero (DBEQ – 0) or not zero (DBNE – 1) versions, 
and bit 4 is the sign bit of the 9-bit relative offset. 
Bits 7 and 6 would be 0:0 for DBNE.
*/
	uint8_t abdxys = (b765 << 5) | (b4 << 4) | (b3 << 3) | b210;
	
	switch (b765) {
		case 0x00: sink << "DBEQ "; break;
		case 0x01: sink << "DBNE "; break;
		case 0x02: sink << "TBEQ "; break;
		case 0x03: sink << "TBNE "; break;
		case 0x04: sink << "IBEQ "; break;
		case 0x05: sink << "IBNE "; break;
		default: sink << "??? ";
	}
	
	sink << EBLB::getRegName(b210) << " , " << std::dec << rel9;
}

loop.execute = {
	address_t branchAddr;
	
	isBranch = false;

	branchAddr = cpu->getRegPC() + rel9;
	
	switch (b765) {
		case 0x00: /*DBEQ*/{
			uint16_t val; 
			if (b210 < 0x4) {
				val = cpu->eblb->getter<uint8_t>(b210);
				if (val != 0) { val = val - 1;}
				cpu->eblb->setter<uint8_t>(b210, val);
			} else {
				val = cpu->eblb->getter<uint16_t>(b210);
				if (val != 0) { val = val - 1;}
				cpu->eblb->setter<uint16_t>(b210, val);
			}
			isBranch = (val == 0);
		} break;
		case 0x01: /*DBNE*/{
			uint16_t val; 
			if (b210 < 0x4) {
				val = cpu->eblb->getter<uint8_t>(b210);
				if (val != 0) { val = val - 1;}
				cpu->eblb->setter<uint8_t>(b210, val);
			} else {
				val = cpu->eblb->getter<uint16_t>(b210);
				if (val != 0) { val = val - 1;}
				cpu->eblb->setter<uint16_t>(b210, val);
			}
			isBranch = (val != 0);
			
		} break;
		case 0x02: /*TBEQ*/{
			isBranch = (cpu->eblb->getter<uint8_t>(b210) == 0);
		} break;
		case 0x03: /*TBNE*/{
			isBranch = (cpu->eblb->getter<uint8_t>(b210) != 0);
		} break;
		case 0x04: /*IBEQ*/{
			uint16_t val; 
			if (b210 < 0x4) {
				val = cpu->eblb->getter<uint8_t>(b210);
				if (val != 0) { val = val + 1;}
				cpu->eblb->setter<uint8_t>(b210, val);
			} else {
				val = cpu->eblb->getter<uint16_t>(b210);
				if (val != 0) { val = val + 1;}
				cpu->eblb->setter<uint16_t>(b210, val);
			}
			isBranch = (val == 0);

		} break;
		case 0x05: /*IBNE*/{
			uint16_t val; 
			if (b210 < 0x4) {
				val = cpu->eblb->getter<uint8_t>(b210);
				if (val != 0) { val = val + 1;}
				cpu->eblb->setter<uint8_t>(b210, val);
			} else {
				val = cpu->eblb->getter<uint16_t>(b210);
				if (val != 0) { val = val + 1;}
				cpu->eblb->setter<uint16_t>(b210, val);
			}
			isBranch = (val != 0);

		} break;
		default: /*???*/;
	}
	
	if (isBranch) {
		cpu->setRegPC(branchAddr);

	 	// TODO: Refill the instruction queue with three program words from the new address
	}
	
}





