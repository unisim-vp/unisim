// -*- C++ -*-

// TODO: Very Important
// relied to instruction Queue  
// Do not forgot to perform three program word fetches to refill the queue after a branch or subroutine call

/* ********* Short Branch Instructions ******** */

op sbr(0x2[4]:sel[4]:sext<8> rel8[8])

sbr.disasm = {
	
	switch (sel) {
		case 0x0: sink << "BRA ";break;
		case 0x1: sink << "BRN ";break;
		case 0x2: sink << "BHI ";break;
		case 0x3: sink << "BLS ";break;
		case 0x4: sink << "BCC "; /* same opcode for BHS */ break;
		case 0x5: sink << "BCS "; /* same opcode for BLO */ break;
		case 0x6: sink << "BNE ";break;
		case 0x7: sink << "BEQ ";break;
		case 0x8: sink << "BVC ";break;
		case 0x9: sink << "BVS ";break;
		case 0xA: sink << "BPL ";break;
		case 0xB: sink << "BMI ";break;
		case 0xC: sink << "BGE ";break;
		case 0xD: sink << "BLT ";break;
		case 0xE: sink << "BGT ";break;
		case 0xF: sink << "BLE ";break;
	}
	sink << rel8;
}

sbr.execute = {
	bool branch = false;
	
	switch (sel) {
		case 0x0: // BRA: branch always
			branch = true;
			break;
		case 0x1: // BRN: branch never
			// Nothing to do
			break;
		case 0x2: // BHI: branch if higher (C+Z=0)
			if (cpu->ccr->getC()+cpu->ccr->getZ() == 0) branch = true; 
			break;
		case 0x3: // BLS: branch if lower or same 
			if (cpu->ccr->getC()+cpu->ccr->getZ() == 1) branch = true;
			break;
		case 0x4: // BCC: branch if carel8y clear or BHS: branch if higher or same
			if (cpu->ccr->getC() == 0) branch = true;
			break;
		case 0x5: // BCS: branch if carel8y set or BLO: branch if lower 
			if (cpu->ccr->getC() == 1) branch = true;
			break;
		case 0x6: // BNE: branch if not equal
			if (cpu->ccr->getZ() == 0) branch = true;
			break;
		case 0x7: // BEQ: branch if equal
			if (cpu->ccr->getZ() == 1) branch = true; 
			break;
		case 0x8: // BVC: branch if overflow clear
			if (cpu->ccr->getV() == 0) branch = true; 
			break;
		case 0x9: // BVS: branch if overflow set
			if (cpu->ccr->getV() == 1) branch = true; 
			break;
		case 0xA: // BPL: branch if plus
			if (cpu->ccr->getN() == 0) branch = true;
			break;
		case 0xB: // BMI: branch if minus
			if (cpu->ccr->getN() == 1) branch = true; 
			break;
		case 0xC: // BGE: branch if greater than or equal
			if (cpu->ccr->getN() ^ cpu->ccr->getV() == 0) branch = true; 
			break;
		case 0xD: // BLT: branch if less than
			if (cpu->ccr->getN() ^ cpu->ccr->getV() == 1) branch = true; 
			break;
		case 0xE: // BGT: branch if greater than
			if (cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV()) == 0) branch = true; 
			break;
		case 0xF: // BLE: branch if less than or equal
			if (cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV()) == 1) branch = true; 
			break;
	}
	
	if (branch) cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
}

/* ******** Long Branch Instructions ******* */

op lbr(0x18[8]:0x2[4]:sel[4]:sext<16> rel16[16])

lbr.disasm = {
	
	switch (sel) {
		case 0x0: sink << "LBRA ";break;
		case 0x1: sink << "LBRN ";break;
		case 0x2: sink << "LBHI ";break;
		case 0x3: sink << "LBLS ";break;
		case 0x4: sink << "LBCC "; /* same opcode for LBHS */ break;
		case 0x5: sink << "LBCS "; /* same opcode for LBLO */ break;
		case 0x6: sink << "LBNE ";break;
		case 0x7: sink << "LBEQ ";break;
		case 0x8: sink << "LBVC ";break;
		case 0x9: sink << "LBVS ";break;
		case 0xA: sink << "LBPL ";break;
		case 0xB: sink << "LBMI ";break;
		case 0xC: sink << "LBGE ";break;
		case 0xD: sink << "LBLT ";break;
		case 0xE: sink << "LBGT ";break;
		case 0xF: sink << "LBLE ";break;
	}
	sink << rel16;
}

lbr.execute = {
	bool branch = false;
	
	switch (sel) {
		case 0x0: // LBRA: branch always
			branch = true;
			break;
		case 0x1: // LBRN: branch never
			// Nothing to do
			break;
		case 0x2: // LBHI: branch if higher (C+Z=0)
			if (cpu->ccr->getC()+cpu->ccr->getZ() == 0) branch = true; 
			break;
		case 0x3: // LBLS: branch if lower or same 
			if (cpu->ccr->getC()+cpu->ccr->getZ() == 1) branch = true;
			break;
		case 0x4: // LBCC: branch if carel8y clear or LBHS: branch if higher or same
			if (cpu->ccr->getC() == 0) branch = true;
			break;
		case 0x5: // LBCS: branch if carel8y set or LBLO: branch if lower 
			if (cpu->ccr->getC() == 1) branch = true;
			break;
		case 0x6: // LBNE: branch if not equal
			if (cpu->ccr->getZ() == 0) branch = true;
			break;
		case 0x7: // LBEQ: branch if equal
			if (cpu->ccr->getZ() == 1) branch = true; 
			break;
		case 0x8: // LBVC: branch if overflow clear
			if (cpu->ccr->getV() == 0) branch = true; 
			break;
		case 0x9: // LBVS: branch if overflow set
			if (cpu->ccr->getV() == 1) branch = true; 
			break;
		case 0xA: // LBPL: branch if plus
			if (cpu->ccr->getN() == 0) branch = true;
			break;
		case 0xB: // LBMI: branch if minus
			if (cpu->ccr->getN() == 1) branch = true; 
			break;
		case 0xC: // LBGE: branch if greater than or equal
			if (cpu->ccr->getN() ^ cpu->ccr->getV() == 0) branch = true; 
			break;
		case 0xD: // LBLT: branch if less than
			if (cpu->ccr->getN() ^ cpu->ccr->getV() == 1) branch = true; 
			break;
		case 0xE: // LBGT: branch if greater than
			if (cpu->ccr->getZ()+(cpu->ccr->getN() ^ cpu->ccr->getV()) == 0) branch = true; 
			break;
		case 0xF: // LBLE: branch if less than or equal
			if (cpu->ccr->getZ()+(cpu->ccr->getN() ^ cpu->ccr->getV()) == 1) branch = true; 
			break;
	}
	
	if (branch) cpu->setRegPC((int16_t) cpu->getRegPC() + rel16);
}

/* ******** Bit Condition Branch instructions *********** */

// if (b==1) BRCLR_instruction else BRSET_instruction;

op br_clr_set_dir(0x27[7]:b[1]:opr8a[8]:msk8[8]:sext<8> rel8[8])

br_clr_set_dir.disasm = {
	if (b==1) {
		sink << "BRCLR $"; 
	} else {
		sink << "BRSET $";
	}
	
	sink << std::hex << opr8a << ", $" << std::hex << msk8 << ", " << rel8;
}

br_clr_set_dir.execute = {
	uint8_t opr8aVal = cpu->memRead8(opr8a,MEMORY::DIRECT);
	
	if (b==0) {
		opr8aVal = ~opr8aVal;
	}
	
	if (opr8aVal & msk8 == 0) {
		cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
	}
}

op br_clr_set_ext(0xF[7]:b[1]:> <:opr16a[16]:msk8[8]:sext<8> rel8[8])

br_clr_set_ext.disasm = {
	if (b==1) {
		sink << "BRCLR $"; 
	} else {
		sink << "BRSET $";
	}
	
	sink << std::hex << opr16a << ", $" << std::hex << msk8 << ", " << rel8;
}

br_clr_set_ext.execute = {
	uint8_t opr16aVal = cpu->memRead8(opr16a);
	
	if (b==0) {
		opr16aVal = ~opr16aVal;
	}
	
	if (opr16aVal & msk8 == 0) {
		cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
	}
}

op br_clr_set_idx(0x3[7]:b[1]:> <:*xb[XB]:> <:msk8[8]:sext<8> rel8[8])

br_clr_set_idx.disasm = {
	if (b==1) {
		sink << "BRCLR "; 
	} else {
		sink << "BRSET ";
	}
	
	xb->disasm(sink);
	sink << ", $" << std::hex << msk8 << ", " << rel8;
}

br_clr_set_idx.execute = {
	uint8_t xbVal = cpu->memRead8(xb->getEAddr(cpu));
	
	if (b==0) {
		xbVal = ~xbVal;
	}
	
	if (xbVal & msk8 == 0) {
		cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
	}
}

/* ********** Jump and subroutine instructions ******** */

// BSR: Branch to subroutine
op bsr(0x07[8]:rel8[8])

bsr.disasm = {
	sink << "BSR " << rel8;
}

bsr.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * Subroutine address fi PC
	 */

	cpu->setRegSP(cpu->getRegSP()-2);
	cpu->memWrite8(cpu->getRegSP(), (uint8_t) (cpu->getRegPC() >> 8));
	cpu->memWrite8(cpu->getRegSP()+1, (uint8_t) (cpu->getRegPC() & 0x00FF));
	cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);
}

// CALL: Call subroutine in Expanded Memory
op call_ext(0x4A[8]:opr16a[16]:page[8])

call_ext.disasm = {
	sink << "CALL $" << std::hex << opr16a << ", $" << std::hex << page;
}

call_ext.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * (SP)-1 => SP
	 * (PPAGE) => M[SP]
	 * page => PPAGE
	 * Subroutine address => PC
	 */
	 
	cpu->setRegSP(cpu->getRegSP()-2);
	cpu->memWrite8(cpu->getRegSP(), (uint8_t) (cpu->getRegPC() >> 8));
	cpu->memWrite8(cpu->getRegSP()+1, (uint8_t) (cpu->getRegPC() & 0x00FF));

	cpu->setRegSP(cpu->getRegSP()-1);
	cpu->memWrite8(cpu->getRegSP(), cpu->mmc->getPpage());
	cpu->mmc->setPpage(page);
	cpu->setRegPC(opr16a);
}

op call_idx(0x4B[8]:> <:*xb[XB]:> <:page[8])

call_idx.disasm = {
	sink << "CALL ";
	xb->disasm(sink);
	sink << ", $" << std::hex << page;
}

call_idx.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * (SP)-1 => SP
	 * (PPAGE) => M[SP]
	 * page => PPAGE
	 * Subroutine address => PC
	 */
	 
	cpu->setRegSP(cpu->getRegSP()-2);
	cpu->memWrite8(cpu->getRegSP(), (uint8_t) (cpu->getRegPC() >> 8));
	cpu->memWrite8(cpu->getRegSP()+1, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegSP(cpu->getRegSP()-1);
	cpu->memWrite8(cpu->getRegSP(), cpu->mmc->getPpage());
	cpu->mmc->setPpage(page);
	cpu->setRegPC(xb->getEAddr(cpu));
}

// JMP: JUMP
op jmp_ext(0x06[8]:> <:opr16a[16])

jmp_ext.disasm = {
	sink << "JMP $" << std::hex << opr16a;
}

jmp_ext.execute = {
	cpu->setRegPC(opr16a);
}

op jmp_idx(0x05[8]:> <:*xb[XB])

jmp_idx.disasm = {
	sink << "JMP ";
	xb->disasm(sink);
}

jmp_idx.execute = {
	cpu->setRegPC(xb->getEAddr(cpu));
}

// JSR: Jump to subroutine
op jsr_dir(0x17[8]:opr8a[8])

jsr_dir.disasm = {
	sink << "JSR $" << std::hex << opr8a;
}

jsr_dir.execute = {
	/*
	 * (SP)-2 => SP
	 * RTNh:RTNl => M[SP]:M[SP+1]
	 * subroutine address => PC
	 */
	cpu->setRegSP(cpu->getRegSP()-2);
	cpu->memWrite8(cpu->getRegSP(), (uint8_t) (cpu->getRegPC() >> 8));
	cpu->memWrite8(cpu->getRegSP()+1, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegPC(cpu->mmc->getDirectAddress(opr8a));
}

op jsr_ext(0x16[8]:> <:opr16a[16])

jsr_ext.disasm = {
	sink << "JSR $" << std::hex << opr16a;
}

jsr_ext.execute = {
	cpu->setRegSP(cpu->getRegSP()-2);
	cpu->memWrite8(cpu->getRegSP(), (uint8_t) (cpu->getRegPC() >> 8));
	cpu->memWrite8(cpu->getRegSP()+1, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegPC(opr16a);
}

op jsr_idx(0x15[8]:> <:*xb[XB])

jsr_idx.disasm = {
	sink << "JSR ";
	xb->disasm(sink);
}

jsr_idx.execute = {
	cpu->setRegSP(cpu->getRegSP()-2);
	cpu->memWrite8(cpu->getRegSP(), (uint8_t) (cpu->getRegPC() >> 8));
	cpu->memWrite8(cpu->getRegSP()+1, (uint8_t) (cpu->getRegPC() & 0x00FF));
	
	cpu->setRegPC(xb->getEAddr(cpu));
}

// RTC: Return from call
op rtc(0x0A[8])

rtc.disasm = {
	sink << "RTC";
}

rtc.execute = {
	/*
	 * (M[SP]) => PPage
	 * (SP)+1 => SP
	 * (M[SP]):(M[SP+1]) => PCh:PCl
	 * (SP)+2 => SP
	 */

	 uint8_t hByte, lByte;
	 
	 cpu->mmc->setPpage(cpu->memRead8(cpu->getRegSP()));
	 cpu->setRegSP(cpu->getRegSP() + 1);
	 
	 hByte = cpu->memRead8(cpu->getRegSP());
	 lByte = cpu->memRead8(cpu->getRegSP()+1);
	 cpu->setRegPC(((uint16_t) hByte << 8) | (0x00FF & lByte));
	 
	 cpu->setRegSP(cpu->getRegSP() + 2);
}

// RTS: Return from subroutine
op rts(0x3D[8])

rts.disasm = {
	sink << "RTS";
}

rts.execute = {
	 uint8_t hByte, lByte;

	 hByte = cpu->memRead8(cpu->getRegSP());
	 lByte = cpu->memRead8(cpu->getRegSP()+1);
	 cpu->setRegPC(((uint16_t) hByte << 8) | (0x00FF & lByte));
	 
	 cpu->setRegSP(cpu->getRegSP() + 2);
}


/* ************ Loop Primitive ********* */

op loop(0x04[8]:b765[3]:b4[1]:b3[1]:b210[3]:> <:sext<8> rel9[8])

loop.disasm = {
/*
Encoding for lb is summarized in the following table. 
Bit 3 is not used (don’t care), 
Bit 5 selects branch on zero (DBEQ – 0) or not zero (DBNE – 1) versions, 
and bit 4 is the sign bit of the 9-bit relative offset. 
Bits 7 and 6 would be 0:0 for DBNE.
*/
	uint8_t abdxys = (b765 << 5) | (b4 << 4) | (b3 << 3) | b210;
	
	switch (b765) {
		case 0x00: sink << "DBEQ "; break;
		case 0x01: sink << "DBNE "; break;
		case 0x02: sink << "TBEQ "; break;
		case 0x03: sink << "TBNE "; break;
		case 0x04: sink << "IBEQ "; break;
		case 0x05: sink << "IBNE "; break;
		default: sink << "??? ";
	}
	
	sink << EBLB::getRegName(b210) << " , " << std::dec << rel9;
}

loop.execute = {
	address_t branchAddr;

	branchAddr = cpu->getRegPC() + rel9;
	
	switch (b765) {
		case 0x00: /*DBEQ*/{
			uint16_t val; 
			if (b210 < 0x4) {
				val = cpu->eblb->getter<uint8_t>(b210);
				if (val != 0) { val = val - 1;}
				cpu->eblb->setter<uint8_t>(b210, val);
			} else {
				val = cpu->eblb->getter<uint16_t>(b210);
				if (val != 0) { val = val - 1;}
				cpu->eblb->setter<uint16_t>(b210, val);
			}
			if (val == 0) cpu->setRegPC(branchAddr);
			
		} break;
		case 0x01: /*DBNE*/{
			uint16_t val; 
			if (b210 < 0x4) {
				val = cpu->eblb->getter<uint8_t>(b210);
				if (val != 0) { val = val - 1;}
				cpu->eblb->setter<uint8_t>(b210, val);
			} else {
				val = cpu->eblb->getter<uint16_t>(b210);
				if (val != 0) { val = val - 1;}
				cpu->eblb->setter<uint16_t>(b210, val);
			}
			if (val != 0) cpu->setRegPC(branchAddr);
			
		} break;
		case 0x02: /*TBEQ*/{
			if (cpu->eblb->getter<uint8_t>(b210) == 0) cpu->setRegPC(branchAddr);
		} break;
		case 0x03: /*TBNE*/{
			if (cpu->eblb->getter<uint8_t>(b210) != 0) cpu->setRegPC(branchAddr);
		} break;
		case 0x04: /*IBEQ*/{
			uint16_t val; 
			if (b210 < 0x4) {
				val = cpu->eblb->getter<uint8_t>(b210);
				if (val != 0) { val = val + 1;}
				cpu->eblb->setter<uint8_t>(b210, val);
			} else {
				val = cpu->eblb->getter<uint16_t>(b210);
				if (val != 0) { val = val + 1;}
				cpu->eblb->setter<uint16_t>(b210, val);
			}
			if (val == 0) cpu->setRegPC(branchAddr);

		} break;
		case 0x05: /*IBNE*/{
			uint16_t val; 
			if (b210 < 0x4) {
				val = cpu->eblb->getter<uint8_t>(b210);
				if (val != 0) { val = val + 1;}
				cpu->eblb->setter<uint8_t>(b210, val);
			} else {
				val = cpu->eblb->getter<uint16_t>(b210);
				if (val != 0) { val = val + 1;}
				cpu->eblb->setter<uint16_t>(b210, val);
			}
			if (val != 0) cpu->setRegPC(branchAddr);

		} break;
		default: /*???*/;
	}
	
}





