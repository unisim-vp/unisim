// -*- C++ -*-

// A->B  or B->A 
op t_ab_ba(0x18[8]:0x7[7]:b[1])

t_ab_ba.disasm = {
	if (b == 0) { sink << "TAB"; } else { sink << "TBA";} 
}

t_ab_ba.execute = {
	int8_t val;
	
	if (b == 0) {
		val = cpu->getRegA();
		cpu->setRegB(val);
	} else {
		val = cpu->getRegB();
		cpu->setRegA(val);
	}
	
// CRC flags 0->V; setZ; setN
	cpu->ccr->setV(0);
	if (val == 0) {cpu->ccr->setZ(1);} else {cpu->ccr->setZ(0);}
	if (val < 0) { cpu->ccr->setN(1);} else { cpu->ccr->setN(0); }
}

// ****************  Common Section to HCS12X ( HLS = 0 ) *************
// *************** HCS12 - EXCHANGE Instructions ************

// XGDX or XGDY or EXG 
op exg_hcs12(0xB7[8]:> <:0b1[1]:lms[3]:0b0[1]:lls[3])  
/*
 * lms sourceRegister index
 * lls destinationRegister index  
 * */
exg_hcs12.disasm = {

	uint8_t rrSrc, rrDst;

	// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
	switch (lms) {
		case EB::EBMSLSRegs::CCR: rrSrc = EB::EBRegs::CCRL; break; // src is 0x21 register
		case EB::EBMSLSRegs::TMPx: rrSrc = EB::EBRegs::TMP3; break; // src is 0x32 register
		default: rrSrc = lms;  
	}

	switch (lls) {
		case EB::EBMSLSRegs::CCR: rrDst = EB::EBRegs::CCRL; break; // dst is 0x21 register
		case EB::EBMSLSRegs::TMPx: rrDst = EB::EBRegs::TMP2; break; // dst is 0x31 register
		default: rrDst = lls;    
	}

	// Exchange register Contents. There is no sign extension
	uint8_t eb = (1 << 8) | (lms << 4) | (0 << 3) | lls;
	
	switch (eb) 
	{
		case 0xC5: sink << "XGDX "; break;
		case 0xC6: sink << "XGDY "; break;
		default: sink << "EXG ";
	}
	
	sink << EB::getRegName(rrSrc) << "," << EB::getRegName(rrDst); 

}

exg_hcs12.execute = {
/* Legal "rr" value for EB::setter and EB::getter functions 
 * 0x00:A; 0x01:B; 
 * 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRW
 * 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
 * 0x04:D; 0x05:X; 0x06:Y; 0x07:SP  
 */

	uint8_t srcSize, dstSize; 
	uint8_t rrSrc, rrDst;
	
	// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
	switch (lms) {
		case EB::EBMSLSRegs::CCR: rrSrc = EB::EBRegs::CCRL; break; // src is 0x21 register
		case EB::EBMSLSRegs::TMPx: rrSrc = EB::EBRegs::TMP3; break; // src is 0x32 register
		default: rrSrc = lms;  
	}

	switch (lls) {
		case EB::EBMSLSRegs::CCR: rrDst = EB::EBRegs::CCRL; break; // dst is 0x21 register
		case EB::EBMSLSRegs::TMPx: rrDst = EB::EBRegs::TMP2; break; // dst is 0x31 register
		default: rrDst = lls;    
	}
		
	srcSize = EB::getRegSize(rrSrc);
	dstSize = EB::getRegSize(rrDst);
	
	// Exchange register Contents. EXG r1, r2 
	// There is no sign extension
	// Only CCR[7:0] is used for HCS12

	if (srcSize == dstSize) {
		// (r1) <=> (r2)
		if (srcSize == 8) {
			cpu->eb->exchange<uint8_t>(rrSrc, rrDst);
		} else {
			cpu->eb->exchange<uint16_t>(rrSrc, rrDst);
		}
	} 
	else if (((srcSize == 8) || (lms == 2)) && (dstSize == 16)) {
		// $00:(r1) => r2 
		// if r2 isn't D then && (r2[7:0]) => r1
		uint16_t r1Val = 0x00FF & cpu->eb->getter<uint8_t>(rrSrc);
		uint8_t r2Val = (uint8_t) cpu->eb->getter<uint16_t>(rrDst); // only low 8 bits
		cpu->eb->setter<uint16_t>(rrDst, r1Val);
		if (rrDst != 4 /* reg D*/) {
			cpu->eb->setter<uint16_t>(rrDst, r2Val);			
		} 
	}
	else if ((srcSize == 16) && (dstSize == 8)) {
		// (r1[7:0]) => (r2)
		// if r2 is A then $00:(r2) => r1 else $FF:(r2) => r1
		uint8_t r1Val = cpu->eb->getter<uint16_t>(rrSrc); // only low 8 bits
		uint8_t r2Val = cpu->eb->getter<uint8_t>(rrDst);
		
		cpu->eb->setter<uint8_t>(rrDst,r1Val);
		if (rrDst == 0 /*reg A*/) {
			cpu->eb->setter<uint16_t>(rrSrc, 0x00FF & r2Val);
		} else {
			cpu->eb->setter<uint16_t>(rrSrc, 0xFF00 | r2Val);
		}
	}
	
}

// ***************************  TRANSFER Instructions

// TAP or TFR or TPA or TSX or TSY or TXS or TYS or SEX
op tfr_hcs12(0xB7[8]:> <:0b0[1]:lms[3]:hls[1]:lls[3])  
/*
 * lms sourceRegister index
 * lls destinationRegister index  
 * */
tfr_hcs12.disasm = {

	uint8_t rrSrc, rrDst;

	// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
	switch (lms) {
		case EB::EBMSLSRegs::CCR: rrSrc = EB::EBRegs::CCRL; break; // src is 0x21 register
		case EB::EBMSLSRegs::TMPx: rrSrc = EB::EBRegs::TMP3; break; // src is 0x32 register
		default: rrSrc = lms;  
	}

	switch (lls) {
		case EB::EBMSLSRegs::CCR: rrDst = EB::EBRegs::CCRL; break; // dst is 0x21 register
		case EB::EBMSLSRegs::TMPx: rrDst = EB::EBRegs::TMP2; break; // dst is 0x31 register
		default: rrDst = lls;    
	}

	// Transfer Register Content to Another register
	uint8_t eb = (0 << 8) | (lms << 4) | (0 << 3) | lls;
	
	switch (eb) 
	{
		case 0x02: sink << "TAP "; break;
		case 0x20: sink << "TPA "; break;
		case 0x75: sink << "TSX "; break;
		case 0x76: sink << "TSY "; break;
		case 0x57: sink << "TXS "; break;
		case 0x67: sink << "TYS "; break;
		default: sink << "TFR ";
	}
	
	sink << EB::getRegName(rrSrc) << "," << EB::getRegName(rrDst); 

}


tfr_hcs12.execute = {
/* Legal "rr" value for EB::setter and EB::getter functions 
 * 0x00:A; 0x01:B; 
 * 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRW 
 * 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
 * 0x04:D; 0x05:X; 0x06:Y; 0x07:SP  
 */

	uint8_t srcSize, dstSize; 
	uint8_t rrSrc, rrDst;
	
	// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
	switch (lms) {
		case EB::EBMSLSRegs::CCR: rrSrc = EB::EBRegs::CCRL; break; // src is 0x21 register
		case EB::EBMSLSRegs::TMPx: rrSrc = EB::EBRegs::TMP3; break; // src is 0x32 register
		default: rrSrc = lms;  
	}

	switch (lls) {
		case EB::EBMSLSRegs::CCR: rrDst = EB::EBRegs::CCRL; break; // dst is 0x21 register
		case EB::EBMSLSRegs::TMPx: rrDst = EB::EBRegs::TMP2; break; // dst is 0x31 register
		default: rrDst = lls;    
	}
		
	srcSize = EB::getRegSize(rrSrc);
	dstSize = EB::getRegSize(rrDst);

	// Transfer Register Content to Another register
	// Only CCR[7:0] is used for HCS12

	/*
	if (sizeof(r1) && sizeof(r2) { (r1) => (r2)}
	else if ( (sizeof(r1)==8) && (sizeof(r2)==16) ) {sex:r1 => r2}
	else if ( (sizeof(r1)==16) && (sizeof(r2)==8) ) { (r1[7:0]) => (r2) }
	*/  

	if (srcSize == dstSize) {
		// (r1) => (r2)
		if (srcSize == 8) {
			cpu->eb->setter<uint8_t>(rrDst, cpu->eb->getter<uint8_t>(rrSrc));
		} else {
			cpu->eb->setter<uint16_t>(rrDst, cpu->eb->getter<uint16_t>(rrSrc));
		}
	} 
	else if (((srcSize == 8) || (lms == 2)) && (dstSize == 16)) {
		// sex:r1 => r2
		if ((cpu->eb->getter<uint8_t>(rrSrc) & 0x80) == 0x80)  
		{ // if r1 bit 7 = 1 then $FF:(r1) => r2
			cpu->eb->setter<uint16_t>(rrDst, ((uint16_t) cpu->eb->getter<uint8_t>(rrSrc)) | 0xFF00);
		} else 
		{ // if r1 bit 7 = 1 then $00:(r1) => r2
			cpu->eb->setter<uint16_t>(rrDst, ((uint16_t) cpu->eb->getter<uint8_t>(rrSrc)) & 0x00FF);
		}  
	}
	else if ((srcSize == 16) && (dstSize == 8)) {
		// (r1[7:0]) => (r2)
		uint8_t tmp = cpu->eb->getter<uint16_t>(rrSrc) & 0x00FF;
		cpu->eb->setter<uint8_t>(rrDst, tmp);
	}
	
}

// ****************  Specific Section to HCS12X ( HLS = 1 ) *************

// ***************  HCS12X - EXCHANGE Instructions ************

// XGDX or XGDY or EXG 
op exg_hcs12x(0xB7[8]:> <:0b1[1]:lms[3]:0b1[1]:lls[3])  
/*
 * lms sourceRegister index
 * lls destinationRegister index  
 * */
exg_hcs12x.disasm = {

	uint8_t rrSrc, rrDst;

	// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
	switch (lms) {
		case EB::EBMSLSRegs::CCR: // src is CCRW register
			if (lls == EB::EBMSLSRegs::A) {
				rrSrc = EB::EBRegs::CCRH; //0x22;
			} else if (lls = EB::EBMSLSRegs::B) {
				rrSrc = EB::EBRegs::CCRL; //0x21;
			} else {
				rrSrc = EB::EBRegs::CCRW; //0x23;
			}
			break; 
		case EB::EBMSLSRegs::TMPx: // src is TMP register
			if (lls = EB::EBMSLSRegs::D) {
				rrSrc = EB::EBRegs::TMP1; //0x30; // TMP1
			} else {
				rrSrc = EB::EBRegs::TMP3; //0x32; // TMP3
			}
			break; 
		default: rrSrc = lms;  
	}

	switch (lls) {
		case EB::EBMSLSRegs::CCR: // dst is CCRW register
			if (lms == EB::EBMSLSRegs::A) {
				rrDst = EB::EBRegs::CCRH; //0x22;
			} else if (lms == EB::EBMSLSRegs::B) {
				rrDst = EB::EBRegs::CCRL; //0x21;
			} else {
				rrDst = EB::EBRegs::CCRW; //0x23;
			}

			break; 
		case EB::EBMSLSRegs::TMPx: // dst is TMP2 register
			if (lms == EB::EBRegs::D ) {
				rrDst = EB::EBRegs::TMP1; //0x30; // TMP1
			} else {
				rrDst = EB::EBRegs::TMP2; //0x31; // TMP2
			}
			break; 
		default: rrDst = lls;    
	}
	
 	// Exchange register Contents. There is no sign extension
	
	string srcName = EB::getRegName(rrSrc);
	string dstName = EB::getRegName(rrDst);
	
	if (lls == EB::EBMSLSRegs::A ) {
		if (lms == EB::EBMSLSRegs::CCR ) {
			srcName = EB::getRegName(EB::EBRegs::CCRH);  
		} 
		else if ((lms != EB::EBMSLSRegs::B ) && (lms != EB::EBMSLSRegs::D)) {
			srcName = srcName + "H";
		} 
	} if (lls == EB::EBMSLSRegs::B) {
		if (lms == EB::EBMSLSRegs::CCR) {
			srcName = EB::getRegName(EB::EBRegs::CCRL);  
		} 
		else if ((lms != EB::EBMSLSRegs::A ) && (lms != EB::EBMSLSRegs::D)) {
			srcName = srcName + "L";
		} 
	} 

	if (lms == EB::EBMSLSRegs::A) {
		if (lls == EB::EBMSLSRegs::CCR /* reg CCR */) {
			dstName = EB::getRegName(EB::EBRegs::CCRH);  
		} 
		else if ((lls != EB::EBMSLSRegs::B) && (lls != EB::EBMSLSRegs::D)) {
			dstName = dstName + "H";
		} 
	} if (lms == EB::EBMSLSRegs::B) {
		if (lls == EB::EBMSLSRegs::CCR) {
			dstName = EB::getRegName(EB::EBRegs::CCRL);  
		} 
		else if ((lls != EB::EBMSLSRegs::A) && (lls != EB::EBMSLSRegs::D)) {
			dstName = dstName + "L";
		} 
	} 

	// Exchange Registers Contents
	uint8_t eb = (1 << 8) | (lms << 4) | (1 << 3) | lls;
	
	switch (eb) 
	{
		case 0xC5: sink << "XGDX "; break;
		case 0xC6: sink << "XGDY "; break;
		default: sink << "EXG ";
	}
	
	sink << srcName << "," << dstName;
	
}

exg_hcs12x.execute = {
/* Legal "rr" value for EB::setter and EB::getter functions 
 * 0x00:A; 0x01:B; 
 * 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRWord
 * 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
 * 0x04:D; 0x05:X; 0x06:Y; 0x07:SP  
 */

	uint8_t srcSize, dstSize; 
	uint8_t rrSrc, rrDst;
	
	// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
	switch (lms) {
		case EB::EBMSLSRegs::CCR:
			rrSrc = EB::EBRegs::CCRW;  // src is 0x23 register
			break;
		case EB::EBMSLSRegs::TMPx: 
			if (lls == EB::EBMSLSRegs::D) {
				rrSrc = EB::EBRegs::TMP1; /* src is 0x30 register*/
			} else {
				rrSrc = EB::EBRegs::TMP3; /* src is 0x32 register*/
			}
			break; 
		default: rrSrc = lms;  
	}

	switch (lls) {
		case EB::EBMSLSRegs::CCR:
			rrDst = EB::EBRegs::CCRW; // rrDst is 0x23 register
			break; 
		case EB::EBMSLSRegs::TMPx: 
			if (lms == EB::EBMSLSRegs::D) {
				rrDst = EB::EBRegs::TMP1; /* src is 0x30 register*/
			} else {
				rrDst = EB::EBRegs::TMP3; /* src is 0x32 register*/
			}
			break; 
		default: rrDst = lls;    
	}
		
	srcSize = EB::getRegSize(rrSrc);
	dstSize = EB::getRegSize(rrDst);
	
	// Exchange register Contents. There is no sign extension
	/*
	if (sizeof(r1) && sizeof(r2) { (r1) <=> (r2)}
	else if ( (sizeof(r1)==8) && (sizeof(r2)==16) ) {$00:(r1) => r2}
	else if ( (sizeof(r1)==16) && (sizeof(r2)==8) ) { (r1[7:0]) <=> (r2) }
	*/
	
	if ( srcSize == dstSize) 
	{
		// (r1) <=> (r2)
		if (srcSize == 8) 
		{
			cpu->eb->exchange<uint8_t>(rrSrc,rrDst);
		} 
		else if (srcSize == 16) 
		{
			cpu->eb->exchange<uint16_t>(rrSrc,rrDst);
		}
	} 
	else if ((srcSize == 8) && (dstSize == 16)) 
	{
		// $00:(r1) => r2
		/* if (r2 is D) $00:(r1) => D
		 * else 
		 *  if (r1 is A) (r1) => r2H
		 *  else if (r1 is B) (r1) => r2L
		 */
		 if (rrDst == EB::EBRegs::D /* reg D */)
		 {
		 	cpu->eb->setter<uint16_t>(rrDst, 0x00FF & cpu->eb->getter<uint8_t>(rrSrc));
		 }
		 else if (rrSrc == EB::EBRegs::A)
		 {
		 	uint16_t tmp = cpu->eb->getter<uint16_t>(rrDst) & 0x00FF;  // get the lower bits
		 	tmp = tmp | (((uint16_t) cpu->eb->getter<uint8_t>(rrSrc)) << 8);
		 	cpu->eb->setter<uint16_t>(rrDst, tmp);
		 }
		 else if (rrSrc == EB::EBRegs::B)
		 {
		 	uint16_t tmp = cpu->eb->getter<uint16_t>(rrDst) & 0xFF00; // get higher bits
		 	tmp = tmp | ( 0x00FF & cpu->eb->getter<uint8_t>(rrSrc));
		 	cpu->eb->setter<uint16_t>(rrDst, tmp);
		 } 
	} 
	else if ((srcSize == 16) && (dstSize == 8)) 
	{
		// (r1[7:0]) <=> (r2)
		/*
		 * if (r1 is D)
		 * 	 if (r2 is A) (B) <=> (A)
		 * 	 else $FF => A // r2 is B  
		 * else
		 * 	 if (r2 is A) (r1H) <=> A
		 * 	 else (r1L) <=> B 
		 */		
		 if (rrSrc == EB::EBRegs::D) {
		 	if (rrDst == EB::EBRegs::A) {
		 		cpu->eb->exchange<uint8_t>(EB::EBRegs::B, EB::EBRegs::A);
		 	} else if (rrDst == EB::EBRegs::B) {
		 		cpu->eb->setter<uint8_t>(EB::EBRegs::A, 0xFF);
		 	}
		 } else {
		 	if (rrDst == EB::EBRegs::A) {
		 		uint16_t a16 = ((uint16_t) cpu->eb->getter<uint16_t>(EB::EBRegs::A)) << 8;
		 		uint8_t r1h = cpu->eb->getter<uint16_t>(rrSrc) >> 8;
		 		uint16_t r1l = cpu->eb->getter<uint16_t>(rrSrc) & 0x00FF;
		 		
		 		cpu->eb->setter<uint16_t>(rrSrc, a16 | r1l);
		 		cpu->eb->setter<uint8_t>(rrDst, r1h);
		 		
		 	} else if (rrDst == EB::EBRegs::B) {
		 		uint16_t r1h = cpu->eb->getter<uint16_t>(rrSrc) & 0xFF00;
		 		uint8_t r1l = cpu->eb->getter<uint16_t>(rrSrc) & 0x00FF;
		 		uint16_t b16 = 0x00FF & cpu->eb->getter<uint8_t>(rrDst);
		 		 
		 		cpu->eb->setter<uint16_t>(rrSrc, r1h | b16);
		 		cpu->eb->setter<uint16_t>(rrDst, r1l);
		 	}
		 }
	}	
}

// *************************** HCS12X - TRANSFER Instructions

// TAP or TFR or TPA or TSX or TSY or TXS or TYS or SEX
op tfr_hcs12x(0xB7[8]:> <:0b0[1]:lms[3]:0b1[1]:lls[3])  
/*
 * lms sourceRegister index
 * lls destinationRegister index  
 * */
tfr_hcs12x.disasm = {

	uint8_t rrSrc, rrDst;

	// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
	switch (lms) {
		case EB::EBMSLSRegs::CCR: // src is CCRW register
			if (lls == EB::EBMSLSRegs::A) {
				rrSrc = EB::EBRegs::CCRH; //0x22;
			} else if (lls = EB::EBMSLSRegs::B) {
				rrSrc = EB::EBRegs::CCRL; //0x21;
			} else {
				rrSrc = EB::EBRegs::CCRW; //0x23;
			}
			break; 
		case EB::EBMSLSRegs::TMPx: // src is TMP register
			if (lls = EB::EBMSLSRegs::D) {
				rrSrc = EB::EBRegs::TMP1; //0x30; // TMP1
			} else {
				rrSrc = EB::EBRegs::TMP3; //0x32; // TMP3
			}
			break; 
		default: rrSrc = lms;  
	}

	switch (lls) {
		case EB::EBMSLSRegs::CCR: // dst is CCRW register
			if (lms == EB::EBMSLSRegs::A) {
				rrDst = EB::EBRegs::CCRH; //0x22;
			} else if (lms == EB::EBMSLSRegs::B) {
				rrDst = EB::EBRegs::CCRL; //0x21;
			} else {
				rrDst = EB::EBRegs::CCRW; //0x23;
			}

			break; 
		case EB::EBMSLSRegs::TMPx: // dst is TMP2 register
			if (lms == EB::EBRegs::D ) {
				rrDst = EB::EBRegs::TMP1; //0x30; // TMP1
			} else {
				rrDst = EB::EBRegs::TMP2; //0x31; // TMP2
			}
			break; 
		default: rrDst = lls;    
	}
	
 	// Transfer register Contents. TFR r1,r2
	
	string srcName = EB::getRegName(rrSrc);
	string dstName = EB::getRegName(rrDst);
	
	if (lls == EB::EBMSLSRegs::A ) {
		if (lms == EB::EBMSLSRegs::CCR ) {
			srcName = EB::getRegName(EB::EBRegs::CCRH);  
		} 
		else if ((lms != EB::EBMSLSRegs::B ) && (lms != EB::EBMSLSRegs::D)) {
			srcName = srcName + "H";
		} 
	} if (lls == EB::EBMSLSRegs::B) {
		if (lms == EB::EBMSLSRegs::CCR) {
			srcName = EB::getRegName(EB::EBRegs::CCRL);  
		} 
		else if ((lms != EB::EBMSLSRegs::A ) && (lms != EB::EBMSLSRegs::D)) {
			srcName = srcName + "L";
		} 
	} 

	if (lms == EB::EBMSLSRegs::A) {
		if (lls == EB::EBMSLSRegs::CCR /* reg CCR */) {
			dstName = EB::getRegName(EB::EBRegs::CCRH);  
		} 
		else if ((lls != EB::EBMSLSRegs::B) && (lls != EB::EBMSLSRegs::D)) {
			dstName = dstName + "H";
		} 
	} if (lms == EB::EBMSLSRegs::B) {
		if (lls == EB::EBMSLSRegs::CCR) {
			dstName = EB::getRegName(EB::EBRegs::CCRL);  
		} 
		else if ((lls != EB::EBMSLSRegs::A) && (lls != EB::EBMSLSRegs::D)) {
			dstName = dstName + "L";
		} 
	} 

	// Transfer Register Content to Another register
	uint8_t eb = (0 << 8) | (lms << 4) | (1 << 3) | lls;
	
	switch (eb) 
	{
		case 0x02: sink << "TAP "; break;
		case 0x20: sink << "TPA "; break;
		case 0x75: sink << "TSX "; break;
		case 0x76: sink << "TSY "; break;
		case 0x57: sink << "TXS "; break;
		case 0x67: sink << "TYS "; break;
		default: sink << "TFR ";
	}
	
	sink << EB::getRegName(rrSrc) << "," << EB::getRegName(rrDst); 
}

tfr_hcs12x.execute = {
/* Legal "rr" value for EB::setter and EB::getter functions 
 * 0x00:A; 0x01:B; 
 * 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRW 
 * 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
 * 0x04:D; 0x05:X; 0x06:Y; 0x07:SP  
 */

	uint8_t srcSize, dstSize; 
	uint8_t rrSrc, rrDst;
	
	// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
	switch (lms) {
		case EB::EBMSLSRegs::CCR:
			rrSrc = EB::EBRegs::CCRW;  // src is 0x23 register
			break;
		case EB::EBMSLSRegs::TMPx: 
			if (lls == EB::EBMSLSRegs::D) {
				rrSrc = EB::EBRegs::TMP1; /* src is 0x30 register*/
			} else {
				rrSrc = EB::EBRegs::TMP3; /* src is 0x32 register*/
			}
			break; 
		default: rrSrc = lms;  
	}

	switch (lls) {
		case EB::EBMSLSRegs::CCR:
			rrDst = EB::EBRegs::CCRW; // rrDst is 0x23 register
			break; 
		case EB::EBMSLSRegs::TMPx: 
			if (lms == EB::EBMSLSRegs::D) {
				rrDst = EB::EBRegs::TMP1; /* src is 0x30 register*/
			} else {
				rrDst = EB::EBRegs::TMP3; /* src is 0x32 register*/
			}
			break; 
		default: rrDst = lls;    
	}
		
	srcSize = EB::getRegSize(rrSrc);
	dstSize = EB::getRegSize(rrDst);

	// Transfer Register Content to Another register
	/*
	if (sizeof(r1) && sizeof(r2) { (r1) => r2}
	else if ( (sizeof(r1)==8) && (sizeof(r2)==16) ) {sex:(r1) => r2}
	else if ( (sizeof(r1)==16) && (sizeof(r2)==8) ) { (r1[7:0]) => r2 }
	*/  

	if (srcSize == dstSize) 
	{ 
		/*
		 * if ((r1 is D) && ((r2 is X) || (r2 is Y))) then sex:D => r2
		 * else (r1) => r2 
		 */
		 if ((rrSrc == EB::EBRegs::D) && ((rrDst == EB::EBRegs::X) || (rrDst == EB::EBRegs::Y))) 
		 {
		 	uint16_t tmp = cpu->eb->getter<uint16_t>(rrSrc);
		 	if ((tmp & 0x8000) == 0x8000) {
		 		cpu->eb->setter<uint16_t>(rrDst, 0xFFFF);
		 	} else {
		 		cpu->eb->setter<uint16_t>(rrDst, 0x0000);
		 	}
		 } else {
		 	if (srcSize == 8) {
		 		cpu->eb->setter<uint8_t>(rrDst, cpu->eb->getter<uint8_t>(rrSrc));
		 	} else {
		 		cpu->eb->setter<uint16_t>(rrDst, cpu->eb->getter<uint16_t>(rrSrc));
		 	}
		 } 
		 
	} else if ((srcSize == 8) && (dstSize == 16))
	{
		/*
		 * if (r2 is D) then sex:(r1) => r2
		 * else 
		 *    if (r1 is A) then (r1) => r2H
		 *    else (r1) => r2L 
		 * */
		 if (rrDst == EB::EBRegs::D) {
		 	uint8_t tmp = cpu->eb->getter<uint8_t>(rrSrc);
		 	if ((tmp & 0x80) == 0x80) {
		 		cpu->eb->setter<uint16_t>(rrDst, ((uint16_t) tmp) | 0xFF00);
		 	} else {
		 		cpu->eb->setter<uint16_t>(rrDst, ((uint16_t) tmp) & 0x00FF);
		 	}
		 } else {
		 	uint8_t r1 = cpu->eb->getter<uint8_t>(rrSrc);
		 	if (rrSrc == EB::EBRegs::A) {
		 		uint16_t r2l = cpu->eb->getter<uint16_t>(rrDst) & 0x00FF;
		 		cpu->eb->setter<uint16_t>(rrDst, (((uint16_t) r1) << 8) | r2l); 
		 	} else {
		 		uint16_t r2h = cpu->eb->getter<uint16_t>(rrDst) & 0xFF00;
		 		cpu->eb->setter<uint16_t>(rrDst, r2h | r1);
		 	}
		 }
	} else if ((srcSize == 16) && (dstSize == 8))
	{
		/*
		 * if (r2 is A) then
		 *   if (r1 is D) then B => A
		 *   else r1H => A
		 * else
		 *   r1L => B
		 */
		 if (rrDst == EB::EBRegs::A) {
		 	if (rrSrc == EB::EBRegs::D) {
		 		cpu->eb->setter<uint8_t>(EB::EBRegs::A, cpu->eb->getter<uint8_t>(EB::EBRegs::B));
		 	} else {
		 		cpu->eb->setter<uint8_t>(EB::EBRegs::A, (uint8_t) (cpu->eb->getter<uint8_t>(rrSrc) >> 8));
		 	}
		 } else {
		 	cpu->eb->setter<uint8_t>(EB::EBRegs::B, (uint8_t) (cpu->eb->getter<uint8_t>(rrSrc) & 0x00FF));
		 }
	} 
}


