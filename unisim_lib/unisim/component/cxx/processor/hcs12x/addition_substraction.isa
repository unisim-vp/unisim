/*
 *  Copyright (c) 2008,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
 */


/* ***** Addition Instructions ****** */

// ABA ( A+B => A)
op aba(0x18[8]:0x06[8])

aba.disasm = {
	sink << "ABA";
}

aba.execute = {
	uint8_t result, carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t aVal = cpu->getRegA();
	uint8_t bVal = cpu->getRegB();
	 
	Add8(result, carry_out, overflow, aVal, bVal, carry_in);
	
	cpu->setRegA(result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

//	if (((aVal & 0x0F)+(bVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();	
	
	uint8_t a3 = (cpu->getRegA() & 0x08);
	uint8_t b3 = (cpu->getRegB() & 0x08);
	uint8_t _r3 = ~(result & 0x08);

	if ((a3 & b3) | (b3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();
}

// ABX  (X+B => X) 
op abx(0x1A[8]:0xE5[8])

abx.disasm = {
	sink << "ABX";
}

abx.execute = {

	uint16_t result;
	uint8_t carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t bVal = cpu->getRegB();
	uint16_t xVal = cpu->getRegX();
	
	Add16(result, carry_out, overflow,(uint16_t) bVal, xVal, carry_in);
	
	cpu->setRegX(result);
	
}

// ABY (Y+B=>Y)
op aby(0x19[8]:0xED[8])

aby.disasm = {
	sink << "ABY";
}
aby.execute = {
	uint16_t result;
	uint8_t carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t bVal = cpu->getRegB();
	uint16_t yVal = cpu->getRegY();
	
	Add16(result, carry_out, overflow, (uint16_t) bVal, yVal, carry_in);
	
	cpu->setRegY(result);
	
}

// ADCab IMM  (regAB + ii + carry => regAB) 
op adc_ab_imm(0b1[1]:b[1]:0x09[6]:opr8i[8])

adc_ab_imm.disasm = {
	if (b==0) {
		sink << "ADCA #$";
	} else {
		sink << "ADCB #$";
	}
	sink << std::hex << opr8i;
}

adc_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Add8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

//	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();		

	uint8_t a3 = (regVal & 0x08);
	uint8_t m3 = (opr8i & 0x08);
	uint8_t _r3 = ~(result & 0x08);

	if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();	
}

// ADCab DIR  (regAB + mem[regDirect:opr8a] + carry => regAB)
op adc_ab_dir(0b1[1]:b[1]:0x19[6]:opr8a[8])

adc_ab_dir.disasm = {
	if (b==0) {
		sink << "ADCA $";
	} else {
		sink << "ADCB $"; 
	}
	sink << std::hex << opr8a;
}

adc_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	uint8_t opr8aVal = cpu->memRead8(addr);

	Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

//	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();		

	uint8_t a3 = (regVal & 0x08);
	uint8_t m3 = (opr8aVal & 0x08);
	uint8_t _r3 = ~(result & 0x08);

	if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();	

}

// ADCab EXT (regAB + mem[opr16a] + carry => regAB)
op adc_ab_ext(0b1[1]:b[1]:0x39[6]:> <:opr16a[16])

adc_ab_ext.disasm = {
	if (b==0) {
		sink << "ADCA $";
	} else {
		sink << "ADCB $";		
	}
	sink << std::hex << opr16a;
}

adc_ab_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t opr16aVal = cpu->memRead8(addr);

	Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

//	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();		

	uint8_t a3 = (regVal & 0x08);
	uint8_t m3 = (opr16aVal & 0x08);
	uint8_t _r3 = ~(result & 0x08);

	if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();	
	
}

// ADCab IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB + mem[xb->addrE] + carry => regAB)
op adc_ab_idx(0b1[1]:b[1]:0x29[6]:> <:*xb[XB])

adc_ab_idx.disasm = {
	if (b==0){
		sink << "ADCA ";
	} else {
		sink << "ADCB ";
	}

	xb->disasm(sink);
}

adc_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t xbVal = cpu->memRead8(addr);

	Add8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

//	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();		

	uint8_t a3 = (regVal & 0x08);
	uint8_t m3 = (xbVal & 0x08);
	uint8_t _r3 = ~(result & 0x08);

	if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();	

}

// ADDab IMM (regAB + ii => regAB)
op add_ab_imm(0b1[1]:b[1]:0x0B[6]:opr8i[8])

add_ab_imm.disasm = {
	if (b==0) {
		sink << "ADDA #$";
	} else {
		sink << "ADDB #$";
	}
	sink << std::hex << opr8i;
}

add_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Add8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

//	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();		

	uint8_t a3 = (regVal & 0x08);
	uint8_t m3 = (opr8i & 0x08);
	uint8_t _r3 = ~(result & 0x08);

	if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();	
	
}

// ADDab DIR  (regAB + mem[regDirect:opr8a] => regAB)
op add_ab_dir(0b1[1]:b[1]:0x1B[6]:opr8a[8])

add_ab_dir.disasm = {
	if (b==0) {
		sink << "ADDA $";
	} else {
		sink << "ADDB $"; 
	}
	sink << std::hex << opr8a;
}

add_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint8_t opr8aVal = cpu->memRead8(addr);

	Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

//	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();	

	uint8_t a3 = (regVal & 0x08);
	uint8_t m3 = (opr8aVal & 0x08);
	uint8_t _r3 = ~(result & 0x08);

	if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();	

}

// ADDab EXT  (regAB + mem[opr16a] => regAB)
op add_ab_ext(0b1[1]:b[1]:0x3B[6]:> <:opr16a[16])

add_ab_ext.disasm = {
	if (b==0) {
		sink << "ADDA $";
	} else {
		sink << "ADDB $";		
	}
	sink << std::hex << opr16a;
}

add_ab_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t opr16aVal = cpu->memRead8(addr);

	Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

//	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();	

	uint8_t a3 = (regVal & 0x08);
	uint8_t m3 = (opr16aVal & 0x08);
	uint8_t _r3 = ~(result & 0x08);

	if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();	
	
}

// ADDab  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB + mem[xb->addrE] => regAB)
op add_ab_idx(0b1[1]:b[1]:0x2B[6]:> <:*xb[XB])

add_ab_idx.disasm = {
	if (b==0){
		sink << "ADDA ";
	} else {
		sink << "ADDB ";
	}

	xb->disasm(sink);
}

add_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t xbVal = cpu->memRead8(addr);

	Add8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

//	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();	

	uint8_t a3 = (regVal & 0x08);
	uint8_t m3 = (xbVal & 0x08);
	uint8_t _r3 = ~(result & 0x08);

	if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();	

}

// ADED IMM  (regD + #opr16i + carry => regD) 
op aded_imm(0x18[8]:0xC3[8]:opr16i[16])

aded_imm.disasm = {
	sink << "ADED #$" << std::hex << opr16i;
}

aded_imm.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint16_t regVal = cpu->getRegD();

	Add16(result, carry_out, overflow, regVal, opr16i, carry_in);
	
	cpu->setRegD(result);
		
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// ADED DIR  (regD + mem16[regDirect:opr8a] + carry => regD)
op aded_dir(0x18[8]:> <:0xD3[8]:opr8a[8])

aded_dir.disasm = {
	sink << "ADED $" << std::hex << opr8a;
}

aded_dir.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint16_t regVal = cpu->getRegD();

	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	uint16_t opr8aVal = cpu->memRead16(addr);

	Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	cpu->setRegD(result);	
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ADED EXT (regD + mem16[opr16a] + carry => regD)
op aded_ext(0x18[8]:0xF3[8]:> <:opr16a[16])

aded_ext.disasm = {
	sink << "ADED $" << std::hex << opr16a;
}

aded_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint16_t regVal = cpu->getRegD();

	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t opr16aVal = cpu->memRead16(addr);

	Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	cpu->setRegD(result);
		
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// ADED IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD + mem16[xb->addrE] + carry => regD)
op aded_idx(0x18[8]:0xE3[8]:> <:*xb[XB])

aded_idx.disasm = {
	sink << "ADED ";
	xb->disasm(sink);
}

aded_idx.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint16_t regVal = cpu->getRegD();
	
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t xbVal = cpu->memRead16(addr);

	Add16(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	cpu->setRegD(result);
		
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ADExy IMM  (regXY + #opr16i + carry => regXY) 
op ade_xy_imm(0x18[8]:0b1[1]:b[1]:0x09[6]:opr16i[16])

ade_xy_imm.disasm = {
	if (b==0) {
		sink << "ADEX #$";
	} else {
		sink << "ADEY #$";
	}
	sink << std::hex << opr16i;
}

ade_xy_imm.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}

	Add16(result, carry_out, overflow, regVal, opr16i, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// ADExy DIR  (regXY + mem16[regDirect:opr8a] + carry => regXY)
op ade_xy_dir(0x18[8]:> <:0b1[1]:b[1]:0x19[6]:opr8a[8])

ade_xy_dir.disasm = {
	if (b==0) {
		sink << "ADEX $";
	} else {
		sink << "ADEY $"; 
	}
	sink << std::hex << opr8a;
}

ade_xy_dir.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	uint16_t opr8aVal = cpu->memRead16(addr);

	Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ADExy EXT (regXY + mem16[opr16a] + carry => regXY)
op ade_xy_ext(0x18[8]:0b1[1]:b[1]:0x39[6]:> <:opr16a[16])

ade_xy_ext.disasm = {
	if (b==0) {
		sink << "ADEX $";
	} else {
		sink << "ADEY $";		
	}
	sink << std::hex << opr16a;
}

ade_xy_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t opr16aVal = cpu->memRead16(addr);

	Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// ADExy IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY + mem16[xb->addrE] + carry => regXY)
op ade_xy_idx(0x18[8]:0b1[1]:b[1]:0x29[6]:> <:*xb[XB])

ade_xy_idx.disasm = {
	if (b==0){
		sink << "ADEX ";
	} else {
		sink << "ADEY ";
	}

	xb->disasm(sink);
}

ade_xy_idx.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint16_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t xbVal = cpu->memRead16(addr);

	Add16(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}


// ADDxy IMM (regXY + #opr16i => regXY)
op add_xy_imm(0x18[8]:0b1[1]:b[1]:0x0B[6]:opr16i[16])

add_xy_imm.disasm = {
	if (b==0) {
		sink << "ADDX #$";
	} else {
		sink << "ADDY #$";
	}
	sink << std::hex << opr16i;
}

add_xy_imm.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}

	Add16(result, carry_out, overflow, regVal, opr16i, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// ADDxy DIR  (regXY + mem16[regDirect:opr8a] => regXY)
op add_xy_dir(0x18[8]:> <:0b1[1]:b[1]:0x1B[6]:opr8a[8])

add_xy_dir.disasm = {
	if (b==0) {
		sink << "ADDX $";
	} else {
		sink << "ADDY $"; 
	}
	sink << std::hex << opr8a;
}

add_xy_dir.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	uint8_t carry_in = 0;
	uint16_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint16_t opr8aVal = cpu->memRead16(addr);

	Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ADDxy EXT  (regXY + mem16[opr16a] => regXY)
op add_xy_ext(0x18[8]:0b1[1]:b[1]:0x3B[6]:> <:opr16a[16])

add_xy_ext.disasm = {
	if (b==0) {
		sink << "ADDX $";
	} else {
		sink << "ADDY $";		
	}
	sink << std::hex << opr16a;
}

add_xy_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t opr16aVal = cpu->memRead16(addr);

	Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// ADDxy  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY + mem16[xb->addrE] => regXY)
op add_xy_idx(0x18[8]:0b1[1]:b[1]:0x2B[6]:> <:*xb[XB])

add_xy_idx.disasm = {
	if (b==0){
		sink << "ADDX ";
	} else {
		sink << "ADDY ";
	}

	xb->disasm(sink);
}

add_xy_idx.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t xbVal = cpu->memRead16(addr);

	Add16(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}




// SUBD IMM or ADDD IMM (regD -+ ii => regD)
op add_sub_d_imm(0b1[1]:b[1]:0x03[6]:> <:opr16i[16])

add_sub_d_imm.disasm = {
	if (b==0) {
		sink << "SUBD #$";
	} else {
		sink << "ADDD #$";
	}
	sink << std::hex << opr16i;
}

add_sub_d_imm.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	 
	uint8_t carry_in = 0;
	uint16_t regVal = cpu->getRegD();

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, opr16i, carry_in);
	}
	
	cpu->setRegD(result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SUBD DIR or ADDD DIR  (regD -+ mem[regDirect+opr8a]) 
op add_sub_d_dir(0b1[1]:b[1]:0x13[6]:opr8a[8])

add_sub_d_dir.disasm = {
	if (b==0) {
		sink << "SUBD $";
	} else {
		sink << "ADDD $";
	}
	sink << std::hex << opr8a;
}

add_sub_d_dir.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	uint16_t regVal = cpu->getRegD();

	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	uint16_t opr8aVal = cpu->memRead16(addr);

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	}
	
	cpu->setRegD(result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SUBD EXT or ADDD EXT (regD -+ mem[opr16a]) => regD)
op add_sub_d_ext(0b1[1]:b[1]:0x33[6]:> <:opr16a[16])

add_sub_d_ext.disasm = {
	if (b==0) {
		sink << "SUBD $";	
	} else {
		sink << "ADDD $";
	}
	
	sink << std::hex << opr16a;

}

add_sub_d_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal = cpu->getRegD();
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t opr16aVal = cpu->memRead16(addr);

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	}

	cpu->setRegD(result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SUBD/ADDD  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD -+ mem[xb->addrE] => regD) 
op add_sub_d_idx(0b1[1]:b[1]:0x23[6]:> <:*xb[XB])

add_sub_d_idx.disasm = {
	if (b==0) {
		sink << "SUBD ";
	} else {
		sink << "ADDD ";
	}

	xb->disasm(sink);
}

add_sub_d_idx.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal = cpu->getRegD();
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t xbVal = cpu->memRead16(addr);

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, xbVal, carry_in);
	}

	cpu->setRegD(result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

/* ****** Subtraction Instructions **** */

// SBA  (regA - regB => regA)
op sba(0x18[8]:0x16[8])

sba.disasm = {
	sink << "SBA";
}

sba.execute = {
	uint8_t result, carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t aVal = cpu->getRegA();
	uint8_t bVal = cpu->getRegB();
	 
	Sub8(result, carry_out, overflow, aVal, bVal, carry_in);
	
	cpu->setRegA(result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBCA/SBCB  IMM (regAB - ii - carry => regAB)
op sbc_ab_imm(0b1[1]:b[1]:0x02[6]:opr8i[8])

sbc_ab_imm.disasm = {
	if (b==0) {
		sink << "SBCA #$";
	} else {
		sink << "SBCB #$";
	}
	sink << std::hex << opr8i;
}

sbc_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBCA/SBCB  DIR  (regAB - mem[regDirect:opr8a] - carry => regAB)
op sbc_ab_dir(0b1[1]:b[1]:0x12[6]:opr8a[8])

sbc_ab_dir.disasm = {
	if (b==0) {
		sink << "SBCA $";
	} else {
		sink << "SBCB $"; 
	}
	sink << std::hex << opr8a;
}

sbc_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint8_t opr8aVal = cpu->memRead8(addr);

	Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBCA/SBCB  EXT (regAB - mem[opr16a] - carry => regAB)
op sbc_ab_ext(0b1[1]:b[1]:0x32[6]:> <:opr16a[16])

sbc_ab_ext.disasm = {
	if (b==0) {
		sink << "SBCA $";
	} else {
		sink << "SBCB $";		
	}
	sink << std::hex << opr16a;
}

sbc_ab_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t opr16aVal = cpu->memRead8(addr);

	Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBCA/SBCB IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB - mem[xb->addrE] - carry => regAB)
op sbc_ab_idx(0b1[1]:b[1]:0x22[6]:> <:*xb[XB])

sbc_ab_idx.disasm = {
	if (b==0){
		sink << "SBCA ";
	} else {
		sink << "SBCB ";
	}

	xb->disasm(sink);
}

sbc_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t xbVal = cpu->memRead8(addr);

	Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBED  IMM (regD - #opr16i - carry => regD)
op sbed_imm(0x18[8]:0x83[8]:opr16i[16])

sbed_imm.disasm = {
	sink << "SBED #$" << std::hex << opr16i;
}

sbed_imm.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint16_t regVal = cpu->getRegD();

	Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);
	
	cpu->setRegD(result);
		
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBED  DIR  (regD - mem16[regDirect:opr8a] - carry => regD)
op sbed_dir(0x18[8]:> <:0x93[8]:opr8a[8])

sbed_dir.disasm = {
	sink << "SBED $" << std::hex << opr8a;
}

sbed_dir.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint16_t regVal = cpu->getRegD();

	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint16_t opr8aVal = cpu->memRead16(addr);

	Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	cpu->setRegD(result);
		
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBED  EXT (regD - mem16[opr16a] - carry => regD)
op sbed_ext(0x18[8]:0xB3[8]:> <:opr16a[16])

sbed_ext.disasm = {
	sink << "SBED $" << std::hex << opr16a;
}

sbed_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint16_t regVal = cpu->getRegD();

	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t opr16aVal = cpu->memRead16(addr);

	Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	cpu->setRegD(result);
		
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBED IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD - mem16[xb->addrE] - carry => regD)
op sbed_idx(0x18[8]:0xA3[8]:> <:*xb[XB])

sbed_idx.disasm = {
	sink << "SBED ";
	xb->disasm(sink);
}

sbed_idx.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint16_t regVal = cpu->getRegD();
	
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t xbVal = cpu->memRead16(addr);

	Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	cpu->setRegD(result);
		
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBEX/SBEY  IMM (regXY - #opr16i - carry => regXY)
op sbe_xy_imm(0x18[8]:0b1[1]:b[1]:0x02[6]:opr16i[16])

sbe_xy_imm.disasm = {
	if (b==0) {
		sink << "SBEX #$";
	} else {
		sink << "SBEY #$";
	}
	sink << std::hex << opr16i;
}

sbe_xy_imm.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}

	Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBEX/SBEY  DIR  (regXY - mem16[regDirect:opr8a] - carry => regXY)
op sbe_xy_dir(0x18[8]:> <:0b1[1]:b[1]:0x12[6]:opr8a[8])

sbe_xy_dir.disasm = {
	if (b==0) {
		sink << "SBEX $";
	} else {
		sink << "SBEY $"; 
	}
	sink << std::hex << opr8a;
}

sbe_xy_dir.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint16_t opr8aVal = cpu->memRead16(addr);

	Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBEX/SBEY  EXT (regXY - mem16[opr16a] - carry => regXY)
op sbe_xy_ext(0x18[8]:0b1[1]:b[1]:0x32[6]:> <:opr16a[16])

sbe_xy_ext.disasm = {
	if (b==0) {
		sink << "SBEX $";
	} else {
		sink << "SBEY $";		
	}
	sink << std::hex << opr16a;
}

sbe_xy_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t opr16aVal = cpu->memRead16(addr);

	Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SBEX/SBEY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY - mem16[xb->addrE] - carry => regXY)
op sbe_xy_idx(0x18[8]:0b1[1]:b[1]:0x22[6]:> <:*xb[XB])

sbe_xy_idx.disasm = {
	if (b==0){
		sink << "SBEX ";
	} else {
		sink << "SBEY ";
	}

	xb->disasm(sink);
}

sbe_xy_idx.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint16_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t xbVal = cpu->memRead16(addr);

	Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SUBA/SUBB  IMM (regAB - ii => regAB)
op sub_ab_imm(0b1[1]:b[1]:0x00[6]:opr8i[8])

sub_ab_imm.disasm = {
	if (b==0) {
		sink << "SUBA #$";
	} else {
		sink << "SUBB #$";
	}
	sink << std::hex << opr8i;
}

sub_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// SUBA/SUBB  DIR  (regAB - mem[regDirect:opr8a] => regAB)
op sub_ab_dir(0b1[1]:b[1]:0x10[6]:opr8a[8])

sub_ab_dir.disasm = {
	if (b==0) {
		sink << "SUBA $";
	} else {
		sink << "SUBB $"; 
	}
	sink << std::hex << opr8a;
}

sub_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint8_t opr8aVal = cpu->memRead8(addr);

	Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SUBA/SUBB  EXT (regAB - mem[opr16a] => regAB)
op sub_ab_ext(0b1[1]:b[1]:0x30[6]:> <:opr16a[16])

sub_ab_ext.disasm = {
	if (b==0) {
		sink << "SUBA $";
	} else {
		sink << "SUBB $";		
	}
	sink << std::hex << opr16a;
}

sub_ab_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t opr16aVal = cpu->memRead8(addr);

	Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// SUBA/SUBB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB - mem[xb->addrE] => regAB)
op sub_ab_idx(0b1[1]:b[1]:0x20[6]:> <:*xb[XB])

sub_ab_idx.disasm = {
	if (b==0){
		sink << "SUBA ";
	} else {
		sink << "SUBB ";
	}

	xb->disasm(sink);
}

sub_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t xbVal = cpu->memRead8(addr);

	Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
}

// ******************************

// SUBX/SUBY  IMM (regXy - opr16i => regXY)
op sub_xy_imm(0x18[8]:0b1[1]:b[1]:0x00[6]:opr16i[16])

sub_xy_imm.disasm = {
	if (b==0) {
		sink << "SUBX #$";
	} else {
		sink << "SUBY #$";
	}
	sink << std::hex << opr16i;
}

sub_xy_imm.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}

	Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// SUBX/SUBY  DIR  (regXY - mem16[regDirect:opr8a] => regXY)
op sub_xy_dir(0x18[8]:> <:0b1[1]:b[1]:0x10[6]:opr8a[8])

sub_xy_dir.disasm = {
	if (b==0) {
		sink << "SUBX $";
	} else {
		sink << "SUBY $"; 
	}
	sink << std::hex << opr8a;
}

sub_xy_dir.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint16_t opr8aVal = cpu->memRead16(addr);

	Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// SUBX/SUBY  EXT (regXY - mem16[opr16a] => regXY)
op sub_xy_ext(0x18[8]:0b1[1]:b[1]:0x30[6]:> <:opr16a[16])

sub_xy_ext.disasm = {
	if (b==0) {
		sink << "SUBX $";
	} else {
		sink << "SUBY $";		
	}
	sink << std::hex << opr16a;
}

sub_xy_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal;
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t opr16aVal = cpu->memRead16(addr);

	Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// SUBX/SUBY  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY - mem16[xb->addrE] => regXY)
op sub_xy_idx(0x18[8]:0b1[1]:b[1]:0x20[6]:> <:*xb[XB])

sub_xy_idx.disasm = {
	if (b==0){
		sink << "SUBX ";
	} else {
		sink << "SUBY ";
	}

	xb->disasm(sink);
}

sub_xy_idx.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t xbVal = cpu->memRead16(addr);

	Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
}

// ******************************

/* ***** Binary-Coded Decimal Instructions ****** */

// DAA (if (ccr.H) then regA + 0x6 => regA)
op daa(0x18[8]:0x07[8])

daa.disasm = {
	sink << "DAA";
}

daa.execute = {
	uint8_t hBit = cpu->ccr->getH();
	uint8_t cBit = cpu->ccr->getC();

	uint8_t overflow, carry_out, result;

	uint8_t aVal = cpu->getRegA(); 
	uint8_t a74 =  aVal >> 4;
	uint8_t a30 = aVal & 0x0F;

	
	if ((cBit == 0) &&
		(a74 < 0x9) &&
		(hBit == 0) &&
		(a30 > 0x9))
	{
		Add8(result, carry_out, overflow, aVal, 0x06, 0x00);
		cpu->setRegA(result);
		cpu->ccr->clrC();
	}
	
	if ((cBit == 0) &&
		(a74 < 0xA) &&
		(hBit == 1) &&
		(a30 < 0x4))
	{
		Add8(result, carry_out, overflow, aVal, 0x06, 0x00);
		cpu->setRegA(result);
		cpu->ccr->clrC();
	}

	if ((cBit == 0) &&
		(a74 > 0x9) &&
		(hBit == 0) &&
		(a30 < 0xA))
	{
		Add8(result, carry_out, overflow, aVal, 0x60, 0x00);
		cpu->setRegA(result);
		cpu->ccr->setC();
	}

	if ((cBit == 0) &&
		(a74 > 0x8) &&
		(hBit == 0) &&
		(a30 > 0x9))
	{
		Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
		cpu->setRegA(result);
		cpu->ccr->setC();
	}

	if ((cBit == 0) &&
		(a74 > 0x9) &&
		(hBit == 1) &&
		(a30 < 0x4))
	{
		Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
		cpu->setRegA(result);
		cpu->ccr->setC();
	}

	if ((cBit == 1) &&
		(a74 < 0x3) &&
		(hBit == 0) &&
		(a30 < 0xA))
	{
		Add8(result, carry_out, overflow, aVal, 0x60, 0x00);
		cpu->setRegA(result);
		cpu->ccr->setC();
	}

	if ((cBit == 1) &&
		(a74 < 0x3) &&
		(hBit == 0) &&
		(a30 > 0x9))
	{
		Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
		cpu->setRegA(result);
		cpu->ccr->setC();
	}

	if ((cBit == 1) &&
		(a74 < 0x4) &&
		(hBit == 1) &&
		(a30 < 0x4))
	{
		Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
		cpu->setRegA(result);
		cpu->ccr->setC();
	}
	
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	if (result == 0x00) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if (overflow == 1) cpu->ccr->setV(); else cpu->ccr->clrV(); 
}

