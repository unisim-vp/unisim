// -*- C++ -*-

/* ***** Addition Instructions ****** */

// ABA ( A+B => A)
op aba(0x18[8]:0x06[8])

aba.disasm = {
	sink << "ABA";
}

aba.execute = {
	uint8_t result, carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t aVal = cpu->getRegA();
	uint8_t bVal = cpu->getRegB();
	 
	Add8(result, carry_out, overflow, aVal, bVal, carry_in);
	
	cpu->setRegA(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((aVal & 0x0F)+(bVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);	
}

// ABX  (X+B => X) 
op abx(0x1A[8]:0xE5[8])

abx.disasm = {
	sink << "ABX";
}

abx.execute = {

	uint16_t result;
	uint8_t carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t bVal = cpu->getRegB();
	uint16_t xVal = cpu->getRegX();
	
	Add16(result, carry_out, overflow,(uint16_t) bVal, xVal, carry_in);
	
	cpu->setRegX(result);
	
}

// ABY (Y+B=>Y)
op aby(0x19[8]:0xED[8])

aby.disasm = {
	sink << "ABY";
}
aby.execute = {
	uint16_t result;
	uint8_t carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t bVal = cpu->getRegB();
	uint16_t yVal = cpu->getRegY();
	
	Add16(result, carry_out, overflow, (uint16_t) bVal, yVal, carry_in);
	
	cpu->setRegY(result);
	
}

// ADCab IMM  (regAB + ii + carry => regAB) 
op adc_ab_imm(0b1[1]:b[1]:0x09[6]:opr8i[8])

adc_ab_imm.disasm = {
	if (b==0) {
		sink << "ADCA #$";
	} else {
		sink << "ADCB #$";
	}
	sink << std::hex << opr8i;
}

adc_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Add8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
	
}

// ADCab DIR  (regAB + mem[regDirect:opr8a] + carry => regAB)
op adc_ab_dir(0b1[1]:b[1]:0x19[6]:opr8a[8])

adc_ab_dir.disasm = {
	if (b==0) {
		sink << "ADCA $";
	} else {
		sink << "ADCB $"; 
	}
	sink << std::hex << opr8a;
}

adc_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	uint8_t opr8aVal = cpu->memRead8(opr8a, MEMORY::DIRECT);

	Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
}

// ADCab EXT (regAB + mem[opr16a] + carry => regAB)
op adc_ab_ext(0b1[1]:b[1]:0x39[6]:> <:opr16a[16])

adc_ab_ext.disasm = {
	if (b==0) {
		sink << "ADCA $";
	} else {
		sink << "ADCB $";		
	}
	sink << std::hex << opr16a;
}

adc_ab_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t opr16aVal = cpu->memRead8(opr16a);

	Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
	
}

// ADCab IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB + mem[xb->addrE] + carry => regAB)
op adc_ab_idx(0b1[1]:b[1]:0x29[6]:> <:*xb[XB])

adc_ab_idx.disasm = {
	if (b==0){
		sink << "ADCA ";
	} else {
		sink << "ADCB ";
	}

	xb->disasm(sink);
}

adc_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t xbVal = cpu->memRead8(xb->getEAddr(cpu));

	Add8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
}

// ADDab IMM (regAB + ii => regAB)
op add_ab_imm(0b1[1]:b[1]:0x0B[6]:opr8i[8])

add_ab_imm.disasm = {
	if (b==0) {
		sink << "ADDA #$";
	} else {
		sink << "ADDB #$";
	}
	sink << std::hex << opr8i;
}

add_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Add8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
	
}

// ADDab DIR  (regAB + mem[regDirect:opr8a] => regAB)
op add_ab_dir(0b1[1]:b[1]:0x1B[6]:opr8a[8])

add_ab_dir.disasm = {
	if (b==0) {
		sink << "ADDA $";
	} else {
		sink << "ADDB $"; 
	}
	sink << std::hex << opr8a;
}

add_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	uint8_t opr8aVal = cpu->memRead8(opr8a, MEMORY::DIRECT);

	Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);	
}

// ADDab EXT  (regAB + mem[opr16a] => regAB)
op add_ab_ext(0b1[1]:b[1]:0x3B[6]:> <:opr16a[16])

add_ab_ext.disasm = {
	if (b==0) {
		sink << "ADDA $";
	} else {
		sink << "ADDB $";		
	}
	sink << std::hex << opr16a;
}

add_ab_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t opr16aVal = cpu->memRead8(opr16a);

	Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);	
	
}

// ADDab  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB + mem[xb->addrE] => regAB)
op add_ab_idx(0b1[1]:b[1]:0x2B[6]:> <:*xb[XB])

add_ab_idx.disasm = {
	if (b==0){
		sink << "ADDA ";
	} else {
		sink << "ADDB ";
	}

	xb->disasm(sink);
}

add_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t xbVal = cpu->memRead8(xb->getEAddr(cpu));

	Add8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);	
}

// SUBD IMM or ADDD IMM (regD -+ ii => regD)
op add_sub_d_imm(0b1[1]:b[1]:0x03[6]:> <:opr16i[16])

add_sub_d_imm.disasm = {
	if (b==0) {
		sink << "SUBD #$";
	} else {
		sink << "ADDD #$";
	}
	sink << std::hex << opr16i;
}

add_sub_d_imm.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	 
	uint8_t carry_in = 0;
	uint16_t regVal = cpu->getRegD();

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, opr16i, carry_in);
	}
	
	cpu->setRegD(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

// SUBD DIR or ADDD DIR  (regD -+ mem[regDirect+opr8a]) 
op add_sub_d_dir(0b1[1]:b[1]:0x13[6]:opr8a[8])

add_sub_d_dir.disasm = {
	if (b==0) {
		sink << "SUBD $";
	} else {
		sink << "ADDD $";
	}
	sink << std::hex << opr8a;
}

add_sub_d_dir.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	uint16_t regVal = cpu->getRegD();

	uint16_t opr8aVal = cpu->memRead16(opr8a, MEMORY::DIRECT);

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	}
	
	cpu->setRegD(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

// SUBD EXT or ADDD EXT (regD -+ mem[opr16a]) => regD)
op add_sub_d_ext(0b1[1]:b[1]:0x33[6]:> <:opr16a[16])

add_sub_d_ext.disasm = {
	if (b==0) {
		sink << "SUBD $";	
	} else {
		sink << "ADDD $";
	}
	
	sink << std::hex << opr16a;

}

add_sub_d_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal = cpu->getRegD();
	
	uint16_t opr16aVal = cpu->memRead16(opr16a);

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	}

	cpu->setRegD(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

// SUBD/ADDD  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD -+ mem[xb->addrE] => regD) 
op add_sub_d_idx(0b1[1]:b[1]:0x23[6]:> <:*xb[XB])

add_sub_d_idx.disasm = {
	if (b==0) {
		sink << "SUBD ";
	} else {
		sink << "ADDD ";
	}

	xb->disasm(sink);
}

add_sub_d_idx.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal = cpu->getRegD();
	
	uint16_t xbVal = cpu->memRead16(xb->getEAddr(cpu));

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, xbVal, carry_in);
	}

	cpu->setRegD(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

/* ****** Subtraction Instructions **** */

// SBA  (regA - regB => regA)
op sba(0x18[8]:0x16[8])

sba.disasm = {
	sink << "SBA";
}

sba.execute = {
	uint8_t result, carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t aVal = cpu->getRegA();
	uint8_t bVal = cpu->getRegB();
	 
	Sub8(result, carry_out, overflow, aVal, bVal, carry_in);
	
	cpu->setRegA(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

// SBCA/SBCB  IMM (regAB - ii - carry => regAB)
op sbc_ab_imm(0b1[1]:b[1]:0x02[6]:opr8i[8])

sbc_ab_imm.disasm = {
	if (b==0) {
		sink << "SBCA #$";
	} else {
		sink << "SBCB #$";
	}
	sink << std::hex << opr8i;
}

sbc_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

// SBCA/SBCB  DIR  (regAB - mem[regDirect:opr8a] - carry => regAB)
op sbc_ab_dir(0b1[1]:b[1]:0x12[6]:opr8a[8])

sbc_ab_dir.disasm = {
	if (b==0) {
		sink << "SBCA $";
	} else {
		sink << "SBCB $"; 
	}
	sink << std::hex << opr8a;
}

sbc_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	uint8_t opr8aVal = cpu->memRead8(opr8a, MEMORY::DIRECT);

	Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

// SBCA/SBCB  EXT (regAB - mem[opr16a] - carry => regAB)
op sbca_ext(0b1[1]:b[1]:0x32[6]:> <:opr16a[16])

sbca_ext.disasm = {
	if (b==0) {
		sink << "SBCA $";
	} else {
		sink << "SBCB $";		
	}
	sink << std::hex << opr16a;
}

sbca_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t opr16aVal = cpu->memRead8(opr16a);

	Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

// SBCA/ABCB IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB - mem[xb->addrE] - carry => regAB)
op sbc_ab_idx(0b1[1]:b[1]:0x22[6]:> <:*xb[XB])

sbc_ab_idx.disasm = {
	if (b==0){
		sink << "SBCA ";
	} else {
		sink << "SBCB ";
	}

	xb->disasm(sink);
}

sbc_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t xbVal = cpu->memRead8(xb->getEAddr(cpu));

	Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

// SUBA/SUBB  IMM (regAB - ii => regAB)
op sub_ab_imm(0b1[1]:b[1]:0x00[6]:opr8i[8])

sub_ab_imm.disasm = {
	if (b==0) {
		sink << "SUBA #$";
	} else {
		sink << "SUBB #$";
	}
	sink << std::hex << opr8i;
}

sub_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	
}

// SUBA/SUBB  DIR  (regAB - mem[regDirect:opr8a] => regAB)
op sub_ab_dir(0b1[1]:b[1]:0x10[6]:opr8a[8])

sub_ab_dir.disasm = {
	if (b==0) {
		sink << "SUBA $";
	} else {
		sink << "SUBB $"; 
	}
	sink << std::hex << opr8a;
}

sub_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	uint8_t opr8aVal = cpu->memRead8(opr8a, MEMORY::DIRECT);

	Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

// SUBA/SUBB  EXT (regAB - mem[opr16a] => regAB)
op sub_ab_ext(0b1[1]:b[1]:0x30[6]:> <:opr16a[16])

sub_ab_ext.disasm = {
	if (b==0) {
		sink << "SUBA $";
	} else {
		sink << "SUBB $";		
	}
	sink << std::hex << opr16a;
}

sub_ab_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t opr16aVal = cpu->memRead8(opr16a);

	Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	
}

// SUBA/SUBB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB - mem[xb->addrE] => regAB)
op sub_ab_idx(0b1[1]:b[1]:0x20[6]:> <:*xb[XB])

sub_ab_idx.disasm = {
	if (b==0){
		sink << "SUBA ";
	} else {
		sink << "SUBB ";
	}

	xb->disasm(sink);
}

sub_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t xbVal = cpu->memRead8(xb->getEAddr(cpu));

	Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1);
}

/* ***** Binary-Coded Decimal Instructions ****** */

// DAA (if (ccr.H) then regA + 0x6 => regA)
op daa(0x18[8]:0x07[8])

daa.disasm = {
	sink << "DAA";
}

daa.execute = {
	uint8_t hBit = cpu->ccr->getH();
	uint8_t cBit = cpu->ccr->getC();

	if (hBit == 1) {
		uint8_t result, result0, carry_out0, carry_out, overflow;

		uint8_t aVal = cpu->getRegA();
		
		if (hBit == 1) {
			Add8(result0, carry_out0, overflow, aVal, 0x06, 0x0);
			Add8(result, carry_out, overflow, result0, carry_out0 << 4, 0x0); 
		}
		
		cpu->setRegA(result);
		
		cpu->ccr->setC(carry_out);
		cpu->ccr->setV(overflow);
	
		if (result == 0) cpu->ccr->setZ(1);
		if ((result & 0x80) == 0x80) cpu->ccr->setN(1);
	}
}

