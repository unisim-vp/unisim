// -*- C++ -*-

/* ***** Addition Instructions ****** */

op aba(0x18[8]:0x06[8])

aba.disasm = {
	sink << "ABA";
}

aba.execute = {
	uint8_t result, carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t aVal = cpu->getRegA();
	uint8_t bVal = cpu->getRegB();
	 
	Add8(result, carry_out, overflow, aVal, bVal, carry_in);
	
	cpu->setRegA(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((aVal & 0x0F)+(bVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);	
}

op abx(0x1A[8]:0xE5[8])

abx.disasm = {
	sink << "ABX";
}

abx.execute = {

	uint16_t result;
	uint8_t carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t bVal = cpu->getRegB();
	uint16_t xVal = cpu->getRegX();
	
	Add16(result, carry_out, overflow,(uint16_t) bVal, xVal, carry_in);
	
	cpu->setRegX(result);
	
}

op aby(0x19[8]:0xED[8])

aby.disasm = {
	sink << "ABY";
}
aby.execute = {
	uint16_t result;
	uint8_t carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t bVal = cpu->getRegB();
	uint16_t yVal = cpu->getRegY();
	
	Add16(result, carry_out, overflow, (uint16_t) bVal, yVal, carry_in);
	
	cpu->setRegY(result);
	
}

op adc_ab_imm(0b1[1]:b[1]:0x09[6]:opr8i[8])

adc_ab_imm.disasm = {
	if (b==0) {
		sink << "ADCA #$";
	} else {
		sink << "ADCB #$";
	}
	sink << std::hex << opr8i;
}

adc_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Add8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
	
}

op adc_ab_dir(0b1[1]:b[1]:0x19[6]:opr8a[8])

adc_ab_dir.disasm = {
	if (b==0) {
		sink << "ADCA $";
	} else {
		sink << "ADCB $"; 
	}
	sink << std::hex << opr8a;
}

adc_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	uint8_t opr8aVal = cpu->mmc->memDirectRead8(opr8a);

	Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
}

op adca_ext(0b1[1]:b[1]:0x39[6]:> <:opr16a[16])

adca_ext.disasm = {
	if (b==0) {
		sink << "ADCA $";
	} else {
		sink << "ADCB $";		
	}
	sink << std::hex << opr16a;
}

adca_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t opr16aVal = cpu->mmc->memRead8(opr16a);

	Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
	
}

op adc_ab_idx(0b1[1]:b[1]:0x29[6]:> <:*xb[XB])

adc_ab_idx.disasm = {
	if (b==0){
		sink << "ADCA ";
	} else {
		sink << "ADCB ";
	}

	xb->disasm(sink);
}

adc_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t xbVal = cpu->mmc->memRead8(xb->getEAddr(cpu));

	Add8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
}


op add_ab_imm(0b1[1]:b[1]:0x0B[6]:opr8i[8])

add_ab_imm.disasm = {
	if (b==0) {
		sink << "ADDA #$";
	} else {
		sink << "ADDB #$";
	}
	sink << std::hex << opr8i;
}

add_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Add8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);		
	
}

op add_ab_dir(0b1[1]:b[1]:0x1B[6]:opr8a[8])

add_ab_dir.disasm = {
	if (b==0) {
		sink << "ADDA $";
	} else {
		sink << "ADDB $"; 
	}
	sink << std::hex << opr8a;
}

add_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	uint8_t opr8aVal = cpu->mmc->memDirectRead8(opr8a);

	Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);	
}

op add_ab_ext(0b1[1]:b[1]:0x3B[6]:> <:opr16a[16])

add_ab_ext.disasm = {
	if (b==0) {
		sink << "ADDA $";
	} else {
		sink << "ADDB $";		
	}
	sink << std::hex << opr16a;
}

add_ab_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t opr16aVal = cpu->mmc->memRead8(opr16a);

	Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);	
	
}


op add_ab_idx(0b1[1]:b[1]:0x2B[6]:> <:*xb[XB])

add_ab_idx.disasm = {
	if (b==0){
		sink << "ADDA ";
	} else {
		sink << "ADDB ";
	}

	xb->disasm(sink);
}

add_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t xbVal = cpu->mmc->memRead8(xb->getEAddr(cpu));

	Add8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(1); else cpu->ccr->setH(0);	
}


op add_sub_d_imm(0b1[1]:b[1]:0x03[6]:> <:opr16i[16])

add_sub_d_imm.disasm = {
	if (b==0) {
		sink << "SUBD #$";
	} else {
		sink << "ADDD #$";
	}
	sink << std::hex << opr16i;
}

add_sub_d_imm.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	 
	uint8_t carry_in = 0;
	uint16_t regVal = cpu->getRegD();

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, opr16i, carry_in);
	}
	
	cpu->setRegD(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op add_sub_d_dir(0b1[1]:b[1]:0x13[6]:opr8a[8])

add_sub_d_dir.disasm = {
	if (b==0) {
		sink << "SUBD $";
	} else {
		sink << "ADDD $";
	}
	sink << std::hex << opr8a;
}

add_sub_d_dir.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	uint16_t regVal = cpu->getRegD();

	uint16_t opr8aVal = cpu->mmc->memDirectRead16(opr8a);

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	}
	
	cpu->setRegD(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op add_sub_d_ext(0b1[1]:b[1]:0x33[6]:> <:opr16a[16])

add_sub_d_ext.disasm = {
	if (b==0) {
		sink << "SUBD $";	
	} else {
		sink << "ADDD $";
	}
	
	sink << std::hex << opr16a;

}

add_sub_d_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal = cpu->getRegD();
	
	uint16_t opr16aVal = cpu->mmc->memRead16(opr16a);

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	}

	cpu->setRegD(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op add_sub_d_idx(0b1[1]:b[1]:0x23[6]:> <:*xb[XB])

add_sub_d_idx.disasm = {
	if (b==0) {
		sink << "SUBD ";
	} else {
		sink << "ADDD ";
	}

	xb->disasm(sink);
}

add_sub_d_idx.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	uint8_t carry_in = 0;
	
	uint16_t regVal = cpu->getRegD();
	
	uint16_t xbVal = cpu->mmc->memRead16(xb->getEAddr(cpu));

	if (b==0) {
		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);
	} else {
		Add16(result, carry_out, overflow, regVal, xbVal, carry_in);
	}

	cpu->setRegD(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

/* ****** Substraction Instructions **** */

op sba(0x18[8]:0x16[8])

sba.disasm = {
	sink << "SBA";
}

sba.execute = {
	uint8_t result, carry_out, overflow;

	uint8_t carry_in=0;
	uint8_t aVal = cpu->getRegA();
	uint8_t bVal = cpu->getRegB();
	 
	Sub8(result, carry_out, overflow, aVal, bVal, carry_in);
	
	cpu->setRegA(result);
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op sbc_ab_imm(0b1[1]:b[1]:0x02[6]:opr8i[8])

sbc_ab_imm.disasm = {
	if (b==0) {
		sink << "SBCA #$";
	} else {
		sink << "SBCB #$";
	}
	sink << std::hex << opr8i;
}

sbc_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op sbc_ab_dir(0b1[1]:b[1]:0x12[6]:opr8a[8])

sbc_ab_dir.disasm = {
	if (b==0) {
		sink << "SBCA $";
	} else {
		sink << "SBCB $"; 
	}
	sink << std::hex << opr8a;
}

sbc_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	uint8_t opr8aVal = cpu->mmc->memDirectRead8(opr8a);

	Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op sbca_ext(0b1[1]:b[1]:0x32[6]:> <:opr16a[16])

sbca_ext.disasm = {
	if (b==0) {
		sink << "SBCA $";
	} else {
		sink << "SBCB $";		
	}
	sink << std::hex << opr16a;
}

sbca_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t opr16aVal = cpu->mmc->memRead8(opr16a);

	Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op sbc_ab_idx(0b1[1]:b[1]:0x22[6]:> <:*xb[XB])

sbc_ab_idx.disasm = {
	if (b==0){
		sink << "SBCA ";
	} else {
		sink << "SBCB ";
	}

	xb->disasm(sink);
}

sbc_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = cpu->ccr->getC();
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t xbVal = cpu->mmc->memRead8(xb->getEAddr(cpu));

	Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}


op sub_ab_imm(0b1[1]:b[1]:0x00[6]:opr8i[8])

sub_ab_imm.disasm = {
	if (b==0) {
		sink << "SUBA #$";
	} else {
		sink << "SUBB #$";
	}
	sink << std::hex << opr8i;
}

sub_ab_imm.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	
}

op sub_ab_dir(0b1[1]:b[1]:0x10[6]:opr8a[8])

sub_ab_dir.disasm = {
	if (b==0) {
		sink << "SUBA $";
	} else {
		sink << "SUBB $"; 
	}
	sink << std::hex << opr8a;
}

sub_ab_dir.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	uint8_t opr8aVal = cpu->mmc->memDirectRead8(opr8a);

	Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op sub_ab_ext(0b1[1]:b[1]:0x30[6]:> <:opr16a[16])

sub_ab_ext.disasm = {
	if (b==0) {
		sink << "SUBA $";
	} else {
		sink << "SUBB $";		
	}
	sink << std::hex << opr16a;
}

sub_ab_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t opr16aVal = cpu->mmc->memRead8(opr16a);

	Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	
}


op sub_ab_idx(0b1[1]:b[1]:0x20[6]:> <:*xb[XB])

sub_ab_idx.disasm = {
	if (b==0){
		sink << "SUBA ";
	} else {
		sink << "SUBB ";
	}

	xb->disasm(sink);
}

sub_ab_idx.execute = {
	uint8_t result, carry_out, overflow;
	
	uint8_t carry_in = 0;
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	
	uint8_t xbVal = cpu->mmc->memRead8(xb->getEAddr(cpu));

	Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->setC(carry_out);
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1);
}

/* ***** Binary-Coded Decimal Instructions ****** */

op daa(0x18[8]:0x07[8])

daa.disasm = {
	sink << "DAA";
}

daa.execute = {
	uint8_t hBit =cpu->ccr->getH();

	if (hBit == 1) {
		uint8_t result1, result2, carry_out, overflow;

		uint8_t aVal = cpu->getRegA();

		Sub8(result1, carry_out, overflow, aVal, 0x0A, 0);
		Add8(result2, carry_out, overflow, result1, 0x10, 0);
		
		cpu->setRegA(result2);
		
		cpu->ccr->setC(carry_out);
		cpu->ccr->setV(overflow);
	
		if (result2 == 0) cpu->ccr->setZ(1);
		if ((result2 & 0x80) == 0x80) cpu->ccr->setN(1);
	}
}

