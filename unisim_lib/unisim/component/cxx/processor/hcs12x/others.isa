/*
 *  Copyright (c) 2008,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
 */


// NOP:
op nop(0xA7[8])

nop.getCycles = { return 1; }

nop.disasm = {
	sink << "NOP";	
}

nop.execute = {
	// This single-byte instruction increments the PC and does nothing else.
}

// STOP:
op stop(0x18[8]:0x3E[8])

stop.var stopDisabled : { bool } = { false }

stop.getCycles = { if (stopDisabled) return 2; else return 16; }

stop.disasm = {
	sink << "STOP";
}

stop.execute = {
	
	if (cpu->ccr->getS() == 1) {
		stopDisabled = true;
		/*
		 * if S control bit = 1, the STOP instruction is disabled and acts like two-cycle NOP
		 */
		// TODO: consume two cycles	 
	} else {
		stopDisabled = false;
		/*
		 * (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
		 * (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
		 * (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
		 * (SP) – $0002 => SP; B : A => (M(SP) : M(SP+1))
		 * (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
		 * Stop All Clocks and puts the device in standby mode
		 */
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
		 cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());
		 
		 /* TODO: 
		  * Stop All Clocks and puts the device in standby mode.
		  * Asserting the RESET, XIRQ, or IRQ signals ends standby mode. 
		  */
		 
	 	 cpu->Sleep();
	 	 
	 	 /* TODO:
	 	  * If XIRQ is asserted while the X mask bit = 0 (XIRQ interrupts enabled), 
	 	  * execution resumes with a vector fetch for the XIRQ interrupt. 
	 	  * While the X mask bit = 1 (XIRQ interrupts disabled), 
	 	  * a 2-cycle recovery sequence is used to adjust the instruction queue and the stack pointer, 
	 	  * and execution continues with the next instruction after STOP.
	 	  */
	}
}

// WAIT
op wai(0x3E[8])

wai.getCycles = { return 13; }

wai.disasm = {
	sink << "WAI";
}

wai.execute = {

	/*
	 * (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; B : A => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
	 * The CPU12 then enters a wait state for an integer number of bus clock cycles. 
	 * During the wait state, CPU12 clocks are stopped, but otherMCUclocks can continue to run.
	 * WAIT for not masked interrupt
	 */
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
	 cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());

	/* TODO: 
	 * Enter a wait state for an integer number of bus clock cycle
	 * Only CPU12 clocks are stopped
	 * Wait for not masked interrupt
	 */

	 cpu->Wait();
	 
	 /*
	  * If XIRQ is asserted while the X mask bit = 0 (XIRQ interrupts enabled),
	  * execution resumes with a vector fetch for the XIRQ interrupt. 
	  * While the X mask bit = 1 (XIRQ interrupts disabled), 
	  * a 2-cycle recovery sequence is used to adjust the instruction queue and the stack pointer, 
	  * and execution continues with the next instruction after WAI.
	  */
}

// BGND: Enter Background debug mode

op bgnd(0x00[8])

bgnd.getCycles = { return 5; }

bgnd.disasm = {
	sink << "BGND";
}

bgnd.execute = {
	// TODO
}

/* ********** Interrupt instructions ******** */

// RTI: Return from interrupt

op rti(0x0B[8])

rti.var isPending : { bool } = { false }

rti.getCycles = { if (isPending) return 10; else return 8; }

rti.disasm = {
	sink << "RTI";
}

// TODO: check if there is interrupt pending and set "isPending"
 
rti.execute = {

	/*
	 * (M(SP) : M(SP+1)) => CCRH : CCRL; (SP) + $0002 => SP
	 * (M(SP) : M(SP+1)) => B : A; (SP) + $0002 => SP
	 * (M(SP) : M(SP+1)) => XH : XL; (SP) + $0004 => SP
	 * (M(SP) : M(SP+1)) => PCH : PCL; (SP) – $0002 => SP
	 * (M(SP) : M(SP+1)) => YH : YL; (SP) + $0004 => SP
	 * */
	 
	address_t addr = cpu->getRegSP();
	
	/* Leave bit X unchanged.
	 * X bit can be set only by a reset or by recognition of an (!XIRQ) interrupt
	 */ 	 
	cpu->ccr->setCCR((cpu->memRead16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)) & 0xFFBF) | (cpu->ccr->getCCR() & 0x0040));

	addr = addr + 2;
	cpu->setRegB(cpu->memRead8(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
	cpu->setRegA(cpu->memRead8(cpu->mmc->getPhysicalAddress(addr+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));

	addr = addr + 2;
	cpu->setRegX(cpu->memRead16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));

	addr = addr + 2;
	cpu->setRegY(cpu->memRead16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));

	addr = addr + 2;
	cpu->setRegPC(cpu->memRead16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));

	addr = addr + 2;
	cpu->setRegSP(addr);
}

// SWI: Software Interrupt

op swi(0x3F[8])

swi.getCycles = { return 9; }

swi.disasm = {
	sink << "SWI";
}

swi.execute = {
	/* (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; B : A=> (M(SP) : M(SP+1))
	 * In case of CPU12
	 * (SP) – $0001 => SP; CCR => (M(SP) )
	 * In case of CPU12X
	 * (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
	 * 1 => I; 0 => U
	 * (SWI Vector) => PC
	 */

	address_t addr = cpu->getRegSP();
	
	addr = addr - 2;
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());
	
	addr = addr - 2;
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());
	
	addr = addr - 2;
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());
	
	addr = addr - 2;
	cpu->memWrite8(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());
	
	addr = addr - 2;
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());
	
	cpu->ccr->setI();
	cpu->ccr->setCCRHigh(cpu->ccr->getCCRHigh() & 0x7F);
	
	// TODO: (SWI Vector) => PC
}

// TRAP: unimplemented opcode trap
// trapnum: Trap number $30-$39 or $40-$FF

op trap(0x18[8]:trapnum[8])

trap.getCycles = { return 10; }

trap.disasm = {
	sink << "TRAP $" << std::hex << trapnum;
}

trap.execute = {
	
	if (((trapnum >= 0x30) && (trapnum <= 0x39)) || ((trapnum >= 0x40) && (trapnum <= 0xFF))) {
		/*
		 * (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
		 * (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
		 * (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
		 * (SP) – $0002 => SP; B : A => (M(SP) : M(SP+1))
		 * In case of CPU12
		 * (SP) – $0001 => SP; CCR => (M(SP) )
		 * In case of CPU12X
		 * (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
		 * 1 => I; 0 => U
		 * (Trap Vector) => PC
		 */
		 
		address_t addr = cpu->getRegSP();
		
		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());
		
		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());
		
		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());

		addr = addr - 2;
		cpu->memWrite8(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());
		
		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());
		
		// 1 => I; 0 => U
		cpu->ccr->setI();
		cpu->ccr->setCCRHigh(cpu->ccr->getCCRHigh() & 0x7F);
		
		// (Trap Vector) => PC
		cpu->setRegPC(cpu->memRead16(cpu->get_Trap_Vector()));
	}
}

// SYS: System Call Interrupt
// System call interrupt vector is $FF12:$FF13

op sys(0x18[8]:0xA7[8])

sys.getCycles = { return 10; }

sys.disasm = {
	sink << "SYS";
}

sys.execute = {
	
	/*
	 * (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
	 * (SP) – $0002 => SP; B : A => (M(SP) : M(SP+1))
	 * In case of CPU12
	 * (SP) – $0001 => SP; CCR => (M(SP) )
	 * In case of CPU12X
	 * (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
	 * 1 => I; 0 => U
	 * (Trap Vector) => PC
	 */
		 
	address_t addr = cpu->getRegSP();
		
	addr = addr - 2;
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());
		
	addr = addr - 2;
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());
		
	addr = addr - 2;
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());

	addr = addr - 2;
	cpu->memWrite8(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());
		
	addr = addr - 2;
	cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());
		
	// 1 => I; 0 => U
	cpu->ccr->setI();
	cpu->ccr->setCCRHigh(cpu->ccr->getCCRHigh() & 0x7F);
		
	// (Sys Vector) => PC
	cpu->setRegPC(cpu->memRead16(cpu->get_Sys_Vector()));
}
