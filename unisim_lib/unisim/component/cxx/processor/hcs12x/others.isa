/*
 *  Copyright (c) 2008,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
 */


// NOP:
op nop(0xA7[8])

nop.disasm = {
	sink << "NOP";	
}

nop.execute = {
	// This single-byte instruction increments the PC and does nothing else.
}

// STOP:
op stop(0x18[8]:0x3E[8])

stop.disasm = {
	sink << "STOP";
}

stop.execute = {
	
	if (cpu->ccr->getS() == 1) {
		/*
		 * if S control bit = 1, the STOP instruction is disabled and acts like two-cycle NOP
		 */
		// TODO: consume two cycles	 
	} else {
		/*
		 * (SP) – $0002 ⇒ SP; RTNH : RTNL ⇒ (M(SP) : M(SP+1))
		 * (SP) – $0002 ⇒ SP; YH : YL ⇒ (M(SP) : M(SP+1))
		 * (SP) – $0002 ⇒ SP; XH : XL ⇒ (M(SP) : M(SP+1))
		 * (SP) – $0002 ⇒ SP; B : A ⇒ (M(SP) : M(SP+1))
		 * (SP) – $0002 ⇒ SP; CCRH : CCRL ⇒ (M(SP) : M(SP+1))
		 * Stop All Clocks and puts the device in standby mode
		 */
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite16(cpu->getRegSP(), cpu->getRegPC());
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite16(cpu->getRegSP(), cpu->getRegY());
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite16(cpu->getRegSP(), cpu->getRegX());
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite8(cpu->getRegSP(), cpu->getRegB());
		 cpu->memWrite8(cpu->getRegSP()+1, cpu->getRegA());
		 
		 cpu->setRegSP(cpu->getRegSP()-2);
		 cpu->memWrite16(cpu->getRegSP(), cpu->ccr->getCCR());
		 
		 /* TODO: 
		  * Stop All Clocks and puts the device in standby mode.
		  * Asserting the RESET, XIRQ, or IRQ signals ends standby mode. 
		  */
		 
	 	 cpu->Sleep();
	 	 
	 	 /* TODO:
	 	  * If XIRQ is asserted while the X mask bit = 0 (XIRQ interrupts enabled), 
	 	  * execution resumes with a vector fetch for the XIRQ interrupt. 
	 	  * While the X mask bit = 1 (XIRQ interrupts disabled), 
	 	  * a 2-cycle recovery sequence is used to adjust the instruction queue and the stack pointer, 
	 	  * and execution continues with the next instruction after STOP.
	 	  */
	}
}

// WAIT
op wait(0x3E[8])

wait.disasm = {
	sink << "WAI";
}

wait.execute = {

	/*
	 * (SP) – $0002 ⇒ SP; RTNH : RTNL ⇒ (M(SP) : M(SP+1))
	 * (SP) – $0002 ⇒ SP; YH : YL ⇒ (M(SP) : M(SP+1))
	 * (SP) – $0002 ⇒ SP; XH : XL ⇒ (M(SP) : M(SP+1))
	 * (SP) – $0002 ⇒ SP; B : A ⇒ (M(SP) : M(SP+1))
	 * (SP) – $0002 ⇒ SP; CCRH : CCRL ⇒ (M(SP) : M(SP+1))
	 * The CPU12 then enters a wait state for an integer number of bus clock cycles. 
	 * During the wait state, CPU12 clocks are stopped, but otherMCUclocks can continue to run.
	 * WAIT for not masked interrupt
	 */
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite16(cpu->getRegSP(), cpu->getRegPC());
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite16(cpu->getRegSP(), cpu->getRegY());
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite16(cpu->getRegSP(), cpu->getRegX());
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite8(cpu->getRegSP(), cpu->getRegB());
	 cpu->memWrite8(cpu->getRegSP()+1, cpu->getRegA());
	 
	 cpu->setRegSP(cpu->getRegSP()-2);
	 cpu->memWrite16(cpu->getRegSP(), cpu->ccr->getCCR());

	/* TODO: 
	 * Enter a wait state for an integer number of bus clock cycle
	 * Only CPU12 clocks are stopped
	 * Wait for not masked interrupt
	 */

	 cpu->Wait();
	 
	 /*
	  * If XIRQ is asserted while the X mask bit = 0 (XIRQ interrupts enabled),
	  * execution resumes with a vector fetch for the XIRQ interrupt. 
	  * While the X mask bit = 1 (XIRQ interrupts disabled), 
	  * a 2-cycle recovery sequence is used to adjust the instruction queue and the stack pointer, 
	  * and execution continues with the next instruction after WAI.
	  */
}

// BGND: Enter Background debug mode

op bgnd(0x00[8])

bgnd.disasm = {
	sink << "BGND";
}

bgnd.execute = {
	// TODO
}

/* ********** Interrupt instructions ******** */

// RTI: Return from interrupt

op rti(0x0B[8])

rti.disasm = {
	sink << "RTI";
}

rti.execute = {
	/*
	 * (M(SP) : M(SP+1)) ⇒ CCRH : CCRL; (SP) + $0002 ⇒ SP
	 * (M(SP) : M(SP+1)) ⇒ B : A; (SP) + $0002 ⇒ SP
	 * (M(SP) : M(SP+1)) ⇒ XH : XL; (SP) + $0004 ⇒ SP
	 * (M(SP) : M(SP+1)) ⇒ PCH : PCL; (SP) – $0002 ⇒ SP
	 * (M(SP) : M(SP+1)) ⇒ YH : YL; (SP) + $0004 ⇒ SP
	 * */
	 
	address_t addr = cpu->getRegSP();
	
	/* Leave bit X unchanged.
	 * X bit can be set only by a reset or by recognition of an (!XIRQ) interrupt
	 */ 	 
	cpu->ccr->setCCR((cpu->memRead16(addr) & 0xFFBF) | (cpu->ccr->getCCR() & 0x0040));

	addr = addr + 2;
	cpu->setRegB(cpu->memRead8(addr));
	cpu->setRegA(cpu->memRead8(addr+1));

	addr = addr + 2;
	cpu->setRegX(cpu->memRead16(addr));

	addr = addr + 2;
	cpu->setRegY(cpu->memRead16(addr));

	addr = addr + 2;
	cpu->setRegPC(cpu->memRead16(addr));

	addr = addr + 2;
	cpu->setRegSP(addr);
}

// SWI: Software Interrupt

op swi(0x3F[8])

swi.disasm = {
	sink << "SWI";
}

swi.execute = {
	/* (SP) – $0002 ⇒ SP; RTNH : RTNL ⇒ (M(SP) : M(SP+1))
	 * (SP) – $0002 ⇒ SP; YH : YL ⇒ (M(SP) : M(SP+1))
	 * (SP) – $0002 ⇒ SP; XH : XL ⇒ (M(SP) : M(SP+1))
	 * (SP) – $0002 ⇒ SP; B : A⇒ (M(SP) : M(SP+1))
	 * In case of CPU12
	 * (SP) – $0001 ⇒ SP; CCR ⇒ (M(SP) )
	 * In case of CPU12X
	 * (SP) – $0002 ⇒ SP; CCRH : CCRL ⇒ (M(SP) : M(SP+1))
	 * 1 ⇒ I; 0 ⇒ U
	 * (SWI Vector) ⇒ PC
	 */

	address_t addr = cpu->getRegSP();
	
	addr = addr - 2;
	cpu->memWrite16(addr, cpu->getRegPC());
	
	addr = addr - 2;
	cpu->memWrite16(addr, cpu->getRegY());
	
	addr = addr - 2;
	cpu->memWrite16(addr, cpu->getRegX());
	
	addr = addr - 2;
	cpu->memWrite8(addr, cpu->getRegB());
	cpu->memWrite16(addr+1, cpu->getRegA());
	
	addr = addr - 2;
	cpu->memWrite16(addr, cpu->ccr->getCCR());
	
	cpu->ccr->setCCRLow(cpu->ccr->getCCRLow() | 0x10);
	cpu->ccr->setCCRHigh(cpu->ccr->getCCRHigh() & 0x7F);
	
	// TODO: (SWI Vector) ⇒ PC
}

// TRAP: unimplemented opcode trap
// trapnum: Trap number $30-$39 or $40-$FF

op trap(0x18[8]:trapnum[8])

trap.disasm = {
	sink << "TRAP $" << std::hex << trapnum;
}

trap.execute = {
	
	if (((trapnum >= 0x30) && (trapnum <= 0x39)) || ((trapnum >= 0x40) && (trapnum <= 0xFF))) {
		/*
		 * (SP) – $0002 ⇒ SP; RTNH : RTNL ⇒ (M(SP) : M(SP+1))
		 * (SP) – $0002 ⇒ SP; YH : YL ⇒ (M(SP) : M(SP+1))
		 * (SP) – $0002 ⇒ SP; XH : XL ⇒ (M(SP) : M(SP+1))
		 * (SP) – $0002 ⇒ SP; B : A ⇒ (M(SP) : M(SP+1))
		 * In case of CPU12
		 * (SP) – $0001 ⇒ SP; CCR ⇒ (M(SP) )
		 * In case of CPU12X
		 * (SP) – $0002 ⇒ SP; CCRH : CCRL ⇒ (M(SP) : M(SP+1))
		 * 1 ⇒ I; 0 ⇒ U
		 * (Trap Vector) ⇒ PC
		 */
		 
		address_t addr = cpu->getRegSP();
		
		addr = addr - 2;
		cpu->memWrite16(addr, cpu->getRegPC());
		
		addr = addr - 2;
		cpu->memWrite16(addr, cpu->getRegY());
		
		addr = addr - 2;
		cpu->memWrite16(addr, cpu->getRegX());

		addr = addr - 2;
		cpu->memWrite8(addr, cpu->getRegB());
		cpu->memWrite16(addr+1, cpu->getRegA());
		
		addr = addr - 2;
		cpu->memWrite16(addr, cpu->ccr->getCCR());
		
		cpu->ccr->setCCRLow(cpu->ccr->getCCRLow() | 0x10);
		cpu->ccr->setCCRHigh(cpu->ccr->getCCRHigh() & 0x7F);
		
		// TODO: (Trap Vector) ⇒ PC
	}
}

