#include "hcs12x.hh"
#include <cassert>
#include <ostream>
#include <cstring>
#line 59 "hcs12x.isa"

#include <unisim/component/cxx/processor/hcs12x/xb.hh>
#include <stdlib.h>

using unisim::component::cxx::processor::hcs12x::XB::XbModes;

#line 13 "hcs12x.cc"
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x {
unsigned int const CodeType::maxsize;
std::ostream& operator << ( std::ostream& _sink, CodeType const& _ct ) {
	char const* xrepr = "0123456789abcdef";
	char const* sep = "";
	for( unsigned int idx = 0; idx < _ct.size; ++idx, sep = " " ) {
		uint32_t byte = _ct.str[idx];
		_sink << sep << xrepr[byte/16] << xrepr[byte%16];
	}
	return _sink;
}
Operation::Operation(CodeType const& _code, uint16_t _addr, const char *_name)
:
encoding(_code),
addr(_addr),
name(_name)
{
}

Operation::~Operation()
{
}

#line 88 "hcs12x.isa"
uint8_t
#line 39 "hcs12x.cc"
Operation::getCycles()
{
#line 88 "hcs12x.isa"
	{
		/*
		* if (indexed_addressing) then
		*   return XbModes::GetIDXCycles(xb->getXbMode(), <idx_cyles>, <idx1_cyles>, <idx2_cyles>, <idxd_ind_cyles>, <idx2_ind_cyles>);
		*
		*/
		return 0;
	}
#line 51 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 55 "hcs12x.cc"
Operation::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 59 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 62 "hcs12x.cc"
)
{
#line 83 "hcs12x.isa"
	{

		//	sink << "asm(\"NOP\");\n";
	}
#line 70 "hcs12x.cc"
}
#line 79 "hcs12x.isa"
void
#line 74 "hcs12x.cc"
Operation::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 78 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 81 "hcs12x.cc"
)
{
#line 79 "hcs12x.isa"
	{
		//	sink << "asm(\"NOP\");\n";
	}
#line 88 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 92 "hcs12x.cc"
Operation::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 96 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 99 "hcs12x.cc"
)
{
#line 73 "hcs12x.isa"
	{
		sink << "?";

		return "?";
	}
#line 108 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 112 "hcs12x.cc"
Operation::execute(
#line 67 "hcs12x.isa"
CPU *
#line 116 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 119 "hcs12x.cc"
)
{
#line 67 "hcs12x.isa"
	{
		printf("Unknown instruction\n");

		exit(-1);
	}
#line 128 "hcs12x.cc"
}
class OpCall_idx : public Operation
{
public:
	OpCall_idx(CodeType const& code, uint16_t addr);
	~OpCall_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 137 "hcs12x.cc"
	* xb;
	uint32_t page;
	virtual
#line 79 "hcs12x.isa"
	void
#line 143 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 147 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 150 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 155 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 159 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 162 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 167 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 172 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 176 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 179 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 221 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 225 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 228 "hcs12x.cc"
	);
private:
};

class OpTrap : public Operation
{
public:
	OpTrap(CodeType const& code, uint16_t addr);
	uint32_t trapnum;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 241 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 246 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 250 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 253 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 295 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 299 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 302 "hcs12x.cc"
	);
private:
};

class OpLdaab_imm : public Operation
{
public:
	OpLdaab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 316 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 321 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 325 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 328 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 370 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 374 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 377 "hcs12x.cc"
	);
private:
};

class OpLdaab_dir : public Operation
{
public:
	OpLdaab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 391 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 396 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 400 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 403 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 445 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 449 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 452 "hcs12x.cc"
	);
private:
};

class OpLdaab_ext : public Operation
{
public:
	OpLdaab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 466 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 471 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 475 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 478 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 520 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 524 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 527 "hcs12x.cc"
	);
private:
};

class OpLdaab_idx : public Operation
{
public:
	OpLdaab_idx(CodeType const& code, uint16_t addr);
	~OpLdaab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 540 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 545 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 549 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 552 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 557 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 561 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 564 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 569 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 574 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 578 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 581 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 623 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 627 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 630 "hcs12x.cc"
	);
private:
};

class OpLd_dyxs_imm : public Operation
{
public:
	OpLd_dyxs_imm(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 644 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 649 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 653 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 656 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 698 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 702 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 705 "hcs12x.cc"
	);
private:
};

class OpLd_dyxs_dir : public Operation
{
public:
	OpLd_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 719 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 724 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 728 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 731 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 773 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 777 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 780 "hcs12x.cc"
	);
private:
};

class OpLd_dyxs_ext : public Operation
{
public:
	OpLd_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 794 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 799 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 803 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 806 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 848 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 852 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 855 "hcs12x.cc"
	);
private:
};

class OpLd_dyxs_idx : public Operation
{
public:
	OpLd_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpLd_dyxs_idx();
	uint32_t dyxs;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 868 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 873 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 877 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 880 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 885 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 889 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 892 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 897 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 902 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 906 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 909 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 951 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 955 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 958 "hcs12x.cc"
	);
private:
};

class OpLeay : public Operation
{
public:
	OpLeay(CodeType const& code, uint16_t addr);
	~OpLeay();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 970 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 975 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 980 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 984 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 987 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1029 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1033 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1036 "hcs12x.cc"
	);
private:
};

class OpLeax : public Operation
{
public:
	OpLeax(CodeType const& code, uint16_t addr);
	~OpLeax();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1048 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1053 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1058 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1062 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1065 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1107 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1111 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1114 "hcs12x.cc"
	);
private:
};

class OpLeas : public Operation
{
public:
	OpLeas(CodeType const& code, uint16_t addr);
	~OpLeas();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1126 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1131 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1136 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1140 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1143 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1185 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1189 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1192 "hcs12x.cc"
	);
private:
};

class OpStaab_dir : public Operation
{
public:
	OpStaab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1206 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1211 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1215 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1218 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1260 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1264 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1267 "hcs12x.cc"
	);
private:
};

class OpStaab_ext : public Operation
{
public:
	OpStaab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1281 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1286 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1290 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1293 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1335 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1339 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1342 "hcs12x.cc"
	);
private:
};

class OpStaab_idx : public Operation
{
public:
	OpStaab_idx(CodeType const& code, uint16_t addr);
	~OpStaab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1355 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 1360 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 1364 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 1367 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 1372 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 1376 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 1379 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1384 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1389 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1393 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1396 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1438 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1442 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1445 "hcs12x.cc"
	);
private:
};

class OpSt_dyxs_dir : public Operation
{
public:
	OpSt_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1459 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1464 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1468 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1471 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1513 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1517 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1520 "hcs12x.cc"
	);
private:
};

class OpSt_dyxs_ext : public Operation
{
public:
	OpSt_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1534 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1539 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1543 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1546 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1588 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1592 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1595 "hcs12x.cc"
	);
private:
};

class OpSt_dyxs_idx : public Operation
{
public:
	OpSt_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpSt_dyxs_idx();
	uint32_t dyxs;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1608 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 1613 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 1617 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 1620 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 1625 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 1629 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 1632 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1637 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1642 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1646 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1649 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1691 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1695 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1698 "hcs12x.cc"
	);
private:
};

class OpGldaab_dir : public Operation
{
public:
	OpGldaab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1712 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1717 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1721 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1724 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1766 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1770 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1773 "hcs12x.cc"
	);
private:
};

class OpGldaab_ext : public Operation
{
public:
	OpGldaab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1787 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1792 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1796 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1799 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1841 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1845 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1848 "hcs12x.cc"
	);
private:
};

class OpGldaab_idx : public Operation
{
public:
	OpGldaab_idx(CodeType const& code, uint16_t addr);
	~OpGldaab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1861 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 1866 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 1870 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 1873 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 1878 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 1882 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 1885 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1890 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1895 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1899 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1902 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 1944 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 1948 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 1951 "hcs12x.cc"
	);
private:
};

class OpGld_dyxs_dir : public Operation
{
public:
	OpGld_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 1965 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 1970 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 1974 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 1977 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2019 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2023 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2026 "hcs12x.cc"
	);
private:
};

class OpGld_dyxs_ext : public Operation
{
public:
	OpGld_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2040 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2045 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2049 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2052 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2094 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2098 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2101 "hcs12x.cc"
	);
private:
};

class OpGld_dyxs_idx : public Operation
{
public:
	OpGld_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpGld_dyxs_idx();
	uint32_t dyxs;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 2114 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 2119 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 2123 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 2126 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 2131 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 2135 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 2138 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2143 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2148 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2152 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2155 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2197 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2201 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2204 "hcs12x.cc"
	);
private:
};

class OpGstaab_dir : public Operation
{
public:
	OpGstaab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2218 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2223 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2227 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2230 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2272 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2276 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2279 "hcs12x.cc"
	);
private:
};

class OpGstaab_ext : public Operation
{
public:
	OpGstaab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2293 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2298 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2302 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2305 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2347 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2351 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2354 "hcs12x.cc"
	);
private:
};

class OpGstaab_idx : public Operation
{
public:
	OpGstaab_idx(CodeType const& code, uint16_t addr);
	~OpGstaab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 2367 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 2372 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 2376 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 2379 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 2384 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 2388 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 2391 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2396 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2401 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2405 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2408 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2450 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2454 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2457 "hcs12x.cc"
	);
private:
};

class OpGst_dyxs_dir : public Operation
{
public:
	OpGst_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2471 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2476 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2480 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2483 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2525 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2529 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2532 "hcs12x.cc"
	);
private:
};

class OpGst_dyxs_ext : public Operation
{
public:
	OpGst_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2546 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2551 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2555 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2558 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2600 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2604 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2607 "hcs12x.cc"
	);
private:
};

class OpGst_dyxs_idx : public Operation
{
public:
	OpGst_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpGst_dyxs_idx();
	uint32_t dyxs;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 2620 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 2625 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 2629 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 2632 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 2637 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 2641 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 2644 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2649 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2654 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2658 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2661 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2703 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2707 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2710 "hcs12x.cc"
	);
private:
};

class OpT_ab_ba : public Operation
{
public:
	OpT_ab_ba(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2723 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2728 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2732 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2735 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2777 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2781 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2784 "hcs12x.cc"
	);
private:
};

class OpExg_hcs12 : public Operation
{
public:
	OpExg_hcs12(CodeType const& code, uint16_t addr);
	uint32_t lms;
	uint32_t lls;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2798 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2803 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2807 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2810 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2852 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2856 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2859 "hcs12x.cc"
	);
private:
};

class OpTfr_hcs12 : public Operation
{
public:
	OpTfr_hcs12(CodeType const& code, uint16_t addr);
	uint32_t lms;
	uint32_t hls;
	uint32_t lls;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2874 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2879 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2883 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2886 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 2928 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 2932 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 2935 "hcs12x.cc"
	);
private:
};

class OpExg_hcs12x : public Operation
{
public:
	OpExg_hcs12x(CodeType const& code, uint16_t addr);
	uint32_t lms;
	uint32_t lls;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 2949 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 2954 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 2958 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 2961 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3003 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3007 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3010 "hcs12x.cc"
	);
private:
};

class OpTfr_hcs12x : public Operation
{
public:
	OpTfr_hcs12x(CodeType const& code, uint16_t addr);
	uint32_t lms;
	uint32_t lls;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3024 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3029 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3033 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3036 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3078 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3082 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3085 "hcs12x.cc"
	);
private:
};

class OpMovb_0B : public Operation
{
public:
	OpMovb_0B(CodeType const& code, uint16_t addr);
	uint32_t ii;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3099 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3104 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3108 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3111 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3153 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3157 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3160 "hcs12x.cc"
	);
private:
};

class OpMovb_08 : public Operation
{
public:
	OpMovb_08(CodeType const& code, uint16_t addr);
	~OpMovb_08();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3172 "hcs12x.cc"
	* xb;
	uint32_t ii;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3178 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3183 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3187 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3190 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3232 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3236 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3239 "hcs12x.cc"
	);
private:
};

class OpMovb_0C : public Operation
{
public:
	OpMovb_0C(CodeType const& code, uint16_t addr);
	uint32_t opr16asrc;
	uint32_t opr16adst;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3253 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3258 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3262 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3265 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3307 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3311 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3314 "hcs12x.cc"
	);
private:
};

class OpMovb_09 : public Operation
{
public:
	OpMovb_09(CodeType const& code, uint16_t addr);
	~OpMovb_09();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3326 "hcs12x.cc"
	* xb;
	uint32_t opr16asrc;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3332 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3337 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3341 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3344 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3386 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3390 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3393 "hcs12x.cc"
	);
private:
};

class OpMovb_0D : public Operation
{
public:
	OpMovb_0D(CodeType const& code, uint16_t addr);
	~OpMovb_0D();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3405 "hcs12x.cc"
	* xb;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3411 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3416 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3420 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3423 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3465 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3469 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3472 "hcs12x.cc"
	);
private:
};

class OpMovb_0A : public Operation
{
public:
	OpMovb_0A(CodeType const& code, uint16_t addr);
	~OpMovb_0A();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3484 "hcs12x.cc"
	* xbsrc;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3488 "hcs12x.cc"
	* xbdst;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3493 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3498 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3502 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3505 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3547 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3551 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3554 "hcs12x.cc"
	);
private:
};

class OpMovw_03 : public Operation
{
public:
	OpMovw_03(CodeType const& code, uint16_t addr);
	uint32_t opr16i;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3568 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3573 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3577 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3580 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3622 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3626 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3629 "hcs12x.cc"
	);
private:
};

class OpMovw_04 : public Operation
{
public:
	OpMovw_04(CodeType const& code, uint16_t addr);
	uint32_t opr16asrc;
	uint32_t opr16adst;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3643 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3648 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3652 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3655 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3697 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3701 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3704 "hcs12x.cc"
	);
private:
};

class OpMovw_00 : public Operation
{
public:
	OpMovw_00(CodeType const& code, uint16_t addr);
	~OpMovw_00();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3716 "hcs12x.cc"
	* xb;
	uint32_t opr16i;
	virtual
#line 73 "hcs12x.isa"
	string
#line 3722 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3726 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3729 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3771 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3775 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3778 "hcs12x.cc"
	);
private:
};

class OpMovw_01 : public Operation
{
public:
	OpMovw_01(CodeType const& code, uint16_t addr);
	~OpMovw_01();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3790 "hcs12x.cc"
	* xb;
	uint32_t opr16asrc;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3796 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3801 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3805 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3808 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3850 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3854 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3857 "hcs12x.cc"
	);
private:
};

class OpMovw_05 : public Operation
{
public:
	OpMovw_05(CodeType const& code, uint16_t addr);
	~OpMovw_05();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3869 "hcs12x.cc"
	* xb;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3875 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3880 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3884 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3887 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 3929 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 3933 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 3936 "hcs12x.cc"
	);
private:
};

class OpMovw_02 : public Operation
{
public:
	OpMovw_02(CodeType const& code, uint16_t addr);
	~OpMovw_02();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3948 "hcs12x.cc"
	* xbsrc;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3952 "hcs12x.cc"
	* xbdst;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 3957 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 3962 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 3966 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 3969 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4011 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4015 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4018 "hcs12x.cc"
	);
private:
};

class OpAba : public Operation
{
public:
	OpAba(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4030 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4035 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4039 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4042 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4084 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4088 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4091 "hcs12x.cc"
	);
private:
};

class OpAbx : public Operation
{
public:
	OpAbx(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4103 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4108 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4112 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4115 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4157 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4161 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4164 "hcs12x.cc"
	);
private:
};

class OpAby : public Operation
{
public:
	OpAby(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4176 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4181 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4185 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4188 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4230 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4234 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4237 "hcs12x.cc"
	);
private:
};

class OpAdc_ab_imm : public Operation
{
public:
	OpAdc_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4251 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4256 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4260 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4263 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4305 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4309 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4312 "hcs12x.cc"
	);
private:
};

class OpAdc_ab_dir : public Operation
{
public:
	OpAdc_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4326 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4331 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4335 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4338 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4380 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4384 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4387 "hcs12x.cc"
	);
private:
};

class OpAdc_ab_ext : public Operation
{
public:
	OpAdc_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4401 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4406 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4410 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4413 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4455 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4459 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4462 "hcs12x.cc"
	);
private:
};

class OpAdc_ab_idx : public Operation
{
public:
	OpAdc_ab_idx(CodeType const& code, uint16_t addr);
	~OpAdc_ab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 4475 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4480 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4485 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4489 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4492 "hcs12x.cc"
	);
	virtual
#line 79 "hcs12x.isa"
	void
#line 4497 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 4501 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 4504 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 4509 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 4513 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 4516 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4558 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4562 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4565 "hcs12x.cc"
	);
private:
};

class OpAdd_ab_imm : public Operation
{
public:
	OpAdd_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4579 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4584 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4588 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4591 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4633 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4637 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4640 "hcs12x.cc"
	);
private:
};

class OpAdd_ab_dir : public Operation
{
public:
	OpAdd_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4654 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4659 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4663 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4666 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4708 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4712 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4715 "hcs12x.cc"
	);
private:
};

class OpAdd_ab_ext : public Operation
{
public:
	OpAdd_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4729 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4734 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4738 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4741 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4783 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4787 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4790 "hcs12x.cc"
	);
private:
};

class OpAdd_ab_idx : public Operation
{
public:
	OpAdd_ab_idx(CodeType const& code, uint16_t addr);
	~OpAdd_ab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 4803 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 4808 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 4812 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 4815 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 4820 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 4824 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 4827 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4832 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4837 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4841 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4844 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4886 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4890 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4893 "hcs12x.cc"
	);
private:
};

class OpAded_imm : public Operation
{
public:
	OpAded_imm(CodeType const& code, uint16_t addr);
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4906 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4911 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4915 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4918 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 4960 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 4964 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 4967 "hcs12x.cc"
	);
private:
};

class OpAded_dir : public Operation
{
public:
	OpAded_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 4980 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 4985 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 4989 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 4992 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5034 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5038 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5041 "hcs12x.cc"
	);
private:
};

class OpAded_ext : public Operation
{
public:
	OpAded_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5054 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5059 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5063 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5066 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5108 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5112 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5115 "hcs12x.cc"
	);
private:
};

class OpAded_idx : public Operation
{
public:
	OpAded_idx(CodeType const& code, uint16_t addr);
	~OpAded_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 5127 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 5132 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 5136 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 5139 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 5144 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 5148 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 5151 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5156 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5161 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5165 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5168 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5210 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5214 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5217 "hcs12x.cc"
	);
private:
};

class OpAde_xy_imm : public Operation
{
public:
	OpAde_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5231 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5236 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5240 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5243 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5285 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5289 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5292 "hcs12x.cc"
	);
private:
};

class OpAde_xy_dir : public Operation
{
public:
	OpAde_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5306 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5311 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5315 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5318 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5360 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5364 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5367 "hcs12x.cc"
	);
private:
};

class OpAde_xy_ext : public Operation
{
public:
	OpAde_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5381 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5386 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5390 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5393 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5435 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5439 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5442 "hcs12x.cc"
	);
private:
};

class OpAde_xy_idx : public Operation
{
public:
	OpAde_xy_idx(CodeType const& code, uint16_t addr);
	~OpAde_xy_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 5455 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 5460 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 5464 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 5467 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 5472 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 5476 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 5479 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5484 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5489 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5493 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5496 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5538 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5542 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5545 "hcs12x.cc"
	);
private:
};

class OpAdd_xy_imm : public Operation
{
public:
	OpAdd_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5559 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5564 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5568 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5571 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5613 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5617 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5620 "hcs12x.cc"
	);
private:
};

class OpAdd_xy_dir : public Operation
{
public:
	OpAdd_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5634 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5639 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5643 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5646 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5688 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5692 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5695 "hcs12x.cc"
	);
private:
};

class OpAdd_xy_ext : public Operation
{
public:
	OpAdd_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5709 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5714 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5718 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5721 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5763 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5767 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5770 "hcs12x.cc"
	);
private:
};

class OpAdd_xy_idx : public Operation
{
public:
	OpAdd_xy_idx(CodeType const& code, uint16_t addr);
	~OpAdd_xy_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 5783 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 5788 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 5792 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 5795 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 5800 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 5804 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 5807 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5812 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5817 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5821 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5824 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5866 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5870 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5873 "hcs12x.cc"
	);
private:
};

class OpAdd_sub_d_imm : public Operation
{
public:
	OpAdd_sub_d_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5887 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5892 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5896 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5899 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 5941 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 5945 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 5948 "hcs12x.cc"
	);
private:
};

class OpAdd_sub_d_dir : public Operation
{
public:
	OpAdd_sub_d_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 5962 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 5967 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 5971 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 5974 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6016 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6020 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6023 "hcs12x.cc"
	);
private:
};

class OpAdd_sub_d_ext : public Operation
{
public:
	OpAdd_sub_d_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6037 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6042 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6046 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6049 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6091 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6095 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6098 "hcs12x.cc"
	);
private:
};

class OpAdd_sub_d_idx : public Operation
{
public:
	OpAdd_sub_d_idx(CodeType const& code, uint16_t addr);
	~OpAdd_sub_d_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 6111 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 6116 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 6120 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 6123 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 6128 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 6132 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 6135 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6140 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6145 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6149 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6152 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6194 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6198 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6201 "hcs12x.cc"
	);
private:
};

class OpSba : public Operation
{
public:
	OpSba(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6213 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6218 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6222 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6225 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6267 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6271 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6274 "hcs12x.cc"
	);
private:
};

class OpSbc_ab_imm : public Operation
{
public:
	OpSbc_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6288 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6293 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6297 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6300 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6342 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6346 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6349 "hcs12x.cc"
	);
private:
};

class OpSbc_ab_dir : public Operation
{
public:
	OpSbc_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6363 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6368 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6372 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6375 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6417 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6421 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6424 "hcs12x.cc"
	);
private:
};

class OpSbc_ab_ext : public Operation
{
public:
	OpSbc_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6438 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6443 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6447 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6450 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6492 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6496 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6499 "hcs12x.cc"
	);
private:
};

class OpSbc_ab_idx : public Operation
{
public:
	OpSbc_ab_idx(CodeType const& code, uint16_t addr);
	~OpSbc_ab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 6512 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 6517 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 6521 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 6524 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 6529 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 6533 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 6536 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6541 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6546 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6550 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6553 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6595 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6599 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6602 "hcs12x.cc"
	);
private:
};

class OpSbed_imm : public Operation
{
public:
	OpSbed_imm(CodeType const& code, uint16_t addr);
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6615 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6620 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6624 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6627 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6669 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6673 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6676 "hcs12x.cc"
	);
private:
};

class OpSbed_dir : public Operation
{
public:
	OpSbed_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6689 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6694 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6698 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6701 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6743 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6747 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6750 "hcs12x.cc"
	);
private:
};

class OpSbed_ext : public Operation
{
public:
	OpSbed_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6763 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6768 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6772 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6775 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6817 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6821 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6824 "hcs12x.cc"
	);
private:
};

class OpSbed_idx : public Operation
{
public:
	OpSbed_idx(CodeType const& code, uint16_t addr);
	~OpSbed_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 6836 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 6841 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 6845 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 6848 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 6853 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 6857 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 6860 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6865 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6870 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6874 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6877 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6919 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6923 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 6926 "hcs12x.cc"
	);
private:
};

class OpSbe_xy_imm : public Operation
{
public:
	OpSbe_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 6940 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 6945 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 6949 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 6952 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 6994 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 6998 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7001 "hcs12x.cc"
	);
private:
};

class OpSbe_xy_dir : public Operation
{
public:
	OpSbe_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7015 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7020 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7024 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7027 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7069 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7073 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7076 "hcs12x.cc"
	);
private:
};

class OpSbe_xy_ext : public Operation
{
public:
	OpSbe_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7090 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7095 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7099 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7102 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7144 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7148 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7151 "hcs12x.cc"
	);
private:
};

class OpSbe_xy_idx : public Operation
{
public:
	OpSbe_xy_idx(CodeType const& code, uint16_t addr);
	~OpSbe_xy_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 7164 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 7169 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 7173 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 7176 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 7181 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 7185 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 7188 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7193 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7198 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7202 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7205 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7247 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7251 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7254 "hcs12x.cc"
	);
private:
};

class OpSub_ab_imm : public Operation
{
public:
	OpSub_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7268 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7273 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7277 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7280 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7322 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7326 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7329 "hcs12x.cc"
	);
private:
};

class OpSub_ab_dir : public Operation
{
public:
	OpSub_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7343 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7348 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7352 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7355 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7397 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7401 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7404 "hcs12x.cc"
	);
private:
};

class OpSub_ab_ext : public Operation
{
public:
	OpSub_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7418 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7423 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7427 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7430 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7472 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7476 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7479 "hcs12x.cc"
	);
private:
};

class OpSub_ab_idx : public Operation
{
public:
	OpSub_ab_idx(CodeType const& code, uint16_t addr);
	~OpSub_ab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 7492 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 7497 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 7501 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 7504 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 7509 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 7513 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 7516 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7521 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7526 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7530 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7533 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7575 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7579 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7582 "hcs12x.cc"
	);
private:
};

class OpSub_xy_imm : public Operation
{
public:
	OpSub_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7596 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7601 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7605 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7608 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7650 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7654 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7657 "hcs12x.cc"
	);
private:
};

class OpSub_xy_dir : public Operation
{
public:
	OpSub_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7671 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7676 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7680 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7683 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7725 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7729 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7732 "hcs12x.cc"
	);
private:
};

class OpSub_xy_ext : public Operation
{
public:
	OpSub_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7746 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7751 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7755 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7758 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7800 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7804 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7807 "hcs12x.cc"
	);
private:
};

class OpSub_xy_idx : public Operation
{
public:
	OpSub_xy_idx(CodeType const& code, uint16_t addr);
	~OpSub_xy_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 7820 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 7825 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 7829 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 7832 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 7837 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 7841 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 7844 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7849 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7854 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7858 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7861 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7903 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7907 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7910 "hcs12x.cc"
	);
private:
};

class OpDaa : public Operation
{
public:
	OpDaa(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7922 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 7927 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 7931 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 7934 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 7976 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 7980 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 7983 "hcs12x.cc"
	);
private:
};

class OpDec_ext : public Operation
{
public:
	OpDec_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 7996 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8001 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8005 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8008 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8050 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8054 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8057 "hcs12x.cc"
	);
private:
};

class OpDec_idx : public Operation
{
public:
	OpDec_idx(CodeType const& code, uint16_t addr);
	~OpDec_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 8069 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 8074 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 8078 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 8081 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 8086 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 8090 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 8093 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8098 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8103 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8107 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8110 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8152 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8156 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8159 "hcs12x.cc"
	);
private:
};

class OpDec_ab : public Operation
{
public:
	OpDec_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8172 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8177 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8181 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8184 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8226 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8230 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8233 "hcs12x.cc"
	);
private:
};

class OpDecw_ext : public Operation
{
public:
	OpDecw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8246 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8251 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8255 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8258 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8300 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8304 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8307 "hcs12x.cc"
	);
private:
};

class OpDecw_idx : public Operation
{
public:
	OpDecw_idx(CodeType const& code, uint16_t addr);
	~OpDecw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 8319 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 8324 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 8328 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 8331 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 8336 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 8340 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 8343 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8348 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8353 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8357 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8360 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8402 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8406 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8409 "hcs12x.cc"
	);
private:
};

class OpDec_xy : public Operation
{
public:
	OpDec_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8422 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8427 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8431 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8434 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8476 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8480 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8483 "hcs12x.cc"
	);
private:
};

class OpDes : public Operation
{
public:
	OpDes(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8495 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8500 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8504 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8507 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8549 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8553 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8556 "hcs12x.cc"
	);
private:
};

class OpDex : public Operation
{
public:
	OpDex(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8568 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8573 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8577 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8580 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8622 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8626 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8629 "hcs12x.cc"
	);
private:
};

class OpDey : public Operation
{
public:
	OpDey(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8641 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8646 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8650 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8653 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8695 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8699 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8702 "hcs12x.cc"
	);
private:
};

class OpInc_ext : public Operation
{
public:
	OpInc_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8715 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8720 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8724 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8727 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8769 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8773 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8776 "hcs12x.cc"
	);
private:
};

class OpInc_idx : public Operation
{
public:
	OpInc_idx(CodeType const& code, uint16_t addr);
	~OpInc_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 8788 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 8793 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 8797 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 8800 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 8805 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 8809 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 8812 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8817 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8822 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8826 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8829 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8871 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8875 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8878 "hcs12x.cc"
	);
private:
};

class OpInc_ab : public Operation
{
public:
	OpInc_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8891 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8896 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8900 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8903 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 8945 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 8949 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 8952 "hcs12x.cc"
	);
private:
};

class OpIncw_ext : public Operation
{
public:
	OpIncw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 8965 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 8970 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 8974 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 8977 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9019 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9023 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9026 "hcs12x.cc"
	);
private:
};

class OpIncw_idx : public Operation
{
public:
	OpIncw_idx(CodeType const& code, uint16_t addr);
	~OpIncw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 9038 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 9043 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 9047 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 9050 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 9055 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 9059 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 9062 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9067 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9072 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9076 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9079 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9121 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9125 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9128 "hcs12x.cc"
	);
private:
};

class OpInc_xy : public Operation
{
public:
	OpInc_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9141 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9146 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9150 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9153 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9195 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9199 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9202 "hcs12x.cc"
	);
private:
};

class OpIns : public Operation
{
public:
	OpIns(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9214 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9219 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9223 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9226 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9268 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9272 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9275 "hcs12x.cc"
	);
private:
};

class OpInx : public Operation
{
public:
	OpInx(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9287 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9292 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9296 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9299 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9341 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9345 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9348 "hcs12x.cc"
	);
private:
};

class OpIny : public Operation
{
public:
	OpIny(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9360 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9365 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9369 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9372 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9414 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9418 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9421 "hcs12x.cc"
	);
private:
};

class OpCba : public Operation
{
public:
	OpCba(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9433 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9438 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9442 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9445 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9487 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9491 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9494 "hcs12x.cc"
	);
private:
};

class OpCmp_ab_imm : public Operation
{
public:
	OpCmp_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9508 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9513 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9517 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9520 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9562 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9566 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9569 "hcs12x.cc"
	);
private:
};

class OpCmp_ab_dir : public Operation
{
public:
	OpCmp_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9583 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9588 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9592 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9595 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9637 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9641 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9644 "hcs12x.cc"
	);
private:
};

class OpCmp_ab_ext : public Operation
{
public:
	OpCmp_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9658 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9663 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9667 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9670 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9712 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9716 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9719 "hcs12x.cc"
	);
private:
};

class OpCmp_ab_idx : public Operation
{
public:
	OpCmp_ab_idx(CodeType const& code, uint16_t addr);
	~OpCmp_ab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 9732 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 9737 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 9741 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 9744 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 9749 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 9753 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 9756 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9761 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9766 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9770 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9773 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9815 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9819 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9822 "hcs12x.cc"
	);
private:
};

class OpCp_dyxs_imm : public Operation
{
public:
	OpCp_dyxs_imm(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9836 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9841 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9845 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9848 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9890 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9894 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9897 "hcs12x.cc"
	);
private:
};

class OpCp_dyxs_dir : public Operation
{
public:
	OpCp_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9911 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9916 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9920 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9923 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 9965 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 9969 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 9972 "hcs12x.cc"
	);
private:
};

class OpCp_dyxs_ext : public Operation
{
public:
	OpCp_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 9986 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 9991 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 9995 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 9998 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10040 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10044 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10047 "hcs12x.cc"
	);
private:
};

class OpCp_dyxs_idx : public Operation
{
public:
	OpCp_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpCp_dyxs_idx();
	uint32_t dyxs;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 10060 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 10065 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 10069 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 10072 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 10077 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 10081 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 10084 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10089 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10094 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10098 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10101 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10143 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10147 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10150 "hcs12x.cc"
	);
private:
};

class OpCpe_dyxs_imm : public Operation
{
public:
	OpCpe_dyxs_imm(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10164 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10169 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10173 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10176 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10218 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10222 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10225 "hcs12x.cc"
	);
private:
};

class OpCpe_dyxs_dir : public Operation
{
public:
	OpCpe_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10239 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10244 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10248 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10251 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10293 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10297 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10300 "hcs12x.cc"
	);
private:
};

class OpCpe_dyxs_ext : public Operation
{
public:
	OpCpe_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10314 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10319 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10323 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10326 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10368 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10372 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10375 "hcs12x.cc"
	);
private:
};

class OpCpe_dyxs_idx : public Operation
{
public:
	OpCpe_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpCpe_dyxs_idx();
	uint32_t dyxs;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 10388 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 10393 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 10397 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 10400 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 10405 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 10409 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 10412 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10417 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10422 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10426 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10429 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10471 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10475 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10478 "hcs12x.cc"
	);
private:
};

class OpTst_ext : public Operation
{
public:
	OpTst_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10491 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10496 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10500 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10503 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10545 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10549 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10552 "hcs12x.cc"
	);
private:
};

class OpTst_idx : public Operation
{
public:
	OpTst_idx(CodeType const& code, uint16_t addr);
	~OpTst_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 10564 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 10569 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 10573 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 10576 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 10581 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 10585 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 10588 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10593 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10598 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10602 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10605 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10647 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10651 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10654 "hcs12x.cc"
	);
private:
};

class OpTst_ab : public Operation
{
public:
	OpTst_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10667 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10672 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10676 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10679 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10721 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10725 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10728 "hcs12x.cc"
	);
private:
};

class OpTstw_ext : public Operation
{
public:
	OpTstw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10741 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10746 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10750 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10753 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10795 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10799 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10802 "hcs12x.cc"
	);
private:
};

class OpTstw_idx : public Operation
{
public:
	OpTstw_idx(CodeType const& code, uint16_t addr);
	~OpTstw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 10814 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 10819 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 10823 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 10826 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 10831 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 10835 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 10838 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10843 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10848 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10852 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10855 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10897 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10901 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10904 "hcs12x.cc"
	);
private:
};

class OpTst_xy : public Operation
{
public:
	OpTst_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10917 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 10922 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 10926 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 10929 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 10971 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 10975 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 10978 "hcs12x.cc"
	);
private:
};

class OpEmind : public Operation
{
public:
	OpEmind(CodeType const& code, uint16_t addr);
	~OpEmind();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 10990 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 10995 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11000 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11004 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11007 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11049 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11053 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11056 "hcs12x.cc"
	);
private:
};

class OpEminm : public Operation
{
public:
	OpEminm(CodeType const& code, uint16_t addr);
	~OpEminm();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11068 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11073 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11078 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11082 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11085 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11127 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11131 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11134 "hcs12x.cc"
	);
private:
};

class OpMina : public Operation
{
public:
	OpMina(CodeType const& code, uint16_t addr);
	~OpMina();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11146 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11151 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11156 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11160 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11163 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11205 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11209 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11212 "hcs12x.cc"
	);
private:
};

class OpMinm : public Operation
{
public:
	OpMinm(CodeType const& code, uint16_t addr);
	~OpMinm();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11224 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11229 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11234 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11238 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11241 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11283 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11287 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11290 "hcs12x.cc"
	);
private:
};

class OpEmaxd : public Operation
{
public:
	OpEmaxd(CodeType const& code, uint16_t addr);
	~OpEmaxd();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11302 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11307 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11312 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11316 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11319 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11361 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11365 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11368 "hcs12x.cc"
	);
private:
};

class OpEmaxm : public Operation
{
public:
	OpEmaxm(CodeType const& code, uint16_t addr);
	~OpEmaxm();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11380 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11385 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11390 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11394 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11397 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11439 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11443 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11446 "hcs12x.cc"
	);
private:
};

class OpMaxa : public Operation
{
public:
	OpMaxa(CodeType const& code, uint16_t addr);
	~OpMaxa();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11458 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11463 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11468 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11472 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11475 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11517 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11521 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11524 "hcs12x.cc"
	);
private:
};

class OpMaxm : public Operation
{
public:
	OpMaxm(CodeType const& code, uint16_t addr);
	~OpMaxm();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11536 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11541 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11546 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11550 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11553 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11595 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11599 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11602 "hcs12x.cc"
	);
private:
};

class OpAnd_ab_imm : public Operation
{
public:
	OpAnd_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11616 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11621 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11625 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11628 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11670 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11674 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11677 "hcs12x.cc"
	);
private:
};

class OpAnd_ab_dir : public Operation
{
public:
	OpAnd_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11691 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11696 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11700 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11703 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11745 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11749 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11752 "hcs12x.cc"
	);
private:
};

class OpAnd_ab_ext : public Operation
{
public:
	OpAnd_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11766 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11771 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11775 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11778 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11820 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11824 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11827 "hcs12x.cc"
	);
private:
};

class OpAnd_ab_idx : public Operation
{
public:
	OpAnd_ab_idx(CodeType const& code, uint16_t addr);
	~OpAnd_ab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11840 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 11845 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 11849 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 11852 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 11857 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 11861 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 11864 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11869 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11874 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11878 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11881 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11923 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 11927 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 11930 "hcs12x.cc"
	);
private:
};

class OpAndcc_imm : public Operation
{
public:
	OpAndcc_imm(CodeType const& code, uint16_t addr);
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 11943 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 11948 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 11952 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 11955 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 11997 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12001 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12004 "hcs12x.cc"
	);
private:
};

class OpAnd_xy_imm : public Operation
{
public:
	OpAnd_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12018 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12023 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12027 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12030 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12072 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12076 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12079 "hcs12x.cc"
	);
private:
};

class OpAnd_xy_dir : public Operation
{
public:
	OpAnd_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12093 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12098 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12102 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12105 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12147 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12151 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12154 "hcs12x.cc"
	);
private:
};

class OpAnd_xy_ext : public Operation
{
public:
	OpAnd_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12168 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12173 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12177 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12180 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12222 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12226 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12229 "hcs12x.cc"
	);
private:
};

class OpAnd_xy_idx : public Operation
{
public:
	OpAnd_xy_idx(CodeType const& code, uint16_t addr);
	~OpAnd_xy_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 12242 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 12247 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 12251 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 12254 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 12259 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 12263 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 12266 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12271 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12276 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12280 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12283 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12325 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12329 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12332 "hcs12x.cc"
	);
private:
};

class OpOra_ab_imm : public Operation
{
public:
	OpOra_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12346 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12351 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12355 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12358 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12400 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12404 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12407 "hcs12x.cc"
	);
private:
};

class OpOra_ab_dir : public Operation
{
public:
	OpOra_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12421 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12426 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12430 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12433 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12475 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12479 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12482 "hcs12x.cc"
	);
private:
};

class OpOra_ab_ext : public Operation
{
public:
	OpOra_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12496 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12501 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12505 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12508 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12550 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12554 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12557 "hcs12x.cc"
	);
private:
};

class OpOra_ab_idx : public Operation
{
public:
	OpOra_ab_idx(CodeType const& code, uint16_t addr);
	~OpOra_ab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 12570 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 12575 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 12579 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 12582 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 12587 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 12591 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 12594 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12599 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12604 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12608 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12611 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12653 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12657 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12660 "hcs12x.cc"
	);
private:
};

class OpOrcc_imm : public Operation
{
public:
	OpOrcc_imm(CodeType const& code, uint16_t addr);
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12673 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12678 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12682 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12685 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12727 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12731 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12734 "hcs12x.cc"
	);
private:
};

class OpOr_xy_imm : public Operation
{
public:
	OpOr_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12748 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12753 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12757 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12760 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12802 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12806 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12809 "hcs12x.cc"
	);
private:
};

class OpOr_xy_dir : public Operation
{
public:
	OpOr_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12823 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12828 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12832 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12835 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12877 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12881 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12884 "hcs12x.cc"
	);
private:
};

class OpOr_xy_ext : public Operation
{
public:
	OpOr_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 12898 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 12903 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 12907 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 12910 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 12952 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 12956 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 12959 "hcs12x.cc"
	);
private:
};

class OpOr_xy_idx : public Operation
{
public:
	OpOr_xy_idx(CodeType const& code, uint16_t addr);
	~OpOr_xy_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 12972 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 12977 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 12981 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 12984 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 12989 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 12993 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 12996 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13001 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13006 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13010 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13013 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13055 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13059 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13062 "hcs12x.cc"
	);
private:
};

class OpEor_ab_imm : public Operation
{
public:
	OpEor_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13076 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13081 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13085 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13088 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13130 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13134 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13137 "hcs12x.cc"
	);
private:
};

class OpEor_ab_dir : public Operation
{
public:
	OpEor_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13151 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13156 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13160 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13163 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13205 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13209 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13212 "hcs12x.cc"
	);
private:
};

class OpEor_ab_ext : public Operation
{
public:
	OpEor_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13226 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13231 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13235 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13238 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13280 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13284 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13287 "hcs12x.cc"
	);
private:
};

class OpEor_ab_idx : public Operation
{
public:
	OpEor_ab_idx(CodeType const& code, uint16_t addr);
	~OpEor_ab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 13300 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 13305 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 13309 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 13312 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 13317 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 13321 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 13324 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13329 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13334 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13338 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13341 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13383 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13387 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13390 "hcs12x.cc"
	);
private:
};

class OpEor_xy_imm : public Operation
{
public:
	OpEor_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13404 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13409 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13413 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13416 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13458 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13462 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13465 "hcs12x.cc"
	);
private:
};

class OpEor_xy_dir : public Operation
{
public:
	OpEor_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13479 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13484 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13488 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13491 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13533 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13537 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13540 "hcs12x.cc"
	);
private:
};

class OpEor_xy_ext : public Operation
{
public:
	OpEor_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13554 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13559 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13563 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13566 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13608 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13612 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13615 "hcs12x.cc"
	);
private:
};

class OpEor_xy_idx : public Operation
{
public:
	OpEor_xy_idx(CodeType const& code, uint16_t addr);
	~OpEor_xy_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 13628 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 13633 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 13637 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 13640 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 13645 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 13649 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 13652 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13657 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13662 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13666 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13669 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13711 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13715 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13718 "hcs12x.cc"
	);
private:
};

class OpClc : public Operation
{
public:
	OpClc(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13730 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13735 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13739 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13742 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13784 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13788 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13791 "hcs12x.cc"
	);
private:
};

class OpCli : public Operation
{
public:
	OpCli(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13803 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13808 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13812 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13815 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13857 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13861 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13864 "hcs12x.cc"
	);
private:
};

class OpClv : public Operation
{
public:
	OpClv(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13876 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13881 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13885 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13888 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 13930 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 13934 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 13937 "hcs12x.cc"
	);
private:
};

class OpClr_ext : public Operation
{
public:
	OpClr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 13950 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 13955 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 13959 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 13962 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14004 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14008 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14011 "hcs12x.cc"
	);
private:
};

class OpClr_idx : public Operation
{
public:
	OpClr_idx(CodeType const& code, uint16_t addr);
	~OpClr_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 14023 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 14028 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 14032 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 14035 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 14040 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 14044 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 14047 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14052 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14057 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14061 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14064 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14106 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14110 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14113 "hcs12x.cc"
	);
private:
};

class OpClrw_ext : public Operation
{
public:
	OpClrw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14126 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14131 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14135 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14138 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14180 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14184 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14187 "hcs12x.cc"
	);
private:
};

class OpClrw_idx : public Operation
{
public:
	OpClrw_idx(CodeType const& code, uint16_t addr);
	~OpClrw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 14199 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 14204 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 14208 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 14211 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 14216 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 14220 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 14223 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14228 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14233 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14237 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14240 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14282 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14286 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14289 "hcs12x.cc"
	);
private:
};

class OpClr_ab : public Operation
{
public:
	OpClr_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14302 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14307 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14311 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14314 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14356 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14360 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14363 "hcs12x.cc"
	);
private:
};

class OpClr_xy : public Operation
{
public:
	OpClr_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14376 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14381 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14385 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14388 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14430 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14434 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14437 "hcs12x.cc"
	);
private:
};

class OpCom_ext : public Operation
{
public:
	OpCom_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14450 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14455 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14459 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14462 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14504 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14508 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14511 "hcs12x.cc"
	);
private:
};

class OpCom_idx : public Operation
{
public:
	OpCom_idx(CodeType const& code, uint16_t addr);
	~OpCom_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 14523 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 14528 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 14532 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 14535 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 14540 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 14544 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 14547 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14552 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14557 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14561 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14564 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14606 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14610 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14613 "hcs12x.cc"
	);
private:
};

class OpCom_ab : public Operation
{
public:
	OpCom_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14626 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14631 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14635 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14638 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14680 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14684 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14687 "hcs12x.cc"
	);
private:
};

class OpComw_ext : public Operation
{
public:
	OpComw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14700 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14705 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14709 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14712 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14754 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14758 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14761 "hcs12x.cc"
	);
private:
};

class OpComw_idx : public Operation
{
public:
	OpComw_idx(CodeType const& code, uint16_t addr);
	~OpComw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 14773 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 14778 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 14782 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 14785 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 14790 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 14794 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 14797 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14802 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14807 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14811 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14814 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14856 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14860 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14863 "hcs12x.cc"
	);
private:
};

class OpCom_xy : public Operation
{
public:
	OpCom_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14876 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14881 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14885 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14888 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 14930 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 14934 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 14937 "hcs12x.cc"
	);
private:
};

class OpNeg_ext : public Operation
{
public:
	OpNeg_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 14950 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 14955 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 14959 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 14962 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15004 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15008 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15011 "hcs12x.cc"
	);
private:
};

class OpNeg_idx : public Operation
{
public:
	OpNeg_idx(CodeType const& code, uint16_t addr);
	~OpNeg_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 15023 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 15028 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 15032 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 15035 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 15040 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 15044 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 15047 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15052 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15057 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15061 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15064 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15106 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15110 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15113 "hcs12x.cc"
	);
private:
};

class OpNeg_ab : public Operation
{
public:
	OpNeg_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15126 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15131 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15135 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15138 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15180 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15184 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15187 "hcs12x.cc"
	);
private:
};

class OpNegw_ext : public Operation
{
public:
	OpNegw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15200 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15205 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15209 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15212 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15254 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15258 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15261 "hcs12x.cc"
	);
private:
};

class OpNegw_idx : public Operation
{
public:
	OpNegw_idx(CodeType const& code, uint16_t addr);
	~OpNegw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 15273 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 15278 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 15282 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 15285 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 15290 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 15294 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 15297 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15302 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15307 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15311 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15314 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15356 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15360 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15363 "hcs12x.cc"
	);
private:
};

class OpNeg_xy : public Operation
{
public:
	OpNeg_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15376 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15381 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15385 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15388 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15430 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15434 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15437 "hcs12x.cc"
	);
private:
};

class OpBclr_dir : public Operation
{
public:
	OpBclr_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	uint32_t mm;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15451 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15456 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15460 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15463 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15505 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15509 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15512 "hcs12x.cc"
	);
private:
};

class OpBclr_ext : public Operation
{
public:
	OpBclr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	uint32_t mm;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15526 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15531 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15535 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15538 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15580 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15584 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15587 "hcs12x.cc"
	);
private:
};

class OpBclr_idx : public Operation
{
public:
	OpBclr_idx(CodeType const& code, uint16_t addr);
	~OpBclr_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 15599 "hcs12x.cc"
	* xb;
	uint32_t mm;
	virtual
#line 79 "hcs12x.isa"
	void
#line 15605 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 15609 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 15612 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 15617 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 15621 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 15624 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15629 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15634 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15638 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15641 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15683 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15687 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15690 "hcs12x.cc"
	);
private:
};

class OpBit_ab_imm : public Operation
{
public:
	OpBit_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t ii;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15704 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15709 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15713 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15716 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15758 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15762 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15765 "hcs12x.cc"
	);
private:
};

class OpBit_ab_dir : public Operation
{
public:
	OpBit_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15779 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15784 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15788 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15791 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15833 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15837 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15840 "hcs12x.cc"
	);
private:
};

class OpBit_ab_ext : public Operation
{
public:
	OpBit_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15854 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15859 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15863 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15866 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 15908 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 15912 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 15915 "hcs12x.cc"
	);
private:
};

class OpBit_ab_idx : public Operation
{
public:
	OpBit_ab_idx(CodeType const& code, uint16_t addr);
	~OpBit_ab_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 15928 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 15933 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 15937 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 15940 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 15945 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 15949 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 15952 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 15957 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 15962 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 15966 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 15969 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16011 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16015 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16018 "hcs12x.cc"
	);
private:
};

class OpBit_xy_imm : public Operation
{
public:
	OpBit_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16032 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16037 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16041 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16044 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16086 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16090 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16093 "hcs12x.cc"
	);
private:
};

class OpBit_xy_dir : public Operation
{
public:
	OpBit_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16107 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16112 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16116 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16119 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16161 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16165 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16168 "hcs12x.cc"
	);
private:
};

class OpBit_xy_ext : public Operation
{
public:
	OpBit_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16182 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16187 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16191 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16194 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16236 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16240 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16243 "hcs12x.cc"
	);
private:
};

class OpBit_xy_idx : public Operation
{
public:
	OpBit_xy_idx(CodeType const& code, uint16_t addr);
	~OpBit_xy_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 16256 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 16261 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 16265 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 16268 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 16273 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 16277 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 16280 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16285 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16290 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16294 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16297 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16339 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16343 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16346 "hcs12x.cc"
	);
private:
};

class OpBset_dir : public Operation
{
public:
	OpBset_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	uint32_t mm;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16360 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16365 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16369 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16372 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16414 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16418 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16421 "hcs12x.cc"
	);
private:
};

class OpBset_ext : public Operation
{
public:
	OpBset_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	uint32_t mm;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16435 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16440 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16444 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16447 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16489 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16493 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16496 "hcs12x.cc"
	);
private:
};

class OpBset_idx : public Operation
{
public:
	OpBset_idx(CodeType const& code, uint16_t addr);
	~OpBset_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 16508 "hcs12x.cc"
	* xb;
	uint32_t mm;
	virtual
#line 79 "hcs12x.isa"
	void
#line 16514 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 16518 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 16521 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 16526 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 16530 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 16533 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16538 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16543 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16547 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16550 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16592 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16596 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16599 "hcs12x.cc"
	);
private:
};

class OpLsl_ext : public Operation
{
public:
	OpLsl_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16612 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16617 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16621 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16624 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16666 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16670 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16673 "hcs12x.cc"
	);
private:
};

class OpLsl_idx : public Operation
{
public:
	OpLsl_idx(CodeType const& code, uint16_t addr);
	~OpLsl_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 16685 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 16690 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 16694 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 16697 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 16702 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 16706 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 16709 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16714 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16719 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16723 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16726 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16768 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16772 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16775 "hcs12x.cc"
	);
private:
};

class OpLsla : public Operation
{
public:
	OpLsla(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16787 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16792 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16796 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16799 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16841 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16845 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16848 "hcs12x.cc"
	);
private:
};

class OpLslb : public Operation
{
public:
	OpLslb(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16860 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16865 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16869 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16872 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16914 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16918 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16921 "hcs12x.cc"
	);
private:
};

class OpLsld : public Operation
{
public:
	OpLsld(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 16933 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 16938 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 16942 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 16945 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 16987 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 16991 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 16994 "hcs12x.cc"
	);
private:
};

class OpLslw_ext : public Operation
{
public:
	OpLslw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17007 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17012 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17016 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17019 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17061 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17065 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17068 "hcs12x.cc"
	);
private:
};

class OpLslw_idx : public Operation
{
public:
	OpLslw_idx(CodeType const& code, uint16_t addr);
	~OpLslw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 17080 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 17085 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 17089 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 17092 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 17097 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 17101 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 17104 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17109 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17114 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17118 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17121 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17163 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17167 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17170 "hcs12x.cc"
	);
private:
};

class OpLslx : public Operation
{
public:
	OpLslx(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17182 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17187 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17191 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17194 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17236 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17240 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17243 "hcs12x.cc"
	);
private:
};

class OpLsly : public Operation
{
public:
	OpLsly(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17255 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17260 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17264 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17267 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17309 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17313 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17316 "hcs12x.cc"
	);
private:
};

class OpRol_ext : public Operation
{
public:
	OpRol_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17329 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17334 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17338 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17341 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17383 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17387 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17390 "hcs12x.cc"
	);
private:
};

class OpRol_idx : public Operation
{
public:
	OpRol_idx(CodeType const& code, uint16_t addr);
	~OpRol_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 17402 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 17407 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 17411 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 17414 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 17419 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 17423 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 17426 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17431 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17436 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17440 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17443 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17485 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17489 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17492 "hcs12x.cc"
	);
private:
};

class OpRola : public Operation
{
public:
	OpRola(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17504 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17509 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17513 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17516 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17558 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17562 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17565 "hcs12x.cc"
	);
private:
};

class OpRolb : public Operation
{
public:
	OpRolb(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17577 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17582 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17586 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17589 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17631 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17635 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17638 "hcs12x.cc"
	);
private:
};

class OpRolw_ext : public Operation
{
public:
	OpRolw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17651 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17656 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17660 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17663 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17705 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17709 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17712 "hcs12x.cc"
	);
private:
};

class OpRolw_idx : public Operation
{
public:
	OpRolw_idx(CodeType const& code, uint16_t addr);
	~OpRolw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 17724 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 17729 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 17733 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 17736 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 17741 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 17745 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 17748 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17753 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17758 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17762 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17765 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17807 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17811 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17814 "hcs12x.cc"
	);
private:
};

class OpRolx : public Operation
{
public:
	OpRolx(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17826 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17831 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17835 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17838 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17880 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17884 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17887 "hcs12x.cc"
	);
private:
};

class OpRoly : public Operation
{
public:
	OpRoly(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17899 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17904 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17908 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17911 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 17953 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 17957 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 17960 "hcs12x.cc"
	);
private:
};

class OpLsr_ext : public Operation
{
public:
	OpLsr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 17973 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 17978 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 17982 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 17985 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18027 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18031 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18034 "hcs12x.cc"
	);
private:
};

class OpLsr_idx : public Operation
{
public:
	OpLsr_idx(CodeType const& code, uint16_t addr);
	~OpLsr_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 18046 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 18051 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 18055 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 18058 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 18063 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 18067 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 18070 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18075 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18080 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18084 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18087 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18129 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18133 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18136 "hcs12x.cc"
	);
private:
};

class OpLsra : public Operation
{
public:
	OpLsra(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18148 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18153 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18157 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18160 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18202 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18206 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18209 "hcs12x.cc"
	);
private:
};

class OpLsrb : public Operation
{
public:
	OpLsrb(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18221 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18226 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18230 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18233 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18275 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18279 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18282 "hcs12x.cc"
	);
private:
};

class OpLsrd : public Operation
{
public:
	OpLsrd(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18294 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18299 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18303 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18306 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18348 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18352 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18355 "hcs12x.cc"
	);
private:
};

class OpLsrw_ext : public Operation
{
public:
	OpLsrw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18368 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18373 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18377 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18380 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18422 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18426 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18429 "hcs12x.cc"
	);
private:
};

class OpLsrw_idx : public Operation
{
public:
	OpLsrw_idx(CodeType const& code, uint16_t addr);
	~OpLsrw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 18441 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 18446 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 18450 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 18453 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 18458 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 18462 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 18465 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18470 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18475 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18479 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18482 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18524 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18528 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18531 "hcs12x.cc"
	);
private:
};

class OpLsrx : public Operation
{
public:
	OpLsrx(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18543 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18548 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18552 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18555 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18597 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18601 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18604 "hcs12x.cc"
	);
private:
};

class OpLsry : public Operation
{
public:
	OpLsry(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18616 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18621 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18625 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18628 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18670 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18674 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18677 "hcs12x.cc"
	);
private:
};

class OpRor_ext : public Operation
{
public:
	OpRor_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18690 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18695 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18699 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18702 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18744 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18748 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18751 "hcs12x.cc"
	);
private:
};

class OpRor_idx : public Operation
{
public:
	OpRor_idx(CodeType const& code, uint16_t addr);
	~OpRor_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 18763 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 18768 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 18772 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 18775 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 18780 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 18784 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 18787 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18792 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18797 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18801 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18804 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18846 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18850 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18853 "hcs12x.cc"
	);
private:
};

class OpRora : public Operation
{
public:
	OpRora(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18865 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18870 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18874 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18877 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18919 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18923 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18926 "hcs12x.cc"
	);
private:
};

class OpRorb : public Operation
{
public:
	OpRorb(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 18938 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 18943 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 18947 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 18950 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 18992 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 18996 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 18999 "hcs12x.cc"
	);
private:
};

class OpRorw_ext : public Operation
{
public:
	OpRorw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19012 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19017 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19021 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19024 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19066 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19070 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19073 "hcs12x.cc"
	);
private:
};

class OpRorw_idx : public Operation
{
public:
	OpRorw_idx(CodeType const& code, uint16_t addr);
	~OpRorw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 19085 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 19090 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 19094 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 19097 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 19102 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 19106 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 19109 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19114 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19119 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19123 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19126 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19168 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19172 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19175 "hcs12x.cc"
	);
private:
};

class OpRorx : public Operation
{
public:
	OpRorx(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19187 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19192 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19196 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19199 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19241 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19245 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19248 "hcs12x.cc"
	);
private:
};

class OpRory : public Operation
{
public:
	OpRory(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19260 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19265 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19269 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19272 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19314 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19318 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19321 "hcs12x.cc"
	);
private:
};

class OpAsr_ext : public Operation
{
public:
	OpAsr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19334 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19339 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19343 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19346 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19388 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19392 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19395 "hcs12x.cc"
	);
private:
};

class OpAsr_idx : public Operation
{
public:
	OpAsr_idx(CodeType const& code, uint16_t addr);
	~OpAsr_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 19407 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 19412 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 19416 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 19419 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 19424 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 19428 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 19431 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19436 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19441 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19445 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19448 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19490 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19494 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19497 "hcs12x.cc"
	);
private:
};

class OpAsra : public Operation
{
public:
	OpAsra(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19509 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19514 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19518 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19521 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19563 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19567 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19570 "hcs12x.cc"
	);
private:
};

class OpAsrb : public Operation
{
public:
	OpAsrb(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19582 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19587 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19591 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19594 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19636 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19640 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19643 "hcs12x.cc"
	);
private:
};

class OpAsrw_ext : public Operation
{
public:
	OpAsrw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19656 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19661 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19665 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19668 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19710 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19714 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19717 "hcs12x.cc"
	);
private:
};

class OpAsrw_idx : public Operation
{
public:
	OpAsrw_idx(CodeType const& code, uint16_t addr);
	~OpAsrw_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 19729 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 19734 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 19738 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 19741 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 19746 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 19750 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 19753 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19758 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19763 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19767 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19770 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19812 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19816 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19819 "hcs12x.cc"
	);
private:
};

class OpAsrx : public Operation
{
public:
	OpAsrx(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19831 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19836 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19840 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19843 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19885 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19889 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19892 "hcs12x.cc"
	);
private:
};

class OpAsry : public Operation
{
public:
	OpAsry(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19904 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19909 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19913 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19916 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 19958 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 19962 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 19965 "hcs12x.cc"
	);
private:
};

class OpBtas_dir : public Operation
{
public:
	OpBtas_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	uint32_t msk8;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 19979 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 19984 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 19988 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 19991 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20033 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20037 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20040 "hcs12x.cc"
	);
private:
};

class OpBtas_ext : public Operation
{
public:
	OpBtas_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	uint32_t msk8;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20054 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20059 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20063 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20066 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20108 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20112 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20115 "hcs12x.cc"
	);
private:
};

class OpBtas_idx : public Operation
{
public:
	OpBtas_idx(CodeType const& code, uint16_t addr);
	~OpBtas_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 20127 "hcs12x.cc"
	* xb;
	uint32_t msk8;
	virtual
#line 79 "hcs12x.isa"
	void
#line 20133 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 20137 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 20140 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 20145 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 20149 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 20152 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20157 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20162 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20166 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20169 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20211 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20215 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20218 "hcs12x.cc"
	);
private:
};

class OpEmul : public Operation
{
public:
	OpEmul(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20230 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20235 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20239 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20242 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20284 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20288 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20291 "hcs12x.cc"
	);
private:
};

class OpEmuls : public Operation
{
public:
	OpEmuls(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20303 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20308 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20312 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20315 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20357 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20361 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20364 "hcs12x.cc"
	);
private:
};

class OpMul : public Operation
{
public:
	OpMul(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20376 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20381 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20385 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20388 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20430 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20434 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20437 "hcs12x.cc"
	);
private:
};

class OpEdiv : public Operation
{
public:
	OpEdiv(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20449 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20454 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20458 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20461 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20503 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20507 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20510 "hcs12x.cc"
	);
private:
};

class OpEdivs : public Operation
{
public:
	OpEdivs(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20522 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20527 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20531 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20534 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20576 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20580 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20583 "hcs12x.cc"
	);
private:
};

class OpFdiv : public Operation
{
public:
	OpFdiv(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20595 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20600 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20604 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20607 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20649 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20653 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20656 "hcs12x.cc"
	);
private:
};

class OpIdiv : public Operation
{
public:
	OpIdiv(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20668 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20673 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20677 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20680 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20722 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20726 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20729 "hcs12x.cc"
	);
private:
};

class OpIdivs : public Operation
{
public:
	OpIdivs(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20741 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20746 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20750 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20753 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20795 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20799 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20802 "hcs12x.cc"
	);
private:
};

class OpEmacs : public Operation
{
public:
	OpEmacs(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20815 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20820 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20824 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20827 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20869 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20873 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20876 "hcs12x.cc"
	);
private:
};

class OpSbr : public Operation
{
public:
	OpSbr(CodeType const& code, uint16_t addr);
	uint32_t sel;
	int32_t rel8;
#line 44 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	bool  branch;
#line 20889 "hcs12x.cc"
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20893 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20898 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20902 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20905 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 20947 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 20951 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 20954 "hcs12x.cc"
	);
private:
};

class OpLbr : public Operation
{
public:
	OpLbr(CodeType const& code, uint16_t addr);
	uint32_t sel;
	int32_t rel16;
#line 144 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	bool  branch;
#line 20967 "hcs12x.cc"
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 20971 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 20976 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 20980 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 20983 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21025 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21029 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21032 "hcs12x.cc"
	);
private:
};

class OpBr_clr_set_dir : public Operation
{
public:
	OpBr_clr_set_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	uint32_t msk8;
	int32_t rel8;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21048 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21053 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21057 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21060 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21102 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21106 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21109 "hcs12x.cc"
	);
private:
};

class OpBr_clr_set_ext : public Operation
{
public:
	OpBr_clr_set_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	uint32_t msk8;
	int32_t rel8;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21125 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21130 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21134 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21137 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21179 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21183 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21186 "hcs12x.cc"
	);
private:
};

class OpBr_clr_set_idx : public Operation
{
public:
	OpBr_clr_set_idx(CodeType const& code, uint16_t addr);
	~OpBr_clr_set_idx();
	uint32_t b;
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 21199 "hcs12x.cc"
	* xb;
	uint32_t msk8;
	int32_t rel8;
	virtual
#line 79 "hcs12x.isa"
	void
#line 21206 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 21210 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 21213 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 21218 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 21222 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 21225 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21230 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21235 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21239 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21242 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21284 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21288 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21291 "hcs12x.cc"
	);
private:
};

class OpBsr : public Operation
{
public:
	OpBsr(CodeType const& code, uint16_t addr);
	int32_t rel8;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21304 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21309 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21313 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21316 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21358 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21362 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21365 "hcs12x.cc"
	);
private:
};

class OpCall_ext : public Operation
{
public:
	OpCall_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	uint32_t page;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21379 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21384 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21388 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21391 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21433 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21437 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21440 "hcs12x.cc"
	);
private:
};

class OpCall_16offset_idx_ind : public Operation
{
public:
	OpCall_16offset_idx_ind(CodeType const& code, uint16_t addr);
	uint32_t rr;
	int32_t n16;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21454 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21459 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21463 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21466 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21508 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21512 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21515 "hcs12x.cc"
	);
private:
};

class OpCall_accD_offset_idx_ind : public Operation
{
public:
	OpCall_accD_offset_idx_ind(CodeType const& code, uint16_t addr);
	uint32_t rr;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21528 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21533 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21537 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21540 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21582 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21586 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21589 "hcs12x.cc"
	);
private:
};

class OpJmp_ext : public Operation
{
public:
	OpJmp_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21602 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21607 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21611 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21614 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21656 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21660 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21663 "hcs12x.cc"
	);
private:
};

class OpJmp_idx : public Operation
{
public:
	OpJmp_idx(CodeType const& code, uint16_t addr);
	~OpJmp_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 21675 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 21680 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 21684 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 21687 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 21692 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 21696 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 21699 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21704 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21709 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21713 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21716 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21758 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21762 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21765 "hcs12x.cc"
	);
private:
};

class OpJsr_dir : public Operation
{
public:
	OpJsr_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21778 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21783 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21787 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21790 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21832 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21836 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21839 "hcs12x.cc"
	);
private:
};

class OpJsr_ext : public Operation
{
public:
	OpJsr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21852 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21857 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21861 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21864 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 21906 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 21910 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 21913 "hcs12x.cc"
	);
private:
};

class OpJsr_idx : public Operation
{
public:
	OpJsr_idx(CodeType const& code, uint16_t addr);
	~OpJsr_idx();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 21925 "hcs12x.cc"
	* xb;
	virtual
#line 79 "hcs12x.isa"
	void
#line 21930 "hcs12x.cc"
	pre_execute(
#line 79 "hcs12x.isa"
	ostream&
#line 21934 "hcs12x.cc"
#line 79 "hcs12x.isa"
	sink
#line 21937 "hcs12x.cc"
	);
	virtual
#line 83 "hcs12x.isa"
	void
#line 21942 "hcs12x.cc"
	post_execute(
#line 83 "hcs12x.isa"
	ostream&
#line 21946 "hcs12x.cc"
#line 83 "hcs12x.isa"
	sink
#line 21949 "hcs12x.cc"
	);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 21954 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 21959 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 21963 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 21966 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22008 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22012 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22015 "hcs12x.cc"
	);
private:
};

class OpRtc : public Operation
{
public:
	OpRtc(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22027 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22032 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22036 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22039 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22081 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22085 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22088 "hcs12x.cc"
	);
private:
};

class OpRts : public Operation
{
public:
	OpRts(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22100 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22105 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22109 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22112 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22154 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22158 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22161 "hcs12x.cc"
	);
private:
};

class OpLoop : public Operation
{
public:
	OpLoop(CodeType const& code, uint16_t addr);
	uint32_t b765;
	uint32_t b4;
	uint32_t b3;
	uint32_t b210;
	uint32_t rel9;
#line 771 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	bool  isBranch;
#line 22177 "hcs12x.cc"
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22181 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22186 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22190 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22193 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22235 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22239 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22242 "hcs12x.cc"
	);
private:
};

class OpPsha : public Operation
{
public:
	OpPsha(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22254 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22259 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22263 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22266 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22308 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22312 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22315 "hcs12x.cc"
	);
private:
};

class OpPshb : public Operation
{
public:
	OpPshb(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22327 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22332 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22336 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22339 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22381 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22385 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22388 "hcs12x.cc"
	);
private:
};

class OpPshc : public Operation
{
public:
	OpPshc(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22400 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22405 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22409 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22412 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22454 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22458 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22461 "hcs12x.cc"
	);
private:
};

class OpPshcw : public Operation
{
public:
	OpPshcw(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22473 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22478 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22482 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22485 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22527 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22531 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22534 "hcs12x.cc"
	);
private:
};

class OpPshd : public Operation
{
public:
	OpPshd(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22546 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22551 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22555 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22558 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22600 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22604 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22607 "hcs12x.cc"
	);
private:
};

class OpPshx : public Operation
{
public:
	OpPshx(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22619 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22624 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22628 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22631 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22673 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22677 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22680 "hcs12x.cc"
	);
private:
};

class OpPshy : public Operation
{
public:
	OpPshy(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22692 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22697 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22701 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22704 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22746 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22750 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22753 "hcs12x.cc"
	);
private:
};

class OpPula : public Operation
{
public:
	OpPula(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22765 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22770 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22774 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22777 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22819 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22823 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22826 "hcs12x.cc"
	);
private:
};

class OpPulb : public Operation
{
public:
	OpPulb(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22838 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22843 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22847 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22850 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22892 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22896 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22899 "hcs12x.cc"
	);
private:
};

class OpPulc : public Operation
{
public:
	OpPulc(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22911 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22916 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22920 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22923 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 22965 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 22969 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 22972 "hcs12x.cc"
	);
private:
};

class OpPulcw : public Operation
{
public:
	OpPulcw(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 22984 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 22989 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 22993 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 22996 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23038 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23042 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23045 "hcs12x.cc"
	);
private:
};

class OpPuld : public Operation
{
public:
	OpPuld(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23057 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23062 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23066 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23069 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23111 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23115 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23118 "hcs12x.cc"
	);
private:
};

class OpPulx : public Operation
{
public:
	OpPulx(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23130 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23135 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23139 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23142 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23184 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23188 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23191 "hcs12x.cc"
	);
private:
};

class OpPuly : public Operation
{
public:
	OpPuly(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23203 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23208 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23212 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23215 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23257 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23261 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23264 "hcs12x.cc"
	);
private:
};

class OpMem : public Operation
{
public:
	OpMem(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23276 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23281 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23285 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23288 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23330 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23334 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23337 "hcs12x.cc"
	);
private:
};

class OpRev : public Operation
{
public:
	OpRev(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23349 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23354 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23358 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23361 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23403 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23407 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23410 "hcs12x.cc"
	);
private:
};

class OpRevw : public Operation
{
public:
	OpRevw(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23422 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23427 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23431 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23434 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23476 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23480 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23483 "hcs12x.cc"
	);
private:
};

class OpWav : public Operation
{
public:
	OpWav(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23495 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23500 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23504 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23507 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23549 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23553 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23556 "hcs12x.cc"
	);
private:
};

class OpWavr : public Operation
{
public:
	OpWavr(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23568 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23573 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23577 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23580 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23622 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23626 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23629 "hcs12x.cc"
	);
private:
};

class OpTbl : public Operation
{
public:
	OpTbl(CodeType const& code, uint16_t addr);
	~OpTbl();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 23641 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23646 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23651 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23655 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23658 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23700 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23704 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23707 "hcs12x.cc"
	);
private:
};

class OpEtlb : public Operation
{
public:
	OpEtlb(CodeType const& code, uint16_t addr);
	~OpEtlb();
#line 1 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 23719 "hcs12x.cc"
	* xb;
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23724 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23729 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23733 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23736 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23778 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23782 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23785 "hcs12x.cc"
	);
private:
};

class OpNop : public Operation
{
public:
	OpNop(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23797 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23802 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23806 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23809 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23851 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23855 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23858 "hcs12x.cc"
	);
private:
};

class OpStop : public Operation
{
public:
	OpStop(CodeType const& code, uint16_t addr);
#line 55 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	bool  stopDisabled;
#line 23869 "hcs12x.cc"
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23873 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23878 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23882 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23885 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 23927 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 23931 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 23934 "hcs12x.cc"
	);
private:
};

class OpWai : public Operation
{
public:
	OpWai(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 23946 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 23951 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 23955 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 23958 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 24000 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 24004 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 24007 "hcs12x.cc"
	);
private:
};

class OpBgnd : public Operation
{
public:
	OpBgnd(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 24019 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 24024 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 24028 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 24031 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 24073 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 24077 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 24080 "hcs12x.cc"
	);
private:
};

class OpRti : public Operation
{
public:
	OpRti(CodeType const& code, uint16_t addr);
#line 202 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	bool  isPending;
#line 24091 "hcs12x.cc"
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 24095 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 24100 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 24104 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 24107 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 24149 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 24153 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 24156 "hcs12x.cc"
	);
private:
};

class OpSwi : public Operation
{
public:
	OpSwi(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 24168 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 24173 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 24177 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 24180 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 24222 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 24226 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 24229 "hcs12x.cc"
	);
private:
};

class OpSys : public Operation
{
public:
	OpSys(CodeType const& code, uint16_t addr);
	virtual
#line 88 "hcs12x.isa"
	uint8_t
#line 24241 "hcs12x.cc"
	getCycles();
	virtual
#line 73 "hcs12x.isa"
	string
#line 24246 "hcs12x.cc"
	disasm(
#line 73 "hcs12x.isa"
	ostream&
#line 24250 "hcs12x.cc"
#line 73 "hcs12x.isa"
	sink
#line 24253 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// big_endian
	// decoder( cisc )
	// address {uint16_t}
	virtual
#line 67 "hcs12x.isa"
	void
#line 24295 "hcs12x.cc"
	execute(
#line 67 "hcs12x.isa"
	CPU *
#line 24299 "hcs12x.cc"
#line 67 "hcs12x.isa"
	cpu
#line 24302 "hcs12x.cc"
	);
private:
};

#line 79 "hcs12x.isa"
void
#line 24309 "hcs12x.cc"
OpCall_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 24313 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 24316 "hcs12x.cc"
)
{
#line 514 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 24325 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 24329 "hcs12x.cc"
OpCall_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 24333 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 24336 "hcs12x.cc"
)
{
#line 520 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 24345 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 24349 "hcs12x.cc"
OpCall_idx::getCycles()
{
#line 526 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 7, 7, 8, 0, 0); }
#line 24354 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 24358 "hcs12x.cc"
OpCall_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 24362 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 24365 "hcs12x.cc"
)
{
#line 528 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		string mnem = "CALL";

		sink << mnem << " ";
		xb->disasm(sink);
		sink << ", 0x" << std::hex << page;

		return mnem;
	}
#line 24379 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 24383 "hcs12x.cc"
OpCall_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 24387 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 24390 "hcs12x.cc"
)
{
#line 539 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* (SP)-1 => SP
		* (PPAGE) => M[SP]
		* page => PPAGE
		* Subroutine address => PC
		*/
		physical_address_t addr;
		page_t old_ppage;

		physical_address_t callAddr = xb->getEAddr(cpu);

		addr = cpu->getRegSP() - 2;
		cpu->setRegSP(addr);

		cpu->memWrite16(addr, cpu->getRegPC());

		addr = cpu->getRegSP() - 1;
		cpu->setRegSP(addr);

		old_ppage = cpu->memRead8(MMC::PPAGE_REG_ADDRESS);
		cpu->memWrite8(addr, old_ppage);

		cpu->memWrite8(MMC::PPAGE_REG_ADDRESS, page);
		cpu->setRegPC(callAddr);
	}
#line 24422 "hcs12x.cc"
}

static Operation *DecodeOpCall_idx(CodeType const& code, uint16_t addr)
{
	return new OpCall_idx(code, addr);
}

// TRAP: unimplemented opcode trap
// trapnum: Trap number 0x30-0x39 or 0x40-0xFF
#line 88 "hcs12x.isa"
uint8_t
#line 24434 "hcs12x.cc"
OpTrap::getCycles()
{
#line 283 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{ return 10; }
#line 24439 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 24443 "hcs12x.cc"
OpTrap::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 24447 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 24450 "hcs12x.cc"
)
{
#line 285 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		string mnem = "TRAP";

		sink << mnem << " 0x" << std::hex << trapnum;
		return mnem;
	}
#line 24460 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 24464 "hcs12x.cc"
OpTrap::execute(
#line 67 "hcs12x.isa"
CPU *
#line 24468 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 24471 "hcs12x.cc"
)
{
#line 292 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{

		if (((trapnum >= 0x30) && (trapnum <= 0x39)) || ((trapnum >= 0x40) && (trapnum <= 0xFF))) {
			/*
			* (SP)  0x0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
			* (SP)  0x0002 => SP; YH : YL => (M(SP) : M(SP+1))
			* (SP)  0x0002 => SP; XH : XL => (M(SP) : M(SP+1))
			* (SP)  0x0002 => SP; B : A => (M(SP) : M(SP+1))
			* In case of CPU12
			* (SP)  0x0001 => SP; CCR => (M(SP) )
			* In case of CPU12X
			* (SP)  0x0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
			* 1 => I; 0 => U
			* (Trap Vector) => PC
			*/

			throw TrapException(trapnum);

			//  All this code is implemented in the CPU exception handling mecanism
			//
			//		address_t addr = cpu->getRegSP();
			//
			//		addr = addr - 2;
			//		cpu->memWrite16(addr, cpu->getRegPC());
			//
			//		addr = addr - 2;
			//		cpu->memWrite16(addr, cpu->getRegY());
			//
			//		addr = addr - 2;
			//		cpu->memWrite16(addr, cpu->getRegX());
			//
			//		addr = addr - 2;
			//		cpu->memWrite8(addr, cpu->getRegB());
			//		cpu->memWrite16(addr+1, cpu->getRegA());
			//
			//		addr = addr - 2;
			//		cpu->memWrite16(addr, cpu->ccr->getCCR());
			//
			//		// 1 => I; 0 => U
			//		cpu->ccr->setI();
			//		cpu->ccr->setCCRHigh(cpu->ccr->getCCRHigh() & 0x7F);
			//
			//		// (Trap Vector) => PC
			//		cpu->setRegPC(cpu->memRead16(cpu->get_Trap_Vector()));
			//


		}
	}
#line 24524 "hcs12x.cc"
}

static Operation *DecodeOpTrap(CodeType const& code, uint16_t addr)
{
	return new OpTrap(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// LDAA or LDAB #opr8i
#line 88 "hcs12x.isa"
uint8_t
#line 24568 "hcs12x.cc"
OpLdaab_imm::getCycles()
{
#line 38 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 1; }
#line 24573 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 24577 "hcs12x.cc"
OpLdaab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 24581 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 24584 "hcs12x.cc"
)
{
#line 40 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "LDAA";
			} else {
			mnem = "LDAB";
		}
		sink << mnem << " #0x" << std::hex << opr8i;
		return mnem;
	}
#line 24599 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 24603 "hcs12x.cc"
OpLdaab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 24607 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 24610 "hcs12x.cc"
)
{
#line 52 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		if (b==0) {
			cpu->setRegA(opr8i); // ldaa #<opr8i>
			} else {
			cpu->setRegB(opr8i); // ldab #<opr8i>
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (opr8i == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((opr8i & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
	}
#line 24625 "hcs12x.cc"
}

static Operation *DecodeOpLdaab_imm(CodeType const& code, uint16_t addr)
{
	return new OpLdaab_imm(code, addr);
}

// LDAA or LDAB opr8a
#line 88 "hcs12x.isa"
uint8_t
#line 24636 "hcs12x.cc"
OpLdaab_dir::getCycles()
{
#line 67 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 3; }
#line 24641 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 24645 "hcs12x.cc"
OpLdaab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 24649 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 24652 "hcs12x.cc"
)
{
#line 69 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "LDAA";
			} else {
			mnem = "LDAB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;
		return mnem;
	}
#line 24667 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 24671 "hcs12x.cc"
OpLdaab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 24675 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 24678 "hcs12x.cc"
)
{
#line 81 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t val = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);
		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
	}
#line 24695 "hcs12x.cc"
}

static Operation *DecodeOpLdaab_dir(CodeType const& code, uint16_t addr)
{
	return new OpLdaab_dir(code, addr);
}

// LDAA or LDAB opr16a
#line 88 "hcs12x.isa"
uint8_t
#line 24706 "hcs12x.cc"
OpLdaab_ext::getCycles()
{
#line 98 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 3; }
#line 24711 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 24715 "hcs12x.cc"
OpLdaab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 24719 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 24722 "hcs12x.cc"
)
{
#line 100 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "LDAA";
			} else {
			mnem = "LDAB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 24737 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 24741 "hcs12x.cc"
OpLdaab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 24745 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 24748 "hcs12x.cc"
)
{
#line 112 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = opr16a;

		uint8_t val = cpu->memRead8(addr);
		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 24767 "hcs12x.cc"
}

static Operation *DecodeOpLdaab_ext(CodeType const& code, uint16_t addr)
{
	return new OpLdaab_ext(code, addr);
}

// LDAA or LDAB oprx0_xysp
// LDAA or LDAB oprx9,xysp
// LDAA or LDAB oprx16,xysp
// LDAA or LDAB [D,xysp]
// LDAA or LDAB [oprx16,xysp]
#line 79 "hcs12x.isa"
void
#line 24782 "hcs12x.cc"
OpLdaab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 24786 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 24789 "hcs12x.cc"
)
{
#line 135 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 24798 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 24802 "hcs12x.cc"
OpLdaab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 24806 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 24809 "hcs12x.cc"
)
{
#line 141 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 24818 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 24822 "hcs12x.cc"
OpLdaab_idx::getCycles()
{
#line 147 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 24827 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 24831 "hcs12x.cc"
OpLdaab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 24835 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 24838 "hcs12x.cc"
)
{
#line 149 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "LDAA";
			} else {
			mnem = "LDAB";
		}
		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 24854 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 24858 "hcs12x.cc"
OpLdaab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 24862 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 24865 "hcs12x.cc"
)
{
#line 162 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);

		uint8_t		val = cpu->memRead8(addr);

		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 24886 "hcs12x.cc"
}

static Operation *DecodeOpLdaab_idx(CodeType const& code, uint16_t addr)
{
	return new OpLdaab_idx(code, addr);
}

// LDD or LDY or LDX or LDS #opr16i
#line 88 "hcs12x.isa"
uint8_t
#line 24897 "hcs12x.cc"
OpLd_dyxs_imm::getCycles()
{
#line 183 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 2; }
#line 24902 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 24906 "hcs12x.cc"
OpLd_dyxs_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 24910 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 24913 "hcs12x.cc"
)
{
#line 185 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "LDD"; break;
			case 1: mnem = "LDY"; break;
			case 2: mnem = "LDX"; break;
			case 3: mnem = "LDS"; break;
		}
		sink << mnem << " #0x" << std::hex << opr16i;
		return mnem;
	}
#line 24929 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 24933 "hcs12x.cc"
OpLd_dyxs_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 24937 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 24940 "hcs12x.cc"
)
{
#line 198 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: cpu->setRegD(opr16i); break;
			case 1: cpu->setRegY(opr16i); break;
			case 2: cpu->setRegX(opr16i); break;
			case 3: cpu->setRegSP(opr16i); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (opr16i == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((opr16i & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 24958 "hcs12x.cc"
}

static Operation *DecodeOpLd_dyxs_imm(CodeType const& code, uint16_t addr)
{
	return new OpLd_dyxs_imm(code, addr);
}

// LDD or LDY or LDX or LDS opr8a
#line 88 "hcs12x.isa"
uint8_t
#line 24969 "hcs12x.cc"
OpLd_dyxs_dir::getCycles()
{
#line 216 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 3; }
#line 24974 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 24978 "hcs12x.cc"
OpLd_dyxs_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 24982 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 24985 "hcs12x.cc"
)
{
#line 218 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "LDD"; break;
			case 1: mnem = "LDY"; break;
			case 2: mnem = "LDX"; break;
			case 3: mnem = "LDS"; break;
		}
		sink << mnem << " 0x" << std::hex << opr8a;
		return mnem;
	}
#line 25001 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25005 "hcs12x.cc"
OpLd_dyxs_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25009 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25012 "hcs12x.cc"
)
{
#line 231 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);
		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 25031 "hcs12x.cc"
}

static Operation *DecodeOpLd_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpLd_dyxs_dir(code, addr);
}

// LDD or LDY or LDX or LDS opr16a
#line 88 "hcs12x.isa"
uint8_t
#line 25042 "hcs12x.cc"
OpLd_dyxs_ext::getCycles()
{
#line 250 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 3; }
#line 25047 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25051 "hcs12x.cc"
OpLd_dyxs_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25055 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25058 "hcs12x.cc"
)
{
#line 252 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "LDD"; break;
			case 1: mnem = "LDY"; break;
			case 2: mnem = "LDX"; break;
			case 3: mnem = "LDS"; break;
		}

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 25075 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25079 "hcs12x.cc"
OpLd_dyxs_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25083 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25086 "hcs12x.cc"
)
{
#line 266 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = opr16a;

		uint16_t val = cpu->memRead16(addr);

		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 25107 "hcs12x.cc"
}

static Operation *DecodeOpLd_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpLd_dyxs_ext(code, addr);
}

// LDD or LDY or LDX or LDS oprx0_xysp
// LDD or LDY or LDX or LDS oprx9,xysp
// LDD or LDY or LDX or LDS oprx16,xysp
// LDD or LDY or LDX or LDS [D,xysp]
// LDD or LDY or LDX or LDS [oprx16,xysp]
#line 79 "hcs12x.isa"
void
#line 25122 "hcs12x.cc"
OpLd_dyxs_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 25126 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 25129 "hcs12x.cc"
)
{
#line 291 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 25138 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 25142 "hcs12x.cc"
OpLd_dyxs_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 25146 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 25149 "hcs12x.cc"
)
{
#line 297 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 25158 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 25162 "hcs12x.cc"
OpLd_dyxs_idx::getCycles()
{
#line 303 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 25167 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25171 "hcs12x.cc"
OpLd_dyxs_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25175 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25178 "hcs12x.cc"
)
{
#line 305 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "LDD"; break;
			case 1: mnem = "LDY"; break;
			case 2: mnem = "LDX"; break;
			case 3: mnem = "LDS"; break;
		}

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 25196 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25200 "hcs12x.cc"
OpLd_dyxs_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25204 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25207 "hcs12x.cc"
)
{
#line 320 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);

		uint16_t	val = cpu->memRead16(addr);

		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 25229 "hcs12x.cc"
}

static Operation *DecodeOpLd_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpLd_dyxs_idx(code, addr);
}

// LEAY oprx0_xysp
// LEAY oprx9,xysp
// LEAY oprx16,xysp
#line 88 "hcs12x.isa"
uint8_t
#line 25242 "hcs12x.cc"
OpLeay::getCycles()
{
#line 345 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 2, 2, 2, 0, 0); }
#line 25247 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25251 "hcs12x.cc"
OpLeay::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25255 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25258 "hcs12x.cc"
)
{
#line 347 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem = "LEAY";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 25269 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25273 "hcs12x.cc"
OpLeay::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25277 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25280 "hcs12x.cc"
)
{
#line 355 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		address_t	addr = xb->getEAddr(cpu);

		cpu->setRegY(addr);

	}
#line 25291 "hcs12x.cc"
}

static Operation *DecodeOpLeay(CodeType const& code, uint16_t addr)
{
	return new OpLeay(code, addr);
}

// LEAX oprx0_xysp
// LEAX oprx9,xysp
// LEAX oprx16,xysp
#line 88 "hcs12x.isa"
uint8_t
#line 25304 "hcs12x.cc"
OpLeax::getCycles()
{
#line 368 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 2, 2, 2, 0, 0); }
#line 25309 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25313 "hcs12x.cc"
OpLeax::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25317 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25320 "hcs12x.cc"
)
{
#line 370 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem = "LEAX";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 25331 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25335 "hcs12x.cc"
OpLeax::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25339 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25342 "hcs12x.cc"
)
{
#line 378 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		address_t	addr = xb->getEAddr(cpu);

		cpu->setRegX(addr);

	}
#line 25353 "hcs12x.cc"
}

static Operation *DecodeOpLeax(CodeType const& code, uint16_t addr)
{
	return new OpLeax(code, addr);
}

// LEAS  oprx0_xysp
// LEAS  oprx9,xysp
// LEAS  oprx16,xysp
#line 88 "hcs12x.isa"
uint8_t
#line 25366 "hcs12x.cc"
OpLeas::getCycles()
{
#line 391 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 2, 2, 2, 0, 0); }
#line 25371 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25375 "hcs12x.cc"
OpLeas::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25379 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25382 "hcs12x.cc"
)
{
#line 393 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem = "LEAS";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 25393 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25397 "hcs12x.cc"
OpLeas::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25401 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25404 "hcs12x.cc"
)
{
#line 401 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		address_t	addr = xb->getEAddr(cpu);

		cpu->setRegSP(addr);

	}
#line 25415 "hcs12x.cc"
}

static Operation *DecodeOpLeas(CodeType const& code, uint16_t addr)
{
	return new OpLeas(code, addr);
}

// STAA or STAB opr8a
#line 88 "hcs12x.isa"
uint8_t
#line 25426 "hcs12x.cc"
OpStaab_dir::getCycles()
{
#line 412 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 2; }
#line 25431 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25435 "hcs12x.cc"
OpStaab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25439 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25442 "hcs12x.cc"
)
{
#line 414 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "STAA";
			} else {
			mnem = "STAB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;
		return mnem;

	}
#line 25458 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25462 "hcs12x.cc"
OpStaab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25466 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25469 "hcs12x.cc"
)
{
#line 427 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t val;

		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }

		cpu->memWrite8(opr8a, val, ADDRESS::DIRECT, false);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 25487 "hcs12x.cc"
}

static Operation *DecodeOpStaab_dir(CodeType const& code, uint16_t addr)
{
	return new OpStaab_dir(code, addr);
}

// STAA or STAB opr16a
#line 88 "hcs12x.isa"
uint8_t
#line 25498 "hcs12x.cc"
OpStaab_ext::getCycles()
{
#line 445 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 3; }
#line 25503 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25507 "hcs12x.cc"
OpStaab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25511 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25514 "hcs12x.cc"
)
{
#line 447 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "STAA";
			} else {
			mnem = "STAB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;

	}
#line 25530 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25534 "hcs12x.cc"
OpStaab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25538 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25541 "hcs12x.cc"
)
{
#line 460 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t	val;
		physical_address_t addr = opr16a;

		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }
		cpu->memWrite8(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 25559 "hcs12x.cc"
}

static Operation *DecodeOpStaab_ext(CodeType const& code, uint16_t addr)
{
	return new OpStaab_ext(code, addr);
}

// STAA or STAB oprx0_xysp
// STAA or STAB oprx9,xysp
// STAA or STAB oprx16,xysp
// STAA or STAB [D,xysp]
// STAA or STAB [oprx16,xysp]
#line 79 "hcs12x.isa"
void
#line 25574 "hcs12x.cc"
OpStaab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 25578 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 25581 "hcs12x.cc"
)
{
#line 483 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 25590 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 25594 "hcs12x.cc"
OpStaab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 25598 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 25601 "hcs12x.cc"
)
{
#line 489 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 25610 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 25614 "hcs12x.cc"
OpStaab_idx::getCycles()
{
#line 495 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ XbModes::GetIDXCycles(xb->getXbMode(), 2, 3, 3, 4, 4); }
#line 25619 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25623 "hcs12x.cc"
OpStaab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25627 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25630 "hcs12x.cc"
)
{
#line 497 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "STAA";
			} else {
			mnem = "STAB";
		}
		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;

	}
#line 25647 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25651 "hcs12x.cc"
OpStaab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25655 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25658 "hcs12x.cc"
)
{
#line 511 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);

		uint8_t val;
		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }
		cpu->memWrite8(addr,val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 25676 "hcs12x.cc"
}

static Operation *DecodeOpStaab_idx(CodeType const& code, uint16_t addr)
{
	return new OpStaab_idx(code, addr);
}

// STD or STY or STX or STS opr8a
#line 88 "hcs12x.isa"
uint8_t
#line 25687 "hcs12x.cc"
OpSt_dyxs_dir::getCycles()
{
#line 529 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 2; }
#line 25692 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25696 "hcs12x.cc"
OpSt_dyxs_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25700 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25703 "hcs12x.cc"
)
{
#line 531 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "STD"; break;
			case 1: mnem = "STY"; break;
			case 2: mnem = "STX"; break;
			case 3: mnem = "STS"; break;
		}

		sink << mnem << " 0x" << std::hex << opr8a;
		return mnem;
	}
#line 25720 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25724 "hcs12x.cc"
OpSt_dyxs_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25728 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25731 "hcs12x.cc"
)
{
#line 545 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val;

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}

		cpu->memWrite16(opr8a, val, ADDRESS::DIRECT, false);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 25754 "hcs12x.cc"
}

static Operation *DecodeOpSt_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpSt_dyxs_dir(code, addr);
}

// STD or STY or STX or STS opr16a
#line 88 "hcs12x.isa"
uint8_t
#line 25765 "hcs12x.cc"
OpSt_dyxs_ext::getCycles()
{
#line 568 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 3; }
#line 25770 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25774 "hcs12x.cc"
OpSt_dyxs_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25778 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25781 "hcs12x.cc"
)
{
#line 570 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "STD"; break;
			case 1: mnem = "STY"; break;
			case 2: mnem = "STX"; break;
			case 3: mnem = "STS"; break;
		}

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;

	}
#line 25799 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25803 "hcs12x.cc"
OpSt_dyxs_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25807 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25810 "hcs12x.cc"
)
{
#line 585 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val = 0;
		physical_address_t addr = opr16a;

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}

		cpu->memWrite16(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 25834 "hcs12x.cc"
}

static Operation *DecodeOpSt_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpSt_dyxs_ext(code, addr);
}

// STD or STY or STX or STS oprx0_xysp
// STD or STY or STX or STS oprx9,xysp
// STD or STY or STX or STS oprx16,xysp
// STD or STY or STX or STS [D,xysp]
// STD or STY or STX or STS [oprx16,xysp]
#line 79 "hcs12x.isa"
void
#line 25849 "hcs12x.cc"
OpSt_dyxs_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 25853 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 25856 "hcs12x.cc"
)
{
#line 614 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 25865 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 25869 "hcs12x.cc"
OpSt_dyxs_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 25873 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 25876 "hcs12x.cc"
)
{
#line 620 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 25885 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 25889 "hcs12x.cc"
OpSt_dyxs_idx::getCycles()
{
#line 626 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 2, 3, 3, 4, 4); }
#line 25894 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25898 "hcs12x.cc"
OpSt_dyxs_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25902 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25905 "hcs12x.cc"
)
{
#line 628 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "STD"; break;
			case 1: mnem = "STY"; break;
			case 2: mnem = "STX"; break;
			case 3: mnem = "STS"; break;
		}

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;

	}
#line 25924 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 25928 "hcs12x.cc"
OpSt_dyxs_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 25932 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 25935 "hcs12x.cc"
)
{
#line 644 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);

		uint16_t val = 0;

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}
		cpu->memWrite16(addr,val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 25959 "hcs12x.cc"
}

static Operation *DecodeOpSt_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpSt_dyxs_idx(code, addr);
}

// **********  GLOBAL MEMORY MODE ***************
// GLDAA or GLDAB opr8a
#line 88 "hcs12x.isa"
uint8_t
#line 25971 "hcs12x.cc"
OpGldaab_dir::getCycles()
{
#line 670 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 4; }
#line 25976 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 25980 "hcs12x.cc"
OpGldaab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 25984 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 25987 "hcs12x.cc"
)
{
#line 672 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "GLDAA";
			} else {
			mnem = "GLDAB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;
		return mnem;
	}
#line 26002 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26006 "hcs12x.cc"
OpGldaab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26010 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26013 "hcs12x.cc"
)
{
#line 684 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t val = cpu->memRead8(opr8a, ADDRESS::DIRECT, true);

		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
	}
#line 26031 "hcs12x.cc"
}

static Operation *DecodeOpGldaab_dir(CodeType const& code, uint16_t addr)
{
	return new OpGldaab_dir(code, addr);
}

// GLDAA or GLDAB opr16a
#line 88 "hcs12x.isa"
uint8_t
#line 26042 "hcs12x.cc"
OpGldaab_ext::getCycles()
{
#line 702 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 4; }
#line 26047 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26051 "hcs12x.cc"
OpGldaab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26055 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26058 "hcs12x.cc"
)
{
#line 704 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "GLDAA";
			} else {
			mnem = "GLDAB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 26073 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26077 "hcs12x.cc"
OpGldaab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26081 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26084 "hcs12x.cc"
)
{
#line 716 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t val = cpu->memRead8(opr16a, ADDRESS::EXTENDED, true);

		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26103 "hcs12x.cc"
}

static Operation *DecodeOpGldaab_ext(CodeType const& code, uint16_t addr)
{
	return new OpGldaab_ext(code, addr);
}

// GLDAA or GLDAB oprx0_xysp
// GLDAA or GLDAB oprx9,xysp
// GLDAA or GLDAB oprx16,xysp
// GLDAA or GLDAB [D,xysp]
// GLDAA or GLDAB [oprx16,xysp]
#line 79 "hcs12x.isa"
void
#line 26118 "hcs12x.cc"
OpGldaab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 26122 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 26125 "hcs12x.cc"
)
{
#line 739 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 26134 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 26138 "hcs12x.cc"
OpGldaab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 26142 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 26145 "hcs12x.cc"
)
{
#line 745 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 26154 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 26158 "hcs12x.cc"
OpGldaab_idx::getCycles()
{
#line 751 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 26163 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26167 "hcs12x.cc"
OpGldaab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26171 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26174 "hcs12x.cc"
)
{
#line 753 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "GLDAA";
			} else {
			mnem = "GLDAB";
		}
		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 26190 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26194 "hcs12x.cc"
OpGldaab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26198 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26201 "hcs12x.cc"
)
{
#line 766 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t		val = cpu->memRead8(xb->getEAddr(cpu), ADDRESS::EXTENDED, true);

		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26220 "hcs12x.cc"
}

static Operation *DecodeOpGldaab_idx(CodeType const& code, uint16_t addr)
{
	return new OpGldaab_idx(code, addr);
}

// GLDD or GLDY or GLDX or GLDS opr8a
#line 88 "hcs12x.isa"
uint8_t
#line 26231 "hcs12x.cc"
OpGld_dyxs_dir::getCycles()
{
#line 785 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 4; }
#line 26236 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26240 "hcs12x.cc"
OpGld_dyxs_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26244 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26247 "hcs12x.cc"
)
{
#line 787 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "GLDD"; break;
			case 1: mnem = "GLDY"; break;
			case 2: mnem = "GLDX"; break;
			case 3: mnem = "GLDS"; break;
		}
		sink << mnem << " 0x" << std::hex << opr8a;
		return mnem;
	}
#line 26263 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26267 "hcs12x.cc"
OpGld_dyxs_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26271 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26274 "hcs12x.cc"
)
{
#line 800 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val = cpu->memRead16(opr8a, ADDRESS::DIRECT, true);

		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26294 "hcs12x.cc"
}

static Operation *DecodeOpGld_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpGld_dyxs_dir(code, addr);
}

// GLDD or GLDY or GLDX or GLDS opr16a
#line 88 "hcs12x.isa"
uint8_t
#line 26305 "hcs12x.cc"
OpGld_dyxs_ext::getCycles()
{
#line 820 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 4; }
#line 26310 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26314 "hcs12x.cc"
OpGld_dyxs_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26318 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26321 "hcs12x.cc"
)
{
#line 822 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "GLDD"; break;
			case 1: mnem = "GLDY"; break;
			case 2: mnem = "GLDX"; break;
			case 3: mnem = "GLDS"; break;
		}

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 26338 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26342 "hcs12x.cc"
OpGld_dyxs_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26346 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26349 "hcs12x.cc"
)
{
#line 836 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val = cpu->memRead16(opr16a, ADDRESS::EXTENDED, true);

		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26369 "hcs12x.cc"
}

static Operation *DecodeOpGld_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpGld_dyxs_ext(code, addr);
}

// GLDD or GLDY or GLDX or GLDS oprx0_xysp
// GLDD or GLDY or GLDX or GLDS oprx9,xysp
// GLDD or GLDY or GLDX or GLDS oprx16,xysp
// GLDD or GLDY or GLDX or GLDS [D,xysp]
// GLDD or GLDY or GLDX or GLDS [oprx16,xysp]
#line 79 "hcs12x.isa"
void
#line 26384 "hcs12x.cc"
OpGld_dyxs_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 26388 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 26391 "hcs12x.cc"
)
{
#line 860 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 26400 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 26404 "hcs12x.cc"
OpGld_dyxs_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 26408 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 26411 "hcs12x.cc"
)
{
#line 866 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 26420 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 26424 "hcs12x.cc"
OpGld_dyxs_idx::getCycles()
{
#line 872 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 26429 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26433 "hcs12x.cc"
OpGld_dyxs_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26437 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26440 "hcs12x.cc"
)
{
#line 874 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "GLDD"; break;
			case 1: mnem = "GLDY"; break;
			case 2: mnem = "GLDX"; break;
			case 3: mnem = "GLDS"; break;
		}

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 26458 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26462 "hcs12x.cc"
OpGld_dyxs_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26466 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26469 "hcs12x.cc"
)
{
#line 889 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t	val = cpu->memRead16(xb->getEAddr(cpu), ADDRESS::EXTENDED, true);

		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26489 "hcs12x.cc"
}

static Operation *DecodeOpGld_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpGld_dyxs_idx(code, addr);
}

// GSTAA or GSTAB opr8a
#line 88 "hcs12x.isa"
uint8_t
#line 26500 "hcs12x.cc"
OpGstaab_dir::getCycles()
{
#line 909 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 3; }
#line 26505 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26509 "hcs12x.cc"
OpGstaab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26513 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26516 "hcs12x.cc"
)
{
#line 911 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "GSTAA";
			} else {
			mnem = "GSTAB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;
		return mnem;

	}
#line 26532 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26536 "hcs12x.cc"
OpGstaab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26540 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26543 "hcs12x.cc"
)
{
#line 924 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t val;

		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }

		cpu->memWrite8(opr8a, val, ADDRESS::DIRECT, true);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26561 "hcs12x.cc"
}

static Operation *DecodeOpGstaab_dir(CodeType const& code, uint16_t addr)
{
	return new OpGstaab_dir(code, addr);
}

// GSTAA or GSTAB opr16a
#line 88 "hcs12x.isa"
uint8_t
#line 26572 "hcs12x.cc"
OpGstaab_ext::getCycles()
{
#line 942 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 4; }
#line 26577 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26581 "hcs12x.cc"
OpGstaab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26585 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26588 "hcs12x.cc"
)
{
#line 944 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "GSTAA";
			} else {
			mnem = "GSTAB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;

	}
#line 26604 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26608 "hcs12x.cc"
OpGstaab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26612 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26615 "hcs12x.cc"
)
{
#line 957 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t	val;

		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }

		cpu->memWrite8(opr16a, val, ADDRESS::EXTENDED, true);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26633 "hcs12x.cc"
}

static Operation *DecodeOpGstaab_ext(CodeType const& code, uint16_t addr)
{
	return new OpGstaab_ext(code, addr);
}

// GSTAA or GSTAB oprx0_xysp
// GSTAA or GSTAB oprx9,xysp
// GSTAA or GSTAB oprx16,xysp
// GSTAA or GSTAB [D,xysp]
// GSTAA or GSTAB [oprx16,xysp]
#line 79 "hcs12x.isa"
void
#line 26648 "hcs12x.cc"
OpGstaab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 26652 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 26655 "hcs12x.cc"
)
{
#line 980 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 26664 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 26668 "hcs12x.cc"
OpGstaab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 26672 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 26675 "hcs12x.cc"
)
{
#line 986 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 26684 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 26688 "hcs12x.cc"
OpGstaab_idx::getCycles()
{
#line 992 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 4, 5, 5); }
#line 26693 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26697 "hcs12x.cc"
OpGstaab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26701 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26704 "hcs12x.cc"
)
{
#line 994 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "GSTAA";
			} else {
			mnem = "GSTAB";
		}
		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;

	}
#line 26721 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26725 "hcs12x.cc"
OpGstaab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26729 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26732 "hcs12x.cc"
)
{
#line 1008 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t val;

		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }

		cpu->memWrite8(xb->getEAddr(cpu),val, ADDRESS::EXTENDED, true);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26750 "hcs12x.cc"
}

static Operation *DecodeOpGstaab_idx(CodeType const& code, uint16_t addr)
{
	return new OpGstaab_idx(code, addr);
}

// GSTD or GSTY or GSTX or GSTS opr8a
#line 88 "hcs12x.isa"
uint8_t
#line 26761 "hcs12x.cc"
OpGst_dyxs_dir::getCycles()
{
#line 1026 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 3; }
#line 26766 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26770 "hcs12x.cc"
OpGst_dyxs_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26774 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26777 "hcs12x.cc"
)
{
#line 1028 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "GSTD"; break;
			case 1: mnem = "GSTY"; break;
			case 2: mnem = "GSTX"; break;
			case 3: mnem = "GSTS"; break;
		}

		sink << mnem << " 0x" << std::hex << opr8a;
		return mnem;
	}
#line 26794 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26798 "hcs12x.cc"
OpGst_dyxs_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26802 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26805 "hcs12x.cc"
)
{
#line 1042 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val;

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}

		cpu->memWrite16(opr8a, val, ADDRESS::DIRECT, true);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26828 "hcs12x.cc"
}

static Operation *DecodeOpGst_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpGst_dyxs_dir(code, addr);
}

// GSTD or GSTY or GSTX or GSTS opr16a
#line 88 "hcs12x.isa"
uint8_t
#line 26839 "hcs12x.cc"
OpGst_dyxs_ext::getCycles()
{
#line 1065 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return 4; }
#line 26844 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26848 "hcs12x.cc"
OpGst_dyxs_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26852 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26855 "hcs12x.cc"
)
{
#line 1067 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "GSTD"; break;
			case 1: mnem = "GSTY"; break;
			case 2: mnem = "GSTX"; break;
			case 3: mnem = "GSTS"; break;
		}

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;

	}
#line 26873 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 26877 "hcs12x.cc"
OpGst_dyxs_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 26881 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 26884 "hcs12x.cc"
)
{
#line 1082 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val = 0;

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}

		cpu->memWrite16(opr16a, val, ADDRESS::EXTENDED, true);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 26907 "hcs12x.cc"
}

static Operation *DecodeOpGst_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpGst_dyxs_ext(code, addr);
}

// GSTD or GSTY or GSTX or GSTS oprx0_xysp
// GSTD or GSTY or GSTX or GSTS oprx9,xysp
// GSTD or GSTY or GSTX or GSTS oprx16,xysp
// GSTD or GSTY or GSTX or GSTS [D,xysp]
// GSTD or GSTY or GSTX or GSTS [oprx16,xysp]
#line 79 "hcs12x.isa"
void
#line 26922 "hcs12x.cc"
OpGst_dyxs_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 26926 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 26929 "hcs12x.cc"
)
{
#line 1110 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 26938 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 26942 "hcs12x.cc"
OpGst_dyxs_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 26946 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 26949 "hcs12x.cc"
)
{
#line 1116 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 26958 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 26962 "hcs12x.cc"
OpGst_dyxs_idx::getCycles()
{
#line 1122 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 4, 5, 5); }
#line 26967 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 26971 "hcs12x.cc"
OpGst_dyxs_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 26975 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 26978 "hcs12x.cc"
)
{
#line 1124 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "GSTD"; break;
			case 1: mnem = "GSTY"; break;
			case 2: mnem = "GSTX"; break;
			case 3: mnem = "GSTS"; break;
		}

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;

	}
#line 26997 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 27001 "hcs12x.cc"
OpGst_dyxs_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 27005 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 27008 "hcs12x.cc"
)
{
#line 1140 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val = 0;

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}
		cpu->memWrite16(xb->getEAddr(cpu), val, ADDRESS::EXTENDED, true);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 27030 "hcs12x.cc"
}

static Operation *DecodeOpGst_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpGst_dyxs_idx(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// A->B  or B->A
#line 88 "hcs12x.isa"
uint8_t
#line 27074 "hcs12x.cc"
OpT_ab_ba::getCycles()
{
#line 39 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{ return 2; }
#line 27079 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 27083 "hcs12x.cc"
OpT_ab_ba::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 27087 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 27090 "hcs12x.cc"
)
{
#line 41 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		string mnem;

		if (b == 0) { mnem = "TAB"; } else { mnem = "TBA";}
		sink << mnem;

		return mnem;
	}
#line 27102 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 27106 "hcs12x.cc"
OpT_ab_ba::execute(
#line 67 "hcs12x.isa"
CPU *
#line 27110 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 27113 "hcs12x.cc"
)
{
#line 50 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		uint8_t val;

		if (b == 0) {
			val = cpu->getRegA();
			cpu->setRegB(val);
			} else {
			val = cpu->getRegB();
			cpu->setRegA(val);
		}

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
	}
#line 27133 "hcs12x.cc"
}

static Operation *DecodeOpT_ab_ba(CodeType const& code, uint16_t addr)
{
	return new OpT_ab_ba(code, addr);
}

// ****************  Common Section to HCS12X ( HLS = 0 ) *************
// *************** HCS12 - EXCHANGE Instructions ************
// XGDX or XGDY or EXG
#line 88 "hcs12x.isa"
uint8_t
#line 27146 "hcs12x.cc"
OpExg_hcs12::getCycles()
{
#line 73 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{ return 1; }
#line 27151 "hcs12x.cc"
}
/*
* lms sourceRegister index
* lls destinationRegister index
* */
#line 73 "hcs12x.isa"
string
#line 27159 "hcs12x.cc"
OpExg_hcs12::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 27163 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 27166 "hcs12x.cc"
)
{
#line 79 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		string mnem;


		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: rrSrc = EBLB::EBLBRegs::CCRL; break; // src is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrSrc = EBLB::EBLBRegs::TMP3; break; // src is 0x32 register
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: rrDst = EBLB::EBLBRegs::CCRL; break; // dst is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrDst = EBLB::EBLBRegs::TMP2; break; // dst is 0x31 register
			default: rrDst = lls;
		}

		// Exchange register Contents. There is no sign extension
		uint8_t eb = (1 << 8) | (lms << 4) | (0 << 3) | lls;

		switch (eb)
		{
			case 0xC5: mnem = "XGDX";  break;
			case 0xC6: mnem = "XGDY"; break;
			default: mnem = "EXG";
		}
		sink << mnem << " ";

		if ((eb != 0xC5) && (eb != 0xC6))
		{
			sink << EBLB::getRegName(rrSrc) << "," << EBLB::getRegName(rrDst);
		}

		return mnem;
	}
#line 27207 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 27211 "hcs12x.cc"
OpExg_hcs12::execute(
#line 67 "hcs12x.isa"
CPU *
#line 27215 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 27218 "hcs12x.cc"
)
{
#line 117 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		/* Legal "rr" value for EBLB::setter and EBLB::getter functions
		* 0x00:A; 0x01:B;
		* 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRW
		* 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
		* 0x04:D; 0x05:X; 0x06:Y; 0x07:SP
		*/

		uint8_t srcSize, dstSize;
		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: rrSrc = EBLB::EBLBRegs::CCRL; break; // src is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrSrc = EBLB::EBLBRegs::TMP3; break; // src is 0x32 register
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: rrDst = EBLB::EBLBRegs::CCRL; break; // dst is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrDst = EBLB::EBLBRegs::TMP2; break; // dst is 0x31 register
			default: rrDst = lls;
		}

		srcSize = EBLB::getRegSize(rrSrc);
		dstSize = EBLB::getRegSize(rrDst);

		// Exchange register Contents. EXG r1, r2
		// There is no sign extension
		// Only CCR[7:0] is used for HCS12

		if (srcSize == dstSize) {
			// (r1) <=> (r2)
			if (srcSize == 8) {
				cpu->eblb->exchange<uint8_t>(rrSrc, rrDst);
				} else {
				cpu->eblb->exchange<uint16_t>(rrSrc, rrDst);
			}
		}
		else if (((srcSize == 8) || (lms == 2)) && (dstSize == 16)) {
			// 0x00:(r1) => r2
			// if r2 isn't D then && (r2[7:0]) => r1
			uint16_t r1Val = 0x00FF & cpu->eblb->getter<uint8_t>(rrSrc);
			uint8_t r2Val = (uint8_t) cpu->eblb->getter<uint16_t>(rrDst); // only low 8 bits
			cpu->eblb->setter<uint16_t>(rrDst, r1Val);
			if (rrDst != 4 /* reg D*/) {
				cpu->eblb->setter<uint16_t>(rrDst, r2Val);
			}
		}
		else if ((srcSize == 16) && (dstSize == 8)) {
			// (r1[7:0]) => (r2)
			// if r2 is A then 0x00:(r2) => r1 else 0xFF:(r2) => r1
			uint8_t r1Val = cpu->eblb->getter<uint16_t>(rrSrc); // only low 8 bits
			uint8_t r2Val = cpu->eblb->getter<uint8_t>(rrDst);

			cpu->eblb->setter<uint8_t>(rrDst,r1Val);
			if (rrDst == 0 /*reg A*/) {
				cpu->eblb->setter<uint16_t>(rrSrc, 0x00FF & r2Val);
				} else {
				cpu->eblb->setter<uint16_t>(rrSrc, 0xFF00 | r2Val);
			}
		}

	}
#line 27286 "hcs12x.cc"
}

static Operation *DecodeOpExg_hcs12(CodeType const& code, uint16_t addr)
{
	return new OpExg_hcs12(code, addr);
}

// ***************************  TRANSFER Instructions
// TFR or TPA or TSX or TSY or TXS or TYS or SEX
#line 88 "hcs12x.isa"
uint8_t
#line 27298 "hcs12x.cc"
OpTfr_hcs12::getCycles()
{
#line 187 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{ return 1; }
#line 27303 "hcs12x.cc"
}
/*
* lms sourceRegister index
* lls destinationRegister index
* */
#line 73 "hcs12x.isa"
string
#line 27311 "hcs12x.cc"
OpTfr_hcs12::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 27315 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 27318 "hcs12x.cc"
)
{
#line 193 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		string mnem;

		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: rrSrc = EBLB::EBLBRegs::CCRL; break; // src is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrSrc = EBLB::EBLBRegs::TMP3; break; // src is 0x32 register
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: rrDst = EBLB::EBLBRegs::CCRL; break; // dst is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrDst = EBLB::EBLBRegs::TMP2; break; // dst is 0x31 register
			default: rrDst = lls;
		}

		// Transfer Register Content to Another register
		uint8_t eb = (0 << 8) | (lms << 4) | (0 << 3) | lls;

		switch (eb)
		{
			case 0x02: mnem = "TAP"; sink << mnem; break;
			case 0x20: mnem = "TPA"; sink << mnem; break;
			case 0x75: mnem = "TSX"; sink << mnem; break;
			case 0x76: mnem = "TSY"; sink << mnem; break;
			case 0x57: mnem = "TXS"; sink << mnem; break;
			case 0x67: mnem = "TYS"; sink << mnem; break;
			default: mnem = "TFR"; sink << mnem << " " << EBLB::getRegName(rrSrc) << "," << EBLB::getRegName(rrDst);
		}

		return mnem;
	}
#line 27356 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 27360 "hcs12x.cc"
OpTfr_hcs12::execute(
#line 67 "hcs12x.isa"
CPU *
#line 27364 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 27367 "hcs12x.cc"
)
{
#line 229 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		/* Legal "rr" value for EBLB::setter and EBLB::getter functions
		* 0x00:A; 0x01:B;
		* 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRW
		* 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
		* 0x04:D; 0x05:X; 0x06:Y; 0x07:SP
		*/

		uint8_t srcSize, dstSize;
		uint8_t rrSrc, rrDst;
		uint8_t oldCCRLow = cpu->ccr->getCCRLow();

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: rrSrc = EBLB::EBLBRegs::CCRL; break; // src is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrSrc = EBLB::EBLBRegs::TMP3; break; // src is 0x32 register
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: rrDst = EBLB::EBLBRegs::CCRL; break; // dst is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrDst = EBLB::EBLBRegs::TMP2; break; // dst is 0x31 register
			default: rrDst = lls;
		}

		srcSize = EBLB::getRegSize(rrSrc);
		dstSize = EBLB::getRegSize(rrDst);

		// Transfer Register Content to Another register
		// Only CCR[7:0] is used for HCS12

		/*
		if (sizeof(r1) && sizeof(r2) { (r1) => (r2)}
		else if ( (sizeof(r1)==8) && (sizeof(r2)==16) ) {sex:r1 => r2}
		else if ( (sizeof(r1)==16) && (sizeof(r2)==8) ) { (r1[7:0]) => (r2) }
		*/

		if (srcSize == dstSize) {
			// (r1) => (r2)
			if (srcSize == 8) {
				cpu->eblb->setter<uint8_t>(rrDst, cpu->eblb->getter<uint8_t>(rrSrc));
				} else {
				cpu->eblb->setter<uint16_t>(rrDst, cpu->eblb->getter<uint16_t>(rrSrc));
			}
		}
		else if (((srcSize == 8) || (lms == 2)) && (dstSize == 16)) {
			// sex:r1 => r2
			if ((cpu->eblb->getter<uint8_t>(rrSrc) & 0x80) == 0x80)
			{ // if r1 bit 7 = 1 then 0xFF:(r1) => r2
				cpu->eblb->setter<uint16_t>(rrDst, ((uint16_t) cpu->eblb->getter<uint8_t>(rrSrc)) | 0xFF00);
			} else
			{ // if r1 bit 7 = 1 then 0x00:(r1) => r2
				cpu->eblb->setter<uint16_t>(rrDst, ((uint16_t) cpu->eblb->getter<uint8_t>(rrSrc)) & 0x00FF);
			}
		}
		else if ((srcSize == 16) && (dstSize == 8)) {
			// (r1[7:0]) => (r2)
			uint8_t tmp = cpu->eblb->getter<uint16_t>(rrSrc) & 0x00FF;
			cpu->eblb->setter<uint8_t>(rrDst, tmp);
		}

		if ((oldCCRLow & 0x40) == 0x00) {
			cpu->ccr->setCCRLow(cpu->ccr->getCCRLow() & 0xBF);
		}
	}
#line 27436 "hcs12x.cc"
}

static Operation *DecodeOpTfr_hcs12(CodeType const& code, uint16_t addr)
{
	return new OpTfr_hcs12(code, addr);
}

// ****************  Specific Section to HCS12X ( HLS = 1 ) *************
// ***************  HCS12X - EXCHANGE Instructions ************
// XGDX or XGDY or EXG
#line 88 "hcs12x.isa"
uint8_t
#line 27449 "hcs12x.cc"
OpExg_hcs12x::getCycles()
{
#line 302 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{ return 1; }
#line 27454 "hcs12x.cc"
}
/*
* lms sourceRegister index
* lls destinationRegister index
* */
#line 73 "hcs12x.isa"
string
#line 27462 "hcs12x.cc"
OpExg_hcs12x::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 27466 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 27469 "hcs12x.cc"
)
{
#line 308 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		string mnem;

		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: // src is CCRW register
			if (lls == EBLB::EBLBMSLSRegs::A) {
				rrSrc = EBLB::EBLBRegs::CCRH; //0x22;
				} else if (lls = EBLB::EBLBMSLSRegs::B) {
				rrSrc = EBLB::EBLBRegs::CCRL; //0x21;
				} else {
				rrSrc = EBLB::EBLBRegs::CCRW; //0x23;
			}
			break;
			case EBLB::EBLBMSLSRegs::TMPx: // src is TMP register
			if (lls = EBLB::EBLBMSLSRegs::D) {
				rrSrc = EBLB::EBLBRegs::TMP1; //0x30; // TMP1
				} else {
				rrSrc = EBLB::EBLBRegs::TMP3; //0x32; // TMP3
			}
			break;
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: // dst is CCRW register
			if (lms == EBLB::EBLBMSLSRegs::A) {
				rrDst = EBLB::EBLBRegs::CCRH; //0x22;
				} else if (lms == EBLB::EBLBMSLSRegs::B) {
				rrDst = EBLB::EBLBRegs::CCRL; //0x21;
				} else {
				rrDst = EBLB::EBLBRegs::CCRW; //0x23;
			}

			break;
			case EBLB::EBLBMSLSRegs::TMPx: // dst is TMP2 register
			if (lms == EBLB::EBLBRegs::D ) {
				rrDst = EBLB::EBLBRegs::TMP1; //0x30; // TMP1
				} else {
				rrDst = EBLB::EBLBRegs::TMP2; //0x31; // TMP2
			}
			break;
			default: rrDst = lls;
		}

		// Exchange register Contents. There is no sign extension

		string srcName = EBLB::getRegName(rrSrc);
		string dstName = EBLB::getRegName(rrDst);

		if (lls == EBLB::EBLBMSLSRegs::A ) {
			if (lms == EBLB::EBLBMSLSRegs::CCR ) {
				srcName = EBLB::getRegName(EBLB::EBLBRegs::CCRH);
			}
			else if ((lms != EBLB::EBLBMSLSRegs::B ) && (lms != EBLB::EBLBMSLSRegs::D)) {
				srcName = srcName + "H";
			}
			} if (lls == EBLB::EBLBMSLSRegs::B) {
			if (lms == EBLB::EBLBMSLSRegs::CCR) {
				srcName = EBLB::getRegName(EBLB::EBLBRegs::CCRL);
			}
			else if ((lms != EBLB::EBLBMSLSRegs::A ) && (lms != EBLB::EBLBMSLSRegs::D)) {
				srcName = srcName + "L";
			}
		}

		if (lms == EBLB::EBLBMSLSRegs::A) {
			if (lls == EBLB::EBLBMSLSRegs::CCR /* reg CCR */) {
				dstName = EBLB::getRegName(EBLB::EBLBRegs::CCRH);
			}
			else if ((lls != EBLB::EBLBMSLSRegs::B) && (lls != EBLB::EBLBMSLSRegs::D)) {
				dstName = dstName + "H";
			}
			} if (lms == EBLB::EBLBMSLSRegs::B) {
			if (lls == EBLB::EBLBMSLSRegs::CCR) {
				dstName = EBLB::getRegName(EBLB::EBLBRegs::CCRL);
			}
			else if ((lls != EBLB::EBLBMSLSRegs::A) && (lls != EBLB::EBLBMSLSRegs::D)) {
				dstName = dstName + "L";
			}
		}

		// Exchange Registers Contents
		uint8_t eb = (1 << 8) | (lms << 4) | (1 << 3) | lls;

		switch (eb)
		{
			case 0xC5: mnem = "XGDX"; break;
			case 0xC6: mnem = "XGDY"; break;
			default: mnem = "EXG";
		}

		sink << mnem << " ";

		if ((eb != 0xC5) && (eb != 0xC6))
		{
			sink << srcName << "," << dstName;
		}

		return mnem;

	}
#line 27577 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 27581 "hcs12x.cc"
OpExg_hcs12x::execute(
#line 67 "hcs12x.isa"
CPU *
#line 27585 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 27588 "hcs12x.cc"
)
{
#line 413 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		/* Legal "rr" value for EBLB::setter and EBLB::getter functions
		* 0x00:A; 0x01:B;
		* 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRWord
		* 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
		* 0x04:D; 0x05:X; 0x06:Y; 0x07:SP
		*/

		uint8_t srcSize, dstSize;
		uint8_t rrSrc, rrDst;
		uint8_t oldCCRLow = cpu->ccr->getCCRLow();

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
		case EBLB::EBLBMSLSRegs::CCR:
			rrSrc = EBLB::EBLBRegs::CCRW;  // src is 0x23 register
			break;
		case EBLB::EBLBMSLSRegs::TMPx:
			if (lls == EBLB::EBLBMSLSRegs::D) {
				rrSrc = EBLB::EBLBRegs::TMP1; /* src is 0x30 register*/
				} else {
				rrSrc = EBLB::EBLBRegs::TMP3; /* src is 0x32 register*/
			}
			break;
			default: rrSrc = lms;
		}

		switch (lls) {
		case EBLB::EBLBMSLSRegs::CCR:
			rrDst = EBLB::EBLBRegs::CCRW; // rrDst is 0x23 register
			break;
		case EBLB::EBLBMSLSRegs::TMPx:
			if (lms == EBLB::EBLBMSLSRegs::D) {
				rrDst = EBLB::EBLBRegs::TMP1; /* src is 0x30 register*/
				} else {
				rrDst = EBLB::EBLBRegs::TMP3; /* src is 0x32 register*/
			}
			break;
			default: rrDst = lls;
		}

		srcSize = EBLB::getRegSize(rrSrc);
		dstSize = EBLB::getRegSize(rrDst);

		// Exchange register Contents. There is no sign extension
		/*
		if (sizeof(r1) && sizeof(r2) { (r1) <=> (r2)}
		else if ( (sizeof(r1)==8) && (sizeof(r2)==16) ) {0x00:(r1) => r2}
		else if ( (sizeof(r1)==16) && (sizeof(r2)==8) ) { (r1[7:0]) <=> (r2) }
		*/

		if ( srcSize == dstSize)
		{
			// (r1) <=> (r2)
			if (srcSize == 8)
			{
				cpu->eblb->exchange<uint8_t>(rrSrc,rrDst);
			}
			else if (srcSize == 16)
			{
				cpu->eblb->exchange<uint16_t>(rrSrc,rrDst);
			}
		}
		else if ((srcSize == 8) && (dstSize == 16))
		{
			// 0x00:(r1) => r2
			/* if (r2 is D) 0x00:(r1) => D
			* else
			*  if (r1 is A) (r1) => r2H
			*  else if (r1 is B) (r1) => r2L
			*/
			if (rrDst == EBLB::EBLBRegs::D /* reg D */)
			{
				cpu->eblb->setter<uint16_t>(rrDst, 0x00FF & cpu->eblb->getter<uint8_t>(rrSrc));
			}
			else if (rrSrc == EBLB::EBLBRegs::A)
			{
				uint16_t tmp = cpu->eblb->getter<uint16_t>(rrDst) & 0x00FF;  // get the lower bits
				tmp = tmp | (((uint16_t) cpu->eblb->getter<uint8_t>(rrSrc)) << 8);
				cpu->eblb->setter<uint16_t>(rrDst, tmp);
			}
			else if (rrSrc == EBLB::EBLBRegs::B)
			{
				uint16_t tmp = cpu->eblb->getter<uint16_t>(rrDst) & 0xFF00; // get higher bits
				tmp = tmp | ( 0x00FF & cpu->eblb->getter<uint8_t>(rrSrc));
				cpu->eblb->setter<uint16_t>(rrDst, tmp);
			}
		}
		else if ((srcSize == 16) && (dstSize == 8))
		{
			// (r1[7:0]) <=> (r2)
			/*
			* if (r1 is D)
			* 	 if (r2 is A) (B) <=> (A)
			* 	 else 0xFF => A // r2 is B
			* else
			* 	 if (r2 is A) (r1H) <=> A
			* 	 else (r1L) <=> B
			*/
			if (rrSrc == EBLB::EBLBRegs::D) {
				if (rrDst == EBLB::EBLBRegs::A) {
					cpu->eblb->exchange<uint8_t>(EBLB::EBLBRegs::B, EBLB::EBLBRegs::A);
					} else if (rrDst == EBLB::EBLBRegs::B) {
					cpu->eblb->setter<uint8_t>(EBLB::EBLBRegs::A, 0xFF);
				}
				} else {
				if (rrDst == EBLB::EBLBRegs::A) {
					uint16_t a16 = ((uint16_t) cpu->eblb->getter<uint16_t>(EBLB::EBLBRegs::A)) << 8;
					uint8_t r1h = cpu->eblb->getter<uint16_t>(rrSrc) >> 8;
					uint16_t r1l = cpu->eblb->getter<uint16_t>(rrSrc) & 0x00FF;

					cpu->eblb->setter<uint16_t>(rrSrc, a16 | r1l);
					cpu->eblb->setter<uint8_t>(rrDst, r1h);

					} else if (rrDst == EBLB::EBLBRegs::B) {
					uint16_t r1h = cpu->eblb->getter<uint16_t>(rrSrc) & 0xFF00;
					uint8_t r1l = cpu->eblb->getter<uint16_t>(rrSrc) & 0x00FF;
					uint16_t b16 = 0x00FF & cpu->eblb->getter<uint8_t>(rrDst);

					cpu->eblb->setter<uint16_t>(rrSrc, r1h | b16);
					cpu->eblb->setter<uint16_t>(rrDst, r1l);
				}
			}
		}

		if ((oldCCRLow & 0x40) == 0x00) {
			cpu->ccr->setCCRLow(cpu->ccr->getCCRLow() & 0xBF);
		}
	}
#line 27721 "hcs12x.cc"
}

static Operation *DecodeOpExg_hcs12x(CodeType const& code, uint16_t addr)
{
	return new OpExg_hcs12x(code, addr);
}

// *************************** HCS12X - TRANSFER Instructions
// TAP or TFR or TPA or TSX or TSY or TXS or TYS or SEX
#line 88 "hcs12x.isa"
uint8_t
#line 27733 "hcs12x.cc"
OpTfr_hcs12x::getCycles()
{
#line 548 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{ return 1; }
#line 27738 "hcs12x.cc"
}
/*
* lms sourceRegister index
* lls destinationRegister index
* */
#line 73 "hcs12x.isa"
string
#line 27746 "hcs12x.cc"
OpTfr_hcs12x::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 27750 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 27753 "hcs12x.cc"
)
{
#line 554 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		string mnem;

		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: // src is CCRW register
			if (lls == EBLB::EBLBMSLSRegs::A) {
				rrSrc = EBLB::EBLBRegs::CCRH; //0x22;
				} else if (lls = EBLB::EBLBMSLSRegs::B) {
				rrSrc = EBLB::EBLBRegs::CCRL; //0x21;
				} else {
				rrSrc = EBLB::EBLBRegs::CCRW; //0x23;
			}
			break;
			case EBLB::EBLBMSLSRegs::TMPx: // src is TMP register
			if (lls = EBLB::EBLBMSLSRegs::D) {
				rrSrc = EBLB::EBLBRegs::TMP1; //0x30; // TMP1
				} else {
				rrSrc = EBLB::EBLBRegs::TMP3; //0x32; // TMP3
			}
			break;
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: // dst is CCRW register
			if (lms == EBLB::EBLBMSLSRegs::A) {
				rrDst = EBLB::EBLBRegs::CCRH; //0x22;
				} else if (lms == EBLB::EBLBMSLSRegs::B) {
				rrDst = EBLB::EBLBRegs::CCRL; //0x21;
				} else {
				rrDst = EBLB::EBLBRegs::CCRW; //0x23;
			}

			break;
			case EBLB::EBLBMSLSRegs::TMPx: // dst is TMP2 register
			if (lms == EBLB::EBLBRegs::D ) {
				rrDst = EBLB::EBLBRegs::TMP1; //0x30; // TMP1
				} else {
				rrDst = EBLB::EBLBRegs::TMP2; //0x31; // TMP2
			}
			break;
			default: rrDst = lls;
		}

		// Transfer register Contents. TFR r1,r2

		string srcName = EBLB::getRegName(rrSrc);
		string dstName = EBLB::getRegName(rrDst);

		if (lls == EBLB::EBLBMSLSRegs::A ) {
			if (lms == EBLB::EBLBMSLSRegs::CCR ) {
				srcName = EBLB::getRegName(EBLB::EBLBRegs::CCRH);
			}
			else if ((lms != EBLB::EBLBMSLSRegs::B ) && (lms != EBLB::EBLBMSLSRegs::D)) {
				srcName = srcName + "H";
			}
			} if (lls == EBLB::EBLBMSLSRegs::B) {
			if (lms == EBLB::EBLBMSLSRegs::CCR) {
				srcName = EBLB::getRegName(EBLB::EBLBRegs::CCRL);
			}
			else if ((lms != EBLB::EBLBMSLSRegs::A ) && (lms != EBLB::EBLBMSLSRegs::D)) {
				srcName = srcName + "L";
			}
		}

		if (lms == EBLB::EBLBMSLSRegs::A) {
			if (lls == EBLB::EBLBMSLSRegs::CCR /* reg CCR */) {
				dstName = EBLB::getRegName(EBLB::EBLBRegs::CCRH);
			}
			else if ((lls != EBLB::EBLBMSLSRegs::B) && (lls != EBLB::EBLBMSLSRegs::D)) {
				dstName = dstName + "H";
			}
			} if (lms == EBLB::EBLBMSLSRegs::B) {
			if (lls == EBLB::EBLBMSLSRegs::CCR) {
				dstName = EBLB::getRegName(EBLB::EBLBRegs::CCRL);
			}
			else if ((lls != EBLB::EBLBMSLSRegs::A) && (lls != EBLB::EBLBMSLSRegs::D)) {
				dstName = dstName + "L";
			}
		}

		// Transfer Register Content to Another register
		uint8_t eb = (0 << 8) | (lms << 4) | (1 << 3) | lls;

		switch (eb)
		{
			case 0x02: mnem = "TAP"; sink << mnem; break;
			case 0x20: mnem = "TPA"; sink << mnem; break;
			case 0x75: mnem = "TSX"; sink << mnem; break;
			case 0x76: mnem = "TSY"; sink << mnem; break;
			case 0x57: mnem = "TXS"; sink << mnem; break;
			case 0x67: mnem ="TYS"; sink << mnem; break;
			default: mnem = "TFR"; sink << mnem << " " << EBLB::getRegName(rrSrc) << "," << EBLB::getRegName(rrDst);
		}

		return mnem;
	}
#line 27857 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 27861 "hcs12x.cc"
OpTfr_hcs12x::execute(
#line 67 "hcs12x.isa"
CPU *
#line 27865 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 27868 "hcs12x.cc"
)
{
#line 655 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		/* Legal "rr" value for EBLB::setter and EBLB::getter functions
		* 0x00:A; 0x01:B;
		* 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRW
		* 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
		* 0x04:D; 0x05:X; 0x06:Y; 0x07:SP
		*/

		uint8_t srcSize, dstSize;
		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
		case EBLB::EBLBMSLSRegs::CCR:
			rrSrc = EBLB::EBLBRegs::CCRW;  // src is 0x23 register
			break;
		case EBLB::EBLBMSLSRegs::TMPx:
			if (lls == EBLB::EBLBMSLSRegs::D) {
				rrSrc = EBLB::EBLBRegs::TMP1; /* src is 0x30 register*/
				} else {
				rrSrc = EBLB::EBLBRegs::TMP3; /* src is 0x32 register*/
			}
			break;
			default: rrSrc = lms;
		}

		switch (lls) {
		case EBLB::EBLBMSLSRegs::CCR:
			rrDst = EBLB::EBLBRegs::CCRW; // rrDst is 0x23 register
			break;
		case EBLB::EBLBMSLSRegs::TMPx:
			if (lms == EBLB::EBLBMSLSRegs::D) {
				rrDst = EBLB::EBLBRegs::TMP1; /* src is 0x30 register*/
				} else {
				rrDst = EBLB::EBLBRegs::TMP3; /* src is 0x32 register*/
			}
			break;
			default: rrDst = lls;
		}

		srcSize = EBLB::getRegSize(rrSrc);
		dstSize = EBLB::getRegSize(rrDst);

		// Transfer Register Content to Another register
		/*
		if (sizeof(r1) && sizeof(r2) { (r1) => r2}
		else if ( (sizeof(r1)==8) && (sizeof(r2)==16) ) {sex:(r1) => r2}
		else if ( (sizeof(r1)==16) && (sizeof(r2)==8) ) { (r1[7:0]) => r2 }
		*/

		if (srcSize == dstSize)
		{
			/*
			* if ((r1 is D) && ((r2 is X) || (r2 is Y))) then sex:D => r2
			* else (r1) => r2
			*/
			if ((rrSrc == EBLB::EBLBRegs::D) && ((rrDst == EBLB::EBLBRegs::X) || (rrDst == EBLB::EBLBRegs::Y)))
			{
				uint16_t tmp = cpu->eblb->getter<uint16_t>(rrSrc);
				if ((tmp & 0x8000) == 0x8000) {
					cpu->eblb->setter<uint16_t>(rrDst, 0xFFFF);
					} else {
					cpu->eblb->setter<uint16_t>(rrDst, 0x0000);
				}
				} else {
				if (srcSize == 8) {
					cpu->eblb->setter<uint8_t>(rrDst, cpu->eblb->getter<uint8_t>(rrSrc));
					} else {
					cpu->eblb->setter<uint16_t>(rrDst, cpu->eblb->getter<uint16_t>(rrSrc));
				}
			}

		} else if ((srcSize == 8) && (dstSize == 16))
		{
			/*
			* if (r2 is D) then sex:(r1) => r2
			* else
			*    if (r1 is A) then (r1) => r2H
			*    else (r1) => r2L
			* */
			if (rrDst == EBLB::EBLBRegs::D) {
				uint8_t tmp = cpu->eblb->getter<uint8_t>(rrSrc);
				if ((tmp & 0x80) == 0x80) {
					cpu->eblb->setter<uint16_t>(rrDst, ((uint16_t) tmp) | 0xFF00);
					} else {
					cpu->eblb->setter<uint16_t>(rrDst, ((uint16_t) tmp) & 0x00FF);
				}
				} else {
				uint8_t r1 = cpu->eblb->getter<uint8_t>(rrSrc);
				if (rrSrc == EBLB::EBLBRegs::A) {
					uint16_t r2l = cpu->eblb->getter<uint16_t>(rrDst) & 0x00FF;
					cpu->eblb->setter<uint16_t>(rrDst, (((uint16_t) r1) << 8) | r2l);
					} else {
					uint16_t r2h = cpu->eblb->getter<uint16_t>(rrDst) & 0xFF00;
					cpu->eblb->setter<uint16_t>(rrDst, r2h | r1);
				}
			}
		} else if ((srcSize == 16) && (dstSize == 8))
		{
			/*
			* if (r2 is A) then
			*   if (r1 is D) then B => A
			*   else r1H => A
			* else
			*   r1L => B
			*/
			if (rrDst == EBLB::EBLBRegs::A) {
				if (rrSrc == EBLB::EBLBRegs::D) {
					cpu->eblb->setter<uint8_t>(EBLB::EBLBRegs::A, cpu->eblb->getter<uint8_t>(EBLB::EBLBRegs::B));
					} else {
					cpu->eblb->setter<uint8_t>(EBLB::EBLBRegs::A, (uint8_t) (cpu->eblb->getter<uint8_t>(rrSrc) >> 8));
				}
				} else {
				cpu->eblb->setter<uint8_t>(EBLB::EBLBRegs::B, (uint8_t) (cpu->eblb->getter<uint8_t>(rrSrc) & 0x00FF));
			}
		}
	}
#line 27989 "hcs12x.cc"
}

static Operation *DecodeOpTfr_hcs12x(CodeType const& code, uint16_t addr)
{
	return new OpTfr_hcs12x(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
#line 88 "hcs12x.isa"
uint8_t
#line 28032 "hcs12x.cc"
OpMovb_0B::getCycles()
{
#line 38 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{ return 3;}
#line 28037 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28041 "hcs12x.cc"
OpMovb_0B::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28045 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28048 "hcs12x.cc"
)
{
#line 40 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVB";

		sink << mnem << " #0x" << std::hex << ii << ",0x" << std::hex << opr16a;
		return mnem;
	}
#line 28058 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28062 "hcs12x.cc"
OpMovb_0B::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28066 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28069 "hcs12x.cc"
)
{
#line 47 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = opr16a;

		cpu->memWrite8(addr,ii);
	}
#line 28078 "hcs12x.cc"
}

static Operation *DecodeOpMovb_0B(CodeType const& code, uint16_t addr)
{
	return new OpMovb_0B(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 28088 "hcs12x.cc"
OpMovb_08::getCycles()
{
#line 55 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 4, 5); }
#line 28093 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28097 "hcs12x.cc"
OpMovb_08::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28101 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28104 "hcs12x.cc"
)
{
#line 57 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVB";

		sink << mnem << " #0x" << std::hex << ii << ",";
		xb->disasm(sink);
		return mnem;
	}
#line 28115 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28119 "hcs12x.cc"
OpMovb_08::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28123 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28126 "hcs12x.cc"
)
{
#line 65 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);

		cpu->memWrite8(addr,ii);
	}
#line 28135 "hcs12x.cc"
}

static Operation *DecodeOpMovb_08(CodeType const& code, uint16_t addr)
{
	return new OpMovb_08(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 28145 "hcs12x.cc"
OpMovb_0C::getCycles()
{
#line 74 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{ return 5; }
#line 28150 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28154 "hcs12x.cc"
OpMovb_0C::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28158 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28161 "hcs12x.cc"
)
{
#line 76 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVB";

		sink << mnem << " 0x" << std::hex << opr16asrc << ",0x" << std::hex << opr16adst;
		return mnem;
	}
#line 28171 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28175 "hcs12x.cc"
OpMovb_0C::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28179 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28182 "hcs12x.cc"
)
{
#line 83 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrsrc = opr16asrc;
		physical_address_t addrdst = opr16adst;

		uint8_t tmp = cpu->memRead8(addrsrc);
		cpu->memWrite8(addrdst, tmp);
	}
#line 28193 "hcs12x.cc"
}

static Operation *DecodeOpMovb_0C(CodeType const& code, uint16_t addr)
{
	return new OpMovb_0C(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 28203 "hcs12x.cc"
OpMovb_09::getCycles()
{
#line 93 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 5, 5, 6); }
#line 28208 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28212 "hcs12x.cc"
OpMovb_09::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28216 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28219 "hcs12x.cc"
)
{
#line 95 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVB";

		sink << mnem << " 0x" <<  std::hex << opr16asrc << ", ";
		xb->disasm(sink);

		return mnem;
	}
#line 28231 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28235 "hcs12x.cc"
OpMovb_09::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28239 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28242 "hcs12x.cc"
)
{
#line 104 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		uint16_t addr = xb->getEAddr(cpu);
		uint8_t tmp = cpu->memRead8(opr16asrc);
		cpu->memWrite8(addr, tmp);
	}
#line 28251 "hcs12x.cc"
}

static Operation *DecodeOpMovb_09(CodeType const& code, uint16_t addr)
{
	return new OpMovb_09(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 28261 "hcs12x.cc"
OpMovb_0D::getCycles()
{
#line 112 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 5, 6, 7); }
#line 28266 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28270 "hcs12x.cc"
OpMovb_0D::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28274 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28277 "hcs12x.cc"
)
{
#line 114 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVB";

		sink << mnem << " ";
		xb->disasm(sink);
		sink << ", 0x" << std::hex << opr16a;
		return mnem;
	}
#line 28289 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28293 "hcs12x.cc"
OpMovb_0D::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28297 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28300 "hcs12x.cc"
)
{
#line 123 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrxb = xb->getEAddr(cpu);
		physical_address_t addropr16a = opr16a;

		uint8_t tmp = cpu->memRead8(addrxb);
		cpu->memWrite8(addropr16a, tmp);
	}
#line 28311 "hcs12x.cc"
}

static Operation *DecodeOpMovb_0D(CodeType const& code, uint16_t addr)
{
	return new OpMovb_0D(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 28321 "hcs12x.cc"
OpMovb_0A::getCycles()
{
#line 133 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{

		switch (xbsrc->getXbMode())
		{
			case XbModes::IDX: return XbModes::GetIDXCycles(xbdst->getXbMode(), 4, 4, 5, 5, 6);
			case XbModes::IDX1: return XbModes::GetIDXCycles(xbdst->getXbMode(), 5, 5, 6, 6, 7);
			case XbModes::IDX2: return XbModes::GetIDXCycles(xbdst->getXbMode(), 5, 5, 6, 6, 6);
			case XbModes::IDXD_Ind: return XbModes::GetIDXCycles(xbdst->getXbMode(), 6, 6, 7, 7, 8);
			case XbModes::IDX2_Ind: return XbModes::GetIDXCycles(xbdst->getXbMode(), 7, 7, 8, 8, 9);
			default: return 0x00;
		}
	}
#line 28337 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28341 "hcs12x.cc"
OpMovb_0A::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28345 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28348 "hcs12x.cc"
)
{
#line 146 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVB";

		sink << mnem << " ";
		xbsrc->disasm(sink);
		sink << ",";
		xbdst->disasm(sink);
		return mnem;
	}
#line 28361 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28365 "hcs12x.cc"
OpMovb_0A::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28369 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28372 "hcs12x.cc"
)
{
#line 156 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		uint16_t addrsrc = xbsrc->getEAddr(cpu);
		uint16_t addrdst = xbdst->getEAddr(cpu);
		uint8_t  tmp = cpu->memRead8(addrsrc);
		cpu->memWrite8(addrdst, tmp);
	}
#line 28382 "hcs12x.cc"
}

static Operation *DecodeOpMovb_0A(CodeType const& code, uint16_t addr)
{
	return new OpMovb_0A(code, addr);
}

// ---------
#line 88 "hcs12x.isa"
uint8_t
#line 28393 "hcs12x.cc"
OpMovw_03::getCycles()
{
#line 167 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{ return 4; }
#line 28398 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28402 "hcs12x.cc"
OpMovw_03::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28406 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28409 "hcs12x.cc"
)
{
#line 169 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVW";

		sink << mnem << " #0x" << std::hex << opr16i << ",0x" << std::hex << opr16a;
		return mnem;
	}
#line 28419 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28423 "hcs12x.cc"
OpMovw_03::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28427 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28430 "hcs12x.cc"
)
{
#line 176 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = opr16a;

		cpu->memWrite16(addr,opr16i);
	}
#line 28439 "hcs12x.cc"
}

static Operation *DecodeOpMovw_03(CodeType const& code, uint16_t addr)
{
	return new OpMovw_03(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 28449 "hcs12x.cc"
OpMovw_04::getCycles()
{
#line 184 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{ return 5; }
#line 28454 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28458 "hcs12x.cc"
OpMovw_04::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28462 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28465 "hcs12x.cc"
)
{
#line 186 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVW";

		sink << mnem << " 0x" << std::hex << opr16asrc << ",0x" << std::hex << opr16adst;
		return mnem;
	}
#line 28475 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28479 "hcs12x.cc"
OpMovw_04::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28483 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28486 "hcs12x.cc"
)
{
#line 193 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrsrc = opr16asrc;
		physical_address_t addrdst = opr16adst;

		uint16_t tmp = cpu->memRead16(addrsrc);
		cpu->memWrite16(addrdst, tmp);
	}
#line 28497 "hcs12x.cc"
}

static Operation *DecodeOpMovw_04(CodeType const& code, uint16_t addr)
{
	return new OpMovw_04(code, addr);
}

// Movw_18_00 IDX IDX1 IDX2 [D,IDX] [IDX2]
#line 73 "hcs12x.isa"
string
#line 28508 "hcs12x.cc"
OpMovw_00::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28512 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28515 "hcs12x.cc"
)
{
#line 205 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVW";

		sink << mnem << " #0x" << std::hex << opr16i << ",";
		xb->disasm(sink);
		return mnem;
	}
#line 28526 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28530 "hcs12x.cc"
OpMovw_00::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28534 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28537 "hcs12x.cc"
)
{
#line 213 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);

		cpu->memWrite16(addr,opr16i);
	}
#line 28546 "hcs12x.cc"
}

static Operation *DecodeOpMovw_00(CodeType const& code, uint16_t addr)
{
	return new OpMovw_00(code, addr);
}

/*
* Movbw_18_01 IDX IDX1 IDX2 [D,IDX] [IDX2]
* */
#line 88 "hcs12x.isa"
uint8_t
#line 28559 "hcs12x.cc"
OpMovw_01::getCycles()
{
#line 226 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 5, 5, 6); }
#line 28564 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28568 "hcs12x.cc"
OpMovw_01::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28572 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28575 "hcs12x.cc"
)
{
#line 228 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVW";

		sink << mnem << " 0x" <<  std::hex << opr16asrc << ",";
		xb->disasm(sink);
		return mnem;
	}
#line 28586 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28590 "hcs12x.cc"
OpMovw_01::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28594 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28597 "hcs12x.cc"
)
{
#line 236 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		physical_address_t addrsrc = opr16asrc;

		uint16_t tmp = cpu->memRead16(addrsrc);
		cpu->memWrite16(addr, tmp);
	}
#line 28608 "hcs12x.cc"
}

static Operation *DecodeOpMovw_01(CodeType const& code, uint16_t addr)
{
	return new OpMovw_01(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 28618 "hcs12x.cc"
OpMovw_05::getCycles()
{
#line 247 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 5, 6, 7); }
#line 28623 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28627 "hcs12x.cc"
OpMovw_05::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28631 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28634 "hcs12x.cc"
)
{
#line 249 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVW";

		sink << mnem << " ";
		xb->disasm(sink);
		sink << ",0x" << std::hex << opr16a;
		return mnem;
	}
#line 28646 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28650 "hcs12x.cc"
OpMovw_05::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28654 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28657 "hcs12x.cc"
)
{
#line 258 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrxb = xb->getEAddr(cpu);
		physical_address_t addrdst = opr16a;

		uint16_t tmp = cpu->memRead16(addrxb);
		cpu->memWrite16(addrdst, tmp);
	}
#line 28668 "hcs12x.cc"
}

static Operation *DecodeOpMovw_05(CodeType const& code, uint16_t addr)
{
	return new OpMovw_05(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 28678 "hcs12x.cc"
OpMovw_02::getCycles()
{
#line 268 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{

		switch (xbsrc->getXbMode())
		{
			case XbModes::IDX: return XbModes::GetIDXCycles(xbdst->getXbMode(), 4, 5, 5, 6, 7);
			case XbModes::IDX1: return XbModes::GetIDXCycles(xbdst->getXbMode(), 4, 5, 5, 6, 7);
			case XbModes::IDX2: return XbModes::GetIDXCycles(xbdst->getXbMode(), 5, 6, 6, 7, 8);
			case XbModes::IDXD_Ind: return XbModes::GetIDXCycles(xbdst->getXbMode(), 5, 6, 6, 7, 8);
			case XbModes::IDX2_Ind: return XbModes::GetIDXCycles(xbdst->getXbMode(), 6, 7, 6, 8, 9);
			default: return 0x00;
		}
	}
#line 28694 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28698 "hcs12x.cc"
OpMovw_02::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28702 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28705 "hcs12x.cc"
)
{
#line 281 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		string mnem = "MOVW";

		sink << mnem << " ";
		xbsrc->disasm(sink);
		sink << ",";
		xbdst->disasm(sink);
		return mnem;
	}
#line 28718 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28722 "hcs12x.cc"
OpMovw_02::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28726 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28729 "hcs12x.cc"
)
{
#line 291 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrsrc = xbsrc->getEAddr(cpu);
		physical_address_t addrdst = xbdst->getEAddr(cpu);

		uint16_t  tmp = cpu->memRead16(addrsrc);
		cpu->memWrite16(addrdst, tmp);
	}
#line 28740 "hcs12x.cc"
}

static Operation *DecodeOpMovw_02(CodeType const& code, uint16_t addr)
{
	return new OpMovw_02(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
/* ***** Addition Instructions ****** */
// ABA ( A+B => A)
#line 88 "hcs12x.isa"
uint8_t
#line 28785 "hcs12x.cc"
OpAba::getCycles()
{
#line 41 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 2;}
#line 28790 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28794 "hcs12x.cc"
OpAba::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28798 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28801 "hcs12x.cc"
)
{
#line 43 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "ABA";

		sink << mnem;

		return mnem;
	}
#line 28812 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28816 "hcs12x.cc"
OpAba::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28820 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28823 "hcs12x.cc"
)
{
#line 51 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in=0;
		uint8_t aVal = cpu->getRegA();
		uint8_t bVal = cpu->getRegB();

		Add8(result, carry_out, overflow, aVal, bVal, carry_in);

		cpu->setRegA(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((aVal & 0x0F)+(bVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (cpu->getRegA() & 0x08);
		uint8_t b3 = (cpu->getRegB() & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & b3) | (b3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();
	}
#line 28852 "hcs12x.cc"
}

static Operation *DecodeOpAba(CodeType const& code, uint16_t addr)
{
	return new OpAba(code, addr);
}

// ABX  (X+B => X)
#line 88 "hcs12x.isa"
uint8_t
#line 28863 "hcs12x.cc"
OpAbx::getCycles()
{
#line 80 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 2;}
#line 28868 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28872 "hcs12x.cc"
OpAbx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28876 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28879 "hcs12x.cc"
)
{
#line 82 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "ABX";

		sink << mnem;

		return mnem;
	}
#line 28890 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28894 "hcs12x.cc"
OpAbx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28898 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28901 "hcs12x.cc"
)
{
#line 90 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		uint16_t result;
		uint8_t carry_out, overflow;

		uint8_t carry_in=0;
		uint8_t bVal = cpu->getRegB();
		uint16_t xVal = cpu->getRegX();

		Add16(result, carry_out, overflow,(uint16_t) bVal, xVal, carry_in);

		cpu->setRegX(result);

	}
#line 28919 "hcs12x.cc"
}

static Operation *DecodeOpAbx(CodeType const& code, uint16_t addr)
{
	return new OpAbx(code, addr);
}

// ABY (Y+B=>Y)
#line 88 "hcs12x.isa"
uint8_t
#line 28930 "hcs12x.cc"
OpAby::getCycles()
{
#line 108 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 2;}
#line 28935 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 28939 "hcs12x.cc"
OpAby::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 28943 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 28946 "hcs12x.cc"
)
{
#line 110 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "ABY";

		sink << mnem;

		return mnem;
	}
#line 28957 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 28961 "hcs12x.cc"
OpAby::execute(
#line 67 "hcs12x.isa"
CPU *
#line 28965 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 28968 "hcs12x.cc"
)
{
#line 118 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint16_t result;
		uint8_t carry_out, overflow;

		uint8_t carry_in=0;
		uint8_t bVal = cpu->getRegB();
		uint16_t yVal = cpu->getRegY();

		Add16(result, carry_out, overflow, (uint16_t) bVal, yVal, carry_in);

		cpu->setRegY(result);

	}
#line 28985 "hcs12x.cc"
}

static Operation *DecodeOpAby(CodeType const& code, uint16_t addr)
{
	return new OpAby(code, addr);
}

// ADCab IMM  (regAB + ii + carry => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 28996 "hcs12x.cc"
OpAdc_ab_imm::getCycles()
{
#line 135 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 1;}
#line 29001 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29005 "hcs12x.cc"
OpAdc_ab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29009 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29012 "hcs12x.cc"
)
{
#line 137 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADCA";
			} else {
			mnem = "ADCB";
		}
		sink << mnem << " #0x"<< std::hex << opr8i;

		return mnem;
	}
#line 29028 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29032 "hcs12x.cc"
OpAdc_ab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29036 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29039 "hcs12x.cc"
)
{
#line 150 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Add8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr8i & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();
	}
#line 29076 "hcs12x.cc"
}

static Operation *DecodeOpAdc_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpAdc_ab_imm(code, addr);
}

// ADCab DIR  (regAB + mem[regDirect:opr8a] + carry => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 29087 "hcs12x.cc"
OpAdc_ab_dir::getCycles()
{
#line 187 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3;}
#line 29092 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29096 "hcs12x.cc"
OpAdc_ab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29100 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29103 "hcs12x.cc"
)
{
#line 189 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADCA";
			} else {
			mnem = "ADCB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 29119 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29123 "hcs12x.cc"
OpAdc_ab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29127 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29130 "hcs12x.cc"
)
{
#line 202 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		uint8_t opr8aVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr8aVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 29171 "hcs12x.cc"
}

static Operation *DecodeOpAdc_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpAdc_ab_dir(code, addr);
}

// ADCab EXT (regAB + mem[opr16a] + carry => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 29182 "hcs12x.cc"
OpAdc_ab_ext::getCycles()
{
#line 243 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3;}
#line 29187 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29191 "hcs12x.cc"
OpAdc_ab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29195 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29198 "hcs12x.cc"
)
{
#line 245 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADCA";
			} else {
			mnem = "ADCB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 29214 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29218 "hcs12x.cc"
OpAdc_ab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29222 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29225 "hcs12x.cc"
)
{
#line 258 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr16aVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 29266 "hcs12x.cc"
}

static Operation *DecodeOpAdc_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpAdc_ab_ext(code, addr);
}

// ADCab IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB + mem[xb->addrE] + carry => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 29277 "hcs12x.cc"
OpAdc_ab_idx::getCycles()
{
#line 299 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 29282 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29286 "hcs12x.cc"
OpAdc_ab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29290 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29293 "hcs12x.cc"
)
{
#line 301 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0){
			mnem = "ADCA";
			} else {
			mnem = "ADCB";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 29311 "hcs12x.cc"
}
#line 79 "hcs12x.isa"
void
#line 29315 "hcs12x.cc"
OpAdc_ab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 29319 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 29322 "hcs12x.cc"
)
{
#line 316 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 29331 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 29335 "hcs12x.cc"
OpAdc_ab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 29339 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 29342 "hcs12x.cc"
)
{
#line 322 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 29351 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29355 "hcs12x.cc"
OpAdc_ab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29359 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29362 "hcs12x.cc"
)
{
#line 328 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (xbVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 29404 "hcs12x.cc"
}

static Operation *DecodeOpAdc_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpAdc_ab_idx(code, addr);
}

// ADDab IMM (regAB + ii => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 29415 "hcs12x.cc"
OpAdd_ab_imm::getCycles()
{
#line 370 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 1; }
#line 29420 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29424 "hcs12x.cc"
OpAdd_ab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29428 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29431 "hcs12x.cc"
)
{
#line 372 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADDA";
			} else {
			mnem = "ADDB";
		}
		sink << mnem << " #0x" << std::hex << opr8i;

		return mnem;
	}
#line 29447 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29451 "hcs12x.cc"
OpAdd_ab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29455 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29458 "hcs12x.cc"
)
{
#line 385 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Add8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr8i & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 29496 "hcs12x.cc"
}

static Operation *DecodeOpAdd_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpAdd_ab_imm(code, addr);
}

// ADDab DIR  (regAB + mem[regDirect:opr8a] => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 29507 "hcs12x.cc"
OpAdd_ab_dir::getCycles()
{
#line 423 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 29512 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29516 "hcs12x.cc"
OpAdd_ab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29520 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29523 "hcs12x.cc"
)
{
#line 425 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADDA";
			} else {
			mnem = "ADDB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 29539 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29543 "hcs12x.cc"
OpAdd_ab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29547 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29550 "hcs12x.cc"
)
{
#line 438 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		uint8_t opr8aVal = cpu->memRead8(addr, ADDRESS::DIRECT, false);

		Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr8aVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 29591 "hcs12x.cc"
}

static Operation *DecodeOpAdd_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpAdd_ab_dir(code, addr);
}

// ADDab EXT  (regAB + mem[opr16a] => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 29602 "hcs12x.cc"
OpAdd_ab_ext::getCycles()
{
#line 479 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 29607 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29611 "hcs12x.cc"
OpAdd_ab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29615 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29618 "hcs12x.cc"
)
{
#line 481 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADDA";
			} else {
			mnem = "ADDB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 29634 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29638 "hcs12x.cc"
OpAdd_ab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29642 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29645 "hcs12x.cc"
)
{
#line 494 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr16aVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 29686 "hcs12x.cc"
}

static Operation *DecodeOpAdd_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpAdd_ab_ext(code, addr);
}

// ADDab  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB + mem[xb->addrE] => regAB)
#line 79 "hcs12x.isa"
void
#line 29697 "hcs12x.cc"
OpAdd_ab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 29701 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 29704 "hcs12x.cc"
)
{
#line 535 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 29713 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 29717 "hcs12x.cc"
OpAdd_ab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 29721 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 29724 "hcs12x.cc"
)
{
#line 541 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 29733 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 29737 "hcs12x.cc"
OpAdd_ab_idx::getCycles()
{
#line 547 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 29742 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29746 "hcs12x.cc"
OpAdd_ab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29750 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29753 "hcs12x.cc"
)
{
#line 549 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0){
			mnem = "ADDA";
			} else {
			mnem = "ADDB";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 29771 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29775 "hcs12x.cc"
OpAdd_ab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29779 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29782 "hcs12x.cc"
)
{
#line 564 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (xbVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 29824 "hcs12x.cc"
}

static Operation *DecodeOpAdd_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpAdd_ab_idx(code, addr);
}

// ADED IMM  (regD + #opr16i + carry => regD)
#line 88 "hcs12x.isa"
uint8_t
#line 29835 "hcs12x.cc"
OpAded_imm::getCycles()
{
#line 606 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 29840 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29844 "hcs12x.cc"
OpAded_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29848 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29851 "hcs12x.cc"
)
{
#line 608 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "ADED";

		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 29862 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29866 "hcs12x.cc"
OpAded_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29870 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29873 "hcs12x.cc"
)
{
#line 616 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal = cpu->getRegD();

		Add16(result, carry_out, overflow, regVal, opr16i, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 29895 "hcs12x.cc"
}

static Operation *DecodeOpAded_imm(CodeType const& code, uint16_t addr)
{
	return new OpAded_imm(code, addr);
}

// ADED DIR  (regD + mem16[regDirect:opr8a] + carry => regD)
#line 88 "hcs12x.isa"
uint8_t
#line 29906 "hcs12x.cc"
OpAded_dir::getCycles()
{
#line 638 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 29911 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29915 "hcs12x.cc"
OpAded_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29919 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29922 "hcs12x.cc"
)
{
#line 640 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "ADED";

		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 29933 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 29937 "hcs12x.cc"
OpAded_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 29941 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 29944 "hcs12x.cc"
)
{
#line 648 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal = cpu->getRegD();

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 29967 "hcs12x.cc"
}

static Operation *DecodeOpAded_dir(CodeType const& code, uint16_t addr)
{
	return new OpAded_dir(code, addr);
}

// ADED EXT (regD + mem16[opr16a] + carry => regD)
#line 88 "hcs12x.isa"
uint8_t
#line 29978 "hcs12x.cc"
OpAded_ext::getCycles()
{
#line 671 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 29983 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 29987 "hcs12x.cc"
OpAded_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 29991 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 29994 "hcs12x.cc"
)
{
#line 673 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "ADED";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 30005 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30009 "hcs12x.cc"
OpAded_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30013 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30016 "hcs12x.cc"
)
{
#line 681 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 30042 "hcs12x.cc"
}

static Operation *DecodeOpAded_ext(CodeType const& code, uint16_t addr)
{
	return new OpAded_ext(code, addr);
}

// ADED IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD + mem16[xb->addrE] + carry => regD)
#line 79 "hcs12x.isa"
void
#line 30053 "hcs12x.cc"
OpAded_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 30057 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 30060 "hcs12x.cc"
)
{
#line 707 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 30069 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 30073 "hcs12x.cc"
OpAded_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 30077 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 30080 "hcs12x.cc"
)
{
#line 713 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 30089 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 30093 "hcs12x.cc"
OpAded_idx::getCycles()
{
#line 719 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 30098 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30102 "hcs12x.cc"
OpAded_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30106 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30109 "hcs12x.cc"
)
{
#line 721 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "ADED";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 30121 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30125 "hcs12x.cc"
OpAded_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30129 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30132 "hcs12x.cc"
)
{
#line 730 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, xbVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30157 "hcs12x.cc"
}

static Operation *DecodeOpAded_idx(CodeType const& code, uint16_t addr)
{
	return new OpAded_idx(code, addr);
}

// ADExy IMM  (regXY + #opr16i + carry => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 30168 "hcs12x.cc"
OpAde_xy_imm::getCycles()
{
#line 755 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 30173 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30177 "hcs12x.cc"
OpAde_xy_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30181 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30184 "hcs12x.cc"
)
{
#line 757 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADEX";
			} else {
			mnem = "ADEY";
		}
		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 30200 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30204 "hcs12x.cc"
OpAde_xy_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30208 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30211 "hcs12x.cc"
)
{
#line 770 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		Add16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 30242 "hcs12x.cc"
}

static Operation *DecodeOpAde_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpAde_xy_imm(code, addr);
}

// ADExy DIR  (regXY + mem16[regDirect:opr8a] + carry => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 30253 "hcs12x.cc"
OpAde_xy_dir::getCycles()
{
#line 801 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 30258 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30262 "hcs12x.cc"
OpAde_xy_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30266 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30269 "hcs12x.cc"
)
{
#line 803 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADEX";
			} else {
			mnem = "ADEY";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 30285 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30289 "hcs12x.cc"
OpAde_xy_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30293 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30296 "hcs12x.cc"
)
{
#line 816 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30329 "hcs12x.cc"
}

static Operation *DecodeOpAde_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpAde_xy_dir(code, addr);
}

// ADExy EXT (regXY + mem16[opr16a] + carry => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 30340 "hcs12x.cc"
OpAde_xy_ext::getCycles()
{
#line 849 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 30345 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30349 "hcs12x.cc"
OpAde_xy_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30353 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30356 "hcs12x.cc"
)
{
#line 851 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADEX";
			} else {
			mnem = "ADEY";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 30372 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30376 "hcs12x.cc"
OpAde_xy_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30380 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30383 "hcs12x.cc"
)
{
#line 864 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 30417 "hcs12x.cc"
}

static Operation *DecodeOpAde_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpAde_xy_ext(code, addr);
}

// ADExy IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY + mem16[xb->addrE] + carry => regXY)
#line 79 "hcs12x.isa"
void
#line 30428 "hcs12x.cc"
OpAde_xy_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 30432 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 30435 "hcs12x.cc"
)
{
#line 898 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 30444 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 30448 "hcs12x.cc"
OpAde_xy_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 30452 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 30455 "hcs12x.cc"
)
{
#line 904 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 30464 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 30468 "hcs12x.cc"
OpAde_xy_idx::getCycles()
{
#line 910 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 30473 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30477 "hcs12x.cc"
OpAde_xy_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30481 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30484 "hcs12x.cc"
)
{
#line 912 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0){
			mnem = "ADEX";
			} else {
			mnem = "ADEY";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 30502 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30506 "hcs12x.cc"
OpAde_xy_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30510 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30513 "hcs12x.cc"
)
{
#line 927 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30547 "hcs12x.cc"
}

static Operation *DecodeOpAde_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpAde_xy_idx(code, addr);
}

// ADDxy IMM (regXY + #opr16i => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 30558 "hcs12x.cc"
OpAdd_xy_imm::getCycles()
{
#line 962 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 30563 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30567 "hcs12x.cc"
OpAdd_xy_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30571 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30574 "hcs12x.cc"
)
{
#line 964 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADDX";
			} else {
			mnem = "ADDY";
		}
		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 30590 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30594 "hcs12x.cc"
OpAdd_xy_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30598 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30601 "hcs12x.cc"
)
{
#line 977 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		Add16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 30632 "hcs12x.cc"
}

static Operation *DecodeOpAdd_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpAdd_xy_imm(code, addr);
}

// ADDxy DIR  (regXY + mem16[regDirect:opr8a] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 30643 "hcs12x.cc"
OpAdd_xy_dir::getCycles()
{
#line 1008 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 30648 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30652 "hcs12x.cc"
OpAdd_xy_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30656 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30659 "hcs12x.cc"
)
{
#line 1010 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADDX";
			} else {
			mnem = "ADDY";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 30675 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30679 "hcs12x.cc"
OpAdd_xy_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30683 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30686 "hcs12x.cc"
)
{
#line 1023 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;
		uint8_t carry_in = 0;
		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30719 "hcs12x.cc"
}

static Operation *DecodeOpAdd_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpAdd_xy_dir(code, addr);
}

// ADDxy EXT  (regXY + mem16[opr16a] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 30730 "hcs12x.cc"
OpAdd_xy_ext::getCycles()
{
#line 1056 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 30735 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30739 "hcs12x.cc"
OpAdd_xy_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30743 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30746 "hcs12x.cc"
)
{
#line 1058 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ADDX";
			} else {
			mnem = "ADDY";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 30762 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30766 "hcs12x.cc"
OpAdd_xy_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30770 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30773 "hcs12x.cc"
)
{
#line 1071 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 30807 "hcs12x.cc"
}

static Operation *DecodeOpAdd_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpAdd_xy_ext(code, addr);
}

// ADDxy  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY + mem16[xb->addrE] => regXY)
#line 79 "hcs12x.isa"
void
#line 30818 "hcs12x.cc"
OpAdd_xy_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 30822 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 30825 "hcs12x.cc"
)
{
#line 1105 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 30834 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 30838 "hcs12x.cc"
OpAdd_xy_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 30842 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 30845 "hcs12x.cc"
)
{
#line 1111 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 30854 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 30858 "hcs12x.cc"
OpAdd_xy_idx::getCycles()
{
#line 1117 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 30863 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30867 "hcs12x.cc"
OpAdd_xy_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30871 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30874 "hcs12x.cc"
)
{
#line 1119 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0){
			mnem = "ADDX";
			} else {
			mnem = "ADDY";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 30892 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30896 "hcs12x.cc"
OpAdd_xy_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30900 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30903 "hcs12x.cc"
)
{
#line 1134 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30937 "hcs12x.cc"
}

static Operation *DecodeOpAdd_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpAdd_xy_idx(code, addr);
}

// SUBD IMM or ADDD IMM (regD -+ ii => regD)
#line 88 "hcs12x.isa"
uint8_t
#line 30948 "hcs12x.cc"
OpAdd_sub_d_imm::getCycles()
{
#line 1171 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 2; }
#line 30953 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 30957 "hcs12x.cc"
OpAdd_sub_d_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 30961 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 30964 "hcs12x.cc"
)
{
#line 1173 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBD";
			} else {
			mnem = "ADDD";
		}

		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 30981 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 30985 "hcs12x.cc"
OpAdd_sub_d_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 30989 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 30992 "hcs12x.cc"
)
{
#line 1187 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal = cpu->getRegD();

		if (b==0) {
			Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);
			} else {
			Add16(result, carry_out, overflow, regVal, opr16i, carry_in);
		}

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31017 "hcs12x.cc"
}

static Operation *DecodeOpAdd_sub_d_imm(CodeType const& code, uint16_t addr)
{
	return new OpAdd_sub_d_imm(code, addr);
}

// SUBD DIR or ADDD DIR  (regD -+ mem[regDirect+opr8a])
#line 88 "hcs12x.isa"
uint8_t
#line 31028 "hcs12x.cc"
OpAdd_sub_d_dir::getCycles()
{
#line 1212 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 31033 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31037 "hcs12x.cc"
OpAdd_sub_d_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31041 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31044 "hcs12x.cc"
)
{
#line 1214 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBD";
			} else {
			mnem = "ADDD";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 31060 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31064 "hcs12x.cc"
OpAdd_sub_d_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31068 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31071 "hcs12x.cc"
)
{
#line 1227 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal = cpu->getRegD();

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		if (b==0) {
			Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
			} else {
			Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
		}

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31098 "hcs12x.cc"
}

static Operation *DecodeOpAdd_sub_d_dir(CodeType const& code, uint16_t addr)
{
	return new OpAdd_sub_d_dir(code, addr);
}

// SUBD EXT or ADDD EXT (regD -+ mem[opr16a]) => regD)
#line 88 "hcs12x.isa"
uint8_t
#line 31109 "hcs12x.cc"
OpAdd_sub_d_ext::getCycles()
{
#line 1254 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 31114 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31118 "hcs12x.cc"
OpAdd_sub_d_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31122 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31125 "hcs12x.cc"
)
{
#line 1256 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBD";
			} else {
			mnem = "ADDD";
		}

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;

	}
#line 31143 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31147 "hcs12x.cc"
OpAdd_sub_d_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31151 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31154 "hcs12x.cc"
)
{
#line 1271 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal = cpu->getRegD();
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		if (b==0) {
			Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
			} else {
			Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
		}

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31182 "hcs12x.cc"
}

static Operation *DecodeOpAdd_sub_d_ext(CodeType const& code, uint16_t addr)
{
	return new OpAdd_sub_d_ext(code, addr);
}

// SUBD/ADDD  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD -+ mem[xb->addrE] => regD)
#line 79 "hcs12x.isa"
void
#line 31193 "hcs12x.cc"
OpAdd_sub_d_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 31197 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 31200 "hcs12x.cc"
)
{
#line 1299 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 31209 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 31213 "hcs12x.cc"
OpAdd_sub_d_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 31217 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 31220 "hcs12x.cc"
)
{
#line 1305 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 31229 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 31233 "hcs12x.cc"
OpAdd_sub_d_idx::getCycles()
{
#line 1311 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 31238 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31242 "hcs12x.cc"
OpAdd_sub_d_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31246 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31249 "hcs12x.cc"
)
{
#line 1313 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBD";
			} else {
			mnem = "ADDD";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 31267 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31271 "hcs12x.cc"
OpAdd_sub_d_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31275 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31278 "hcs12x.cc"
)
{
#line 1328 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal = cpu->getRegD();
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		if (b==0) {
			Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);
			} else {
			Add16(result, carry_out, overflow, regVal, xbVal, carry_in);
		}

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31306 "hcs12x.cc"
}

static Operation *DecodeOpAdd_sub_d_idx(CodeType const& code, uint16_t addr)
{
	return new OpAdd_sub_d_idx(code, addr);
}

/* ****** Subtraction Instructions **** */
// SBA  (regA - regB => regA)
#line 88 "hcs12x.isa"
uint8_t
#line 31318 "hcs12x.cc"
OpSba::getCycles()
{
#line 1358 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 2; }
#line 31323 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31327 "hcs12x.cc"
OpSba::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31331 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31334 "hcs12x.cc"
)
{
#line 1360 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "SBA";

		sink << mnem;

		return mnem;
	}
#line 31345 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31349 "hcs12x.cc"
OpSba::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31353 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31356 "hcs12x.cc"
)
{
#line 1368 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in=0;
		uint8_t aVal = cpu->getRegA();
		uint8_t bVal = cpu->getRegB();

		Sub8(result, carry_out, overflow, aVal, bVal, carry_in);

		cpu->setRegA(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31377 "hcs12x.cc"
}

static Operation *DecodeOpSba(CodeType const& code, uint16_t addr)
{
	return new OpSba(code, addr);
}

// SBCA/SBCB  IMM (regAB - ii - carry => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 31388 "hcs12x.cc"
OpSbc_ab_imm::getCycles()
{
#line 1389 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 1; }
#line 31393 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31397 "hcs12x.cc"
OpSbc_ab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31401 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31404 "hcs12x.cc"
)
{
#line 1391 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SBCA";
			} else {
			mnem = "SBCB";
		}
		sink << mnem << " #0x" << std::hex << opr8i;

		return mnem;
	}
#line 31420 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31424 "hcs12x.cc"
OpSbc_ab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31428 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31431 "hcs12x.cc"
)
{
#line 1404 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31460 "hcs12x.cc"
}

static Operation *DecodeOpSbc_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpSbc_ab_imm(code, addr);
}

// SBCA/SBCB  DIR  (regAB - mem[regDirect:opr8a] - carry => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 31471 "hcs12x.cc"
OpSbc_ab_dir::getCycles()
{
#line 1433 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 31476 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31480 "hcs12x.cc"
OpSbc_ab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31484 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31487 "hcs12x.cc"
)
{
#line 1435 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SBCA";
			} else {
			mnem = "SBCB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 31503 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31507 "hcs12x.cc"
OpSbc_ab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31511 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31514 "hcs12x.cc"
)
{
#line 1448 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		uint8_t opr8aVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31545 "hcs12x.cc"
}

static Operation *DecodeOpSbc_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpSbc_ab_dir(code, addr);
}

// SBCA/SBCB  EXT (regAB - mem[opr16a] - carry => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 31556 "hcs12x.cc"
OpSbc_ab_ext::getCycles()
{
#line 1479 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 31561 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31565 "hcs12x.cc"
OpSbc_ab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31569 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31572 "hcs12x.cc"
)
{
#line 1481 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SBCA";
			} else {
			mnem = "SBCB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 31588 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31592 "hcs12x.cc"
OpSbc_ab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31596 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31599 "hcs12x.cc"
)
{
#line 1494 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31631 "hcs12x.cc"
}

static Operation *DecodeOpSbc_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpSbc_ab_ext(code, addr);
}

// SBCA/SBCB IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB - mem[xb->addrE] - carry => regAB)
#line 79 "hcs12x.isa"
void
#line 31642 "hcs12x.cc"
OpSbc_ab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 31646 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 31649 "hcs12x.cc"
)
{
#line 1526 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 31658 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 31662 "hcs12x.cc"
OpSbc_ab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 31666 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 31669 "hcs12x.cc"
)
{
#line 1532 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 31678 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 31682 "hcs12x.cc"
OpSbc_ab_idx::getCycles()
{
#line 1538 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 31687 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31691 "hcs12x.cc"
OpSbc_ab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31695 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31698 "hcs12x.cc"
)
{
#line 1540 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0){
			mnem = "SBCA";
			} else {
			mnem = "SBCB";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 31716 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31720 "hcs12x.cc"
OpSbc_ab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31724 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31727 "hcs12x.cc"
)
{
#line 1555 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31760 "hcs12x.cc"
}

static Operation *DecodeOpSbc_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpSbc_ab_idx(code, addr);
}

// SBED  IMM (regD - #opr16i - carry => regD)
#line 88 "hcs12x.isa"
uint8_t
#line 31771 "hcs12x.cc"
OpSbed_imm::getCycles()
{
#line 1588 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 31776 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31780 "hcs12x.cc"
OpSbed_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31784 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31787 "hcs12x.cc"
)
{
#line 1590 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "SBED";

		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 31798 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31802 "hcs12x.cc"
OpSbed_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31806 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31809 "hcs12x.cc"
)
{
#line 1598 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal = cpu->getRegD();

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31830 "hcs12x.cc"
}

static Operation *DecodeOpSbed_imm(CodeType const& code, uint16_t addr)
{
	return new OpSbed_imm(code, addr);
}

// SBED  DIR  (regD - mem16[regDirect:opr8a] - carry => regD)
#line 88 "hcs12x.isa"
uint8_t
#line 31841 "hcs12x.cc"
OpSbed_dir::getCycles()
{
#line 1619 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 31846 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31850 "hcs12x.cc"
OpSbed_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31854 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31857 "hcs12x.cc"
)
{
#line 1621 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "SBED";

		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 31868 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31872 "hcs12x.cc"
OpSbed_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31876 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31879 "hcs12x.cc"
)
{
#line 1629 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal = cpu->getRegD();

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31902 "hcs12x.cc"
}

static Operation *DecodeOpSbed_dir(CodeType const& code, uint16_t addr)
{
	return new OpSbed_dir(code, addr);
}

// SBED  EXT (regD - mem16[opr16a] - carry => regD)
#line 88 "hcs12x.isa"
uint8_t
#line 31913 "hcs12x.cc"
OpSbed_ext::getCycles()
{
#line 1652 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 31918 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 31922 "hcs12x.cc"
OpSbed_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 31926 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 31929 "hcs12x.cc"
)
{
#line 1654 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "SBED";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 31940 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 31944 "hcs12x.cc"
OpSbed_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 31948 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 31951 "hcs12x.cc"
)
{
#line 1662 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31976 "hcs12x.cc"
}

static Operation *DecodeOpSbed_ext(CodeType const& code, uint16_t addr)
{
	return new OpSbed_ext(code, addr);
}

// SBED IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD - mem16[xb->addrE] - carry => regD)
#line 79 "hcs12x.isa"
void
#line 31987 "hcs12x.cc"
OpSbed_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 31991 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 31994 "hcs12x.cc"
)
{
#line 1687 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 32003 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 32007 "hcs12x.cc"
OpSbed_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 32011 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 32014 "hcs12x.cc"
)
{
#line 1693 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 32023 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 32027 "hcs12x.cc"
OpSbed_idx::getCycles()
{
#line 1699 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 32032 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32036 "hcs12x.cc"
OpSbed_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32040 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32043 "hcs12x.cc"
)
{
#line 1701 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "SBED";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 32055 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32059 "hcs12x.cc"
OpSbed_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32063 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32066 "hcs12x.cc"
)
{
#line 1710 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 32091 "hcs12x.cc"
}

static Operation *DecodeOpSbed_idx(CodeType const& code, uint16_t addr)
{
	return new OpSbed_idx(code, addr);
}

// SBEX/SBEY  IMM (regXY - #opr16i - carry => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 32102 "hcs12x.cc"
OpSbe_xy_imm::getCycles()
{
#line 1735 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 32107 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32111 "hcs12x.cc"
OpSbe_xy_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32115 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32118 "hcs12x.cc"
)
{
#line 1737 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SBEX";
			} else {
			mnem = "SBEY";
		}
		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 32134 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32138 "hcs12x.cc"
OpSbe_xy_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32142 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32145 "hcs12x.cc"
)
{
#line 1750 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 32175 "hcs12x.cc"
}

static Operation *DecodeOpSbe_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpSbe_xy_imm(code, addr);
}

// SBEX/SBEY  DIR  (regXY - mem16[regDirect:opr8a] - carry => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 32186 "hcs12x.cc"
OpSbe_xy_dir::getCycles()
{
#line 1780 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 32191 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32195 "hcs12x.cc"
OpSbe_xy_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32199 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32202 "hcs12x.cc"
)
{
#line 1782 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SBEX";
			} else {
			mnem = "SBEY";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 32218 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32222 "hcs12x.cc"
OpSbe_xy_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32226 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32229 "hcs12x.cc"
)
{
#line 1795 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 32261 "hcs12x.cc"
}

static Operation *DecodeOpSbe_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpSbe_xy_dir(code, addr);
}

// SBEX/SBEY  EXT (regXY - mem16[opr16a] - carry => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 32272 "hcs12x.cc"
OpSbe_xy_ext::getCycles()
{
#line 1827 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 32277 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32281 "hcs12x.cc"
OpSbe_xy_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32285 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32288 "hcs12x.cc"
)
{
#line 1829 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SBEX";
			} else {
			mnem = "SBEY";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 32304 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32308 "hcs12x.cc"
OpSbe_xy_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32312 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32315 "hcs12x.cc"
)
{
#line 1842 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 32348 "hcs12x.cc"
}

static Operation *DecodeOpSbe_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpSbe_xy_ext(code, addr);
}

// SBEX/SBEY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY - mem16[xb->addrE] - carry => regXY)
#line 79 "hcs12x.isa"
void
#line 32359 "hcs12x.cc"
OpSbe_xy_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 32363 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 32366 "hcs12x.cc"
)
{
#line 1875 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 32375 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 32379 "hcs12x.cc"
OpSbe_xy_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 32383 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 32386 "hcs12x.cc"
)
{
#line 1881 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 32395 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 32399 "hcs12x.cc"
OpSbe_xy_idx::getCycles()
{
#line 1887 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 32404 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32408 "hcs12x.cc"
OpSbe_xy_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32412 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32415 "hcs12x.cc"
)
{
#line 1889 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0){
			mnem = "SBEX";
			} else {
			mnem = "SBEY";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 32433 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32437 "hcs12x.cc"
OpSbe_xy_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32441 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32444 "hcs12x.cc"
)
{
#line 1904 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 32478 "hcs12x.cc"
}

static Operation *DecodeOpSbe_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpSbe_xy_idx(code, addr);
}

// SUBA/SUBB  IMM (regAB - ii => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 32489 "hcs12x.cc"
OpSub_ab_imm::getCycles()
{
#line 1938 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 1; }
#line 32494 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32498 "hcs12x.cc"
OpSub_ab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32502 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32505 "hcs12x.cc"
)
{
#line 1940 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBA";
			} else {
			mnem = "SUBB";
		}
		sink << mnem << " #0x" << std::hex << opr8i;

		return mnem;
	}
#line 32521 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32525 "hcs12x.cc"
OpSub_ab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32529 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32532 "hcs12x.cc"
)
{
#line 1953 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 32562 "hcs12x.cc"
}

static Operation *DecodeOpSub_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpSub_ab_imm(code, addr);
}

// SUBA/SUBB  DIR  (regAB - mem[regDirect:opr8a] => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 32573 "hcs12x.cc"
OpSub_ab_dir::getCycles()
{
#line 1983 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 32578 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32582 "hcs12x.cc"
OpSub_ab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32586 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32589 "hcs12x.cc"
)
{
#line 1985 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBA";
			} else {
			mnem = "SUBB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem ;
	}
#line 32605 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32609 "hcs12x.cc"
OpSub_ab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32613 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32616 "hcs12x.cc"
)
{
#line 1998 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		uint8_t opr8aVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 32648 "hcs12x.cc"
}

static Operation *DecodeOpSub_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpSub_ab_dir(code, addr);
}

// SUBA/SUBB  EXT (regAB - mem[opr16a] => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 32659 "hcs12x.cc"
OpSub_ab_ext::getCycles()
{
#line 2030 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 32664 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32668 "hcs12x.cc"
OpSub_ab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32672 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32675 "hcs12x.cc"
)
{
#line 2032 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBA";
			} else {
			mnem = "SUBB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 32691 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32695 "hcs12x.cc"
OpSub_ab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32699 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32702 "hcs12x.cc"
)
{
#line 2045 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 32735 "hcs12x.cc"
}

static Operation *DecodeOpSub_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpSub_ab_ext(code, addr);
}

// SUBA/SUBB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB - mem[xb->addrE] => regAB)
#line 79 "hcs12x.isa"
void
#line 32746 "hcs12x.cc"
OpSub_ab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 32750 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 32753 "hcs12x.cc"
)
{
#line 2078 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 32762 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 32766 "hcs12x.cc"
OpSub_ab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 32770 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 32773 "hcs12x.cc"
)
{
#line 2084 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 32782 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 32786 "hcs12x.cc"
OpSub_ab_idx::getCycles()
{
#line 2090 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 32791 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32795 "hcs12x.cc"
OpSub_ab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32799 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32802 "hcs12x.cc"
)
{
#line 2092 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0){
			mnem = "SUBA";
			} else {
			mnem = "SUBB";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 32820 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32824 "hcs12x.cc"
OpSub_ab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32828 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32831 "hcs12x.cc"
)
{
#line 2107 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 32864 "hcs12x.cc"
}

static Operation *DecodeOpSub_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpSub_ab_idx(code, addr);
}

// ******************************
// SUBX/SUBY  IMM (regXy - opr16i => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 32876 "hcs12x.cc"
OpSub_xy_imm::getCycles()
{
#line 2142 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 32881 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32885 "hcs12x.cc"
OpSub_xy_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32889 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32892 "hcs12x.cc"
)
{
#line 2144 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBX";
			} else {
			mnem = "SUBY";
		}
		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 32908 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32912 "hcs12x.cc"
OpSub_xy_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 32916 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 32919 "hcs12x.cc"
)
{
#line 2157 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 32950 "hcs12x.cc"
}

static Operation *DecodeOpSub_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpSub_xy_imm(code, addr);
}

// SUBX/SUBY  DIR  (regXY - mem16[regDirect:opr8a] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 32961 "hcs12x.cc"
OpSub_xy_dir::getCycles()
{
#line 2188 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 32966 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 32970 "hcs12x.cc"
OpSub_xy_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 32974 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 32977 "hcs12x.cc"
)
{
#line 2190 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBX";
			} else {
			mnem = "SUBY";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 32993 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 32997 "hcs12x.cc"
OpSub_xy_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33001 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33004 "hcs12x.cc"
)
{
#line 2203 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 33037 "hcs12x.cc"
}

static Operation *DecodeOpSub_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpSub_xy_dir(code, addr);
}

// SUBX/SUBY  EXT (regXY - mem16[opr16a] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 33048 "hcs12x.cc"
OpSub_xy_ext::getCycles()
{
#line 2236 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 4; }
#line 33053 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33057 "hcs12x.cc"
OpSub_xy_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33061 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33064 "hcs12x.cc"
)
{
#line 2238 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "SUBX";
			} else {
			mnem = "SUBY";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 33080 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33084 "hcs12x.cc"
OpSub_xy_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33088 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33091 "hcs12x.cc"
)
{
#line 2251 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 33125 "hcs12x.cc"
}

static Operation *DecodeOpSub_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpSub_xy_ext(code, addr);
}

// SUBX/SUBY  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY - mem16[xb->addrE] => regXY)
#line 79 "hcs12x.isa"
void
#line 33136 "hcs12x.cc"
OpSub_xy_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 33140 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 33143 "hcs12x.cc"
)
{
#line 2285 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 33152 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 33156 "hcs12x.cc"
OpSub_xy_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 33160 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 33163 "hcs12x.cc"
)
{
#line 2291 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 33172 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 33176 "hcs12x.cc"
OpSub_xy_idx::getCycles()
{
#line 2297 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 33181 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33185 "hcs12x.cc"
OpSub_xy_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33189 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33192 "hcs12x.cc"
)
{
#line 2299 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem;

		if (b==0){
			mnem = "SUBX";
			} else {
			mnem = "SUBY";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 33210 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33214 "hcs12x.cc"
OpSub_xy_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33218 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33221 "hcs12x.cc"
)
{
#line 2314 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 33255 "hcs12x.cc"
}

static Operation *DecodeOpSub_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpSub_xy_idx(code, addr);
}

/* ***** Binary-Coded Decimal Instructions ****** */
// DAA (if (ccr.H) then regA + 0x6 => regA)
#line 88 "hcs12x.isa"
uint8_t
#line 33267 "hcs12x.cc"
OpDaa::getCycles()
{
#line 2351 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{ return 3; }
#line 33272 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33276 "hcs12x.cc"
OpDaa::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33280 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33283 "hcs12x.cc"
)
{
#line 2353 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		string mnem = "DAA";

		sink << mnem;

		return mnem;
	}
#line 33294 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33298 "hcs12x.cc"
OpDaa::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33302 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33305 "hcs12x.cc"
)
{
#line 2361 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t hBit = cpu->ccr->getH();
		uint8_t cBit = cpu->ccr->getC();

		uint8_t overflow, carry_out, result;

		uint8_t aVal = cpu->getRegA();
		uint8_t a74 =  aVal >> 4;
		uint8_t a30 = aVal & 0x0F;


		if ((cBit == 0) &&
		(a74 < 0x9) &&
		(hBit == 0) &&
		(a30 > 0x9))
		{
			Add8(result, carry_out, overflow, aVal, 0x06, 0x00);
			cpu->setRegA(result);
			cpu->ccr->clrC();
		}

		if ((cBit == 0) &&
		(a74 < 0xA) &&
		(hBit == 1) &&
		(a30 < 0x4))
		{
			Add8(result, carry_out, overflow, aVal, 0x06, 0x00);
			cpu->setRegA(result);
			cpu->ccr->clrC();
		}

		if ((cBit == 0) &&
		(a74 > 0x9) &&
		(hBit == 0) &&
		(a30 < 0xA))
		{
			Add8(result, carry_out, overflow, aVal, 0x60, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 0) &&
		(a74 > 0x8) &&
		(hBit == 0) &&
		(a30 > 0x9))
		{
			Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 0) &&
		(a74 > 0x9) &&
		(hBit == 1) &&
		(a30 < 0x4))
		{
			Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 1) &&
		(a74 < 0x3) &&
		(hBit == 0) &&
		(a30 < 0xA))
		{
			Add8(result, carry_out, overflow, aVal, 0x60, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 1) &&
		(a74 < 0x3) &&
		(hBit == 0) &&
		(a30 > 0x9))
		{
			Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 1) &&
		(a74 < 0x4) &&
		(hBit == 1) &&
		(a30 < 0x4))
		{
			Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
		if (result == 0x00) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if (overflow == 1) cpu->ccr->setV(); else cpu->ccr->clrV();
	}
#line 33404 "hcs12x.cc"
}

static Operation *DecodeOpDaa(CodeType const& code, uint16_t addr)
{
	return new OpDaa(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// DEC EXT
#line 88 "hcs12x.isa"
uint8_t
#line 33448 "hcs12x.cc"
OpDec_ext::getCycles()
{
#line 38 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 4; }
#line 33453 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33457 "hcs12x.cc"
OpDec_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33461 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33464 "hcs12x.cc"
)
{
#line 40 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "DEC";

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 33474 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33478 "hcs12x.cc"
OpDec_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33482 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33485 "hcs12x.cc"
)
{
#line 47 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);
		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Sub8(result, carry_out, overflow, opr16aVal, 1, carry_in);

		cpu->memWrite8(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 33503 "hcs12x.cc"
}

static Operation *DecodeOpDec_ext(CodeType const& code, uint16_t addr)
{
	return new OpDec_ext(code, addr);
}

// DEC IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 79 "hcs12x.isa"
void
#line 33514 "hcs12x.cc"
OpDec_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 33518 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 33521 "hcs12x.cc"
)
{
#line 65 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 33530 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 33534 "hcs12x.cc"
OpDec_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 33538 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 33541 "hcs12x.cc"
)
{
#line 71 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 33550 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 33554 "hcs12x.cc"
OpDec_idx::getCycles()
{
#line 77 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 5, 6, 6); }
#line 33559 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33563 "hcs12x.cc"
OpDec_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33567 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33570 "hcs12x.cc"
)
{
#line 79 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "DEC";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 33581 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33585 "hcs12x.cc"
OpDec_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33589 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33592 "hcs12x.cc"
)
{
#line 87 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t val = cpu->memRead8(addr);

		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Sub8(result, carry_out, overflow, val, 1, carry_in);

		cpu->memWrite8(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 33612 "hcs12x.cc"
}

static Operation *DecodeOpDec_idx(CodeType const& code, uint16_t addr)
{
	return new OpDec_idx(code, addr);
}

// DECA  or DECB
#line 88 "hcs12x.isa"
uint8_t
#line 33623 "hcs12x.cc"
OpDec_ab::getCycles()
{
#line 107 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 1; }
#line 33628 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33632 "hcs12x.cc"
OpDec_ab::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33636 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33639 "hcs12x.cc"
)
{
#line 109 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem;

		if (b == 0) {
			mnem = "DECA";
			} else {
			mnem = "DECB";
		}

		sink << mnem;
		return mnem;
	}
#line 33655 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33659 "hcs12x.cc"
OpDec_ab::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33663 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33666 "hcs12x.cc"
)
{
#line 122 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		uint8_t result, carry_out, overflow, carry_in;

		uint8_t val;
		if (b==0) {
			val = cpu->getRegA();
			} else {
			val = cpu->getRegB();
		}

		carry_in = 0;
		Sub8(result, carry_out, overflow, val, 1, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 33696 "hcs12x.cc"
}

static Operation *DecodeOpDec_ab(CodeType const& code, uint16_t addr)
{
	return new OpDec_ab(code, addr);
}

// DECW  EXT
#line 88 "hcs12x.isa"
uint8_t
#line 33707 "hcs12x.cc"
OpDecw_ext::getCycles()
{
#line 152 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 5; }
#line 33712 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33716 "hcs12x.cc"
OpDecw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33720 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33723 "hcs12x.cc"
)
{
#line 154 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "DECW";

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 33733 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33737 "hcs12x.cc"
OpDecw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33741 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33744 "hcs12x.cc"
)
{
#line 161 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);
		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Sub16(result, carry_out, overflow, opr16aVal, 1, carry_in);

		cpu->memWrite16(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 33764 "hcs12x.cc"
}

static Operation *DecodeOpDecw_ext(CodeType const& code, uint16_t addr)
{
	return new OpDecw_ext(code, addr);
}

// DECW  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 79 "hcs12x.isa"
void
#line 33775 "hcs12x.cc"
OpDecw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 33779 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 33782 "hcs12x.cc"
)
{
#line 181 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 33791 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 33795 "hcs12x.cc"
OpDecw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 33799 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 33802 "hcs12x.cc"
)
{
#line 187 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 33811 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 33815 "hcs12x.cc"
OpDecw_idx::getCycles()
{
#line 193 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 5, 7, 7); }
#line 33820 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33824 "hcs12x.cc"
OpDecw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33828 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33831 "hcs12x.cc"
)
{
#line 195 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "DECW";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 33842 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33846 "hcs12x.cc"
OpDecw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33850 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33853 "hcs12x.cc"
)
{
#line 203 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t val = cpu->memRead16(addr);

		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Sub16(result, carry_out, overflow, val, 1, carry_in);

		cpu->memWrite16(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 33874 "hcs12x.cc"
}

static Operation *DecodeOpDecw_idx(CodeType const& code, uint16_t addr)
{
	return new OpDecw_idx(code, addr);
}

// DECX or DECY
#line 88 "hcs12x.isa"
uint8_t
#line 33885 "hcs12x.cc"
OpDec_xy::getCycles()
{
#line 224 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 2; }
#line 33890 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33894 "hcs12x.cc"
OpDec_xy::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33898 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33901 "hcs12x.cc"
)
{
#line 226 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "DECX";
			} else {
			mnem = "DECY";
		}
		sink << mnem;
		return mnem;
	}
#line 33916 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33920 "hcs12x.cc"
OpDec_xy::execute(
#line 67 "hcs12x.isa"
CPU *
#line 33924 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 33927 "hcs12x.cc"
)
{
#line 238 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		uint16_t val;
		if (b==0) {
			val = cpu->getRegX();
			} else {
			val = cpu->getRegY();
		}

		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Sub16(result, carry_out, overflow, val, 1, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 33958 "hcs12x.cc"
}

static Operation *DecodeOpDec_xy(CodeType const& code, uint16_t addr)
{
	return new OpDec_xy(code, addr);
}

// DES
#line 88 "hcs12x.isa"
uint8_t
#line 33969 "hcs12x.cc"
OpDes::getCycles()
{
#line 269 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 2; }
#line 33974 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 33978 "hcs12x.cc"
OpDes::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 33982 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 33985 "hcs12x.cc"
)
{
#line 271 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "DES";

		sink << mnem;
		return mnem;
	}
#line 33995 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 33999 "hcs12x.cc"
OpDes::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34003 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34006 "hcs12x.cc"
)
{
#line 278 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		cpu->setRegSP(cpu->getRegSP() - 1);
	}
#line 34013 "hcs12x.cc"
}

static Operation *DecodeOpDes(CodeType const& code, uint16_t addr)
{
	return new OpDes(code, addr);
}

// DEX
#line 88 "hcs12x.isa"
uint8_t
#line 34024 "hcs12x.cc"
OpDex::getCycles()
{
#line 285 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 1; }
#line 34029 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34033 "hcs12x.cc"
OpDex::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34037 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34040 "hcs12x.cc"
)
{
#line 287 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "DEX";

		sink << mnem;
		return mnem;
	}
#line 34050 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34054 "hcs12x.cc"
OpDex::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34058 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34061 "hcs12x.cc"
)
{
#line 294 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		uint16_t val = cpu->getRegX();
		val--;
		cpu->setRegX(val);
		if (val == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	}
#line 34071 "hcs12x.cc"
}

static Operation *DecodeOpDex(CodeType const& code, uint16_t addr)
{
	return new OpDex(code, addr);
}

// DEY
#line 88 "hcs12x.isa"
uint8_t
#line 34082 "hcs12x.cc"
OpDey::getCycles()
{
#line 304 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 1; }
#line 34087 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34091 "hcs12x.cc"
OpDey::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34095 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34098 "hcs12x.cc"
)
{
#line 306 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "DEY";

		sink << mnem;
		return mnem;
	}
#line 34108 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34112 "hcs12x.cc"
OpDey::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34116 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34119 "hcs12x.cc"
)
{
#line 313 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		uint16_t val = cpu->getRegY();
		val--;
		cpu->setRegY(val);
		if (val == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	}
#line 34129 "hcs12x.cc"
}

static Operation *DecodeOpDey(CodeType const& code, uint16_t addr)
{
	return new OpDey(code, addr);
}

/* ********* Increment Instructions ****** */
// INC EXT
#line 88 "hcs12x.isa"
uint8_t
#line 34141 "hcs12x.cc"
OpInc_ext::getCycles()
{
#line 325 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 4; }
#line 34146 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34150 "hcs12x.cc"
OpInc_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34154 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34157 "hcs12x.cc"
)
{
#line 327 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "INC";

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 34167 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34171 "hcs12x.cc"
OpInc_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34175 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34178 "hcs12x.cc"
)
{
#line 334 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);
		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Add8(result, carry_out, overflow, opr16aVal, 1, carry_in);

		cpu->memWrite8(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 34197 "hcs12x.cc"
}

static Operation *DecodeOpInc_ext(CodeType const& code, uint16_t addr)
{
	return new OpInc_ext(code, addr);
}

// INC IDX or IDX or IDX2 or [D,IDX] or [IDX2]
#line 79 "hcs12x.isa"
void
#line 34208 "hcs12x.cc"
OpInc_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 34212 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 34215 "hcs12x.cc"
)
{
#line 353 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 34224 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 34228 "hcs12x.cc"
OpInc_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 34232 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 34235 "hcs12x.cc"
)
{
#line 359 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 34244 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 34248 "hcs12x.cc"
OpInc_idx::getCycles()
{
#line 365 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 5, 6, 6); }
#line 34253 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34257 "hcs12x.cc"
OpInc_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34261 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34264 "hcs12x.cc"
)
{
#line 367 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "INC";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 34275 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34279 "hcs12x.cc"
OpInc_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34283 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34286 "hcs12x.cc"
)
{
#line 375 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t val = cpu->memRead8(addr);

		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Add8(result, carry_out, overflow, val, 1, carry_in);

		cpu->memWrite8(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 34306 "hcs12x.cc"
}

static Operation *DecodeOpInc_idx(CodeType const& code, uint16_t addr)
{
	return new OpInc_idx(code, addr);
}

// INCA  or INCB
#line 88 "hcs12x.isa"
uint8_t
#line 34317 "hcs12x.cc"
OpInc_ab::getCycles()
{
#line 395 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 1; }
#line 34322 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34326 "hcs12x.cc"
OpInc_ab::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34330 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34333 "hcs12x.cc"
)
{
#line 397 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem;

		if (b == 0) {
			mnem = "INCA";
			} else {
			mnem = "INCB";
		}
		sink << mnem;
		return mnem;
	}
#line 34348 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34352 "hcs12x.cc"
OpInc_ab::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34356 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34359 "hcs12x.cc"
)
{
#line 409 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		uint8_t result, carry_out, overflow, carry_in;

		uint8_t val;
		if (b==0) {
			val = cpu->getRegA();
			} else {
			val = cpu->getRegB();
		}

		carry_in = 0;
		Add8(result, carry_out, overflow, val, 1, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 34389 "hcs12x.cc"
}

static Operation *DecodeOpInc_ab(CodeType const& code, uint16_t addr)
{
	return new OpInc_ab(code, addr);
}

// INCW EXT
#line 88 "hcs12x.isa"
uint8_t
#line 34400 "hcs12x.cc"
OpIncw_ext::getCycles()
{
#line 439 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 5; }
#line 34405 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34409 "hcs12x.cc"
OpIncw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34413 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34416 "hcs12x.cc"
)
{
#line 441 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "INCW";

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 34426 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34430 "hcs12x.cc"
OpIncw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34434 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34437 "hcs12x.cc"
)
{
#line 448 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);
		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Add16(result, carry_out, overflow, opr16aVal, 1, carry_in);

		cpu->memWrite16(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 34457 "hcs12x.cc"
}

static Operation *DecodeOpIncw_ext(CodeType const& code, uint16_t addr)
{
	return new OpIncw_ext(code, addr);
}

// INCW  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 79 "hcs12x.isa"
void
#line 34468 "hcs12x.cc"
OpIncw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 34472 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 34475 "hcs12x.cc"
)
{
#line 468 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 34484 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 34488 "hcs12x.cc"
OpIncw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 34492 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 34495 "hcs12x.cc"
)
{
#line 474 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 34504 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 34508 "hcs12x.cc"
OpIncw_idx::getCycles()
{
#line 480 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 34513 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34517 "hcs12x.cc"
OpIncw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34521 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34524 "hcs12x.cc"
)
{
#line 482 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "INCW";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 34535 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34539 "hcs12x.cc"
OpIncw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34543 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34546 "hcs12x.cc"
)
{
#line 490 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t val = cpu->memRead16(addr);

		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Add16(result, carry_out, overflow, val, 1, carry_in);

		cpu->memWrite16(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 34567 "hcs12x.cc"
}

static Operation *DecodeOpIncw_idx(CodeType const& code, uint16_t addr)
{
	return new OpIncw_idx(code, addr);
}

// INX or INCY
#line 88 "hcs12x.isa"
uint8_t
#line 34578 "hcs12x.cc"
OpInc_xy::getCycles()
{
#line 511 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 2; }
#line 34583 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34587 "hcs12x.cc"
OpInc_xy::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34591 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34594 "hcs12x.cc"
)
{
#line 513 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "INCX";
			} else {
			mnem = "INCY";
		}
		sink << mnem;
		return mnem;
	}
#line 34609 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34613 "hcs12x.cc"
OpInc_xy::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34617 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34620 "hcs12x.cc"
)
{
#line 525 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		uint16_t val;
		if (b==0) {
			val = cpu->getRegX();
			} else {
			val = cpu->getRegY();
		}

		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Add16(result, carry_out, overflow, val, 1, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 34651 "hcs12x.cc"
}

static Operation *DecodeOpInc_xy(CodeType const& code, uint16_t addr)
{
	return new OpInc_xy(code, addr);
}

// INS
#line 88 "hcs12x.isa"
uint8_t
#line 34662 "hcs12x.cc"
OpIns::getCycles()
{
#line 556 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 2; }
#line 34667 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34671 "hcs12x.cc"
OpIns::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34675 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34678 "hcs12x.cc"
)
{
#line 558 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "INS";

		sink << mnem;
		return mnem;
	}
#line 34688 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34692 "hcs12x.cc"
OpIns::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34696 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34699 "hcs12x.cc"
)
{
#line 565 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		cpu->setRegSP(cpu->getRegSP() + 1);
	}
#line 34706 "hcs12x.cc"
}

static Operation *DecodeOpIns(CodeType const& code, uint16_t addr)
{
	return new OpIns(code, addr);
}

// INX
#line 88 "hcs12x.isa"
uint8_t
#line 34717 "hcs12x.cc"
OpInx::getCycles()
{
#line 572 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 1; }
#line 34722 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34726 "hcs12x.cc"
OpInx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34730 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34733 "hcs12x.cc"
)
{
#line 574 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "INX";

		sink << mnem;
		return mnem;
	}
#line 34743 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34747 "hcs12x.cc"
OpInx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34751 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34754 "hcs12x.cc"
)
{
#line 581 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		uint16_t val = cpu->getRegX();
		val++;
		cpu->setRegX(val);
		if (val == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	}
#line 34764 "hcs12x.cc"
}

static Operation *DecodeOpInx(CodeType const& code, uint16_t addr)
{
	return new OpInx(code, addr);
}

// INY
#line 88 "hcs12x.isa"
uint8_t
#line 34775 "hcs12x.cc"
OpIny::getCycles()
{
#line 591 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{ return 1; }
#line 34780 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34784 "hcs12x.cc"
OpIny::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34788 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34791 "hcs12x.cc"
)
{
#line 593 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		string mnem = "INY";

		sink << mnem;
		return mnem;
	}
#line 34801 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34805 "hcs12x.cc"
OpIny::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34809 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34812 "hcs12x.cc"
)
{
#line 600 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		uint16_t val = cpu->getRegY();
		val++;
		cpu->setRegY(val);
		if (val == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	}
#line 34822 "hcs12x.cc"
}

static Operation *DecodeOpIny(CodeType const& code, uint16_t addr)
{
	return new OpIny(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// CBA
#line 88 "hcs12x.isa"
uint8_t
#line 34866 "hcs12x.cc"
OpCba::getCycles()
{
#line 39 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 2; }
#line 34871 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34875 "hcs12x.cc"
OpCba::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34879 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34882 "hcs12x.cc"
)
{
#line 41 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		mnem = "CBA";
		sink << mnem;

		return mnem;
	}
#line 34894 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34898 "hcs12x.cc"
OpCba::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34902 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34905 "hcs12x.cc"
)
{
#line 50 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Sub8(result, carry_out, overflow, cpu->getRegA(), cpu->getRegB(), carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 34920 "hcs12x.cc"
}

static Operation *DecodeOpCba(CodeType const& code, uint16_t addr)
{
	return new OpCba(code, addr);
}

//  CMPab  IMM
#line 88 "hcs12x.isa"
uint8_t
#line 34931 "hcs12x.cc"
OpCmp_ab_imm::getCycles()
{
#line 66 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 1; }
#line 34936 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 34940 "hcs12x.cc"
OpCmp_ab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 34944 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 34947 "hcs12x.cc"
)
{
#line 68 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "CMPA";
			} else {
			mnem = "CMPB";
		}
		sink << mnem << " #0x" << std::hex << opr8i;

		return mnem;
	}
#line 34963 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 34967 "hcs12x.cc"
OpCmp_ab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 34971 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 34974 "hcs12x.cc"
)
{
#line 81 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 34996 "hcs12x.cc"
}

static Operation *DecodeOpCmp_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpCmp_ab_imm(code, addr);
}

// CMPab  DIR
#line 88 "hcs12x.isa"
uint8_t
#line 35007 "hcs12x.cc"
OpCmp_ab_dir::getCycles()
{
#line 103 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 3; }
#line 35012 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35016 "hcs12x.cc"
OpCmp_ab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35020 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35023 "hcs12x.cc"
)
{
#line 105 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "CMPA";
			} else {
			mnem = "CMPB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 35039 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35043 "hcs12x.cc"
OpCmp_ab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35047 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35050 "hcs12x.cc"
)
{
#line 118 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;

		uint8_t opr8aVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 35074 "hcs12x.cc"
}

static Operation *DecodeOpCmp_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpCmp_ab_dir(code, addr);
}

// CMPab  EXT
#line 88 "hcs12x.isa"
uint8_t
#line 35085 "hcs12x.cc"
OpCmp_ab_ext::getCycles()
{
#line 142 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 3; }
#line 35090 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35094 "hcs12x.cc"
OpCmp_ab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35098 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35101 "hcs12x.cc"
)
{
#line 144 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "CMPA";
			} else {
			mnem = "CMPB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 35117 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35121 "hcs12x.cc"
OpCmp_ab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35125 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35128 "hcs12x.cc"
)
{
#line 157 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;
		physical_address_t addr = opr16a;

		uint8_t opr16aVal = cpu->memRead8(addr);

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 35153 "hcs12x.cc"
}

static Operation *DecodeOpCmp_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpCmp_ab_ext(code, addr);
}

// CMPab  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 79 "hcs12x.isa"
void
#line 35164 "hcs12x.cc"
OpCmp_ab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 35168 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 35171 "hcs12x.cc"
)
{
#line 182 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 35180 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 35184 "hcs12x.cc"
OpCmp_ab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 35188 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 35191 "hcs12x.cc"
)
{
#line 188 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 35200 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 35204 "hcs12x.cc"
OpCmp_ab_idx::getCycles()
{
#line 194 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 35209 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35213 "hcs12x.cc"
OpCmp_ab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35217 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35220 "hcs12x.cc"
)
{
#line 196 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "CMPA";
			} else {
			mnem = "CMPB";
		}
		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 35237 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35241 "hcs12x.cc"
OpCmp_ab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35245 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35248 "hcs12x.cc"
)
{
#line 210 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 35272 "hcs12x.cc"
}

static Operation *DecodeOpCmp_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpCmp_ab_idx(code, addr);
}

// CPdyxs  IMM
#line 88 "hcs12x.isa"
uint8_t
#line 35283 "hcs12x.cc"
OpCp_dyxs_imm::getCycles()
{
#line 234 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 2; }
#line 35288 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35292 "hcs12x.cc"
OpCp_dyxs_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35296 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35299 "hcs12x.cc"
)
{
#line 236 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "CPD"; break;
			case 1: mnem = "CPY"; break;
			case 2: mnem = "CPX"; break;
			case 3: mnem = "CPS";
		}
		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 35316 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35320 "hcs12x.cc"
OpCp_dyxs_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35324 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35327 "hcs12x.cc"
)
{
#line 250 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;

		carry_in = 0;
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 35351 "hcs12x.cc"
}

static Operation *DecodeOpCp_dyxs_imm(CodeType const& code, uint16_t addr)
{
	return new OpCp_dyxs_imm(code, addr);
}

// CPdyxs DIR
#line 88 "hcs12x.isa"
uint8_t
#line 35362 "hcs12x.cc"
OpCp_dyxs_dir::getCycles()
{
#line 274 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 3; }
#line 35367 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35371 "hcs12x.cc"
OpCp_dyxs_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35375 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35378 "hcs12x.cc"
)
{
#line 276 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "CPD"; break;
			case 1: mnem = "CPY"; break;
			case 2: mnem = "CPX"; break;
			case 3: mnem = "CPS";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 35395 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35399 "hcs12x.cc"
OpCp_dyxs_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35403 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35406 "hcs12x.cc"
)
{
#line 290 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;
		uint16_t opr8aVal;

		opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		carry_in = 0;
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 35433 "hcs12x.cc"
}

static Operation *DecodeOpCp_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpCp_dyxs_dir(code, addr);
}

// CPdyxs EXT
#line 88 "hcs12x.isa"
uint8_t
#line 35444 "hcs12x.cc"
OpCp_dyxs_ext::getCycles()
{
#line 317 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 3; }
#line 35449 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35453 "hcs12x.cc"
OpCp_dyxs_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35457 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35460 "hcs12x.cc"
)
{
#line 319 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "CPD"; break;
			case 1: mnem = "CPY"; break;
			case 2: mnem = "CPX"; break;
			case 3: mnem = "CPS";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 35477 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35481 "hcs12x.cc"
OpCp_dyxs_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35485 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35488 "hcs12x.cc"
)
{
#line 333 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;
		uint16_t opr16aVal = cpu->memRead16(opr16a);

		carry_in = 0;
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 35513 "hcs12x.cc"
}

static Operation *DecodeOpCp_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpCp_dyxs_ext(code, addr);
}

// CPdyxs  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 79 "hcs12x.isa"
void
#line 35524 "hcs12x.cc"
OpCp_dyxs_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 35528 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 35531 "hcs12x.cc"
)
{
#line 358 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 35540 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 35544 "hcs12x.cc"
OpCp_dyxs_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 35548 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 35551 "hcs12x.cc"
)
{
#line 364 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 35560 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 35564 "hcs12x.cc"
OpCp_dyxs_idx::getCycles()
{
#line 370 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 35569 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35573 "hcs12x.cc"
OpCp_dyxs_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35577 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35580 "hcs12x.cc"
)
{
#line 372 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "CPD"; break;
			case 1: mnem = "CPY"; break;
			case 2: mnem = "CPX"; break;
			case 3: mnem = "CPS";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 35599 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35603 "hcs12x.cc"
OpCp_dyxs_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35607 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35610 "hcs12x.cc"
)
{
#line 388 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		carry_in = 0;
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 35635 "hcs12x.cc"
}

static Operation *DecodeOpCp_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpCp_dyxs_idx(code, addr);
}

/* ****** Compare to memory with Borrow ********** */
// CPE_dyxs  IMM
#line 88 "hcs12x.isa"
uint8_t
#line 35647 "hcs12x.cc"
OpCpe_dyxs_imm::getCycles()
{
#line 415 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 3; }
#line 35652 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35656 "hcs12x.cc"
OpCpe_dyxs_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35660 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35663 "hcs12x.cc"
)
{
#line 417 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "CPED"; break;
			case 1: mnem = "CPEY"; break;
			case 2: mnem = "CPEX"; break;
			case 3: mnem = "CPES";
		}
		sink << mnem << " #0x" << std::hex << opr16i;
		return mnem;
	}
#line 35679 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35683 "hcs12x.cc"
OpCpe_dyxs_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35687 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35690 "hcs12x.cc"
)
{
#line 430 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in, zeroBit;
		uint16_t result, regVal;

		zeroBit = cpu->ccr->getZ();
		carry_in = cpu->ccr->getC();
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (zeroBit && (result == 0)) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 35715 "hcs12x.cc"
}

static Operation *DecodeOpCpe_dyxs_imm(CodeType const& code, uint16_t addr)
{
	return new OpCpe_dyxs_imm(code, addr);
}

// CPE_dyxs DIR
#line 88 "hcs12x.isa"
uint8_t
#line 35726 "hcs12x.cc"
OpCpe_dyxs_dir::getCycles()
{
#line 455 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 4; }
#line 35731 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35735 "hcs12x.cc"
OpCpe_dyxs_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35739 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35742 "hcs12x.cc"
)
{
#line 457 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "CPED"; break;
			case 1: mnem = "CPEY"; break;
			case 2: mnem = "CPEX"; break;
			case 3: mnem = "CPES";
		}
		sink << mnem << " 0x" << std::hex << opr8a;
		return mnem;
	}
#line 35758 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35762 "hcs12x.cc"
OpCpe_dyxs_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35766 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35769 "hcs12x.cc"
)
{
#line 470 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in, zeroBit;
		uint16_t result, regVal;
		uint16_t opr8aVal;

		opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		zeroBit =  cpu->ccr->getZ();
		carry_in = cpu->ccr->getC();
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (zeroBit && (result == 0)) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 35797 "hcs12x.cc"
}

static Operation *DecodeOpCpe_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpCpe_dyxs_dir(code, addr);
}

// CPE_dyxs EXT
#line 88 "hcs12x.isa"
uint8_t
#line 35808 "hcs12x.cc"
OpCpe_dyxs_ext::getCycles()
{
#line 498 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 4; }
#line 35813 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35817 "hcs12x.cc"
OpCpe_dyxs_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35821 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35824 "hcs12x.cc"
)
{
#line 500 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "CPED"; break;
			case 1: mnem = "CPEY"; break;
			case 2: mnem = "CPEX"; break;
			case 3: mnem = "CPES";
		}
		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 35840 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35844 "hcs12x.cc"
OpCpe_dyxs_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35848 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35851 "hcs12x.cc"
)
{
#line 513 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in, zeroBit;
		uint16_t result, regVal;
		uint16_t opr16aVal = cpu->memRead16(opr16a);

		zeroBit =  cpu->ccr->getZ();
		carry_in = cpu->ccr->getC();
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (zeroBit && (result == 0)) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 35877 "hcs12x.cc"
}

static Operation *DecodeOpCpe_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpCpe_dyxs_ext(code, addr);
}

// CPE_dyxs  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 79 "hcs12x.isa"
void
#line 35888 "hcs12x.cc"
OpCpe_dyxs_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 35892 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 35895 "hcs12x.cc"
)
{
#line 539 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 35904 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 35908 "hcs12x.cc"
OpCpe_dyxs_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 35912 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 35915 "hcs12x.cc"
)
{
#line 545 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 35924 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 35928 "hcs12x.cc"
OpCpe_dyxs_idx::getCycles()
{
#line 551 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 35933 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 35937 "hcs12x.cc"
OpCpe_dyxs_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 35941 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 35944 "hcs12x.cc"
)
{
#line 553 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		switch (dyxs) {
			case 0: mnem = "CPED"; break;
			case 1: mnem = "CPEY"; break;
			case 2: mnem = "CPEX"; break;
			case 3: mnem = "CPES";
		}
		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 35961 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 35965 "hcs12x.cc"
OpCpe_dyxs_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 35969 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 35972 "hcs12x.cc"
)
{
#line 567 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in, zeroBit;
		uint16_t result, regVal;
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		zeroBit =  cpu->ccr->getZ();
		carry_in = cpu->ccr->getC();
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (zeroBit && (result == 0)) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 35998 "hcs12x.cc"
}

static Operation *DecodeOpCpe_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpCpe_dyxs_idx(code, addr);
}

/* ************ Test Instructions **************** */
// TST EXT
#line 88 "hcs12x.isa"
uint8_t
#line 36010 "hcs12x.cc"
OpTst_ext::getCycles()
{
#line 596 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 3; }
#line 36015 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36019 "hcs12x.cc"
OpTst_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36023 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36026 "hcs12x.cc"
)
{
#line 598 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "TST";

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 36036 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36040 "hcs12x.cc"
OpTst_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36044 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36047 "hcs12x.cc"
)
{
#line 605 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint8_t result;
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);
		carry_in = 0;

		Sub8(result, carry_out, overflow, opr16aVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 36066 "hcs12x.cc"
}

static Operation *DecodeOpTst_ext(CodeType const& code, uint16_t addr)
{
	return new OpTst_ext(code, addr);
}

// TST IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 79 "hcs12x.isa"
void
#line 36077 "hcs12x.cc"
OpTst_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 36081 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 36084 "hcs12x.cc"
)
{
#line 624 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 36093 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 36097 "hcs12x.cc"
OpTst_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 36101 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 36104 "hcs12x.cc"
)
{
#line 630 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 36113 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 36117 "hcs12x.cc"
OpTst_idx::getCycles()
{
#line 636 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 36122 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36126 "hcs12x.cc"
OpTst_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36130 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36133 "hcs12x.cc"
)
{
#line 638 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "TST";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 36144 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36148 "hcs12x.cc"
OpTst_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36152 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36155 "hcs12x.cc"
)
{
#line 646 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint8_t result;
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		carry_in = 0;

		Sub8(result, carry_out, overflow, xbVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 36174 "hcs12x.cc"
}

static Operation *DecodeOpTst_idx(CodeType const& code, uint16_t addr)
{
	return new OpTst_idx(code, addr);
}

// TSTA or TSTB
#line 88 "hcs12x.isa"
uint8_t
#line 36185 "hcs12x.cc"
OpTst_ab::getCycles()
{
#line 665 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 1; }
#line 36190 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36194 "hcs12x.cc"
OpTst_ab::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36198 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36201 "hcs12x.cc"
)
{
#line 667 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "TSTA";
			} else {
			mnem = "TSTB";
		}

		sink << mnem << " ";
		return mnem;
	}
#line 36217 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36221 "hcs12x.cc"
OpTst_ab::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36225 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36228 "hcs12x.cc"
)
{
#line 680 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 36250 "hcs12x.cc"
}

static Operation *DecodeOpTst_ab(CodeType const& code, uint16_t addr)
{
	return new OpTst_ab(code, addr);
}

// TSTW EXT
#line 88 "hcs12x.isa"
uint8_t
#line 36261 "hcs12x.cc"
OpTstw_ext::getCycles()
{
#line 702 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 4; }
#line 36266 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36270 "hcs12x.cc"
OpTstw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36274 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36277 "hcs12x.cc"
)
{
#line 704 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "TSTW";

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 36287 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36291 "hcs12x.cc"
OpTstw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36295 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36298 "hcs12x.cc"
)
{
#line 711 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result;
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		carry_in = 0;

		Sub16(result, carry_out, overflow, opr16aVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 36318 "hcs12x.cc"
}

static Operation *DecodeOpTstw_ext(CodeType const& code, uint16_t addr)
{
	return new OpTstw_ext(code, addr);
}

// TSTW IDX or IDX1 or IDX2 or [D, IDX] or [IDX2]
#line 79 "hcs12x.isa"
void
#line 36329 "hcs12x.cc"
OpTstw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 36333 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 36336 "hcs12x.cc"
)
{
#line 731 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 36345 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 36349 "hcs12x.cc"
OpTstw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 36353 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 36356 "hcs12x.cc"
)
{
#line 737 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 36365 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 36369 "hcs12x.cc"
OpTstw_idx::getCycles()
{
#line 743 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 36374 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36378 "hcs12x.cc"
OpTstw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36382 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36385 "hcs12x.cc"
)
{
#line 745 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "TSTW";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 36396 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36400 "hcs12x.cc"
OpTstw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36404 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36407 "hcs12x.cc"
)
{
#line 753 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result;
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		carry_in = 0;

		Sub16(result, carry_out, overflow, xbVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 36426 "hcs12x.cc"
}

static Operation *DecodeOpTstw_idx(CodeType const& code, uint16_t addr)
{
	return new OpTstw_idx(code, addr);
}

// TSTX or TSTY
#line 88 "hcs12x.isa"
uint8_t
#line 36437 "hcs12x.cc"
OpTst_xy::getCycles()
{
#line 772 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return 2; }
#line 36442 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36446 "hcs12x.cc"
OpTst_xy::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36450 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36453 "hcs12x.cc"
)
{
#line 774 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem;

		switch (b) {
			case 0: mnem = "TSTX"; break;
			case 1: mnem = "TSTY"; break;
		}

		sink << mnem << " ";
		return mnem;
	}
#line 36468 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36472 "hcs12x.cc"
OpTst_xy::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36476 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36479 "hcs12x.cc"
)
{
#line 786 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;

		carry_in = 0;
		switch (b) {
			case 0: regVal = cpu->getRegY(); break;
			case 1: regVal = cpu->getRegY(); break;
		}

		Sub16(result, carry_out, overflow, regVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 36500 "hcs12x.cc"
}

static Operation *DecodeOpTst_xy(CodeType const& code, uint16_t addr)
{
	return new OpTst_xy(code, addr);
}

/* ************ Minimum Instructions ************* */
// EMIND: MIN ((D), (M : M + 1))  D
// opcode(EMIND)-> 0x18 0x1B
#line 88 "hcs12x.isa"
uint8_t
#line 36513 "hcs12x.cc"
OpEmind::getCycles()
{
#line 812 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 36518 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36522 "hcs12x.cc"
OpEmind::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36526 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36529 "hcs12x.cc"
)
{
#line 814 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "EMIND";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 36540 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36544 "hcs12x.cc"
OpEmind::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36548 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36551 "hcs12x.cc"
)
{
#line 822 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint16_t dVal = cpu->getRegD();
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t mVal = cpu->memRead16(addr);

		uint16_t min;
		if (dVal > mVal) { min == mVal; } else { min = dVal; }

		uint16_t result = dVal - mVal;

		cpu->setRegD(min);

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is 0x0000; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: D15  !M15  !R15 + !D15  M15  R15
		* Set if a twos complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((dVal & 0x8000) & ~(mVal & 0x8000) & ~(result & 0x8000) | ~(dVal & 0x8000) & (mVal & 0x8000) & (result & 0x8000)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !D15  M15 + M15  R15 + R15  !D15
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > dVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 36586 "hcs12x.cc"
}

static Operation *DecodeOpEmind(CodeType const& code, uint16_t addr)
{
	return new OpEmind(code, addr);
}

// EMINM: MIN ((D), (M : M + 1))  M : M + 1
// opcode(EMINM)-> 0x18 0x1F
#line 88 "hcs12x.isa"
uint8_t
#line 36598 "hcs12x.cc"
OpEminm::getCycles()
{
#line 859 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 36603 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36607 "hcs12x.cc"
OpEminm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36611 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36614 "hcs12x.cc"
)
{
#line 861 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "EMINM";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 36625 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36629 "hcs12x.cc"
OpEminm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36633 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36636 "hcs12x.cc"
)
{
#line 869 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint16_t dVal = cpu->getRegD();
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t mVal = cpu->memRead16(addr);

		uint16_t min;
		if (dVal > mVal) { min == mVal; } else { min = dVal; }

		uint16_t result = dVal - mVal;

		cpu->memWrite16(addr, min);

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is 0x0000; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: D15  !M15  !R15 + !D15  M15  R15
		* Set if a twos complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((dVal & 0x8000) & ~(mVal & 0x8000) & ~(result & 0x8000) | ~(dVal & 0x8000) & (mVal & 0x8000) & (result & 0x8000)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !D15  M15 + M15  R15 + R15  !D15
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > dVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 36671 "hcs12x.cc"
}

static Operation *DecodeOpEminm(CodeType const& code, uint16_t addr)
{
	return new OpEminm(code, addr);
}

// MINA: MIN ((A), (M))  A
// opcode(MINA)-> 0x18 0x19
#line 88 "hcs12x.isa"
uint8_t
#line 36683 "hcs12x.cc"
OpMina::getCycles()
{
#line 907 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 36688 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36692 "hcs12x.cc"
OpMina::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36696 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36699 "hcs12x.cc"
)
{
#line 909 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "MINA";

		sink << mnem << " ";

		xb->disasm(sink);
		return mnem;
	}
#line 36711 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36715 "hcs12x.cc"
OpMina::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36719 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36722 "hcs12x.cc"
)
{
#line 918 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint8_t aVal = cpu->getRegA();
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t mVal = cpu->memRead8(addr);

		uint8_t min;
		if (aVal > mVal) { min == mVal; } else { min = aVal; }

		uint8_t result = aVal - mVal;

		cpu->setRegA(min);

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is 0x00; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: A7  !M7  !R7 + !A7  M7  R7
		* Set if a twos complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((aVal & 0x80) & ~(mVal & 0x80) & ~(result & 0x80) | ~(aVal & 0x80) & (mVal & 0x80) & (result & 0x80)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !A7  M7 + M7  R7 + R7  !A7
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > aVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 36757 "hcs12x.cc"
}

static Operation *DecodeOpMina(CodeType const& code, uint16_t addr)
{
	return new OpMina(code, addr);
}

// MINM: MIN ((A), (M))  M
// opcode(MINM)->0x18 0x1D
#line 88 "hcs12x.isa"
uint8_t
#line 36769 "hcs12x.cc"
OpMinm::getCycles()
{
#line 955 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 36774 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36778 "hcs12x.cc"
OpMinm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36782 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36785 "hcs12x.cc"
)
{
#line 957 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "MINM";

		sink << mnem << " ";

		xb->disasm(sink);
		return mnem;
	}
#line 36797 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36801 "hcs12x.cc"
OpMinm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36805 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36808 "hcs12x.cc"
)
{
#line 966 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint8_t aVal = cpu->getRegA();
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t mVal = cpu->memRead8(addr);

		uint8_t min;
		if (aVal > mVal) { min == mVal; } else { min = aVal; }

		uint8_t result = aVal - mVal;

		cpu->memWrite8(addr, min);

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is 0x00; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: A7  !M7  !R7 + !A7  M7  R7
		* Set if a twos complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((aVal & 0x80) & ~(mVal & 0x80) & ~(result & 0x80) | ~(aVal & 0x80) & (mVal & 0x80) & (result & 0x80)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !A7  M7 + M7  R7 + R7  !A7
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > aVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 36843 "hcs12x.cc"
}

static Operation *DecodeOpMinm(CodeType const& code, uint16_t addr)
{
	return new OpMinm(code, addr);
}

/* ************ Maximum Instructions ************* */
// EMAND: MAX ((D), (M : M + 1))  D
// opcode(EMAXD)-> 0x18 0x1A
#line 88 "hcs12x.isa"
uint8_t
#line 36856 "hcs12x.cc"
OpEmaxd::getCycles()
{
#line 1006 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 36861 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36865 "hcs12x.cc"
OpEmaxd::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36869 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36872 "hcs12x.cc"
)
{
#line 1008 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "EMAXD";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 36883 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36887 "hcs12x.cc"
OpEmaxd::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36891 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36894 "hcs12x.cc"
)
{
#line 1016 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint16_t dVal = cpu->getRegD();
		physical_address_t addr = xb->getEAddr(cpu);

		uint16_t mVal = cpu->memRead16(addr);

		uint16_t max;
		if (mVal > dVal) { max == mVal; } else { max = dVal; }

		uint16_t result = dVal - mVal;

		cpu->setRegD(max);

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is 0x0000; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: D15  !M15  !R15 + !D15  M15  R15
		* Set if a twos complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((dVal & 0x8000) & ~(mVal & 0x8000) & ~(result & 0x8000) | ~(dVal & 0x8000) & (mVal & 0x8000) & (result & 0x8000)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !D15  M15 + M15  R15 + R15  !D15
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > dVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 36930 "hcs12x.cc"
}

static Operation *DecodeOpEmaxd(CodeType const& code, uint16_t addr)
{
	return new OpEmaxd(code, addr);
}

// EMANM: MAX ((D), (M : M + 1))  M : M + 1
// opcode(EMAXM)-> 0x18 0x1E
#line 88 "hcs12x.isa"
uint8_t
#line 36942 "hcs12x.cc"
OpEmaxm::getCycles()
{
#line 1054 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 36947 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 36951 "hcs12x.cc"
OpEmaxm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 36955 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 36958 "hcs12x.cc"
)
{
#line 1056 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "EMAXM";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 36969 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 36973 "hcs12x.cc"
OpEmaxm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 36977 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 36980 "hcs12x.cc"
)
{
#line 1064 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint16_t dVal = cpu->getRegD();
		physical_address_t addr = xb->getEAddr(cpu);

		uint16_t mVal = cpu->memRead16(addr);

		uint16_t max;
		if (mVal > dVal) { max == mVal; } else { max = dVal; }

		uint16_t result = dVal - mVal;

		cpu->memWrite16(addr, max);

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is 0x0000; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: D15  !M15  !R15 + !D15  M15  R15
		* Set if a twos complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((dVal & 0x8000) & ~(mVal & 0x8000) & ~(result & 0x8000) | ~(dVal & 0x8000) & (mVal & 0x8000) & (result & 0x8000)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !D15  M15 + M15  R15 + R15  !D15
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > dVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 37016 "hcs12x.cc"
}

static Operation *DecodeOpEmaxm(CodeType const& code, uint16_t addr)
{
	return new OpEmaxm(code, addr);
}

// MAXA: MAX ((A), (M))  A
// opcode(MAXA)-> 0x18 0x18
#line 88 "hcs12x.isa"
uint8_t
#line 37028 "hcs12x.cc"
OpMaxa::getCycles()
{
#line 1103 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 37033 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37037 "hcs12x.cc"
OpMaxa::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37041 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37044 "hcs12x.cc"
)
{
#line 1105 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "MAXA";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 37055 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37059 "hcs12x.cc"
OpMaxa::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37063 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37066 "hcs12x.cc"
)
{
#line 1113 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint8_t aVal = cpu->getRegA();
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t mVal = cpu->memRead8(addr);

		uint8_t max;
		if (mVal > aVal) { max == mVal; } else { max = aVal; }

		uint8_t result = aVal - mVal;

		cpu->setRegA(max);

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is 0x00; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: A7  !M7  !R7 + !A7  M7  R7
		* Set if a twos complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((aVal & 0x80) & ~(mVal & 0x80) & ~(result & 0x80) | ~(aVal & 0x80) & (mVal & 0x80) & (result & 0x80)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !A7  M7 + M7  R7 + R7  !A7
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > aVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 37101 "hcs12x.cc"
}

static Operation *DecodeOpMaxa(CodeType const& code, uint16_t addr)
{
	return new OpMaxa(code, addr);
}

// MAXM: MAx ((A), (M))  M
// opcode(MAXM)->0x18 0x1C
#line 88 "hcs12x.isa"
uint8_t
#line 37113 "hcs12x.cc"
OpMaxm::getCycles()
{
#line 1150 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 37118 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37122 "hcs12x.cc"
OpMaxm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37126 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37129 "hcs12x.cc"
)
{
#line 1152 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		string mnem = "MAXM";

		sink << mnem << " ";
		xb->disasm(sink);
		return mnem;
	}
#line 37140 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37144 "hcs12x.cc"
OpMaxm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37148 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37151 "hcs12x.cc"
)
{
#line 1160 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint8_t aVal = cpu->getRegA();
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t mVal = cpu->memRead8(addr);

		uint8_t max;
		if (mVal > aVal) { max == mVal; } else { max = aVal; }

		uint8_t result = aVal - mVal;

		cpu->memWrite8(addr, max);

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is 0x00; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: A7  !M7  !R7 + !A7  M7  R7
		* Set if a twos complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((aVal & 0x80) & ~(mVal & 0x80) & ~(result & 0x80) | ~(aVal & 0x80) & (mVal & 0x80) & (result & 0x80)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !A7  M7 + M7  R7 + R7  !A7
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > aVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 37186 "hcs12x.cc"
}

static Operation *DecodeOpMaxm(CodeType const& code, uint16_t addr)
{
	return new OpMaxm(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// ANDA/ANDB  IMM  (regAB & ii => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 37230 "hcs12x.cc"
OpAnd_ab_imm::getCycles()
{
#line 39 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 1; }
#line 37235 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37239 "hcs12x.cc"
OpAnd_ab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37243 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37246 "hcs12x.cc"
)
{
#line 41 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ANDA";
			} else {
			mnem = "ANDB";
		}
		sink << mnem << " #0x" << std::hex << opr8i;

		return mnem;
	}
#line 37262 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37266 "hcs12x.cc"
OpAnd_ab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37270 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37273 "hcs12x.cc"
)
{
#line 54 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		result = regVal & opr8i;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 37301 "hcs12x.cc"
}

static Operation *DecodeOpAnd_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpAnd_ab_imm(code, addr);
}

// ANDA/ANDB  DIR  (regAB & mem[regDirect:opr8a] => regAB)s
#line 88 "hcs12x.isa"
uint8_t
#line 37312 "hcs12x.cc"
OpAnd_ab_dir::getCycles()
{
#line 82 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 3; }
#line 37317 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37321 "hcs12x.cc"
OpAnd_ab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37325 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37328 "hcs12x.cc"
)
{
#line 84 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ANDA";
			} else {
			mnem = "ANDB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 37344 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37348 "hcs12x.cc"
OpAnd_ab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37352 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37355 "hcs12x.cc"
)
{
#line 97 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		uint8_t opr8aVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		result = regVal & opr8aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 37384 "hcs12x.cc"
}

static Operation *DecodeOpAnd_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpAnd_ab_dir(code, addr);
}

// ANDA/ANDB EXT (regAB & mem[opr16a] => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 37395 "hcs12x.cc"
OpAnd_ab_ext::getCycles()
{
#line 126 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 3; }
#line 37400 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37404 "hcs12x.cc"
OpAnd_ab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37408 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37411 "hcs12x.cc"
)
{
#line 128 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ANDA";
			} else {
			mnem = "ANDB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 37427 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37431 "hcs12x.cc"
OpAnd_ab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37435 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37438 "hcs12x.cc"
)
{
#line 141 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		result = regVal & opr16aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 37467 "hcs12x.cc"
}

static Operation *DecodeOpAnd_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpAnd_ab_ext(code, addr);
}

// ANDA/ANDB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regAB & mem[xb->addrE] => regAB)
#line 79 "hcs12x.isa"
void
#line 37478 "hcs12x.cc"
OpAnd_ab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 37482 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 37485 "hcs12x.cc"
)
{
#line 170 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 37494 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 37498 "hcs12x.cc"
OpAnd_ab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 37502 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 37505 "hcs12x.cc"
)
{
#line 176 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 37514 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 37518 "hcs12x.cc"
OpAnd_ab_idx::getCycles()
{
#line 182 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 37523 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37527 "hcs12x.cc"
OpAnd_ab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37531 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37534 "hcs12x.cc"
)
{
#line 184 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0){
			mnem = "ANDA";
			} else {
			mnem = "ANDB";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 37552 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37556 "hcs12x.cc"
OpAnd_ab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37560 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37563 "hcs12x.cc"
)
{
#line 199 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		result = regVal & xbVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 37593 "hcs12x.cc"
}

static Operation *DecodeOpAnd_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpAnd_ab_idx(code, addr);
}

// ANDCC  IMM  (ccr & ii => ccr)
#line 88 "hcs12x.isa"
uint8_t
#line 37604 "hcs12x.cc"
OpAndcc_imm::getCycles()
{
#line 229 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 1; }
#line 37609 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37613 "hcs12x.cc"
OpAndcc_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37617 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37620 "hcs12x.cc"
)
{
#line 231 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem = "ANDCC";

		sink << mnem << " #0x" << std::hex << opr8i;

		return mnem;
	}
#line 37631 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37635 "hcs12x.cc"
OpAndcc_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37639 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37642 "hcs12x.cc"
)
{
#line 239 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal = cpu->ccr->getCCRLow();

		result = regVal & opr8i;

		cpu->ccr->setCCRLow(result);

	}
#line 37656 "hcs12x.cc"
}

static Operation *DecodeOpAndcc_imm(CodeType const& code, uint16_t addr)
{
	return new OpAndcc_imm(code, addr);
}

// ANDX/ANDY IMM (regXY & opr16i => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 37667 "hcs12x.cc"
OpAnd_xy_imm::getCycles()
{
#line 253 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 3; }
#line 37672 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37676 "hcs12x.cc"
OpAnd_xy_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37680 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37683 "hcs12x.cc"
)
{
#line 255 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ANDX";
			} else {
			mnem = "ANDY";
		}

		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 37700 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37704 "hcs12x.cc"
OpAnd_xy_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37708 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37711 "hcs12x.cc"
)
{
#line 269 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal & opr16i;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 37738 "hcs12x.cc"
}

static Operation *DecodeOpAnd_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpAnd_xy_imm(code, addr);
}

// ANDX/ANDY DIR (regXY & mem[regDirect:opr8a]:mem[regDirect:opr8a+1] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 37749 "hcs12x.cc"
OpAnd_xy_dir::getCycles()
{
#line 296 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 4; }
#line 37754 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37758 "hcs12x.cc"
OpAnd_xy_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37762 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37765 "hcs12x.cc"
)
{
#line 298 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ANDX";
			} else {
			mnem = "ANDY";
		}

		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 37782 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37786 "hcs12x.cc"
OpAnd_xy_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37790 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37793 "hcs12x.cc"
)
{
#line 312 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal & opr8aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 37822 "hcs12x.cc"
}

static Operation *DecodeOpAnd_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpAnd_xy_dir(code, addr);
}

// ANDX/ANDY EXT (regXY & mem[opr16a]:mem[opr16a+1] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 37833 "hcs12x.cc"
OpAnd_xy_ext::getCycles()
{
#line 341 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 4; }
#line 37838 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37842 "hcs12x.cc"
OpAnd_xy_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37846 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37849 "hcs12x.cc"
)
{
#line 343 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ANDX";
			} else {
			mnem = "ANDY";
		}

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 37866 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37870 "hcs12x.cc"
OpAnd_xy_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37874 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 37877 "hcs12x.cc"
)
{
#line 357 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal & opr16aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 37906 "hcs12x.cc"
}

static Operation *DecodeOpAnd_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpAnd_xy_ext(code, addr);
}

// ANDX/ANDY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regXY & mem[xb->addrE]:mem[xb->addrE+1] => regXY)
#line 79 "hcs12x.isa"
void
#line 37917 "hcs12x.cc"
OpAnd_xy_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 37921 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 37924 "hcs12x.cc"
)
{
#line 386 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 37933 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 37937 "hcs12x.cc"
OpAnd_xy_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 37941 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 37944 "hcs12x.cc"
)
{
#line 392 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 37953 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 37957 "hcs12x.cc"
OpAnd_xy_idx::getCycles()
{
#line 398 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 37962 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 37966 "hcs12x.cc"
OpAnd_xy_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 37970 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 37973 "hcs12x.cc"
)
{
#line 400 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ANDX";
			} else {
			mnem = "ANDY";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 37991 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 37995 "hcs12x.cc"
OpAnd_xy_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 37999 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38002 "hcs12x.cc"
)
{
#line 415 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal & xbVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 38031 "hcs12x.cc"
}

static Operation *DecodeOpAnd_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpAnd_xy_idx(code, addr);
}

// ORAA/ORAB IMM (regAB or opr8i => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 38042 "hcs12x.cc"
OpOra_ab_imm::getCycles()
{
#line 445 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 1; }
#line 38047 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38051 "hcs12x.cc"
OpOra_ab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38055 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38058 "hcs12x.cc"
)
{
#line 447 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ORAA";
			} else {
			mnem = "ORAB";
		}
		sink << mnem << " #0x" << std::hex << opr8i;

		return mnem;
	}
#line 38074 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38078 "hcs12x.cc"
OpOra_ab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38082 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38085 "hcs12x.cc"
)
{
#line 460 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		result = regVal | opr8i;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 38113 "hcs12x.cc"
}

static Operation *DecodeOpOra_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpOra_ab_imm(code, addr);
}

// ORAA/ORAB  DIR  (regAB | mem[regDirect:opr8a] => regAB)s
#line 88 "hcs12x.isa"
uint8_t
#line 38124 "hcs12x.cc"
OpOra_ab_dir::getCycles()
{
#line 488 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 3; }
#line 38129 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38133 "hcs12x.cc"
OpOra_ab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38137 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38140 "hcs12x.cc"
)
{
#line 490 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ORAA";
			} else {
			mnem = "ORAB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 38156 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38160 "hcs12x.cc"
OpOra_ab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38164 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38167 "hcs12x.cc"
)
{
#line 503 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		uint8_t opr8aVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		result = regVal | opr8aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 38196 "hcs12x.cc"
}

static Operation *DecodeOpOra_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpOra_ab_dir(code, addr);
}

// ORAA/ORAB EXT (regAB | mem[opr16a] => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 38207 "hcs12x.cc"
OpOra_ab_ext::getCycles()
{
#line 532 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 3; }
#line 38212 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38216 "hcs12x.cc"
OpOra_ab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38220 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38223 "hcs12x.cc"
)
{
#line 534 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ORAA";
			} else {
			mnem = "ORAB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 38239 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38243 "hcs12x.cc"
OpOra_ab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38247 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38250 "hcs12x.cc"
)
{
#line 547 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		result = regVal | opr16aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 38279 "hcs12x.cc"
}

static Operation *DecodeOpOra_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpOra_ab_ext(code, addr);
}

// ORAA/ORAB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regAB | mem[xb->addrE] => regAB)
#line 79 "hcs12x.isa"
void
#line 38290 "hcs12x.cc"
OpOra_ab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 38294 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 38297 "hcs12x.cc"
)
{
#line 576 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 38306 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 38310 "hcs12x.cc"
OpOra_ab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 38314 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 38317 "hcs12x.cc"
)
{
#line 582 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 38326 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 38330 "hcs12x.cc"
OpOra_ab_idx::getCycles()
{
#line 588 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 38335 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38339 "hcs12x.cc"
OpOra_ab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38343 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38346 "hcs12x.cc"
)
{
#line 590 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0){
			mnem = "ORAA";
			} else {
			mnem = "ORAB";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 38364 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38368 "hcs12x.cc"
OpOra_ab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38372 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38375 "hcs12x.cc"
)
{
#line 605 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		result = regVal | xbVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 38405 "hcs12x.cc"
}

static Operation *DecodeOpOra_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpOra_ab_idx(code, addr);
}

// ORCC  IMM  (ccr & ii => ccr)
#line 88 "hcs12x.isa"
uint8_t
#line 38416 "hcs12x.cc"
OpOrcc_imm::getCycles()
{
#line 635 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 1; }
#line 38421 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38425 "hcs12x.cc"
OpOrcc_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38429 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38432 "hcs12x.cc"
)
{
#line 637 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem = "ORCC";

		sink << mnem << " #0x" << std::hex << opr8i;

		return mnem;
	}
#line 38443 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38447 "hcs12x.cc"
OpOrcc_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38451 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38454 "hcs12x.cc"
)
{
#line 645 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result, xFlag;

		uint8_t regVal = cpu->ccr->getCCRLow();

		// get ccr.X which may not be affected by ORCC instruction
		// if (ccr.X==1) then xFlag=0xFF else xFlag=0xBF;  0xBF = 0b10111111
		xFlag = regVal | 0xBF;

		result = (regVal | opr8i) & xFlag;

		cpu->ccr->setCCRLow(result);

	}
#line 38472 "hcs12x.cc"
}

static Operation *DecodeOpOrcc_imm(CodeType const& code, uint16_t addr)
{
	return new OpOrcc_imm(code, addr);
}

// TODO: implement specialization ++++++++++++++
// SEC: set carry
// use specialize orcc_imm with opr8i=0x01
// SEI: set I (inhibit I interrupts)
// use specialize orcc_imm with opr8i=0x10
// SEV: set overflow
// use specialize orcc_imm with opr8i=0x02
// end todo specialization ++++++++++++++++++++++
// ORX/ORY IMM (regXY | opr16i => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 38491 "hcs12x.cc"
OpOr_xy_imm::getCycles()
{
#line 677 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 3; }
#line 38496 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38500 "hcs12x.cc"
OpOr_xy_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38504 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38507 "hcs12x.cc"
)
{
#line 679 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ORX";
			} else {
			mnem = "ORY";
		}

		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 38524 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38528 "hcs12x.cc"
OpOr_xy_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38532 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38535 "hcs12x.cc"
)
{
#line 693 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal | opr16i;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 38562 "hcs12x.cc"
}

static Operation *DecodeOpOr_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpOr_xy_imm(code, addr);
}

// ORX/ORY DIR (regXY | mem[regDirect:opr8a]:mem[regDirect:opr8a+1] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 38573 "hcs12x.cc"
OpOr_xy_dir::getCycles()
{
#line 720 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 4; }
#line 38578 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38582 "hcs12x.cc"
OpOr_xy_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38586 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38589 "hcs12x.cc"
)
{
#line 722 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ORX";
			} else {
			mnem = "ORY";
		}

		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 38606 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38610 "hcs12x.cc"
OpOr_xy_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38614 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38617 "hcs12x.cc"
)
{
#line 736 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal | opr8aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 38646 "hcs12x.cc"
}

static Operation *DecodeOpOr_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpOr_xy_dir(code, addr);
}

// ORX/ORY EXT (regXY | mem[opr16a]:mem[opr16a+1] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 38657 "hcs12x.cc"
OpOr_xy_ext::getCycles()
{
#line 765 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 4; }
#line 38662 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38666 "hcs12x.cc"
OpOr_xy_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38670 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38673 "hcs12x.cc"
)
{
#line 767 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ORX";
			} else {
			mnem = "ORY";
		}

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 38690 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38694 "hcs12x.cc"
OpOr_xy_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38698 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38701 "hcs12x.cc"
)
{
#line 781 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal | opr16aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 38730 "hcs12x.cc"
}

static Operation *DecodeOpOr_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpOr_xy_ext(code, addr);
}

// ORX/ORY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regXY | mem[xb->addrE]:mem[xb->addrE+1] => regXY)
#line 79 "hcs12x.isa"
void
#line 38741 "hcs12x.cc"
OpOr_xy_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 38745 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 38748 "hcs12x.cc"
)
{
#line 810 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 38757 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 38761 "hcs12x.cc"
OpOr_xy_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 38765 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 38768 "hcs12x.cc"
)
{
#line 816 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 38777 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 38781 "hcs12x.cc"
OpOr_xy_idx::getCycles()
{
#line 822 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 38786 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38790 "hcs12x.cc"
OpOr_xy_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38794 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38797 "hcs12x.cc"
)
{
#line 824 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ORX";
			} else {
			mnem = "ORY";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 38815 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38819 "hcs12x.cc"
OpOr_xy_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38823 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38826 "hcs12x.cc"
)
{
#line 839 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal | xbVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 38855 "hcs12x.cc"
}

static Operation *DecodeOpOr_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpOr_xy_idx(code, addr);
}

// EORA/EORB IMM (regAB ^ opr8i => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 38866 "hcs12x.cc"
OpEor_ab_imm::getCycles()
{
#line 869 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 1; }
#line 38871 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38875 "hcs12x.cc"
OpEor_ab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38879 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38882 "hcs12x.cc"
)
{
#line 871 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "EORA";
			} else {
			mnem = "EORB";
		}
		sink << mnem << " #0x" << std::hex << opr8i;

		return mnem;
	}
#line 38898 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38902 "hcs12x.cc"
OpEor_ab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38906 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38909 "hcs12x.cc"
)
{
#line 884 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		result = regVal ^ opr8i;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 38936 "hcs12x.cc"
}

static Operation *DecodeOpEor_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpEor_ab_imm(code, addr);
}

// EORA/EORB  DIR  (regAB ^ mem[regDirect:opr8a] => regAB)s
#line 88 "hcs12x.isa"
uint8_t
#line 38947 "hcs12x.cc"
OpEor_ab_dir::getCycles()
{
#line 911 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 3; }
#line 38952 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 38956 "hcs12x.cc"
OpEor_ab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 38960 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 38963 "hcs12x.cc"
)
{
#line 913 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "ORAA";
			} else {
			mnem = "ORAB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 38979 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 38983 "hcs12x.cc"
OpEor_ab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 38987 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 38990 "hcs12x.cc"
)
{
#line 926 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		uint8_t opr8aVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		result = regVal ^ opr8aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 39019 "hcs12x.cc"
}

static Operation *DecodeOpEor_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpEor_ab_dir(code, addr);
}

// EORA/EORB EXT (regAB ^ mem[opr16a] => regAB)
#line 88 "hcs12x.isa"
uint8_t
#line 39030 "hcs12x.cc"
OpEor_ab_ext::getCycles()
{
#line 955 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 3; }
#line 39035 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39039 "hcs12x.cc"
OpEor_ab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39043 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39046 "hcs12x.cc"
)
{
#line 957 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "EORA";
			} else {
			mnem = "EORB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 39062 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39066 "hcs12x.cc"
OpEor_ab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39070 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39073 "hcs12x.cc"
)
{
#line 970 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		result = regVal ^ opr16aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 39102 "hcs12x.cc"
}

static Operation *DecodeOpEor_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpEor_ab_ext(code, addr);
}

// EORA/EORB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regAB ^ mem[xb->addrE] => regAB)
#line 79 "hcs12x.isa"
void
#line 39113 "hcs12x.cc"
OpEor_ab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 39117 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 39120 "hcs12x.cc"
)
{
#line 999 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 39129 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 39133 "hcs12x.cc"
OpEor_ab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 39137 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 39140 "hcs12x.cc"
)
{
#line 1005 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 39149 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 39153 "hcs12x.cc"
OpEor_ab_idx::getCycles()
{
#line 1011 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 39158 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39162 "hcs12x.cc"
OpEor_ab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39166 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39169 "hcs12x.cc"
)
{
#line 1013 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0){
			mnem = "EORA";
			} else {
			mnem = "EORB";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 39187 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39191 "hcs12x.cc"
OpEor_ab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39195 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39198 "hcs12x.cc"
)
{
#line 1028 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		result = regVal ^ xbVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 39228 "hcs12x.cc"
}

static Operation *DecodeOpEor_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpEor_ab_idx(code, addr);
}

// EORX/EORY IMM (regXY ^ opr16i => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 39239 "hcs12x.cc"
OpEor_xy_imm::getCycles()
{
#line 1058 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 3; }
#line 39244 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39248 "hcs12x.cc"
OpEor_xy_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39252 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39255 "hcs12x.cc"
)
{
#line 1060 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "EORX";
			} else {
			mnem = "EORY";
		}

		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 39272 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39276 "hcs12x.cc"
OpEor_xy_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39280 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39283 "hcs12x.cc"
)
{
#line 1074 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal ^ opr16i;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 39310 "hcs12x.cc"
}

static Operation *DecodeOpEor_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpEor_xy_imm(code, addr);
}

// EORX/EORY DIR (regXY ^ mem[regDirect:opr8a]:mem[regDirect:opr8a+1] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 39321 "hcs12x.cc"
OpEor_xy_dir::getCycles()
{
#line 1101 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 4; }
#line 39326 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39330 "hcs12x.cc"
OpEor_xy_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39334 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39337 "hcs12x.cc"
)
{
#line 1103 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "EORX";
			} else {
			mnem = "EORY";
		}

		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 39354 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39358 "hcs12x.cc"
OpEor_xy_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39362 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39365 "hcs12x.cc"
)
{
#line 1117 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;

		uint16_t opr8aVal = cpu->memRead16(opr8a, ADDRESS::DIRECT, false);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal ^ opr8aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 39394 "hcs12x.cc"
}

static Operation *DecodeOpEor_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpEor_xy_dir(code, addr);
}

// EORX/EORY EXT (regXY ^ mem[opr16a]:mem[opr16a+1] => regXY)
#line 88 "hcs12x.isa"
uint8_t
#line 39405 "hcs12x.cc"
OpEor_xy_ext::getCycles()
{
#line 1146 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return 4; }
#line 39410 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39414 "hcs12x.cc"
OpEor_xy_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39418 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39421 "hcs12x.cc"
)
{
#line 1148 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "EORX";
			} else {
			mnem = "EORY";
		}

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 39438 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39442 "hcs12x.cc"
OpEor_xy_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39446 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39449 "hcs12x.cc"
)
{
#line 1162 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = opr16a;
		uint16_t opr16aVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal ^ opr16aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 39478 "hcs12x.cc"
}

static Operation *DecodeOpEor_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpEor_xy_ext(code, addr);
}

// EORX/EORY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regXY ^ mem[xb->addrE]:mem[xb->addrE+1] => regXY)
#line 79 "hcs12x.isa"
void
#line 39489 "hcs12x.cc"
OpEor_xy_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 39493 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 39496 "hcs12x.cc"
)
{
#line 1191 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 39505 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 39509 "hcs12x.cc"
OpEor_xy_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 39513 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 39516 "hcs12x.cc"
)
{
#line 1197 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 39525 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 39529 "hcs12x.cc"
OpEor_xy_idx::getCycles()
{
#line 1203 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 39534 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39538 "hcs12x.cc"
OpEor_xy_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39542 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39545 "hcs12x.cc"
)
{
#line 1205 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "EORX";
			} else {
			mnem = "EORY";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 39563 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39567 "hcs12x.cc"
OpEor_xy_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39571 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39574 "hcs12x.cc"
)
{
#line 1220 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t xbVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal ^ xbVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 39603 "hcs12x.cc"
}

static Operation *DecodeOpEor_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpEor_xy_idx(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
/* ********** Clear, Complement, and Negate instructions ********* */
// CLC: clear bit C
#line 88 "hcs12x.isa"
uint8_t
#line 39648 "hcs12x.cc"
OpClc::getCycles()
{
#line 41 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 39653 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39657 "hcs12x.cc"
OpClc::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39661 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39664 "hcs12x.cc"
)
{
#line 43 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "CLC";

		sink << mnem;

		return mnem;
	}
#line 39675 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39679 "hcs12x.cc"
OpClc::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39683 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39686 "hcs12x.cc"
)
{
#line 51 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		cpu->ccr->clrC();
	}
#line 39693 "hcs12x.cc"
}

static Operation *DecodeOpClc(CodeType const& code, uint16_t addr)
{
	return new OpClc(code, addr);
}

// CLI: clear bit I
#line 88 "hcs12x.isa"
uint8_t
#line 39704 "hcs12x.cc"
OpCli::getCycles()
{
#line 58 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 39709 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39713 "hcs12x.cc"
OpCli::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39717 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39720 "hcs12x.cc"
)
{
#line 60 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "CLI";

		sink << mnem;

		return  mnem;
	}
#line 39731 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39735 "hcs12x.cc"
OpCli::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39739 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39742 "hcs12x.cc"
)
{
#line 68 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		cpu->ccr->clrI();
	}
#line 39749 "hcs12x.cc"
}

static Operation *DecodeOpCli(CodeType const& code, uint16_t addr)
{
	return new OpCli(code, addr);
}

// CLV: clear bit V
#line 88 "hcs12x.isa"
uint8_t
#line 39760 "hcs12x.cc"
OpClv::getCycles()
{
#line 75 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 39765 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39769 "hcs12x.cc"
OpClv::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39773 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39776 "hcs12x.cc"
)
{
#line 77 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "CLV";

		sink << mnem;

		return mnem;
	}
#line 39787 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39791 "hcs12x.cc"
OpClv::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39795 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39798 "hcs12x.cc"
)
{
#line 85 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		cpu->ccr->clrV();
	}
#line 39805 "hcs12x.cc"
}

static Operation *DecodeOpClv(CodeType const& code, uint16_t addr)
{
	return new OpClv(code, addr);
}

// clear Memory
#line 88 "hcs12x.isa"
uint8_t
#line 39816 "hcs12x.cc"
OpClr_ext::getCycles()
{
#line 92 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 3; }
#line 39821 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39825 "hcs12x.cc"
OpClr_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39829 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39832 "hcs12x.cc"
)
{
#line 94 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "CLR";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 39843 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39847 "hcs12x.cc"
OpClr_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39851 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39854 "hcs12x.cc"
)
{
#line 102 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		cpu->memWrite8(addr, 0);

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 39867 "hcs12x.cc"
}

static Operation *DecodeOpClr_ext(CodeType const& code, uint16_t addr)
{
	return new OpClr_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 39877 "hcs12x.cc"
OpClr_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 39881 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 39884 "hcs12x.cc"
)
{
#line 114 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 39893 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 39897 "hcs12x.cc"
OpClr_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 39901 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 39904 "hcs12x.cc"
)
{
#line 120 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 39913 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 39917 "hcs12x.cc"
OpClr_idx::getCycles()
{
#line 127 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 2, 3, 3, 4, 4); }
#line 39922 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39926 "hcs12x.cc"
OpClr_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39930 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39933 "hcs12x.cc"
)
{
#line 129 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "CLR";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 39945 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 39949 "hcs12x.cc"
OpClr_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 39953 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 39956 "hcs12x.cc"
)
{
#line 138 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		cpu->memWrite8(addr, 0);

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 39969 "hcs12x.cc"
}

static Operation *DecodeOpClr_idx(CodeType const& code, uint16_t addr)
{
	return new OpClr_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 39979 "hcs12x.cc"
OpClrw_ext::getCycles()
{
#line 150 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 39984 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 39988 "hcs12x.cc"
OpClrw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 39992 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 39995 "hcs12x.cc"
)
{
#line 152 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "CLRW";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 40006 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40010 "hcs12x.cc"
OpClrw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40014 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40017 "hcs12x.cc"
)
{
#line 160 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		cpu->memWrite16(addr, 0);

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 40030 "hcs12x.cc"
}

static Operation *DecodeOpClrw_ext(CodeType const& code, uint16_t addr)
{
	return new OpClrw_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 40040 "hcs12x.cc"
OpClrw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 40044 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 40047 "hcs12x.cc"
)
{
#line 172 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 40056 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 40060 "hcs12x.cc"
OpClrw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 40064 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 40067 "hcs12x.cc"
)
{
#line 178 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 40076 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 40080 "hcs12x.cc"
OpClrw_idx::getCycles()
{
#line 185 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 4, 5, 5); }
#line 40085 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40089 "hcs12x.cc"
OpClrw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40093 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40096 "hcs12x.cc"
)
{
#line 187 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "CLRW";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 40108 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40112 "hcs12x.cc"
OpClrw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40116 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40119 "hcs12x.cc"
)
{
#line 196 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		cpu->memWrite16(addr, 0);

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 40132 "hcs12x.cc"
}

static Operation *DecodeOpClrw_idx(CodeType const& code, uint16_t addr)
{
	return new OpClrw_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 40142 "hcs12x.cc"
OpClr_ab::getCycles()
{
#line 208 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 40147 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40151 "hcs12x.cc"
OpClr_ab::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40155 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40158 "hcs12x.cc"
)
{
#line 210 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "CLRA";
			} else {
			mnem = "CLRB";
		}

		sink << mnem;

		return mnem;
	}
#line 40175 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40179 "hcs12x.cc"
OpClr_ab::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40183 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40186 "hcs12x.cc"
)
{
#line 224 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		if (b==0) {
			cpu->setRegA(0);
			} else {
			cpu->setRegB(0);
		}

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 40203 "hcs12x.cc"
}

static Operation *DecodeOpClr_ab(CodeType const& code, uint16_t addr)
{
	return new OpClr_ab(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 40213 "hcs12x.cc"
OpClr_xy::getCycles()
{
#line 240 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 40218 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40222 "hcs12x.cc"
OpClr_xy::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40226 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40229 "hcs12x.cc"
)
{
#line 242 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "CLRX";
			} else {
			mnem = "CLRY";
		}

		sink << mnem;

		return mnem;
	}
#line 40246 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40250 "hcs12x.cc"
OpClr_xy::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40254 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40257 "hcs12x.cc"
)
{
#line 256 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		if (b==0) {
			cpu->setRegX(0);
			} else {
			cpu->setRegY(0);
		}

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 40274 "hcs12x.cc"
}

static Operation *DecodeOpClr_xy(CodeType const& code, uint16_t addr)
{
	return new OpClr_xy(code, addr);
}

// COM: One's complement memory Location
#line 88 "hcs12x.isa"
uint8_t
#line 40285 "hcs12x.cc"
OpCom_ext::getCycles()
{
#line 273 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 40290 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40294 "hcs12x.cc"
OpCom_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40298 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40301 "hcs12x.cc"
)
{
#line 275 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "COM";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 40312 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40316 "hcs12x.cc"
OpCom_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40320 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40323 "hcs12x.cc"
)
{
#line 283 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t val = ~cpu->memRead8(addr);
		cpu->memWrite8(addr, val);

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 40337 "hcs12x.cc"
}

static Operation *DecodeOpCom_ext(CodeType const& code, uint16_t addr)
{
	return new OpCom_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 40347 "hcs12x.cc"
OpCom_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 40351 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 40354 "hcs12x.cc"
)
{
#line 296 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 40363 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 40367 "hcs12x.cc"
OpCom_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 40371 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 40374 "hcs12x.cc"
)
{
#line 302 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 40383 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 40387 "hcs12x.cc"
OpCom_idx::getCycles()
{
#line 309 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 5, 6, 6); }
#line 40392 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40396 "hcs12x.cc"
OpCom_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40400 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40403 "hcs12x.cc"
)
{
#line 311 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "COM";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 40415 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40419 "hcs12x.cc"
OpCom_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40423 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40426 "hcs12x.cc"
)
{
#line 320 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t val = ~cpu->memRead8(addr);
		cpu->memWrite8(addr, val);

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 40441 "hcs12x.cc"
}

static Operation *DecodeOpCom_idx(CodeType const& code, uint16_t addr)
{
	return new OpCom_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 40451 "hcs12x.cc"
OpCom_ab::getCycles()
{
#line 334 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 40456 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40460 "hcs12x.cc"
OpCom_ab::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40464 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40467 "hcs12x.cc"
)
{
#line 336 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "COMA";
			} else {
			mnem = "COMB";
		}

		sink << mnem;

		return mnem;
	}
#line 40484 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40488 "hcs12x.cc"
OpCom_ab::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40492 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40495 "hcs12x.cc"
)
{
#line 350 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint8_t val;
		if (b==0) {
			val = cpu->getRegA();
			} else {
			val = cpu->getRegB();
		}

		val = ~val;

		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 40521 "hcs12x.cc"
}

static Operation *DecodeOpCom_ab(CodeType const& code, uint16_t addr)
{
	return new OpCom_ab(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 40531 "hcs12x.cc"
OpComw_ext::getCycles()
{
#line 375 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 5; }
#line 40536 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40540 "hcs12x.cc"
OpComw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40544 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40547 "hcs12x.cc"
)
{
#line 377 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "COMW";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 40558 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40562 "hcs12x.cc"
OpComw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40566 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40569 "hcs12x.cc"
)
{
#line 385 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint16_t val = ~cpu->memRead16(addr);
		cpu->memWrite16(addr, val);

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 40583 "hcs12x.cc"
}

static Operation *DecodeOpComw_ext(CodeType const& code, uint16_t addr)
{
	return new OpComw_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 40593 "hcs12x.cc"
OpComw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 40597 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 40600 "hcs12x.cc"
)
{
#line 398 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 40609 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 40613 "hcs12x.cc"
OpComw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 40617 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 40620 "hcs12x.cc"
)
{
#line 404 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 40629 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 40633 "hcs12x.cc"
OpComw_idx::getCycles()
{
#line 410 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 40638 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40642 "hcs12x.cc"
OpComw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40646 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40649 "hcs12x.cc"
)
{
#line 412 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "COMW";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 40661 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40665 "hcs12x.cc"
OpComw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40669 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40672 "hcs12x.cc"
)
{
#line 421 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t val = ~cpu->memRead16(addr);
		cpu->memWrite16(addr, val);

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 40687 "hcs12x.cc"
}

static Operation *DecodeOpComw_idx(CodeType const& code, uint16_t addr)
{
	return new OpComw_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 40697 "hcs12x.cc"
OpCom_xy::getCycles()
{
#line 435 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 40702 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40706 "hcs12x.cc"
OpCom_xy::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40710 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40713 "hcs12x.cc"
)
{
#line 437 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "COMX";
			} else {
			mnem = "COMY";
		}

		sink << mnem;

		return mnem;
	}
#line 40730 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40734 "hcs12x.cc"
OpCom_xy::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40738 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40741 "hcs12x.cc"
)
{
#line 451 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint16_t val;
		if (b==0) {
			val = cpu->getRegX();
			} else {
			val = cpu->getRegY();
		}

		val = ~val;

		if (b==0) {
			cpu->setRegX(val);
			} else {
			cpu->setRegY(val);
		}

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 40767 "hcs12x.cc"
}

static Operation *DecodeOpCom_xy(CodeType const& code, uint16_t addr)
{
	return new OpCom_xy(code, addr);
}

// NEG: Two's Complement Negate
#line 88 "hcs12x.isa"
uint8_t
#line 40778 "hcs12x.cc"
OpNeg_ext::getCycles()
{
#line 477 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 40783 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40787 "hcs12x.cc"
OpNeg_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40791 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40794 "hcs12x.cc"
)
{
#line 479 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "NEG";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 40805 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40809 "hcs12x.cc"
OpNeg_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40813 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40816 "hcs12x.cc"
)
{
#line 487 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t result, carry_out, overflow;
		physical_address_t addr = opr16a;
		Sub8(result, carry_out, overflow, 0, cpu->memRead8(addr), 0);
		cpu->memWrite8(addr, result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 40831 "hcs12x.cc"
}

static Operation *DecodeOpNeg_ext(CodeType const& code, uint16_t addr)
{
	return new OpNeg_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 40841 "hcs12x.cc"
OpNeg_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 40845 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 40848 "hcs12x.cc"
)
{
#line 501 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 40857 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 40861 "hcs12x.cc"
OpNeg_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 40865 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 40868 "hcs12x.cc"
)
{
#line 507 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 40877 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 40881 "hcs12x.cc"
OpNeg_idx::getCycles()
{
#line 513 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 5, 6, 6); }
#line 40886 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40890 "hcs12x.cc"
OpNeg_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40894 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40897 "hcs12x.cc"
)
{
#line 515 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "NEG";

		sink << mnem << " 0x";
		xb->disasm(sink);

		return mnem;
	}
#line 40909 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40913 "hcs12x.cc"
OpNeg_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40917 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40920 "hcs12x.cc"
)
{
#line 524 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint8_t result, carry_out, overflow;
		physical_address_t addr = xb->getEAddr(cpu);

		Sub8(result, carry_out, overflow, 0, cpu->memRead8(addr), 0);
		cpu->memWrite8(addr, result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();}

	}
#line 40938 "hcs12x.cc"
}

static Operation *DecodeOpNeg_idx(CodeType const& code, uint16_t addr)
{
	return new OpNeg_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 40948 "hcs12x.cc"
OpNeg_ab::getCycles()
{
#line 541 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 40953 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 40957 "hcs12x.cc"
OpNeg_ab::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 40961 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 40964 "hcs12x.cc"
)
{
#line 543 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "NEGA";
			} else {
			mnem = "NEGB";
		}

		sink << mnem;

		return mnem;
	}
#line 40981 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 40985 "hcs12x.cc"
OpNeg_ab::execute(
#line 67 "hcs12x.isa"
CPU *
#line 40989 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 40992 "hcs12x.cc"
)
{
#line 557 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val, result, carry_out, overflow;

		if (b==0) {
			val = cpu->getRegA();
			} else {
			val = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, 0, val, 0);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 41018 "hcs12x.cc"
}

static Operation *DecodeOpNeg_ab(CodeType const& code, uint16_t addr)
{
	return new OpNeg_ab(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 41028 "hcs12x.cc"
OpNegw_ext::getCycles()
{
#line 582 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 5; }
#line 41033 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41037 "hcs12x.cc"
OpNegw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41041 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41044 "hcs12x.cc"
)
{
#line 584 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "NEGW";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 41055 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41059 "hcs12x.cc"
OpNegw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41063 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41066 "hcs12x.cc"
)
{
#line 592 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		physical_address_t addr = opr16a;

		Sub16(result, carry_out, overflow, 0, cpu->memRead16(addr), 0);
		cpu->memWrite16(addr, result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x8000) == 0x8000) {cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 41084 "hcs12x.cc"
}

static Operation *DecodeOpNegw_ext(CodeType const& code, uint16_t addr)
{
	return new OpNegw_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 41094 "hcs12x.cc"
OpNegw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 41098 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 41101 "hcs12x.cc"
)
{
#line 609 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 41110 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 41114 "hcs12x.cc"
OpNegw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 41118 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 41121 "hcs12x.cc"
)
{
#line 615 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 41130 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 41134 "hcs12x.cc"
OpNegw_idx::getCycles()
{
#line 621 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 41139 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41143 "hcs12x.cc"
OpNegw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41147 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41150 "hcs12x.cc"
)
{
#line 623 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "NEGW";

		sink << mnem << " 0x";
		xb->disasm(sink);

		return mnem;
	}
#line 41162 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41166 "hcs12x.cc"
OpNegw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41170 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41173 "hcs12x.cc"
)
{
#line 632 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint8_t carry_out, overflow;
		uint16_t result;

		physical_address_t addr = xb->getEAddr(cpu);

		Sub16(result, carry_out, overflow, 0, cpu->memRead16(addr), 0);
		cpu->memWrite16(addr, result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x8000) == 0x8000) {cpu->ccr->setN();} else { cpu->ccr->clrN();}

	}
#line 41193 "hcs12x.cc"
}

static Operation *DecodeOpNegw_idx(CodeType const& code, uint16_t addr)
{
	return new OpNegw_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 41203 "hcs12x.cc"
OpNeg_xy::getCycles()
{
#line 651 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 41208 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41212 "hcs12x.cc"
OpNeg_xy::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41216 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41219 "hcs12x.cc"
)
{
#line 653 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "NEGX";
			} else {
			mnem = "NEGY";
		}

		sink << mnem;

		return mnem;
	}
#line 41236 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41240 "hcs12x.cc"
OpNeg_xy::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41244 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41247 "hcs12x.cc"
)
{
#line 667 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t val, result;

		if (b==0) {
			val = cpu->getRegX();
			} else {
			val = cpu->getRegY();
		}

		Sub16(result, carry_out, overflow, 0, val, 0);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x8000) == 0x8000) {cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 41274 "hcs12x.cc"
}

static Operation *DecodeOpNeg_xy(CodeType const& code, uint16_t addr)
{
	return new OpNeg_xy(code, addr);
}

/* ********** Bit Test and Manipulation Instructions ************* */
// BCLR: Clear bit(s) in memory
#line 88 "hcs12x.isa"
uint8_t
#line 41286 "hcs12x.cc"
OpBclr_dir::getCycles()
{
#line 697 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 41291 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41295 "hcs12x.cc"
OpBclr_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41299 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41302 "hcs12x.cc"
)
{
#line 699 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "BCLR";

		sink << mnem << " 0x" << std::hex << opr8a << ", 0x" << std::hex << mm;

		return mnem;
	}
#line 41313 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41317 "hcs12x.cc"
OpBclr_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41321 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41324 "hcs12x.cc"
)
{
#line 707 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint8_t ddVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);
		uint8_t mmCom = ~mm;

		uint8_t val = ddVal & mmCom;

		cpu->memWrite8(opr8a, val, ADDRESS::DIRECT, false);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 41341 "hcs12x.cc"
}

static Operation *DecodeOpBclr_dir(CodeType const& code, uint16_t addr)
{
	return new OpBclr_dir(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 41351 "hcs12x.cc"
OpBclr_ext::getCycles()
{
#line 723 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 41356 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41360 "hcs12x.cc"
OpBclr_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41364 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41367 "hcs12x.cc"
)
{
#line 725 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "BCLR";

		sink << mnem << " 0x" << std::hex << opr16a << ", 0x" << std::hex << mm;

		return mnem;
	}
#line 41378 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41382 "hcs12x.cc"
OpBclr_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41386 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41389 "hcs12x.cc"
)
{
#line 733 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);
		uint8_t mmCom = ~mm;

		uint8_t val = opr16aVal & mmCom;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 41406 "hcs12x.cc"
}

static Operation *DecodeOpBclr_ext(CodeType const& code, uint16_t addr)
{
	return new OpBclr_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 41416 "hcs12x.cc"
OpBclr_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 41420 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 41423 "hcs12x.cc"
)
{
#line 749 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 41432 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 41436 "hcs12x.cc"
OpBclr_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 41440 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 41443 "hcs12x.cc"
)
{
#line 755 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 41452 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 41456 "hcs12x.cc"
OpBclr_idx::getCycles()
{
#line 761 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 6, 0, 0); }
#line 41461 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41465 "hcs12x.cc"
OpBclr_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41469 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41472 "hcs12x.cc"
)
{
#line 763 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "BCLR";

		sink << mnem << " ";
		xb->disasm(sink);
		sink << ", 0x" << std::hex << mm;

		return mnem;
	}
#line 41485 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41489 "hcs12x.cc"
OpBclr_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41493 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41496 "hcs12x.cc"
)
{
#line 773 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);
		uint8_t mmCom = ~mm;

		uint8_t val = xbVal & mmCom;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 41514 "hcs12x.cc"
}

static Operation *DecodeOpBclr_idx(CodeType const& code, uint16_t addr)
{
	return new OpBclr_idx(code, addr);
}

// BITA or BITB: bit test A/B (Logical 'AND' A/B with Memory
#line 88 "hcs12x.isa"
uint8_t
#line 41525 "hcs12x.cc"
OpBit_ab_imm::getCycles()
{
#line 791 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 41530 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41534 "hcs12x.cc"
OpBit_ab_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41538 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41541 "hcs12x.cc"
)
{
#line 793 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "BITA";
			} else {
			mnem = "BITB";
		}
		sink << mnem << " #0x" << std::hex << ii;

		return mnem;
	}
#line 41557 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41561 "hcs12x.cc"
OpBit_ab_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41565 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41568 "hcs12x.cc"
)
{
#line 806 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val;

		if (b==0) {
			val = cpu->getRegA() & ii;
			} else {
			val = cpu->getRegB() & ii;
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 41586 "hcs12x.cc"
}

static Operation *DecodeOpBit_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpBit_ab_imm(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 41596 "hcs12x.cc"
OpBit_ab_dir::getCycles()
{
#line 823 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 3; }
#line 41601 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41605 "hcs12x.cc"
OpBit_ab_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41609 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41612 "hcs12x.cc"
)
{
#line 825 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "BITA";
			} else {
			mnem = "BITB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 41628 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41632 "hcs12x.cc"
OpBit_ab_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41636 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41639 "hcs12x.cc"
)
{
#line 838 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint8_t val;

		if (b==0) {
			val = cpu->getRegA() & cpu->memRead8(opr8a, ADDRESS::DIRECT, false);
			} else {
			val = cpu->getRegB() & cpu->memRead8(opr8a, ADDRESS::DIRECT, false);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 41658 "hcs12x.cc"
}

static Operation *DecodeOpBit_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpBit_ab_dir(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 41668 "hcs12x.cc"
OpBit_ab_ext::getCycles()
{
#line 856 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 3; }
#line 41673 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41677 "hcs12x.cc"
OpBit_ab_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41681 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41684 "hcs12x.cc"
)
{
#line 858 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "BITA";
			} else {
			mnem = "BITB";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 41700 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41704 "hcs12x.cc"
OpBit_ab_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41708 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41711 "hcs12x.cc"
)
{
#line 871 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t val;

		if (b==0) {
			val = cpu->getRegA() & cpu->memRead8(addr);
			} else {
			val = cpu->getRegB() & cpu->memRead8(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 41730 "hcs12x.cc"
}

static Operation *DecodeOpBit_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpBit_ab_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 41740 "hcs12x.cc"
OpBit_ab_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 41744 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 41747 "hcs12x.cc"
)
{
#line 889 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 41756 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 41760 "hcs12x.cc"
OpBit_ab_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 41764 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 41767 "hcs12x.cc"
)
{
#line 895 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 41776 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 41780 "hcs12x.cc"
OpBit_ab_idx::getCycles()
{
#line 901 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 41785 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41789 "hcs12x.cc"
OpBit_ab_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41793 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41796 "hcs12x.cc"
)
{
#line 903 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "BITA";
			} else {
			mnem = "BITB";
		}
		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 41813 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41817 "hcs12x.cc"
OpBit_ab_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41821 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41824 "hcs12x.cc"
)
{
#line 917 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t val;

		if (b==0) {
			val = cpu->getRegA() & cpu->memRead8(addr);
			} else {
			val = cpu->getRegB() & cpu->memRead8(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 41843 "hcs12x.cc"
}

static Operation *DecodeOpBit_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpBit_ab_idx(code, addr);
}

// BITX or BITY: bit test X/Y (Logical 'AND' X/Y with Memory
#line 88 "hcs12x.isa"
uint8_t
#line 41854 "hcs12x.cc"
OpBit_xy_imm::getCycles()
{
#line 936 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 3; }
#line 41859 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41863 "hcs12x.cc"
OpBit_xy_imm::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41867 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41870 "hcs12x.cc"
)
{
#line 938 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "BITX";
			} else {
			mnem = "BITY";
		}

		sink << mnem << " #0x" << std::hex << opr16i;

		return mnem;
	}
#line 41887 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41891 "hcs12x.cc"
OpBit_xy_imm::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41895 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41898 "hcs12x.cc"
)
{
#line 952 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val;

		if (b==0) {
			val = cpu->getRegX() & opr16i;
			} else {
			val = cpu->getRegY() & opr16i;
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 41916 "hcs12x.cc"
}

static Operation *DecodeOpBit_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpBit_xy_imm(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 41926 "hcs12x.cc"
OpBit_xy_dir::getCycles()
{
#line 969 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 41931 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 41935 "hcs12x.cc"
OpBit_xy_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 41939 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 41942 "hcs12x.cc"
)
{
#line 971 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "BITA";
			} else {
			mnem = "BITB";
		}
		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 41958 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 41962 "hcs12x.cc"
OpBit_xy_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 41966 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 41969 "hcs12x.cc"
)
{
#line 984 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint16_t val;

		if (b==0) {
			val = cpu->getRegX() & cpu->memRead16(opr8a, ADDRESS::DIRECT, false);
			} else {
			val = cpu->getRegY() & cpu->memRead16(opr8a, ADDRESS::DIRECT, false);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 41988 "hcs12x.cc"
}

static Operation *DecodeOpBit_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpBit_xy_dir(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 41998 "hcs12x.cc"
OpBit_xy_ext::getCycles()
{
#line 1002 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 42003 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42007 "hcs12x.cc"
OpBit_xy_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42011 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42014 "hcs12x.cc"
)
{
#line 1004 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "BITX";
			} else {
			mnem = "BITY";
		}
		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 42030 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42034 "hcs12x.cc"
OpBit_xy_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42038 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42041 "hcs12x.cc"
)
{
#line 1017 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint16_t val;

		if (b==0) {
			val = cpu->getRegX() & cpu->memRead16(addr);
			} else {
			val = cpu->getRegY() & cpu->memRead16(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 42060 "hcs12x.cc"
}

static Operation *DecodeOpBit_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpBit_xy_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 42070 "hcs12x.cc"
OpBit_xy_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 42074 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 42077 "hcs12x.cc"
)
{
#line 1035 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 42086 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 42090 "hcs12x.cc"
OpBit_xy_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 42094 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 42097 "hcs12x.cc"
)
{
#line 1041 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 42106 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 42110 "hcs12x.cc"
OpBit_xy_idx::getCycles()
{
#line 1047 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 42115 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42119 "hcs12x.cc"
OpBit_xy_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42123 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42126 "hcs12x.cc"
)
{
#line 1049 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem;

		if (b==0) {
			mnem = "BITX";
			} else {
			mnem = "BITY";
		}

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 42144 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42148 "hcs12x.cc"
OpBit_xy_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42152 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42155 "hcs12x.cc"
)
{
#line 1064 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t val;

		if (b==0) {
			val = cpu->getRegX() & cpu->memRead16(addr);
			} else {
			val = cpu->getRegY() & cpu->memRead16(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 42174 "hcs12x.cc"
}

static Operation *DecodeOpBit_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpBit_xy_idx(code, addr);
}

// BSET: Set bits in memory
#line 88 "hcs12x.isa"
uint8_t
#line 42185 "hcs12x.cc"
OpBset_dir::getCycles()
{
#line 1083 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 42190 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42194 "hcs12x.cc"
OpBset_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42198 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42201 "hcs12x.cc"
)
{
#line 1085 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "BSET";

		sink << mnem << " 0x" << std::hex << opr8a << ", 0x" << std::hex << mm;

		return mnem;
	}
#line 42212 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42216 "hcs12x.cc"
OpBset_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42220 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42223 "hcs12x.cc"
)
{
#line 1093 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint8_t ddVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		uint8_t val = ddVal | mm;

		cpu->memWrite8(opr8a, val, ADDRESS::DIRECT, false);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 42239 "hcs12x.cc"
}

static Operation *DecodeOpBset_dir(CodeType const& code, uint16_t addr)
{
	return new OpBset_dir(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 42249 "hcs12x.cc"
OpBset_ext::getCycles()
{
#line 1108 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 42254 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42258 "hcs12x.cc"
OpBset_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42262 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42265 "hcs12x.cc"
)
{
#line 1110 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "BSET";

		sink << mnem << " 0x" << std::hex << opr16a << ", 0x" << std::hex << mm;

		return mnem;
	}
#line 42276 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42280 "hcs12x.cc"
OpBset_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42284 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42287 "hcs12x.cc"
)
{
#line 1118 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		uint8_t val = opr16aVal | mm;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 42303 "hcs12x.cc"
}

static Operation *DecodeOpBset_ext(CodeType const& code, uint16_t addr)
{
	return new OpBset_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 42313 "hcs12x.cc"
OpBset_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 42317 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 42320 "hcs12x.cc"
)
{
#line 1133 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 42329 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 42333 "hcs12x.cc"
OpBset_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 42337 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 42340 "hcs12x.cc"
)
{
#line 1139 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 42349 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 42353 "hcs12x.cc"
OpBset_idx::getCycles()
{
#line 1145 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 6, 0, 0); }
#line 42358 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42362 "hcs12x.cc"
OpBset_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42366 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42369 "hcs12x.cc"
)
{
#line 1147 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "BSET";

		sink << mnem << " ";
		xb->disasm(sink);
		sink << ", 0x" << std::hex << mm;

		return mnem;
	}
#line 42382 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42386 "hcs12x.cc"
OpBset_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42390 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42393 "hcs12x.cc"
)
{
#line 1157 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		uint8_t val = xbVal | mm;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 42410 "hcs12x.cc"
}

static Operation *DecodeOpBset_idx(CodeType const& code, uint16_t addr)
{
	return new OpBset_idx(code, addr);
}

/* ********** Shift and Rotate instructions ********************** */
// LSL: Logical Shift Left
// ASL: Arithmetic Shift Left
#line 88 "hcs12x.isa"
uint8_t
#line 42423 "hcs12x.cc"
OpLsl_ext::getCycles()
{
#line 1177 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 42428 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42432 "hcs12x.cc"
OpLsl_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42436 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42439 "hcs12x.cc"
)
{
#line 1179 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSL";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 42450 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42454 "hcs12x.cc"
OpLsl_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42458 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42461 "hcs12x.cc"
)
{
#line 1187 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t val = cpu->memRead8(addr);

		if ((val & 0x80) == 0x80) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }

		val = val << 1;
		cpu->memWrite8(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 42479 "hcs12x.cc"
}

static Operation *DecodeOpLsl_ext(CodeType const& code, uint16_t addr)
{
	return new OpLsl_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 42489 "hcs12x.cc"
OpLsl_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 42493 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 42496 "hcs12x.cc"
)
{
#line 1204 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 42505 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 42509 "hcs12x.cc"
OpLsl_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 42513 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 42516 "hcs12x.cc"
)
{
#line 1210 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 42525 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 42529 "hcs12x.cc"
OpLsl_idx::getCycles()
{
#line 1216 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 5, 6, 6); }
#line 42534 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42538 "hcs12x.cc"
OpLsl_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42542 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42545 "hcs12x.cc"
)
{
#line 1218 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSL";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 42557 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42561 "hcs12x.cc"
OpLsl_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42565 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42568 "hcs12x.cc"
)
{
#line 1227 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t val = cpu->memRead8(addr);

		if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->memWrite8(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 42587 "hcs12x.cc"
}

static Operation *DecodeOpLsl_idx(CodeType const& code, uint16_t addr)
{
	return new OpLsl_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 42597 "hcs12x.cc"
OpLsla::getCycles()
{
#line 1245 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 42602 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42606 "hcs12x.cc"
OpLsla::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42610 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42613 "hcs12x.cc"
)
{
#line 1247 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSLA";

		sink << mnem;

		return mnem;
	}
#line 42624 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42628 "hcs12x.cc"
OpLsla::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42632 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42635 "hcs12x.cc"
)
{
#line 1255 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegA(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 42652 "hcs12x.cc"
}

static Operation *DecodeOpLsla(CodeType const& code, uint16_t addr)
{
	return new OpLsla(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 42662 "hcs12x.cc"
OpLslb::getCycles()
{
#line 1271 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 42667 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42671 "hcs12x.cc"
OpLslb::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42675 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42678 "hcs12x.cc"
)
{
#line 1273 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSLB";

		sink << mnem;

		return mnem;
	}
#line 42689 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42693 "hcs12x.cc"
OpLslb::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42697 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42700 "hcs12x.cc"
)
{
#line 1281 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegB(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 42717 "hcs12x.cc"
}

static Operation *DecodeOpLslb(CodeType const& code, uint16_t addr)
{
	return new OpLslb(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 42727 "hcs12x.cc"
OpLsld::getCycles()
{
#line 1297 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 42732 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42736 "hcs12x.cc"
OpLsld::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42740 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42743 "hcs12x.cc"
)
{
#line 1299 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSLD";

		sink << mnem;

		return mnem;
	}
#line 42754 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42758 "hcs12x.cc"
OpLsld::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42762 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42765 "hcs12x.cc"
)
{
#line 1307 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegD();

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegD(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 42782 "hcs12x.cc"
}

static Operation *DecodeOpLsld(CodeType const& code, uint16_t addr)
{
	return new OpLsld(code, addr);
}

// LSLW: Logical Shift Left
// ASLW: Arithmetic Shift Left
#line 88 "hcs12x.isa"
uint8_t
#line 42794 "hcs12x.cc"
OpLslw_ext::getCycles()
{
#line 1326 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 5; }
#line 42799 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42803 "hcs12x.cc"
OpLslw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42807 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42810 "hcs12x.cc"
)
{
#line 1328 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSLW";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 42821 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42825 "hcs12x.cc"
OpLslw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42829 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42832 "hcs12x.cc"
)
{
#line 1336 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint16_t val = cpu->memRead16(addr);

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }

		val = val << 1;
		cpu->memWrite16(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 42850 "hcs12x.cc"
}

static Operation *DecodeOpLslw_ext(CodeType const& code, uint16_t addr)
{
	return new OpLslw_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 42860 "hcs12x.cc"
OpLslw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 42864 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 42867 "hcs12x.cc"
)
{
#line 1353 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 42876 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 42880 "hcs12x.cc"
OpLslw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 42884 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 42887 "hcs12x.cc"
)
{
#line 1359 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 42896 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 42900 "hcs12x.cc"
OpLslw_idx::getCycles()
{
#line 1365 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 42905 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42909 "hcs12x.cc"
OpLslw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42913 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42916 "hcs12x.cc"
)
{
#line 1367 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSLW";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 42928 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42932 "hcs12x.cc"
OpLslw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 42936 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 42939 "hcs12x.cc"
)
{
#line 1376 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t val = cpu->memRead16(addr);

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->memWrite16(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 42958 "hcs12x.cc"
}

static Operation *DecodeOpLslw_idx(CodeType const& code, uint16_t addr)
{
	return new OpLslw_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 42968 "hcs12x.cc"
OpLslx::getCycles()
{
#line 1394 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 42973 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 42977 "hcs12x.cc"
OpLslx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 42981 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 42984 "hcs12x.cc"
)
{
#line 1396 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSLX";

		sink << mnem;

		return mnem;
	}
#line 42995 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 42999 "hcs12x.cc"
OpLslx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43003 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43006 "hcs12x.cc"
)
{
#line 1404 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegX(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43023 "hcs12x.cc"
}

static Operation *DecodeOpLslx(CodeType const& code, uint16_t addr)
{
	return new OpLslx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 43033 "hcs12x.cc"
OpLsly::getCycles()
{
#line 1420 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 43038 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43042 "hcs12x.cc"
OpLsly::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43046 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43049 "hcs12x.cc"
)
{
#line 1422 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSLY";

		sink << mnem;

		return mnem;
	}
#line 43060 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43064 "hcs12x.cc"
OpLsly::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43068 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43071 "hcs12x.cc"
)
{
#line 1430 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegY(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43088 "hcs12x.cc"
}

static Operation *DecodeOpLsly(CodeType const& code, uint16_t addr)
{
	return new OpLsly(code, addr);
}

// ROL: Rotate Memory/Accumulator Left through carry
#line 88 "hcs12x.isa"
uint8_t
#line 43099 "hcs12x.cc"
OpRol_ext::getCycles()
{
#line 1447 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 43104 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43108 "hcs12x.cc"
OpRol_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43112 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43115 "hcs12x.cc"
)
{
#line 1449 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROL";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 43126 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43130 "hcs12x.cc"
OpRol_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43134 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43137 "hcs12x.cc"
)
{
#line 1457 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t val = cpu->memRead8(addr);

		uint8_t carry = 0;
		if ((val & 0x80) == 0x80) { carry = 1; }
		val = (val << 1) | carry;
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43156 "hcs12x.cc"
}

static Operation *DecodeOpRol_ext(CodeType const& code, uint16_t addr)
{
	return new OpRol_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 43166 "hcs12x.cc"
OpRol_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 43170 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 43173 "hcs12x.cc"
)
{
#line 1475 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 43182 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 43186 "hcs12x.cc"
OpRol_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 43190 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 43193 "hcs12x.cc"
)
{
#line 1481 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 43202 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 43206 "hcs12x.cc"
OpRol_idx::getCycles()
{
#line 1487 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 5, 6, 6); }
#line 43211 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43215 "hcs12x.cc"
OpRol_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43219 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43222 "hcs12x.cc"
)
{
#line 1489 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROL";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 43234 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43238 "hcs12x.cc"
OpRol_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43242 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43245 "hcs12x.cc"
)
{
#line 1498 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t val = cpu->memRead8(addr);

		uint8_t carry = 0;
		if ((val & 0x80) == 0x80) { carry = 1; }
		val = (val << 1) | carry;
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43265 "hcs12x.cc"
}

static Operation *DecodeOpRol_idx(CodeType const& code, uint16_t addr)
{
	return new OpRol_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 43275 "hcs12x.cc"
OpRola::getCycles()
{
#line 1517 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 43280 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43284 "hcs12x.cc"
OpRola::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43288 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43291 "hcs12x.cc"
)
{
#line 1519 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROLA";

		sink << mnem;

		return mnem;
	}
#line 43302 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43306 "hcs12x.cc"
OpRola::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43310 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43313 "hcs12x.cc"
)
{
#line 1527 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		uint8_t carry = 0;
		if ((val & 0x80) == 0x80) { carry = 1; }
		val = (val << 1) | carry;
		cpu->setRegA(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43331 "hcs12x.cc"
}

static Operation *DecodeOpRola(CodeType const& code, uint16_t addr)
{
	return new OpRola(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 43341 "hcs12x.cc"
OpRolb::getCycles()
{
#line 1544 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 43346 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43350 "hcs12x.cc"
OpRolb::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43354 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43357 "hcs12x.cc"
)
{
#line 1546 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROLB";

		sink << mnem;

		return mnem;
	}
#line 43368 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43372 "hcs12x.cc"
OpRolb::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43376 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43379 "hcs12x.cc"
)
{
#line 1554 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		uint8_t carry = 0;
		if ((val & 0x80) == 0x80) { carry = 1; }
		val = (val << 1) | carry;
		cpu->setRegB(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43397 "hcs12x.cc"
}

static Operation *DecodeOpRolb(CodeType const& code, uint16_t addr)
{
	return new OpRolb(code, addr);
}

// ROLW: Rotate word Memory/Accumulator Left through carry
#line 88 "hcs12x.isa"
uint8_t
#line 43408 "hcs12x.cc"
OpRolw_ext::getCycles()
{
#line 1573 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 5; }
#line 43413 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43417 "hcs12x.cc"
OpRolw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43421 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43424 "hcs12x.cc"
)
{
#line 1575 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROLW";

		sink <<  mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 43435 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43439 "hcs12x.cc"
OpRolw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43443 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43446 "hcs12x.cc"
)
{
#line 1583 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint16_t val = cpu->memRead16(addr);

		uint16_t carry = 0;
		if ((val & 0x8000) == 0x8000) { carry = 1; }
		val = (val << 1) | carry;
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43465 "hcs12x.cc"
}

static Operation *DecodeOpRolw_ext(CodeType const& code, uint16_t addr)
{
	return new OpRolw_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 43475 "hcs12x.cc"
OpRolw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 43479 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 43482 "hcs12x.cc"
)
{
#line 1601 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 43491 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 43495 "hcs12x.cc"
OpRolw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 43499 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 43502 "hcs12x.cc"
)
{
#line 1607 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 43511 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 43515 "hcs12x.cc"
OpRolw_idx::getCycles()
{
#line 1613 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 43520 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43524 "hcs12x.cc"
OpRolw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43528 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43531 "hcs12x.cc"
)
{
#line 1615 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROLW";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 43543 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43547 "hcs12x.cc"
OpRolw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43551 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43554 "hcs12x.cc"
)
{
#line 1624 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t val = cpu->memRead16(addr);

		uint16_t carry = 0;
		if ((val & 0x8000) == 0x8000) { carry = 1; }
		val = (val << 1) | carry;
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43574 "hcs12x.cc"
}

static Operation *DecodeOpRolw_idx(CodeType const& code, uint16_t addr)
{
	return new OpRolw_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 43584 "hcs12x.cc"
OpRolx::getCycles()
{
#line 1643 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 43589 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43593 "hcs12x.cc"
OpRolx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43597 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43600 "hcs12x.cc"
)
{
#line 1645 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROLX";

		sink << mnem;

		return mnem;
	}
#line 43611 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43615 "hcs12x.cc"
OpRolx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43619 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43622 "hcs12x.cc"
)
{
#line 1653 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		uint16_t carry = 0;
		if ((val & 0x8000) == 0x8000) { carry = 1; }
		val = (val << 1) | carry;
		cpu->setRegX(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43640 "hcs12x.cc"
}

static Operation *DecodeOpRolx(CodeType const& code, uint16_t addr)
{
	return new OpRolx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 43650 "hcs12x.cc"
OpRoly::getCycles()
{
#line 1670 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 43655 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43659 "hcs12x.cc"
OpRoly::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43663 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43666 "hcs12x.cc"
)
{
#line 1672 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROLY";

		sink << mnem;

		return mnem;
	}
#line 43677 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43681 "hcs12x.cc"
OpRoly::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43685 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43688 "hcs12x.cc"
)
{
#line 1680 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		uint16_t carry = 0;
		if ((val & 0x8000) == 0x8000) { carry = 1; }
		val = (val << 1) | carry;
		cpu->setRegY(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43706 "hcs12x.cc"
}

static Operation *DecodeOpRoly(CodeType const& code, uint16_t addr)
{
	return new OpRoly(code, addr);
}

// LSR: Logical Shift Right
#line 88 "hcs12x.isa"
uint8_t
#line 43717 "hcs12x.cc"
OpLsr_ext::getCycles()
{
#line 1698 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 43722 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43726 "hcs12x.cc"
OpLsr_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43730 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43733 "hcs12x.cc"
)
{
#line 1700 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSR";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 43744 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43748 "hcs12x.cc"
OpLsr_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43752 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43755 "hcs12x.cc"
)
{
#line 1708 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t val = cpu->memRead8(addr);

		if ((val & 0x01) == 0x01) { cpu->ccr->setC();}	else  { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->memWrite8(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43773 "hcs12x.cc"
}

static Operation *DecodeOpLsr_ext(CodeType const& code, uint16_t addr)
{
	return new OpLsr_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 43783 "hcs12x.cc"
OpLsr_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 43787 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 43790 "hcs12x.cc"
)
{
#line 1725 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 43799 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 43803 "hcs12x.cc"
OpLsr_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 43807 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 43810 "hcs12x.cc"
)
{
#line 1731 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 43819 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 43823 "hcs12x.cc"
OpLsr_idx::getCycles()
{
#line 1737 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 5, 6, 6); }
#line 43828 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43832 "hcs12x.cc"
OpLsr_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43836 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43839 "hcs12x.cc"
)
{
#line 1739 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSR";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 43851 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43855 "hcs12x.cc"
OpLsr_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43859 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43862 "hcs12x.cc"
)
{
#line 1748 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t val = cpu->memRead8(addr);

		if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->memWrite8(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43881 "hcs12x.cc"
}

static Operation *DecodeOpLsr_idx(CodeType const& code, uint16_t addr)
{
	return new OpLsr_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 43891 "hcs12x.cc"
OpLsra::getCycles()
{
#line 1766 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 43896 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43900 "hcs12x.cc"
OpLsra::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43904 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43907 "hcs12x.cc"
)
{
#line 1768 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSRA";

		sink << mnem;

		return mnem;
	}
#line 43918 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43922 "hcs12x.cc"
OpLsra::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43926 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43929 "hcs12x.cc"
)
{
#line 1776 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegA(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 43946 "hcs12x.cc"
}

static Operation *DecodeOpLsra(CodeType const& code, uint16_t addr)
{
	return new OpLsra(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 43956 "hcs12x.cc"
OpLsrb::getCycles()
{
#line 1792 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 43961 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 43965 "hcs12x.cc"
OpLsrb::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 43969 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 43972 "hcs12x.cc"
)
{
#line 1794 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSRB";

		sink << mnem;

		return mnem;
	}
#line 43983 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 43987 "hcs12x.cc"
OpLsrb::execute(
#line 67 "hcs12x.isa"
CPU *
#line 43991 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 43994 "hcs12x.cc"
)
{
#line 1802 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegB(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44011 "hcs12x.cc"
}

static Operation *DecodeOpLsrb(CodeType const& code, uint16_t addr)
{
	return new OpLsrb(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 44021 "hcs12x.cc"
OpLsrd::getCycles()
{
#line 1818 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 44026 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44030 "hcs12x.cc"
OpLsrd::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44034 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44037 "hcs12x.cc"
)
{
#line 1820 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSRD";

		sink << mnem;

		return mnem;
	}
#line 44048 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44052 "hcs12x.cc"
OpLsrd::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44056 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44059 "hcs12x.cc"
)
{
#line 1828 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegD();

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();}	else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegD(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44076 "hcs12x.cc"
}

static Operation *DecodeOpLsrd(CodeType const& code, uint16_t addr)
{
	return new OpLsrd(code, addr);
}

// LSRW: Logical Shift Right word
#line 88 "hcs12x.isa"
uint8_t
#line 44087 "hcs12x.cc"
OpLsrw_ext::getCycles()
{
#line 1845 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 5; }
#line 44092 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44096 "hcs12x.cc"
OpLsrw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44100 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44103 "hcs12x.cc"
)
{
#line 1847 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSRW";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 44114 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44118 "hcs12x.cc"
OpLsrw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44122 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44125 "hcs12x.cc"
)
{
#line 1855 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint16_t val = cpu->memRead16(addr);

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();}	else  { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->memWrite16(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44143 "hcs12x.cc"
}

static Operation *DecodeOpLsrw_ext(CodeType const& code, uint16_t addr)
{
	return new OpLsrw_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 44153 "hcs12x.cc"
OpLsrw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 44157 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 44160 "hcs12x.cc"
)
{
#line 1872 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 44169 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 44173 "hcs12x.cc"
OpLsrw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 44177 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 44180 "hcs12x.cc"
)
{
#line 1878 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 44189 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 44193 "hcs12x.cc"
OpLsrw_idx::getCycles()
{
#line 1884 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 44198 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44202 "hcs12x.cc"
OpLsrw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44206 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44209 "hcs12x.cc"
)
{
#line 1886 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSRW";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 44221 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44225 "hcs12x.cc"
OpLsrw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44229 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44232 "hcs12x.cc"
)
{
#line 1895 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t val = cpu->memRead16(addr);

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->memWrite16(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44251 "hcs12x.cc"
}

static Operation *DecodeOpLsrw_idx(CodeType const& code, uint16_t addr)
{
	return new OpLsrw_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 44261 "hcs12x.cc"
OpLsrx::getCycles()
{
#line 1913 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 44266 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44270 "hcs12x.cc"
OpLsrx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44274 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44277 "hcs12x.cc"
)
{
#line 1915 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSRX";

		sink << mnem;

		return mnem;
	}
#line 44288 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44292 "hcs12x.cc"
OpLsrx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44296 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44299 "hcs12x.cc"
)
{
#line 1923 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegX(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44316 "hcs12x.cc"
}

static Operation *DecodeOpLsrx(CodeType const& code, uint16_t addr)
{
	return new OpLsrx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 44326 "hcs12x.cc"
OpLsry::getCycles()
{
#line 1939 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 44331 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44335 "hcs12x.cc"
OpLsry::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44339 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44342 "hcs12x.cc"
)
{
#line 1941 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "LSRY";

		sink << mnem;

		return mnem;
	}
#line 44353 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44357 "hcs12x.cc"
OpLsry::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44361 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44364 "hcs12x.cc"
)
{
#line 1949 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegY(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44381 "hcs12x.cc"
}

static Operation *DecodeOpLsry(CodeType const& code, uint16_t addr)
{
	return new OpLsry(code, addr);
}

// ROR: Rotate Memory/Accumulator Right through Carry
#line 88 "hcs12x.isa"
uint8_t
#line 44392 "hcs12x.cc"
OpRor_ext::getCycles()
{
#line 1966 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 44397 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44401 "hcs12x.cc"
OpRor_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44405 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44408 "hcs12x.cc"
)
{
#line 1968 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROR";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 44419 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44423 "hcs12x.cc"
OpRor_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44427 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44430 "hcs12x.cc"
)
{
#line 1976 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t val = cpu->memRead8(addr);

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }
		val = (carry << 7) | (val >> 1);
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44449 "hcs12x.cc"
}

static Operation *DecodeOpRor_ext(CodeType const& code, uint16_t addr)
{
	return new OpRor_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 44459 "hcs12x.cc"
OpRor_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 44463 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 44466 "hcs12x.cc"
)
{
#line 1994 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 44475 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 44479 "hcs12x.cc"
OpRor_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 44483 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 44486 "hcs12x.cc"
)
{
#line 2000 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 44495 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 44499 "hcs12x.cc"
OpRor_idx::getCycles()
{
#line 2006 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 5, 6, 6); }
#line 44504 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44508 "hcs12x.cc"
OpRor_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44512 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44515 "hcs12x.cc"
)
{
#line 2008 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ROR";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 44527 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44531 "hcs12x.cc"
OpRor_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44535 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44538 "hcs12x.cc"
)
{
#line 2017 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t val = cpu->memRead8(addr);

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }
		val = (carry << 7) | (val >> 1);
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44558 "hcs12x.cc"
}

static Operation *DecodeOpRor_idx(CodeType const& code, uint16_t addr)
{
	return new OpRor_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 44568 "hcs12x.cc"
OpRora::getCycles()
{
#line 2036 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 44573 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44577 "hcs12x.cc"
OpRora::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44581 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44584 "hcs12x.cc"
)
{
#line 2038 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "RORA";

		sink << mnem;

		return mnem;
	}
#line 44595 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44599 "hcs12x.cc"
OpRora::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44603 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44606 "hcs12x.cc"
)
{
#line 2046 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }
		val = (carry << 7) | (val >> 1);
		cpu->setRegA(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44624 "hcs12x.cc"
}

static Operation *DecodeOpRora(CodeType const& code, uint16_t addr)
{
	return new OpRora(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 44634 "hcs12x.cc"
OpRorb::getCycles()
{
#line 2063 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 44639 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44643 "hcs12x.cc"
OpRorb::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44647 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44650 "hcs12x.cc"
)
{
#line 2065 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "RORB";

		sink << mnem;

		return mnem;
	}
#line 44661 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44665 "hcs12x.cc"
OpRorb::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44669 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44672 "hcs12x.cc"
)
{
#line 2073 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }
		val = (carry << 7) | (val >> 1);
		cpu->setRegB(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44690 "hcs12x.cc"
}

static Operation *DecodeOpRorb(CodeType const& code, uint16_t addr)
{
	return new OpRorb(code, addr);
}

// RORW: Rotate word Memory/Accumulator Right through Carry
#line 88 "hcs12x.isa"
uint8_t
#line 44701 "hcs12x.cc"
OpRorw_ext::getCycles()
{
#line 2092 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 5; }
#line 44706 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44710 "hcs12x.cc"
OpRorw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44714 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44717 "hcs12x.cc"
)
{
#line 2094 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "RORW";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 44728 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44732 "hcs12x.cc"
OpRorw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44736 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44739 "hcs12x.cc"
)
{
#line 2102 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint16_t val = cpu->memRead16(addr);

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }
		val = (carry << 15) | (val >> 1);
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44758 "hcs12x.cc"
}

static Operation *DecodeOpRorw_ext(CodeType const& code, uint16_t addr)
{
	return new OpRorw_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 44768 "hcs12x.cc"
OpRorw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 44772 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 44775 "hcs12x.cc"
)
{
#line 2120 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 44784 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 44788 "hcs12x.cc"
OpRorw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 44792 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 44795 "hcs12x.cc"
)
{
#line 2126 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 44804 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 44808 "hcs12x.cc"
OpRorw_idx::getCycles()
{
#line 2132 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 44813 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44817 "hcs12x.cc"
OpRorw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44821 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44824 "hcs12x.cc"
)
{
#line 2134 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "RORW";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 44836 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44840 "hcs12x.cc"
OpRorw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44844 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44847 "hcs12x.cc"
)
{
#line 2143 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t val = cpu->memRead16(addr);

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }
		val = (carry << 15) | (val >> 1);
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44867 "hcs12x.cc"
}

static Operation *DecodeOpRorw_idx(CodeType const& code, uint16_t addr)
{
	return new OpRorw_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 44877 "hcs12x.cc"
OpRorx::getCycles()
{
#line 2162 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 44882 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44886 "hcs12x.cc"
OpRorx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44890 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44893 "hcs12x.cc"
)
{
#line 2164 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "RORX";

		sink << mnem;

		return mnem;
	}
#line 44904 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44908 "hcs12x.cc"
OpRorx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44912 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44915 "hcs12x.cc"
)
{
#line 2172 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }
		val = (carry << 15) | (val >> 1);
		cpu->setRegX(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44933 "hcs12x.cc"
}

static Operation *DecodeOpRorx(CodeType const& code, uint16_t addr)
{
	return new OpRorx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 44943 "hcs12x.cc"
OpRory::getCycles()
{
#line 2189 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 44948 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 44952 "hcs12x.cc"
OpRory::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 44956 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 44959 "hcs12x.cc"
)
{
#line 2191 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "RORY";

		sink << mnem;

		return mnem;
	}
#line 44970 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 44974 "hcs12x.cc"
OpRory::execute(
#line 67 "hcs12x.isa"
CPU *
#line 44978 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 44981 "hcs12x.cc"
)
{
#line 2199 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }
		val = (carry << 15) | (val >> 1);
		cpu->setRegY(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 44999 "hcs12x.cc"
}

static Operation *DecodeOpRory(CodeType const& code, uint16_t addr)
{
	return new OpRory(code, addr);
}

// ASR: Arithmetic Shift Right
#line 88 "hcs12x.isa"
uint8_t
#line 45010 "hcs12x.cc"
OpAsr_ext::getCycles()
{
#line 2217 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 4; }
#line 45015 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45019 "hcs12x.cc"
OpAsr_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45023 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45026 "hcs12x.cc"
)
{
#line 2219 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ASR";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 45037 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45041 "hcs12x.cc"
OpAsr_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45045 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45048 "hcs12x.cc"
)
{
#line 2227 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t val = cpu->memRead8(addr);

		uint8_t msb = val & 0x80;

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 45070 "hcs12x.cc"
}

static Operation *DecodeOpAsr_ext(CodeType const& code, uint16_t addr)
{
	return new OpAsr_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 45080 "hcs12x.cc"
OpAsr_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 45084 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 45087 "hcs12x.cc"
)
{
#line 2248 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 45096 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 45100 "hcs12x.cc"
OpAsr_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 45104 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 45107 "hcs12x.cc"
)
{
#line 2254 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 45116 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 45120 "hcs12x.cc"
OpAsr_idx::getCycles()
{
#line 2260 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 4, 5, 6, 6); }
#line 45125 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45129 "hcs12x.cc"
OpAsr_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45133 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45136 "hcs12x.cc"
)
{
#line 2262 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ASR";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 45148 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45152 "hcs12x.cc"
OpAsr_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45156 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45159 "hcs12x.cc"
)
{
#line 2271 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t val = cpu->memRead8(addr);

		uint8_t msb = val & 0x80;

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 45182 "hcs12x.cc"
}

static Operation *DecodeOpAsr_idx(CodeType const& code, uint16_t addr)
{
	return new OpAsr_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 45192 "hcs12x.cc"
OpAsra::getCycles()
{
#line 2293 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 45197 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45201 "hcs12x.cc"
OpAsra::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45205 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45208 "hcs12x.cc"
)
{
#line 2295 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ASRA";

		sink << mnem;

		return mnem;
	}
#line 45219 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45223 "hcs12x.cc"
OpAsra::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45227 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45230 "hcs12x.cc"
)
{
#line 2303 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		uint8_t msb = val & 0x80;

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->setRegA(val);

		if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 45251 "hcs12x.cc"
}

static Operation *DecodeOpAsra(CodeType const& code, uint16_t addr)
{
	return new OpAsra(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 45261 "hcs12x.cc"
OpAsrb::getCycles()
{
#line 2323 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 1; }
#line 45266 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45270 "hcs12x.cc"
OpAsrb::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45274 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45277 "hcs12x.cc"
)
{
#line 2325 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ASRB";

		sink << mnem;

		return mnem;
	}
#line 45288 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45292 "hcs12x.cc"
OpAsrb::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45296 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45299 "hcs12x.cc"
)
{
#line 2333 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		uint8_t msb = val & 0x80;

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->setRegB(val);

		if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 45320 "hcs12x.cc"
}

static Operation *DecodeOpAsrb(CodeType const& code, uint16_t addr)
{
	return new OpAsrb(code, addr);
}

// ASRW: Arithmetic Shift Right word
#line 88 "hcs12x.isa"
uint8_t
#line 45331 "hcs12x.cc"
OpAsrw_ext::getCycles()
{
#line 2354 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 5; }
#line 45336 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45340 "hcs12x.cc"
OpAsrw_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45344 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45347 "hcs12x.cc"
)
{
#line 2356 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ASRW";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 45358 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45362 "hcs12x.cc"
OpAsrw_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45366 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45369 "hcs12x.cc"
)
{
#line 2364 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = opr16a;
		uint16_t val = cpu->memRead16(addr);

		uint16_t msb = val & 0x8000;

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 45391 "hcs12x.cc"
}

static Operation *DecodeOpAsrw_ext(CodeType const& code, uint16_t addr)
{
	return new OpAsrw_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 45401 "hcs12x.cc"
OpAsrw_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 45405 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 45408 "hcs12x.cc"
)
{
#line 2385 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 45417 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 45421 "hcs12x.cc"
OpAsrw_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 45425 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 45428 "hcs12x.cc"
)
{
#line 2391 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 45437 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 45441 "hcs12x.cc"
OpAsrw_idx::getCycles()
{
#line 2397 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 7, 7); }
#line 45446 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45450 "hcs12x.cc"
OpAsrw_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45454 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45457 "hcs12x.cc"
)
{
#line 2399 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem= "ASRW";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 45469 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45473 "hcs12x.cc"
OpAsrw_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45477 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45480 "hcs12x.cc"
)
{
#line 2408 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint16_t val = cpu->memRead16(addr);

		uint16_t msb = val & 0x8000;

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 45503 "hcs12x.cc"
}

static Operation *DecodeOpAsrw_idx(CodeType const& code, uint16_t addr)
{
	return new OpAsrw_idx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 45513 "hcs12x.cc"
OpAsrx::getCycles()
{
#line 2430 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 45518 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45522 "hcs12x.cc"
OpAsrx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45526 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45529 "hcs12x.cc"
)
{
#line 2432 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ASRX";

		sink << mnem;

		return mnem;
	}
#line 45540 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45544 "hcs12x.cc"
OpAsrx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45548 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45551 "hcs12x.cc"
)
{
#line 2440 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		uint16_t msb = val & 0x8000;

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->setRegX(val);

		if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 45572 "hcs12x.cc"
}

static Operation *DecodeOpAsrx(CodeType const& code, uint16_t addr)
{
	return new OpAsrx(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 45582 "hcs12x.cc"
OpAsry::getCycles()
{
#line 2460 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 2; }
#line 45587 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45591 "hcs12x.cc"
OpAsry::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45595 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45598 "hcs12x.cc"
)
{
#line 2462 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "ASRY";

		sink << mnem;

		return mnem;
	}
#line 45609 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45613 "hcs12x.cc"
OpAsry::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45617 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45620 "hcs12x.cc"
)
{
#line 2470 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		uint16_t msb = val & 0x8000;

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->setRegY(val);

		if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 45641 "hcs12x.cc"
}

static Operation *DecodeOpAsry(CodeType const& code, uint16_t addr)
{
	return new OpAsry(code, addr);
}

// BTAS: Bit(s) Test and Set in Memory
#line 88 "hcs12x.isa"
uint8_t
#line 45652 "hcs12x.cc"
OpBtas_dir::getCycles()
{
#line 2492 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 5; }
#line 45657 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45661 "hcs12x.cc"
OpBtas_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45665 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45668 "hcs12x.cc"
)
{
#line 2494 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "BTAS";

		sink << mnem << " 0x" << std::hex << opr8a << ", 0x" << std::hex << msk8;

		return mnem;
	}
#line 45679 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45683 "hcs12x.cc"
OpBtas_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45687 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45690 "hcs12x.cc"
)
{
#line 2502 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		/*
		If (M) & (Mask) = 0, then set Z, else clear Z
		(M) | (Mask) => M

		N: Set if MSB of test is set; cleared otherwise
		Z: Set if test is 0x00; cleared otherwise
		V: 0; cleared
		*/

		uint8_t opr8aVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		uint8_t test = opr8aVal & msk8;
		if (test == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((test & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
		cpu->ccr->clrV();

		cpu->memWrite8(opr8a, opr8aVal | msk8, ADDRESS::DIRECT, false);
	}
#line 45713 "hcs12x.cc"
}

static Operation *DecodeOpBtas_dir(CodeType const& code, uint16_t addr)
{
	return new OpBtas_dir(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 45723 "hcs12x.cc"
OpBtas_ext::getCycles()
{
#line 2524 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return 5; }
#line 45728 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45732 "hcs12x.cc"
OpBtas_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45736 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45739 "hcs12x.cc"
)
{
#line 2526 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "BTAS";

		sink << mnem << " 0x" << std::hex << opr16a << ", 0x" << std::hex << msk8;

		return mnem;
	}
#line 45750 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45754 "hcs12x.cc"
OpBtas_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45758 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45761 "hcs12x.cc"
)
{
#line 2534 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		uint8_t test = opr16aVal & msk8;
		if (test == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((test & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
		cpu->ccr->clrV();

		cpu->memWrite8(addr, opr16aVal | msk8);
	}
#line 45777 "hcs12x.cc"
}

static Operation *DecodeOpBtas_ext(CodeType const& code, uint16_t addr)
{
	return new OpBtas_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 45787 "hcs12x.cc"
OpBtas_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 45791 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 45794 "hcs12x.cc"
)
{
#line 2549 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 45803 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 45807 "hcs12x.cc"
OpBtas_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 45811 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 45814 "hcs12x.cc"
)
{
#line 2555 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 45823 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 45827 "hcs12x.cc"
OpBtas_idx::getCycles()
{
#line 2561 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 5, 5, 7, 0, 0); }
#line 45832 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45836 "hcs12x.cc"
OpBtas_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45840 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45843 "hcs12x.cc"
)
{
#line 2563 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		string mnem = "BTAS";

		sink << mnem << " ";
		xb->disasm(sink);
		sink << ", 0x" << std::hex << msk8;

		return mnem;
	}
#line 45856 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45860 "hcs12x.cc"
OpBtas_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45864 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45867 "hcs12x.cc"
)
{
#line 2573 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		uint8_t test = xbVal & msk8;
		if (test == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((test & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
		cpu->ccr->clrV();

		cpu->memWrite8(addr, xbVal | msk8);
	}
#line 45883 "hcs12x.cc"
}

static Operation *DecodeOpBtas_idx(CodeType const& code, uint16_t addr)
{
	return new OpBtas_idx(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// EMUL: 16 by 16 Bit Multiply (unsigned) (D) x (Y) => Y:D
#line 88 "hcs12x.isa"
uint8_t
#line 45927 "hcs12x.cc"
OpEmul::getCycles()
{
#line 39 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{ return 1; }
#line 45932 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45936 "hcs12x.cc"
OpEmul::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 45940 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 45943 "hcs12x.cc"
)
{
#line 41 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		string mnem = "EMUL";

		sink << mnem;
		return mnem;
	}
#line 45953 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 45957 "hcs12x.cc"
OpEmul::execute(
#line 67 "hcs12x.isa"
CPU *
#line 45961 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 45964 "hcs12x.cc"
)
{
#line 48 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		uint32_t result = (uint32_t) cpu->getRegD() * cpu->getRegY();

		cpu->setRegY(result >> 16);
		cpu->setRegD((uint16_t) result);

		if ((result & 0x00008000) == 0x00008000) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((result & 0x80000000) == 0x80000000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 45978 "hcs12x.cc"
}

static Operation *DecodeOpEmul(CodeType const& code, uint16_t addr)
{
	return new OpEmul(code, addr);
}

// EMULS: 16 by 16 Bit Multiply (signed) (D) x (Y) => Y:D
#line 88 "hcs12x.isa"
uint8_t
#line 45989 "hcs12x.cc"
OpEmuls::getCycles()
{
#line 62 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{ return 3; }
#line 45994 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 45998 "hcs12x.cc"
OpEmuls::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46002 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46005 "hcs12x.cc"
)
{
#line 64 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		string mnem = "EMULS";

		sink << mnem;
		return mnem;
	}
#line 46015 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46019 "hcs12x.cc"
OpEmuls::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46023 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46026 "hcs12x.cc"
)
{
#line 71 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		uint32_t result = (uint32_t) cpu->getRegD() * cpu->getRegY();

		cpu->setRegY((uint16_t) (result >> 16));
		cpu->setRegD((uint16_t) result);

		/*
		* C: Set if bit 15 of the result is set; cleared otherwise
		*/
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }

		/*
		* Z: Set if result is 0x00000000; cleared otherwise
		*/
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* N: Set if the MSB of the result is set; cleared otherwise
		*/
		if ((result & 0x80000000) == 0x80000000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }


	}
#line 46053 "hcs12x.cc"
}

static Operation *DecodeOpEmuls(CodeType const& code, uint16_t addr)
{
	return new OpEmuls(code, addr);
}

// MUL: 8 by 8 Bit Multiply (unsigned) (A) x (B) => A:B
#line 88 "hcs12x.isa"
uint8_t
#line 46064 "hcs12x.cc"
OpMul::getCycles()
{
#line 98 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{ return 1; }
#line 46069 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46073 "hcs12x.cc"
OpMul::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46077 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46080 "hcs12x.cc"
)
{
#line 100 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		string mnem = "MUL";

		sink << mnem;
		return mnem;
	}
#line 46090 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46094 "hcs12x.cc"
OpMul::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46098 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46101 "hcs12x.cc"
)
{
#line 107 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		uint16_t result = cpu->getRegA() * cpu->getRegB();

		cpu->setRegD(result);

		if ((result & 0x0080) == 0x0080) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 46112 "hcs12x.cc"
}

static Operation *DecodeOpMul(CodeType const& code, uint16_t addr)
{
	return new OpMul(code, addr);
}

// EDIV: 32 by 16 bit to 16 bit divide (unsigned) (Y:D) div (X) => Y remainder => D
#line 88 "hcs12x.isa"
uint8_t
#line 46123 "hcs12x.cc"
OpEdiv::getCycles()
{
#line 118 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{ return 11; }
#line 46128 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46132 "hcs12x.cc"
OpEdiv::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46136 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46139 "hcs12x.cc"
)
{
#line 120 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		string mnem = "EDIV";

		sink << mnem;
		return mnem;
	}
#line 46149 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46153 "hcs12x.cc"
OpEdiv::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46157 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46160 "hcs12x.cc"
)
{
#line 127 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		// TODO
		/*
		* source_url: http://www.embeddedrelated.com/groups/68hc12/show/3775.php
		*
		* U16 X, Y, Z;
		* X = (U16)(((U32)Y * 1000) / (U16)Z);
		*
		* with an EMUL and an EDIV is that if the 32/16 bit EDIV division overflows, then the
		* HC12 does not generate a result at all (it just sets the V flag).
		* Therefore using a simple EDIV does not generate the same result
		* for all possible Y and Z's as calculating it with longs.
		*/

		uint32_t dividend = ((uint32_t) cpu->getRegY() << 16) | cpu->getRegD();
		uint16_t divisor = cpu->getRegX();
		uint32_t quotion = cpu->getRegY();
		uint16_t remind = cpu->getRegD();

		if (divisor == 0) {
			// TODO: throw an exception "division by 0"
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();
			quotion = dividend / divisor;
			remind = dividend % divisor;

			if (quotion > 0xFFFF) {
				cpu->ccr->setV();
				} else {
				cpu->ccr->clrV();

				cpu->setRegY((uint16_t) quotion);
				cpu->setRegD(remind);
			}

			if (quotion == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
			if ((((uint16_t) quotion) & 0x8000) == 0x8000 ) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		}

	}
#line 46206 "hcs12x.cc"
}

static Operation *DecodeOpEdiv(CodeType const& code, uint16_t addr)
{
	return new OpEdiv(code, addr);
}

// EDIVS: 32 by 16 bit to 16 bit divide (signed)  (Y:D) div (X) => Y remainder => D
#line 88 "hcs12x.isa"
uint8_t
#line 46217 "hcs12x.cc"
OpEdivs::getCycles()
{
#line 173 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{ return 12; }
#line 46222 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46226 "hcs12x.cc"
OpEdivs::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46230 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46233 "hcs12x.cc"
)
{
#line 175 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		string mnem = "EDIVS";

		sink << mnem;
		return mnem;
	}
#line 46243 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46247 "hcs12x.cc"
OpEdivs::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46251 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46254 "hcs12x.cc"
)
{
#line 182 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{

		uint32_t dividend = ((uint32_t) cpu->getRegY() << 16) | (0x00FF & cpu->getRegD());
		uint16_t divisor = cpu->getRegX();
		uint32_t quotion = cpu->getRegY();
		uint16_t remind = cpu->getRegD();

		if (divisor == 0) {
			// TODO: throw an exception "division by 0"
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();

			quotion = dividend / divisor;
			remind = dividend % divisor;

			if (quotion > 0x7FFF) {
			/* NOTA:
				* For EDIVS, there is a mistake in specification about setting V.
				*/
				cpu->ccr->setV();
				} else {
				cpu->ccr->clrV();

				cpu->setRegY((uint16_t) quotion); // cpu->setRegY((uint16_t) quotion | ((quotion >> 16) & 0x8000));
				cpu->setRegD(remind);
			}

			if (quotion == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
			if (((uint16_t) quotion) & 0x8000 == 0x8000 ) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		}
	}
#line 46291 "hcs12x.cc"
}

static Operation *DecodeOpEdivs(CodeType const& code, uint16_t addr)
{
	return new OpEdivs(code, addr);
}

// FDIV: 16 by 16 fractional divide
#line 88 "hcs12x.isa"
uint8_t
#line 46302 "hcs12x.cc"
OpFdiv::getCycles()
{
#line 219 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{ return 12; }
#line 46307 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46311 "hcs12x.cc"
OpFdiv::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46315 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46318 "hcs12x.cc"
)
{
#line 221 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		string mnem = "FDIV";

		sink << mnem;
		return mnem;
	}
#line 46328 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46332 "hcs12x.cc"
OpFdiv::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46336 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46339 "hcs12x.cc"
)
{
#line 228 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		/* FDIV is equivalent to multiplying the numerator by 2^16 and then performing 32 by 16-bit integer division. */

		uint32_t dividend = (uint32_t) cpu->getRegD() << 16;
		uint16_t divisor = cpu->getRegX();
		uint16_t quotion = 0xFFFF;
		uint16_t remind = cpu->getRegD();

		if (divisor == 0) {
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();
			if (dividend >= divisor) {
				cpu->ccr->setV();
				} else {
				cpu->ccr->clrV();
				quotion = dividend / divisor;
				remind = dividend % divisor;
			}
		}

		cpu->setRegX(quotion);
		cpu->setRegD(remind);
		if (quotion == 0) { cpu->ccr->setZ(); }  else { cpu->ccr->clrZ(); }
	}
#line 46368 "hcs12x.cc"
}

static Operation *DecodeOpFdiv(CodeType const& code, uint16_t addr)
{
	return new OpFdiv(code, addr);
}

// IDIV: 16 by 16 integer divide (unsigned)
#line 88 "hcs12x.isa"
uint8_t
#line 46379 "hcs12x.cc"
OpIdiv::getCycles()
{
#line 257 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{ return 12; }
#line 46384 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46388 "hcs12x.cc"
OpIdiv::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46392 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46395 "hcs12x.cc"
)
{
#line 259 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		string mnem = "IDIV";

		sink << mnem;
		return mnem;
	}
#line 46405 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46409 "hcs12x.cc"
OpIdiv::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46413 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46416 "hcs12x.cc"
)
{
#line 266 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		/* In the case of division by zero, C is set, the quotient is set to 0xFFFF,
		and the remainder is indeterminate. */

		uint16_t dividend = cpu->getRegD();
		uint16_t divisor = cpu->getRegX();
		uint16_t quotion = 0xFFFF;
		uint16_t remind = dividend;

		cpu->ccr->clrV();
		if (divisor == 0) {
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();
			quotion = dividend / divisor;
			remind = dividend % divisor;
		}

		cpu->setRegX(quotion);
		cpu->setRegD(remind);
		if (quotion == 0) { cpu->ccr->setZ(); }  else { cpu->ccr->clrZ(); }
	}
#line 46442 "hcs12x.cc"
}

static Operation *DecodeOpIdiv(CodeType const& code, uint16_t addr)
{
	return new OpIdiv(code, addr);
}

// IDIVS: 16 by 16 integer divide (signed)
#line 88 "hcs12x.isa"
uint8_t
#line 46453 "hcs12x.cc"
OpIdivs::getCycles()
{
#line 292 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{ return 12; }
#line 46458 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46462 "hcs12x.cc"
OpIdivs::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46466 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46469 "hcs12x.cc"
)
{
#line 294 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		string mnem = "IDIVS";

		sink << mnem;
		return mnem;
	}
#line 46479 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46483 "hcs12x.cc"
OpIdivs::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46487 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46490 "hcs12x.cc"
)
{
#line 301 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		/* In the case of division by zero, C is set, the quotient is set to 0xFFFF,
		and the remainder is indeterminate. */

		uint16_t dividend = cpu->getRegD();
		uint16_t divisor = cpu->getRegX();
		uint16_t quotion = 0xFFFF;
		uint16_t remind = dividend;

		cpu->ccr->clrV();
		if (divisor == 0) {
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();
			quotion = dividend / divisor;
			remind = dividend % divisor;
		}

		cpu->setRegX(quotion);
		cpu->setRegD(remind);
		/*
		* V: Set if the result was > 0x7FFF or < 0x8000; cleared otherwise
		* V: Set for numerator 0x8000 (-32768) and denominator 0xFFFF (-1) result is (+32768)
		* Undefined after division by zero
		*/
		if ((dividend == 0x8000) && (divisor == 0xFFFF)) { cpu->ccr->setV(); } else { cpu->ccr->clrV();}
		if (quotion == 0) { cpu->ccr->setZ(); }  else { cpu->ccr->clrZ(); }
		if ((quotion & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 46523 "hcs12x.cc"
}

static Operation *DecodeOpIdivs(CodeType const& code, uint16_t addr)
{
	return new OpIdivs(code, addr);
}

/* ********* Multiply and Accumulate instruction ********* */
// EMACS: Multiply an Accumulate Instruction
#line 88 "hcs12x.isa"
uint8_t
#line 46535 "hcs12x.cc"
OpEmacs::getCycles()
{
#line 337 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{ return 9; }
#line 46540 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46544 "hcs12x.cc"
OpEmacs::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46548 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46551 "hcs12x.cc"
)
{
#line 339 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		string mnem = "EMACS";

		sink << mnem << " 0x" << std::hex << opr16a;
		return mnem;
	}
#line 46561 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46565 "hcs12x.cc"
OpEmacs::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46569 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46572 "hcs12x.cc"
)
{
#line 346 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		/* operation: (M(X) : M(X+1))  (M(Y) : M(Y+1)) + (M ~ M+3)  M ~ M+3 */

		uint16_t xOpr, yOpr;
		uint32_t accOpr, result, inter;


		xOpr = cpu->memRead16(cpu->getRegX());
		yOpr = cpu->memRead16(cpu->getRegY());
		accOpr = cpu->memRead16(opr16a);
		accOpr = (accOpr << 16) | cpu->memRead16(opr16a+2);

		inter = (uint32_t) xOpr * yOpr;
		result =  inter + accOpr;

		cpu->memWrite16(opr16a, (uint16_t) (result >> 16));
		cpu->memWrite16(opr16a+2, (uint16_t) result);

		// N: Set if MSB of result is set; cleared otherwise
		if (result & 0x80000000 == 0x80000000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		// Z: Set if result is 0x00000000; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		/*
		* I: Intermediate result
		* R: Result
		* M: 32 bit accumulator in memory (second operand in the addition)
		* */

		/* V: M31  I31  !R31 + !M31  !I31  R31
		* Set if result > 0x7FFFFFFF (+ overflow) or < 0x80000000 ( underflow)
		* Indicates twos complement overflow
		*/
		// if (result > 0x7FFFFFFF) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
		if (((accOpr & 0x80000000) & (inter & 0x80000000) & ~(result & 0x80000000) | ~(accOpr & 0x80000000) & ~(inter & 0x80000000) & (result & 0x80000000)) >> 31) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		/* C: M15  I15 + I15  !R15 + !R15  M15
		* Set if there was a carry from bit 15 of the result; cleared otherwise
		* Indicates a carry from low word to high word of the result occurred
		*/
		if (((accOpr & 0x00008000) & (inter & 0x00008000) | (inter & 0x00008000) & ~(result & 0x00008000) | ~(result & 0x00008000) & (accOpr & 0x00008000)) >> 15) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

	}
#line 46619 "hcs12x.cc"
}

static Operation *DecodeOpEmacs(CodeType const& code, uint16_t addr)
{
	return new OpEmacs(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// TODO: Very Important
// relied to instruction Queue
// Do not forgot to perform three program word fetches to refill the queue after a branch or subroutine call
/* ********* Short Branch Instructions ******** */
#line 88 "hcs12x.isa"
uint8_t
#line 46666 "hcs12x.cc"
OpSbr::getCycles()
{
#line 46 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		if (branch) return 3; else return 1;

	}
#line 46675 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46679 "hcs12x.cc"
OpSbr::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46683 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46686 "hcs12x.cc"
)
{
#line 52 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem;

		switch (sel) {
			case 0x0: mnem = "BRA";break;
			case 0x1: mnem = "BRN";break;
			case 0x2: mnem = "BHI";break;
			case 0x3: mnem = "BLS";break;
			case 0x4: mnem = "BCC"; /* same opcode for BHS */ break;
			case 0x5: mnem = "BCS"; /* same opcode for BLO */ break;
			case 0x6: mnem = "BNE";break;
			case 0x7: mnem = "BEQ";break;
			case 0x8: mnem = "BVC";break;
			case 0x9: mnem = "BVS";break;
			case 0xA: mnem = "BPL";break;
			case 0xB: mnem = "BMI";break;
			case 0xC: mnem = "BGE";break;
			case 0xD: mnem = "BLT";break;
			case 0xE: mnem = "BGT";break;
			case 0xF: mnem = "BLE";break;
		}
		sink << mnem << " " << std::dec << rel8;

		return mnem;
	}
#line 46715 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46719 "hcs12x.cc"
OpSbr::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46723 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46726 "hcs12x.cc"
)
{
#line 78 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		branch = false;

		switch (sel) {
			case 0x0: // BRA: branch always
			branch = true;
			break;
			case 0x1: // BRN: branch never
			// Nothing to do
			branch = false;
			break;
			case 0x2: // BHI: branch if higher (C+Z=0)
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 0) branch = true;
			break;
			case 0x3: // BLS: branch if lower or same
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 1) branch = true;
			break;
			case 0x4: // BCC: branch if carel8y clear or BHS: branch if higher or same
			if (cpu->ccr->getC() == 0) branch = true;
			break;
			case 0x5: // BCS: branch if carel8y set or BLO: branch if lower
			if (cpu->ccr->getC() == 1) branch = true;
			break;
			case 0x6: // BNE: branch if not equal
			if (cpu->ccr->getZ() == 0) branch = true;
			break;
			case 0x7: // BEQ: branch if equal
			if (cpu->ccr->getZ() == 1) branch = true;
			break;
			case 0x8: // BVC: branch if overflow clear
			if (cpu->ccr->getV() == 0) branch = true;
			break;
			case 0x9: // BVS: branch if overflow set
			if (cpu->ccr->getV() == 1) branch = true;
			break;
			case 0xA: // BPL: branch if plus
			if (cpu->ccr->getN() == 0) branch = true;
			break;
			case 0xB: // BMI: branch if minus
			if (cpu->ccr->getN() == 1) branch = true;
			break;
			case 0xC: // BGE: branch if greater than or equal
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 0) branch = true;
			break;
			case 0xD: // BLT: branch if less than
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 1) branch = true;
			break;
			case 0xE: { // BGT: branch if greater than
				if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 0) branch = true;
			}
			break;
			case 0xF: // BLE: branch if less than or equal
			if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 1) branch = true;
			break;
		}

		if (branch) {
			cpu->setRegPC(cpu->getRegPC() + rel8);
		}
	}
#line 46791 "hcs12x.cc"
}

static Operation *DecodeOpSbr(CodeType const& code, uint16_t addr)
{
	return new OpSbr(code, addr);
}

/* ******** Long Branch Instructions ******* */
#line 88 "hcs12x.isa"
uint8_t
#line 46802 "hcs12x.cc"
OpLbr::getCycles()
{
#line 146 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ if (branch) return 4; else return 3; }
#line 46807 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46811 "hcs12x.cc"
OpLbr::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46815 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46818 "hcs12x.cc"
)
{
#line 148 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem;

		switch (sel) {
			case 0x0: mnem = "LBRA";break;
			case 0x1: mnem = "LBRN";break;
			case 0x2: mnem = "LBHI";break;
			case 0x3: mnem = "LBLS";break;
			case 0x4: mnem = "LBCC"; /* same opcode for LBHS */ break;
			case 0x5: mnem = "LBCS"; /* same opcode for LBLO */ break;
			case 0x6: mnem = "LBNE";break;
			case 0x7: mnem = "LBEQ";break;
			case 0x8: mnem = "LBVC";break;
			case 0x9: mnem = "LBVS";break;
			case 0xA: mnem = "LBPL";break;
			case 0xB: mnem = "LBMI";break;
			case 0xC: mnem = "LBGE";break;
			case 0xD: mnem = "LBLT";break;
			case 0xE: mnem = "LBGT";break;
			case 0xF: mnem = "LBLE";break;
		}
		sink << mnem << " " << std::dec << rel16;

		return mnem;
	}
#line 46847 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46851 "hcs12x.cc"
OpLbr::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46855 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46858 "hcs12x.cc"
)
{
#line 174 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		branch = false;

		switch (sel) {
			case 0x0: // LBRA: branch always
			branch = true;
			break;
			case 0x1: // LBRN: branch never
			// Nothing to do
			branch = false;
			break;
			case 0x2: // LBHI: branch if higher (C+Z=0)
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 0) branch = true;
			break;
			case 0x3: // LBLS: branch if lower or same
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 1) branch = true;
			break;
			case 0x4: // LBCC: branch if carel8y clear or LBHS: branch if higher or same
			if (cpu->ccr->getC() == 0) branch = true;
			break;
			case 0x5: // LBCS: branch if carel8y set or LBLO: branch if lower
			if (cpu->ccr->getC() == 1) branch = true;
			break;
			case 0x6: // LBNE: branch if not equal
			if (cpu->ccr->getZ() == 0) branch = true;
			break;
			case 0x7: // LBEQ: branch if equal
			if (cpu->ccr->getZ() == 1) branch = true;
			break;
			case 0x8: // LBVC: branch if overflow clear
			if (cpu->ccr->getV() == 0) branch = true;
			break;
			case 0x9: // LBVS: branch if overflow set
			if (cpu->ccr->getV() == 1) branch = true;
			break;
			case 0xA: // LBPL: branch if plus
			if (cpu->ccr->getN() == 0) branch = true;
			break;
			case 0xB: // LBMI: branch if minus
			if (cpu->ccr->getN() == 1) branch = true;
			break;
			case 0xC: // LBGE: branch if greater than or equal
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 0) branch = true;
			break;
			case 0xD: // LBLT: branch if less than
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 1) branch = true;
			break;
			case 0xE: // LBGT: branch if greater than
			if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 0) branch = true;
			break;
			case 0xF: // LBLE: branch if less than or equal
			if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 1) branch = true;
			break;
		}

		if (branch) {
			cpu->setRegPC(cpu->getRegPC() + rel16);
		}
	}
#line 46922 "hcs12x.cc"
}

static Operation *DecodeOpLbr(CodeType const& code, uint16_t addr)
{
	return new OpLbr(code, addr);
}

/* ******** Bit Condition Branch instructions *********** */
// if (b==1) BRCLR_instruction else BRSET_instruction;
#line 88 "hcs12x.isa"
uint8_t
#line 46934 "hcs12x.cc"
OpBr_clr_set_dir::getCycles()
{
#line 241 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 4; }
#line 46939 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 46943 "hcs12x.cc"
OpBr_clr_set_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 46947 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 46950 "hcs12x.cc"
)
{
#line 243 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem;

		if (b==1) {
			mnem = "BRCLR";
			} else {
			mnem = "BRSET";
		}

		sink << mnem << " 0x" << std::hex << opr8a << ", 0x" << std::hex << msk8 << ", " << std::dec << rel8;

		return mnem;
	}
#line 46967 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 46971 "hcs12x.cc"
OpBr_clr_set_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 46975 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 46978 "hcs12x.cc"
)
{
#line 257 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		uint8_t opr8aVal = cpu->memRead8(opr8a, ADDRESS::DIRECT, false);

		if (b==0) {
			opr8aVal = ~opr8aVal;
		}

		if ((opr8aVal & msk8) == 0) {
			cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);

			// TODO: Refill the instruction queue with three program words from the new address
		}
	}
#line 46996 "hcs12x.cc"
}

static Operation *DecodeOpBr_clr_set_dir(CodeType const& code, uint16_t addr)
{
	return new OpBr_clr_set_dir(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 47006 "hcs12x.cc"
OpBr_clr_set_ext::getCycles()
{
#line 274 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 5; }
#line 47011 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47015 "hcs12x.cc"
OpBr_clr_set_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47019 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47022 "hcs12x.cc"
)
{
#line 276 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem;

		if (b==1) {
			mnem = "BRCLR";
			} else {
			mnem = "BRSET";
		}

		sink << mnem << " 0x" << std::hex << opr16a << ", 0x" << std::hex << msk8 << ", " << std::dec << rel8;

		return mnem;
	}
#line 47039 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47043 "hcs12x.cc"
OpBr_clr_set_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47047 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47050 "hcs12x.cc"
)
{
#line 290 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		physical_address_t addr = opr16a;
		uint8_t opr16aVal = cpu->memRead8(addr);

		if (b==0) {
			opr16aVal = ~opr16aVal;
		}

		if ((opr16aVal & msk8) == 0) {
			cpu->setRegPC(cpu->getRegPC() + rel8);
		}
	}
#line 47066 "hcs12x.cc"
}

static Operation *DecodeOpBr_clr_set_ext(CodeType const& code, uint16_t addr)
{
	return new OpBr_clr_set_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 47076 "hcs12x.cc"
OpBr_clr_set_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 47080 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 47083 "hcs12x.cc"
)
{
#line 305 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 47092 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 47096 "hcs12x.cc"
OpBr_clr_set_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 47100 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 47103 "hcs12x.cc"
)
{
#line 311 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 47112 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 47116 "hcs12x.cc"
OpBr_clr_set_idx::getCycles()
{
#line 317 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 5, 6, 0, 0); }
#line 47121 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47125 "hcs12x.cc"
OpBr_clr_set_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47129 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47132 "hcs12x.cc"
)
{
#line 319 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem;

		if (b==1) {
			mnem = "BRCLR";
			} else {
			mnem = "BRSET";
		}

		sink << mnem << " ";
		xb->disasm(sink);
		sink << ", 0x" << std::hex << msk8 << ", " << std::dec << rel8;

		return mnem;
	}
#line 47151 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47155 "hcs12x.cc"
OpBr_clr_set_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47159 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47162 "hcs12x.cc"
)
{
#line 335 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		physical_address_t addr = xb->getEAddr(cpu);
		uint8_t xbVal = cpu->memRead8(addr);

		if (b==0) {
			xbVal = ~xbVal;
		}

		if ((xbVal & msk8) == 0) {
			cpu->setRegPC(cpu->getRegPC() + rel8);
		}
	}
#line 47178 "hcs12x.cc"
}

static Operation *DecodeOpBr_clr_set_idx(CodeType const& code, uint16_t addr)
{
	return new OpBr_clr_set_idx(code, addr);
}

/* ********** Jump and subroutine instructions ******** */
// BSR: Branch to subroutine
#line 88 "hcs12x.isa"
uint8_t
#line 47190 "hcs12x.cc"
OpBsr::getCycles()
{
#line 353 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 4; }
#line 47195 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47199 "hcs12x.cc"
OpBsr::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47203 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47206 "hcs12x.cc"
)
{
#line 355 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "BSR";

		sink << mnem << " " << std::dec << rel8;

		return mnem;
	}
#line 47217 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47221 "hcs12x.cc"
OpBsr::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47225 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47228 "hcs12x.cc"
)
{
#line 363 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* Subroutine address fi PC
		*/
		physical_address_t addr;

		addr = cpu->getRegSP() - 2;
		cpu->setRegSP(addr);
		cpu->memWrite16(addr, cpu->getRegPC());

		cpu->setRegPC(cpu->getRegPC() + rel8);
	}
#line 47246 "hcs12x.cc"
}

static Operation *DecodeOpBsr(CodeType const& code, uint16_t addr)
{
	return new OpBsr(code, addr);
}

// CALL: Call subroutine in Expanded Memory
#line 88 "hcs12x.isa"
uint8_t
#line 47257 "hcs12x.cc"
OpCall_ext::getCycles()
{
#line 381 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 7; }
#line 47262 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47266 "hcs12x.cc"
OpCall_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47270 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47273 "hcs12x.cc"
)
{
#line 383 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "CALL";

		sink << mnem << " 0x" << std::hex << opr16a << ", 0x" << std::hex << page;

		return mnem;
	}
#line 47284 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47288 "hcs12x.cc"
OpCall_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47292 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47295 "hcs12x.cc"
)
{
#line 391 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* (SP)-1 => SP
		* (PPAGE) => M[SP]
		* page => PPAGE
		* Subroutine address => PC
		*/
		physical_address_t addr;
		page_t old_ppage;

		addr = cpu->getRegSP() - 2;
		cpu->setRegSP(addr);
		cpu->memWrite16(addr, cpu->getRegPC());

		addr = cpu->getRegSP() - 1;
		cpu->setRegSP(addr);

		old_ppage = cpu->memRead8(MMC::PPAGE_REG_ADDRESS);
		cpu->memWrite8(addr, old_ppage);

		cpu->memWrite8(MMC::PPAGE_REG_ADDRESS, page);
		cpu->setRegPC(opr16a);

	}
#line 47325 "hcs12x.cc"
}

static Operation *DecodeOpCall_ext(CodeType const& code, uint16_t addr)
{
	return new OpCall_ext(code, addr);
}

// I have to decode indexed-indirect addressing here,
// because in the case of indexed-indirect the value of PPAGE is stored in memory after the subroutine address
// XB decoder return only one address
#line 88 "hcs12x.isa"
uint8_t
#line 47338 "hcs12x.cc"
OpCall_16offset_idx_ind::getCycles()
{
#line 424 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 10; }
#line 47343 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47347 "hcs12x.cc"
OpCall_16offset_idx_ind::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47351 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47354 "hcs12x.cc"
)
{
#line 426 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "CALL";

		sink << mnem << " " << "[" << std::dec << n16 << "," << CPU::xb_getAddrRegLabel(rr) << "]";

		return mnem;
	}
#line 47365 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47369 "hcs12x.cc"
OpCall_16offset_idx_ind::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47373 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47376 "hcs12x.cc"
)
{
#line 434 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* (SP)-1 => SP
		* (PPAGE) => M[SP]
		* page => PPAGE
		* Subroutine address => PC
		*/

		physical_address_t addr;
		page_t old_ppage;

		physical_address_t idxAddr = cpu->xb_getAddrRegValue(rr) + n16;

		address_t subAddr = cpu->memRead16(idxAddr);
		uint8_t   ppageVal = cpu->memRead16(idxAddr+2);

		addr = cpu->getRegSP() - 2;
		cpu->setRegSP(addr);
		cpu->memWrite16(addr, cpu->getRegPC());

		addr = cpu->getRegSP() - 1;
		cpu->setRegSP(addr);

		old_ppage = cpu->memRead8(MMC::PPAGE_REG_ADDRESS);
		cpu->memWrite8(addr, old_ppage);

		cpu->memWrite8(MMC::PPAGE_REG_ADDRESS, ppageVal);
		cpu->setRegPC(subAddr);

	}
#line 47412 "hcs12x.cc"
}

static Operation *DecodeOpCall_16offset_idx_ind(CodeType const& code, uint16_t addr)
{
	return new OpCall_16offset_idx_ind(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 47422 "hcs12x.cc"
OpCall_accD_offset_idx_ind::getCycles()
{
#line 469 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 10; }
#line 47427 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47431 "hcs12x.cc"
OpCall_accD_offset_idx_ind::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47435 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47438 "hcs12x.cc"
)
{
#line 471 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "CALL";

		sink << mnem << " " << "[D," << CPU::xb_getAddrRegLabel(rr) << "]";

		return mnem;
	}
#line 47449 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47453 "hcs12x.cc"
OpCall_accD_offset_idx_ind::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47457 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47460 "hcs12x.cc"
)
{
#line 479 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* (SP)-1 => SP
		* (PPAGE) => M[SP]
		* page => PPAGE
		* Subroutine address => PC
		*/

		physical_address_t addr;
		page_t old_ppage;

		physical_address_t idxAddr = cpu->getRegD() + cpu->xb_getAddrRegValue(rr);

		address_t subAddr = cpu->memRead16(idxAddr);
		uint8_t   ppageVal = cpu->memRead16(idxAddr+2);

		addr = cpu->getRegSP() - 2;
		cpu->setRegSP(addr);

		cpu->memWrite16(addr, cpu->getRegPC());

		addr = cpu->getRegSP() - 1;
		cpu->setRegSP(addr);

		old_ppage = cpu->memRead8(MMC::PPAGE_REG_ADDRESS);
		cpu->memWrite8(addr, old_ppage);

		cpu->memWrite8(MMC::PPAGE_REG_ADDRESS, ppageVal);
		cpu->setRegPC(subAddr);
	}
#line 47496 "hcs12x.cc"
}

static Operation *DecodeOpCall_accD_offset_idx_ind(CodeType const& code, uint16_t addr)
{
	return new OpCall_accD_offset_idx_ind(code, addr);
}

// JMP: JUMP
#line 88 "hcs12x.isa"
uint8_t
#line 47507 "hcs12x.cc"
OpJmp_ext::getCycles()
{
#line 571 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 3; }
#line 47512 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47516 "hcs12x.cc"
OpJmp_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47520 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47523 "hcs12x.cc"
)
{
#line 573 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "JMP";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 47534 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47538 "hcs12x.cc"
OpJmp_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47542 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47545 "hcs12x.cc"
)
{
#line 581 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		cpu->setRegPC(opr16a);
	}
#line 47552 "hcs12x.cc"
}

static Operation *DecodeOpJmp_ext(CodeType const& code, uint16_t addr)
{
	return new OpJmp_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 47562 "hcs12x.cc"
OpJmp_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 47566 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 47569 "hcs12x.cc"
)
{
#line 587 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 47578 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 47582 "hcs12x.cc"
OpJmp_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 47586 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 47589 "hcs12x.cc"
)
{
#line 593 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 47598 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 47602 "hcs12x.cc"
OpJmp_idx::getCycles()
{
#line 599 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }
#line 47607 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47611 "hcs12x.cc"
OpJmp_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47615 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47618 "hcs12x.cc"
)
{
#line 601 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "JMP";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 47630 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47634 "hcs12x.cc"
OpJmp_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47638 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47641 "hcs12x.cc"
)
{
#line 610 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		cpu->setRegPC(xb->getEAddr(cpu));
	}
#line 47648 "hcs12x.cc"
}

static Operation *DecodeOpJmp_idx(CodeType const& code, uint16_t addr)
{
	return new OpJmp_idx(code, addr);
}

// JSR: Jump to subroutine
#line 88 "hcs12x.isa"
uint8_t
#line 47659 "hcs12x.cc"
OpJsr_dir::getCycles()
{
#line 617 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 4; }
#line 47664 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47668 "hcs12x.cc"
OpJsr_dir::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47672 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47675 "hcs12x.cc"
)
{
#line 619 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "JSR";

		sink << mnem << " 0x" << std::hex << opr8a;

		return mnem;
	}
#line 47686 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47690 "hcs12x.cc"
OpJsr_dir::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47694 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47697 "hcs12x.cc"
)
{
#line 627 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* subroutine address => PC
		*/
		address_t addr;
		page_t direct_reg;

		addr = cpu->getRegSP() - 2;
		cpu->setRegSP(addr);

		cpu->memWrite16(addr, cpu->getRegPC());

		direct_reg = cpu->memRead8(MMC::DIRECT_REG_ADDRESS);
		addr = ((uint16_t) direct_reg << 8) | opr8a;
		cpu->setRegPC(addr);
	}
#line 47719 "hcs12x.cc"
}

static Operation *DecodeOpJsr_dir(CodeType const& code, uint16_t addr)
{
	return new OpJsr_dir(code, addr);
}

#line 88 "hcs12x.isa"
uint8_t
#line 47729 "hcs12x.cc"
OpJsr_ext::getCycles()
{
#line 648 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 4; }
#line 47734 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47738 "hcs12x.cc"
OpJsr_ext::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47742 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47745 "hcs12x.cc"
)
{
#line 650 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "JSR";

		sink << mnem << " 0x" << std::hex << opr16a;

		return mnem;
	}
#line 47756 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47760 "hcs12x.cc"
OpJsr_ext::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47764 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47767 "hcs12x.cc"
)
{
#line 658 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		physical_address_t addr;

		addr = cpu->getRegSP() - 2;
		cpu->setRegSP(addr);

		cpu->memWrite16(addr, cpu->getRegPC());

		cpu->setRegPC(opr16a);

	}
#line 47782 "hcs12x.cc"
}

static Operation *DecodeOpJsr_ext(CodeType const& code, uint16_t addr)
{
	return new OpJsr_ext(code, addr);
}

#line 79 "hcs12x.isa"
void
#line 47792 "hcs12x.cc"
OpJsr_idx::pre_execute(
#line 79 "hcs12x.isa"
ostream&
#line 47796 "hcs12x.cc"
#line 79 "hcs12x.isa"
sink
#line 47799 "hcs12x.cc"
)
{
#line 672 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		xb->pre_execute(sink);
		// after: other specific actions
	}
#line 47808 "hcs12x.cc"
}
#line 83 "hcs12x.isa"
void
#line 47812 "hcs12x.cc"
OpJsr_idx::post_execute(
#line 83 "hcs12x.isa"
ostream&
#line 47816 "hcs12x.cc"
#line 83 "hcs12x.isa"
sink
#line 47819 "hcs12x.cc"
)
{
#line 678 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		// before: other specific actions
		xb->post_execute(sink);
	}
#line 47828 "hcs12x.cc"
}
#line 88 "hcs12x.isa"
uint8_t
#line 47832 "hcs12x.cc"
OpJsr_idx::getCycles()
{
#line 684 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }
#line 47837 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47841 "hcs12x.cc"
OpJsr_idx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47845 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47848 "hcs12x.cc"
)
{
#line 686 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "JSR";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 47860 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47864 "hcs12x.cc"
OpJsr_idx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47868 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47871 "hcs12x.cc"
)
{
#line 695 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		physical_address_t addr;
		physical_address_t jsrAddr = xb->getEAddr(cpu);

		addr = cpu->getRegSP() - 2;
		cpu->setRegSP(addr);

		cpu->memWrite16(addr, cpu->getRegPC());

		cpu->setRegPC(jsrAddr);

	}
#line 47887 "hcs12x.cc"
}

static Operation *DecodeOpJsr_idx(CodeType const& code, uint16_t addr)
{
	return new OpJsr_idx(code, addr);
}

// RTC: Return from call
#line 88 "hcs12x.isa"
uint8_t
#line 47898 "hcs12x.cc"
OpRtc::getCycles()
{
#line 711 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 7; }
#line 47903 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47907 "hcs12x.cc"
OpRtc::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47911 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47914 "hcs12x.cc"
)
{
#line 713 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "RTC";

		sink << mnem;

		return mnem;
	}
#line 47925 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 47929 "hcs12x.cc"
OpRtc::execute(
#line 67 "hcs12x.isa"
CPU *
#line 47933 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 47936 "hcs12x.cc"
)
{
#line 721 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (M[SP]) => PPage
		* (SP)+1 => SP
		* (M[SP]):(M[SP+1]) => PCh:PCl
		* (SP)+2 => SP
		*/

		uint8_t hByte, lByte;
		physical_address_t addr;

		addr = cpu->getRegSP();
		cpu->memWrite8(MMC::PPAGE_REG_ADDRESS, cpu->memRead8(addr));
		cpu->setRegSP(addr + 1);

		addr = cpu->getRegSP();

		cpu->setRegPC(cpu->memRead16(addr));

		cpu->setRegSP(addr + 2);
	}
#line 47961 "hcs12x.cc"
}

static Operation *DecodeOpRtc(CodeType const& code, uint16_t addr)
{
	return new OpRtc(code, addr);
}

// RTS: Return from subroutine
#line 88 "hcs12x.isa"
uint8_t
#line 47972 "hcs12x.cc"
OpRts::getCycles()
{
#line 746 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ return 5; }
#line 47977 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 47981 "hcs12x.cc"
OpRts::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 47985 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 47988 "hcs12x.cc"
)
{
#line 748 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem = "RTS";

		sink << mnem;

		return mnem;
	}
#line 47999 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48003 "hcs12x.cc"
OpRts::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48007 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48010 "hcs12x.cc"
)
{
#line 756 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		addr = cpu->getRegSP();

		cpu->setRegPC(cpu->memRead16(addr));

		cpu->setRegSP(addr + 2);

	}
#line 48023 "hcs12x.cc"
}

static Operation *DecodeOpRts(CodeType const& code, uint16_t addr)
{
	return new OpRts(code, addr);
}

/* ************ Loop Primitive ********* */
#line 88 "hcs12x.isa"
uint8_t
#line 48034 "hcs12x.cc"
OpLoop::getCycles()
{
#line 773 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{ if (isBranch) return 3; else return 3; }
#line 48039 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48043 "hcs12x.cc"
OpLoop::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48047 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48050 "hcs12x.cc"
)
{
#line 775 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		string mnem;

		/*
		Encoding for lb is summarized in the following table.
		Bit 3 is not used (dont care),
		Bit 5 selects branch on zero (DBEQ  0) or not zero (DBNE  1) versions,
		and bit 4 is the sign bit of the 9-bit relative offset.
		Bits 7 and 6 would be 0:0 for DBNE.
		*/
		uint8_t abdxys = (b765 << 5) | (b4 << 4) | (b3 << 3) | b210;

		switch (b765) {
			case 0x00: mnem = "DBEQ"; break;
			case 0x01: mnem = "DBNE"; break;
			case 0x02: mnem = "TBEQ"; break;
			case 0x03: mnem = "TBNE"; break;
			case 0x04: mnem = "IBEQ"; break;
			case 0x05: mnem = "IBNE"; break;
			default: mnem = "?";
		}

		if (b4 == 0) {
			sink << mnem << " " << EBLB::getRegName(b210) << " , " << std::dec << rel9;
			} else {
			sink << mnem << " " << EBLB::getRegName(b210) << " , " << std::dec << (rel9 - 256);
		}

		return mnem;
	}
#line 48084 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48088 "hcs12x.cc"
OpLoop::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48092 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48095 "hcs12x.cc"
)
{
#line 806 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		address_t branchAddr;

		isBranch = false;

		if (b4 == 0) {
			branchAddr = cpu->getRegPC() + rel9;
			} else {
			branchAddr = cpu->getRegPC() + (rel9 - 256);
		}

		switch (b765) {
			case 0x00: /*DBEQ*/{

				if (b210 < 0x4) {
					uint8_t val;
					val = cpu->eblb->getter<uint8_t>(b210);
					val = val - 1;
					cpu->eblb->setter<uint8_t>(b210, val);
					isBranch = (val == 0);
					} else {
					uint16_t val;
					val = cpu->eblb->getter<uint16_t>(b210);
					val = val - 1;
					cpu->eblb->setter<uint16_t>(b210, val);
					isBranch = (val == 0);
				}

			} break;
			case 0x01: /*DBNE*/{

				if (b210 < 0x4) {
					uint8_t val;
					val = cpu->eblb->getter<uint8_t>(b210);
					val = val - 1;
					cpu->eblb->setter<uint8_t>(b210, val);
					isBranch = (val != 0);
					} else {
					uint16_t val;
					val = cpu->eblb->getter<uint16_t>(b210);
					val = val - 1;
					cpu->eblb->setter<uint16_t>(b210, val);
					isBranch = (val != 0);
				}


			} break;
			case 0x02: /*TBEQ*/{
				if (b210 < 0x4) {
					isBranch = (cpu->eblb->getter<uint8_t>(b210) == 0);
					} else {
					isBranch = (cpu->eblb->getter<uint16_t>(b210) == 0);
				}

			} break;
			case 0x03: /*TBNE*/{
				if (b210 < 0x4) {
					isBranch = (cpu->eblb->getter<uint8_t>(b210) != 0);
					} else {
					isBranch = (cpu->eblb->getter<uint16_t>(b210) != 0);
				}

			} break;
			case 0x04: /*IBEQ*/{

				if (b210 < 0x4) {
					uint8_t val;
					val = cpu->eblb->getter<uint8_t>(b210);
					val = val + 1;
					cpu->eblb->setter<uint8_t>(b210, val);
					isBranch = (val == 0);
					} else {
					uint16_t val;
					val = cpu->eblb->getter<uint16_t>(b210);
					val = val + 1;
					cpu->eblb->setter<uint16_t>(b210, val);
					isBranch = (val == 0);
				}


			} break;
			case 0x05: /*IBNE*/{

				if (b210 < 0x4) {
					uint8_t val;
					val = cpu->eblb->getter<uint8_t>(b210);
					val = val + 1;
					cpu->eblb->setter<uint8_t>(b210, val);
					isBranch = (val != 0);
					} else {
					uint16_t val;
					val = cpu->eblb->getter<uint16_t>(b210);
					val = val + 1;
					cpu->eblb->setter<uint16_t>(b210, val);
					isBranch = (val != 0);
				}


			} break;
			default: /*???*/;
		}

		if (isBranch) {
			cpu->setRegPC(branchAddr);
		}

	}
#line 48206 "hcs12x.cc"
}

static Operation *DecodeOpLoop(CodeType const& code, uint16_t addr)
{
	return new OpLoop(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
/* ********** Stack Pointer instructions ******** */
// CPS: Compare SP to memory
// is emulated in compare_test.isa
// DES: Decrement Sp
// is emulated in decrement_increment.isa
// INS: Increment SP
// is emulated in decrement_increment.isa
// LDS: load SP
// is emulated in load_store.isa
// LEAS: load effective address into SP
// is emulated in load_store.isa
// STS: store SP
// is emulated in load_store.isa
// TSX: transfer SP to X
// is emulated in transfer_exchange.isa
// TSY: transfer SP to Y
// is emulated in transfer_exchange.isa
// TXS: transfer X to SP
// is emulated in transfer_exchange.isa
// TYS: transfer Y to Sp
// is emulated in transfer_exchange.isa
/* ********** stack Operation instructions ********** */
// PSHA: Push A
#line 88 "hcs12x.isa"
uint8_t
#line 48272 "hcs12x.cc"
OpPsha::getCycles()
{
#line 75 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 2; }
#line 48277 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48281 "hcs12x.cc"
OpPsha::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48285 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48288 "hcs12x.cc"
)
{
#line 77 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PSHA";

		sink << mnem;
		return mnem;
	}
#line 48298 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48302 "hcs12x.cc"
OpPsha::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48306 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48309 "hcs12x.cc"
)
{
#line 84 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{

		cpu->setRegSP(cpu->getRegSP()-1);
		cpu->memWrite8(cpu->getRegSP(), cpu->getRegA());
	}
#line 48318 "hcs12x.cc"
}

static Operation *DecodeOpPsha(CodeType const& code, uint16_t addr)
{
	return new OpPsha(code, addr);
}

// PSHB: Push B
#line 88 "hcs12x.isa"
uint8_t
#line 48329 "hcs12x.cc"
OpPshb::getCycles()
{
#line 94 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 2; }
#line 48334 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48338 "hcs12x.cc"
OpPshb::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48342 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48345 "hcs12x.cc"
)
{
#line 96 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PSHB";

		sink << mnem;
		return mnem;
	}
#line 48355 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48359 "hcs12x.cc"
OpPshb::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48363 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48366 "hcs12x.cc"
)
{
#line 103 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-1);
		cpu->memWrite8(cpu->getRegSP(), cpu->getRegB());
	}
#line 48374 "hcs12x.cc"
}

static Operation *DecodeOpPshb(CodeType const& code, uint16_t addr)
{
	return new OpPshb(code, addr);
}

// PSHC: Push CCR (8 lower bits)
#line 88 "hcs12x.isa"
uint8_t
#line 48385 "hcs12x.cc"
OpPshc::getCycles()
{
#line 112 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 2; }
#line 48390 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48394 "hcs12x.cc"
OpPshc::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48398 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48401 "hcs12x.cc"
)
{
#line 114 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PSHC";

		sink << mnem;
		return mnem;
	}
#line 48411 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48415 "hcs12x.cc"
OpPshc::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48419 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48422 "hcs12x.cc"
)
{
#line 121 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-1);
		cpu->memWrite8(cpu->getRegSP(), cpu->ccr->getCCRLow());
	}
#line 48430 "hcs12x.cc"
}

static Operation *DecodeOpPshc(CodeType const& code, uint16_t addr)
{
	return new OpPshc(code, addr);
}

// PSHCW: Push CCR word (16 bits)
#line 88 "hcs12x.isa"
uint8_t
#line 48441 "hcs12x.cc"
OpPshcw::getCycles()
{
#line 130 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 3; }
#line 48446 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48450 "hcs12x.cc"
OpPshcw::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48454 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48457 "hcs12x.cc"
)
{
#line 132 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PSHCW";

		sink << mnem;
		return mnem;
	}
#line 48467 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48471 "hcs12x.cc"
OpPshcw::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48475 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48478 "hcs12x.cc"
)
{
#line 139 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->getRegSP(), cpu->ccr->getCCR());
	}
#line 48486 "hcs12x.cc"
}

static Operation *DecodeOpPshcw(CodeType const& code, uint16_t addr)
{
	return new OpPshcw(code, addr);
}

// PSHD: Push D
#line 88 "hcs12x.isa"
uint8_t
#line 48497 "hcs12x.cc"
OpPshd::getCycles()
{
#line 148 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 2; }
#line 48502 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48506 "hcs12x.cc"
OpPshd::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48510 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48513 "hcs12x.cc"
)
{
#line 150 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PSHD";

		sink << mnem;
		return mnem;
	}
#line 48523 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48527 "hcs12x.cc"
OpPshd::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48531 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48534 "hcs12x.cc"
)
{
#line 157 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->getRegSP(), cpu->getRegD());
	}
#line 48542 "hcs12x.cc"
}

static Operation *DecodeOpPshd(CodeType const& code, uint16_t addr)
{
	return new OpPshd(code, addr);
}

// PSHX: Push X
#line 88 "hcs12x.isa"
uint8_t
#line 48553 "hcs12x.cc"
OpPshx::getCycles()
{
#line 166 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 2; }
#line 48558 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48562 "hcs12x.cc"
OpPshx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48566 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48569 "hcs12x.cc"
)
{
#line 168 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PSHX";

		sink << mnem;
		return mnem;
	}
#line 48579 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48583 "hcs12x.cc"
OpPshx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48587 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48590 "hcs12x.cc"
)
{
#line 175 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->getRegSP(), cpu->getRegX());
	}
#line 48598 "hcs12x.cc"
}

static Operation *DecodeOpPshx(CodeType const& code, uint16_t addr)
{
	return new OpPshx(code, addr);
}

// PSHY: Push Y
#line 88 "hcs12x.isa"
uint8_t
#line 48609 "hcs12x.cc"
OpPshy::getCycles()
{
#line 184 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 2; }
#line 48614 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48618 "hcs12x.cc"
OpPshy::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48622 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48625 "hcs12x.cc"
)
{
#line 186 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PSHY";

		sink << mnem;
		return mnem;
	}
#line 48635 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48639 "hcs12x.cc"
OpPshy::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48643 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48646 "hcs12x.cc"
)
{
#line 193 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->getRegSP(), cpu->getRegY());
	}
#line 48654 "hcs12x.cc"
}

static Operation *DecodeOpPshy(CodeType const& code, uint16_t addr)
{
	return new OpPshy(code, addr);
}

// PULA: Pull A
#line 88 "hcs12x.isa"
uint8_t
#line 48665 "hcs12x.cc"
OpPula::getCycles()
{
#line 202 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 3; }
#line 48670 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48674 "hcs12x.cc"
OpPula::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48678 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48681 "hcs12x.cc"
)
{
#line 204 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PULA";

		sink << mnem;
		return mnem;
	}
#line 48691 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48695 "hcs12x.cc"
OpPula::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48699 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48702 "hcs12x.cc"
)
{
#line 211 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegA(cpu->memRead8(cpu->getRegSP()));
		cpu->setRegSP(cpu->getRegSP()+1);
	}
#line 48710 "hcs12x.cc"
}

static Operation *DecodeOpPula(CodeType const& code, uint16_t addr)
{
	return new OpPula(code, addr);
}

// PULB: Pull B
#line 88 "hcs12x.isa"
uint8_t
#line 48721 "hcs12x.cc"
OpPulb::getCycles()
{
#line 220 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 3; }
#line 48726 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48730 "hcs12x.cc"
OpPulb::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48734 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48737 "hcs12x.cc"
)
{
#line 222 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PULB";

		sink << mnem;
		return mnem;
	}
#line 48747 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48751 "hcs12x.cc"
OpPulb::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48755 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48758 "hcs12x.cc"
)
{
#line 229 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegB(cpu->memRead8(cpu->getRegSP()));
		cpu->setRegSP(cpu->getRegSP()+1);
	}
#line 48766 "hcs12x.cc"
}

static Operation *DecodeOpPulb(CodeType const& code, uint16_t addr)
{
	return new OpPulb(code, addr);
}

// PULC: Pull CCR (16 lower bits)
#line 88 "hcs12x.isa"
uint8_t
#line 48777 "hcs12x.cc"
OpPulc::getCycles()
{
#line 238 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 3; }
#line 48782 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48786 "hcs12x.cc"
OpPulc::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48790 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48793 "hcs12x.cc"
)
{
#line 240 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PULC";

		sink << mnem;
		return mnem;
	}
#line 48803 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48807 "hcs12x.cc"
OpPulc::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48811 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48814 "hcs12x.cc"
)
{
#line 247 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->ccr->setCCRLow(cpu->memRead8(cpu->getRegSP()));
		cpu->setRegSP(cpu->getRegSP()+1);
	}
#line 48822 "hcs12x.cc"
}

static Operation *DecodeOpPulc(CodeType const& code, uint16_t addr)
{
	return new OpPulc(code, addr);
}

// PULCW: Pull CCR word
#line 88 "hcs12x.isa"
uint8_t
#line 48833 "hcs12x.cc"
OpPulcw::getCycles()
{
#line 256 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 4; }
#line 48838 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48842 "hcs12x.cc"
OpPulcw::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48846 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48849 "hcs12x.cc"
)
{
#line 258 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PULCW";

		sink << mnem;
		return mnem;
	}
#line 48859 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48863 "hcs12x.cc"
OpPulcw::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48867 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48870 "hcs12x.cc"
)
{
#line 265 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->ccr->setCCR(cpu->memRead16(cpu->getRegSP()));
		cpu->setRegSP(cpu->getRegSP()+2);
	}
#line 48878 "hcs12x.cc"
}

static Operation *DecodeOpPulcw(CodeType const& code, uint16_t addr)
{
	return new OpPulcw(code, addr);
}

// PULD: Pull D
#line 88 "hcs12x.isa"
uint8_t
#line 48889 "hcs12x.cc"
OpPuld::getCycles()
{
#line 274 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 3; }
#line 48894 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48898 "hcs12x.cc"
OpPuld::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48902 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48905 "hcs12x.cc"
)
{
#line 276 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PULD";

		sink << mnem;
		return mnem;
	}
#line 48915 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48919 "hcs12x.cc"
OpPuld::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48923 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48926 "hcs12x.cc"
)
{
#line 283 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegD(cpu->memRead16(cpu->getRegSP()));
		cpu->setRegSP(cpu->getRegSP()+2);
	}
#line 48934 "hcs12x.cc"
}

static Operation *DecodeOpPuld(CodeType const& code, uint16_t addr)
{
	return new OpPuld(code, addr);
}

// PULX: Pull X
#line 88 "hcs12x.isa"
uint8_t
#line 48945 "hcs12x.cc"
OpPulx::getCycles()
{
#line 292 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 3; }
#line 48950 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 48954 "hcs12x.cc"
OpPulx::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 48958 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 48961 "hcs12x.cc"
)
{
#line 294 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PULX";

		sink << mnem;
		return mnem;
	}
#line 48971 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 48975 "hcs12x.cc"
OpPulx::execute(
#line 67 "hcs12x.isa"
CPU *
#line 48979 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 48982 "hcs12x.cc"
)
{
#line 301 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegX(cpu->memRead16(cpu->getRegSP()));
		cpu->setRegSP(cpu->getRegSP()+2);
	}
#line 48990 "hcs12x.cc"
}

static Operation *DecodeOpPulx(CodeType const& code, uint16_t addr)
{
	return new OpPulx(code, addr);
}

// PULY: Pull Y
#line 88 "hcs12x.isa"
uint8_t
#line 49001 "hcs12x.cc"
OpPuly::getCycles()
{
#line 310 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{ return 3; }
#line 49006 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49010 "hcs12x.cc"
OpPuly::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49014 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49017 "hcs12x.cc"
)
{
#line 312 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		string mnem = "PULY";

		sink << mnem;
		return mnem;
	}
#line 49027 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 49031 "hcs12x.cc"
OpPuly::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49035 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49038 "hcs12x.cc"
)
{
#line 319 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegY(cpu->memRead16(cpu->getRegSP()));
		cpu->setRegSP(cpu->getRegSP()+2);
	}
#line 49046 "hcs12x.cc"
}

static Operation *DecodeOpPuly(CodeType const& code, uint16_t addr)
{
	return new OpPuly(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// MEM: Membership function
#line 88 "hcs12x.isa"
uint8_t
#line 49090 "hcs12x.cc"
OpMem::getCycles()
{
#line 39 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{ return 5; }
#line 49095 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49099 "hcs12x.cc"
OpMem::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49103 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49106 "hcs12x.cc"
)
{
#line 41 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		string mnem = "MEM";

		sink << mnem;

		return mnem;
	}
#line 49117 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 49121 "hcs12x.cc"
OpMem::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49125 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49128 "hcs12x.cc"
)
{
#line 49 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		// The final state of CCR flags is not defined

		/*

		Operation
		---------
		Grade of Membership  M(Y)
		(Y) + 0x0001  Y
		(X) + 0x0004  X

		Description
		-----------
		Before executing MEM, initialize A, X, and Y. Load A with the current crisp value of a system input
		variable. Load Y with the fuzzy input RAM location where the grade of membership is to be stored.
		Load X with the first address of a 4-byte data structure that describes a trapezoidal membership
	function. The data structure consists of:
		Point_1  The x-axis starting point for the leading side (at MX)
		Point_2  The x-axis position of the rightmost point (at MX+1)
		Slope_1  The slope of the leading side (at MX+2)
		Slope_2The slope of the trailing side (atMX+3); the right side slopes up and to the left from
		Point_2
		A Slope_1 or Slope_2 value of 0x00 is a special case in which the membership function either starts
		with a grade of 0xFF at input = Point_1, or ends with a grade of 0xFF at input = Point_2 (infinite slope).
		During execution, the value of A remains unchanged. X is incremented by four and Y is incremented
		by one.

		*/

		// Grade of Membership (gm)  M(Y)
		uint8_t gm;
		uint8_t p1, p2;

		uint8_t aVal = cpu->getRegA();
		address_t xVal = cpu->getRegX();
		address_t yVal = cpu->getRegY();

		p1 = cpu->memRead8(xVal);
		p2 = cpu->memRead8(xVal+1);

		if ((aVal < p1) or (aVal > p2)) {
			gm = 0;
			} else {
			uint8_t s1, s2, min1, min2;


			s1 = cpu->memRead8(xVal+2);
			s2 = cpu->memRead8(xVal+3);

			min1 = (aVal - p1) * s1;
			min2 = (p2 - aVal) * s2;
			if (min1 < min2) {
				cpu->memWrite8(yVal, min1);
				} else {
				cpu->memWrite8(yVal, min2);
			}
		}

		// (Y) + 0x0001  Y
		cpu->setRegY(yVal + 1);

		// (X) + 0x0004  X
		cpu->setRegX(xVal + 4);

	}
#line 49197 "hcs12x.cc"
}

static Operation *DecodeOpMem(CodeType const& code, uint16_t addr)
{
	return new OpMem(code, addr);
}

// REV: (8bits) MIN-MAX rule evaluation
// this instruction can be interrupted.
#line 88 "hcs12x.isa"
uint8_t
#line 49209 "hcs12x.cc"
OpRev::getCycles()
{
#line 119 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{ return 0; /* TODO: take in account the fact that it may be interrupted */}
#line 49214 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49218 "hcs12x.cc"
OpRev::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49222 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49225 "hcs12x.cc"
)
{
#line 121 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		string mnem = "REV";

		sink << mnem;

		return mnem;
	}
#line 49236 "hcs12x.cc"
}
// *** INTERRUPTIBLE ***
#line 67 "hcs12x.isa"
void
#line 49241 "hcs12x.cc"
OpRev::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49245 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49248 "hcs12x.cc"
)
{
#line 130 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/* The V flag is affected by operation.
		* The final state for the others CCR flags is not defined.
		*/

		uint8_t aVal, ccrV, memX, memYX;
		address_t  xVal, yVal;

		xVal = cpu->getRegX();
		yVal = cpu->getRegY();

		memX = cpu->memRead8(xVal);
		while (memX != 0xFF) {

			ccrV = 0;
			aVal = 0xFF;
			while ((memX != 0xFE) && (memX != 0xFF)) {
				memYX = cpu->memRead8(yVal+memX);
				if (memYX < aVal) {
					aVal = memYX;
				}
				xVal++;
				memX = cpu->memRead8(xVal);
			}

			if (memX != 0xFF) {

				ccrV = 1;
				xVal++;
				memX = cpu->memRead8(xVal);
				while ((memX != 0xFE) && (memX != 0xFF)) {
					memYX = cpu->memRead8(yVal+memX);
					if (aVal > memYX) {
						cpu->memWrite8(yVal+memX, aVal);
					}
					xVal++;
					memX = cpu->memRead8(xVal);
				}

				if (memX != 0xFF) {
					xVal++;
					memX = cpu->memRead8(xVal);
				}
			}

			// check asynchronous interruptions
			if (cpu->HasAsynchronousInterrupt())
			{
				throw AsynchronousException();
			}

		}

		xVal++;

		cpu->setRegA(aVal);
		cpu->setRegX(xVal);
		cpu->setRegY(yVal);
		if (ccrV) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	}
#line 49312 "hcs12x.cc"
}

static Operation *DecodeOpRev(CodeType const& code, uint16_t addr)
{
	return new OpRev(code, addr);
}

// REVW: (16bits) MIN-MAX rule evaluation
// this instruction can be interrupted.
#line 88 "hcs12x.isa"
uint8_t
#line 49324 "hcs12x.cc"
OpRevw::getCycles()
{
#line 195 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{ return 0; /* TODO: take in account the fact that it may be interrupted */}
#line 49329 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49333 "hcs12x.cc"
OpRevw::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49337 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49340 "hcs12x.cc"
)
{
#line 197 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		string mnem = "REVW";

		sink << mnem;

		return mnem;
	}
#line 49351 "hcs12x.cc"
}
// *** INTERRUPTIBLE ***
#line 67 "hcs12x.isa"
void
#line 49356 "hcs12x.cc"
OpRevw::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49360 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49363 "hcs12x.cc"
)
{
#line 206 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/* The V flag is affected by operation.
		* The C flag is used for special purpose.
		* The final state for the others CCR flags is not defined.
		*/

		uint8_t aVal, ccrV, ccrC, memOfMemX, memY;
		address_t memX, xVal, yVal;

		xVal = cpu->getRegX();
		yVal = cpu->getRegY(); cpu->setRegTMP(1, yVal);  // (Y) weight pointer kept in TMP2
		ccrC = cpu->ccr->getC();

		memX = cpu->memRead16(xVal);
		while (memX != 0xFFFF) {

			ccrV = 0;
			aVal = 0xFF;
			while ((memX != 0xFFFE) && (memX != 0xFFFF)) {
				memOfMemX = cpu->memRead8(memX);
				if (memOfMemX < aVal) {
					aVal = memOfMemX;
				}
				xVal++;
				memX = cpu->memRead16(xVal);
			}

			if (memX != 0xFFFF) {
				// *** Apply weight	***
				if (ccrC == 1) {
					memY = cpu->memRead8(yVal);
					aVal = (uint8_t) ((uint16_t) aVal * (memY+1)) >> 8;  // cpu->setRegA(aVal);
					yVal++;  cpu->setRegTMP(1, yVal); // cpu->setRegY(yVal);
				}

				ccrV = 1;
				xVal++;
				memX = cpu->memRead16(xVal);
				while ((memX != 0xFFFE) && (memX != 0xFFFF)) {
					memOfMemX = cpu->memRead16(memX);
					if (aVal > memOfMemX) {
						cpu->memWrite8(memX, aVal);
					}
					xVal++;
					memX = cpu->memRead16(xVal);
				}

				if (memX != 0xFFFF) {
					xVal++;
					memX = cpu->memRead16(xVal);
				}
			}

			// check asynchronous interruptions
			if (cpu->HasAsynchronousInterrupt())
			{
				throw AsynchronousException();
			}

		}

		xVal++;

		cpu->setRegA(aVal);
		cpu->setRegX(xVal);
		cpu->setRegY(yVal);
		if (ccrV) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

	}
#line 49436 "hcs12x.cc"
}

static Operation *DecodeOpRevw(CodeType const& code, uint16_t addr)
{
	return new OpRevw(code, addr);
}

// WAV: Weighted Average Calculation
/*
This instruction can be interrupted.
New WAV instructions can be started and interrupted while a previous WAV instruction is interrupted
*/
#line 88 "hcs12x.isa"
uint8_t
#line 49451 "hcs12x.cc"
OpWav::getCycles()
{
#line 284 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{ return 0; /* TODO: take in account the fact that it may be interrupted */}
#line 49456 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49460 "hcs12x.cc"
OpWav::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49464 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49467 "hcs12x.cc"
)
{
#line 286 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		string mnem = "WAV";

		sink << mnem;

		return mnem;
	}
#line 49478 "hcs12x.cc"
}
// *** INTERRUPTIBLE ***
#line 67 "hcs12x.isa"
void
#line 49483 "hcs12x.cc"
OpWav::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49487 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49490 "hcs12x.cc"
)
{
#line 295 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/* The Z flag is affected by operation.
		* The final state for the others CCR flags is not defined.
		*/

		/*
		* Do until B = 0, leave SOP in Y : D, SOW in X
		*   Partial Product = (M pointed to by X)  (M pointed to by Y)
		*   Sum-of-Products (24-bit SOP) = Previous SOP + Partial Product
		*   Sum-of-Weights (16-bit SOW) = Previous SOW + (M pointed to by Y)
		*   (X) + 0x0001  X; (Y) + 0x0001  Y
		*   (B)  0x01  B
		**/

		uint8_t bVal, memX, memY;
		address_t xVal, yVal;
		uint32_t sop;
		uint16_t pp, sow;

		bVal = cpu->getRegB();
		xVal = cpu->getRegX();
		yVal = cpu->getRegY();
		sop = 0;
		sow = 0;
		cpu->setRegTMP(0, 0x0000);
		cpu->setRegTMP(1, 0x0000);
		cpu->setRegTMP(2, 0x0000);

		while (bVal > 0) {

			/** TODO: WAV is interruptible only at this point and not after.
			* if (InterruptPending)
			* {
				*   Write word @ -2,SP (stack TMP3); SP = SP - 2;
				*   Write word @ -2,SP (stack TMP2); SP = SP - 2;
				*   Write word @ -2,SP (stack TMP1); SP = SP - 2;
				*   Adjust PC to point at 0x3C wavr pseudo-opcode (The second byte of WAV opcode).
				* }
			**/

			// check asynchronous interruptions
			if (cpu->HasAsynchronousInterrupt())
			{
				cpu->setRegSP(cpu->getRegSP()-2);
				cpu->memWrite16(cpu->getRegSP(), cpu->getRegTMP(2));
				cpu->setRegSP(cpu->getRegSP()-2);
				cpu->memWrite16(cpu->getRegSP(), cpu->getRegTMP(1));
				cpu->setRegSP(cpu->getRegSP()-2);
				cpu->memWrite16(cpu->getRegSP(), cpu->getRegTMP(0));

				//   Adjust PC to point at 0x3C wavr pseudo-opcode
				cpu->setRegPC(cpu->getRegPC()-1);

				throw AsynchronousException();

			}


			memY = cpu->memRead8(yVal);
			memX = cpu->memRead8(xVal);

			pp = memX * memY;
			sop += pp;
			cpu->setRegTMP(2, (uint16_t) (sop >> 16));
			cpu->setRegTMP(1, (uint16_t) sop);

			sow += memY;
			cpu->setRegTMP(0, sow);

			xVal++;
			yVal++;
			bVal--;

		}

		cpu->setRegB(bVal);
		cpu->setRegY(cpu->getRegTMP(2));
		cpu->setRegD(cpu->getRegTMP(1));
		cpu->setRegX(cpu->getRegTMP(0));

		cpu->ccr->setZ();
	}
#line 49576 "hcs12x.cc"
}

static Operation *DecodeOpWav(CodeType const& code, uint16_t addr)
{
	return new OpWav(code, addr);
}

// WAVR pseudo instruction: Resume execution of interrupted WAV instruction
#line 88 "hcs12x.isa"
uint8_t
#line 49587 "hcs12x.cc"
OpWavr::getCycles()
{
#line 381 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{ return 0; /* TODO: linked to WAV instruction */}
#line 49592 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49596 "hcs12x.cc"
OpWavr::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49600 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49603 "hcs12x.cc"
)
{
#line 383 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		string mnem = "WAVR";

		sink << mnem;

		return mnem;
	}
#line 49614 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 49618 "hcs12x.cc"
OpWavr::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49622 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49625 "hcs12x.cc"
)
{
#line 391 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/* The Z flag is affected by operation.
		* The final state for the others CCR flags is not defined.
		*/

		address_t sp = cpu->getRegSP();
		cpu->setRegTMP(0, cpu->memRead16(sp));
		cpu->setRegTMP(1, cpu->memRead16(sp+2));
		cpu->setRegTMP(2, cpu->memRead16(sp+4));
		cpu->setRegSP(sp+6);

		if ((cpu->getRegTMP(0) == 0) ||
		(cpu->getRegTMP(1) == 0) ||
		(cpu->getRegTMP(2) == 0))
		{
			cpu->ccr->setZ();
			} else {
			cpu->ccr->clrZ();
		}
	}
#line 49649 "hcs12x.cc"
}

static Operation *DecodeOpWavr(CodeType const& code, uint16_t addr)
{
	return new OpWavr(code, addr);
}

/* ********  TABLE INTERPOLATION Instructions ********* */
// TBL: 8-bit Table lookup and Interpolate
#line 88 "hcs12x.isa"
uint8_t
#line 49661 "hcs12x.cc"
OpTbl::getCycles()
{
#line 417 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{ return 6; }
#line 49666 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49670 "hcs12x.cc"
OpTbl::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49674 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49677 "hcs12x.cc"
)
{
#line 419 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		string mnem = "TBL";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 49689 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 49693 "hcs12x.cc"
OpTbl::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49697 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49700 "hcs12x.cc"
)
{
#line 428 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/*
		Operation: (M) + [(B) * ((M+1) - (M))] => A
		The intermediate value [(B) * (Y2 - Y1)] produces a 16-bit result
		with the radix point between bits 7 and 8.

		N: Set if MSB of result is set; cleared otherwise
		Z: Set if result is 0x00; cleared otherwise
		C: Set if result can be rounded up; cleared otherwise
		*/

		physical_address_t addr = xb->getEAddr(cpu);

		uint8_t bVal = cpu->getRegB();
		uint8_t mVal = cpu->memRead8(addr);
		uint8_t m1Val = cpu->memRead8(addr+1);

		uint16_t result = (uint16_t) mVal + (bVal * (m1Val - mVal));
		uint8_t msBits = (uint8_t) (result >> 8);
		uint8_t lowBits = (uint8_t) result;

		cpu->setRegA(msBits);
		if ((msBits & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN();}
		if (msBits == 0x00) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ();}
		if (lowBits > 0x7F) { cpu->ccr->setC(); } else { cpu->ccr->clrC();}
	}
#line 49730 "hcs12x.cc"
}

static Operation *DecodeOpTbl(CodeType const& code, uint16_t addr)
{
	return new OpTbl(code, addr);
}

// ETBL: 16-bit Table lookup and Interpolate
#line 88 "hcs12x.isa"
uint8_t
#line 49741 "hcs12x.cc"
OpEtlb::getCycles()
{
#line 459 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{ return 10; }
#line 49746 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49750 "hcs12x.cc"
OpEtlb::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49754 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49757 "hcs12x.cc"
)
{
#line 461 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		string mnem = "ETBL";

		sink << mnem << " ";
		xb->disasm(sink);

		return mnem;
	}
#line 49769 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 49773 "hcs12x.cc"
OpEtlb::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49777 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49780 "hcs12x.cc"
)
{
#line 470 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/*
		Operation: D = M + [(B) * ((M+2) - (M))]
		The intermediate value [(B) * ((M+2) - (M))] produces a 24-bit result
		with the radix point between bits 7 and 8.
		*/

		physical_address_t addr = xb->getEAddr(cpu);

		uint8_t bVal = cpu->getRegB();
		uint16_t mVal = cpu->memRead16(addr);
		uint16_t m1Val = cpu->memRead16(addr+2);

		uint32_t result = (uint32_t) mVal + (bVal * (m1Val - mVal));
		uint16_t msBits = (uint16_t) (result >> 8);
		uint8_t lowBits = (uint8_t) result;

		cpu->setRegD(msBits);
		if ((msBits & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN();}
		if (result == 0x0000) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ();}
		if (lowBits > 0x7F) { cpu->ccr->setC(); } else { cpu->ccr->clrC();}
	}
#line 49806 "hcs12x.cc"
}

static Operation *DecodeOpEtlb(CodeType const& code, uint16_t addr)
{
	return new OpEtlb(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// NOP:
#line 88 "hcs12x.isa"
uint8_t
#line 49850 "hcs12x.cc"
OpNop::getCycles()
{
#line 39 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{ return 1; }
#line 49855 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49859 "hcs12x.cc"
OpNop::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49863 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49866 "hcs12x.cc"
)
{
#line 41 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		string mnem = "NOP";

		sink << mnem;
		return mnem;
	}
#line 49876 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 49880 "hcs12x.cc"
OpNop::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49884 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49887 "hcs12x.cc"
)
{
#line 48 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		// This single-byte instruction increments the PC and does nothing else.
	}
#line 49894 "hcs12x.cc"
}

static Operation *DecodeOpNop(CodeType const& code, uint16_t addr)
{
	return new OpNop(code, addr);
}

// STOP:
#line 88 "hcs12x.isa"
uint8_t
#line 49905 "hcs12x.cc"
OpStop::getCycles()
{
#line 57 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{ if (stopDisabled) return 2; else return 16; }
#line 49910 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 49914 "hcs12x.cc"
OpStop::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 49918 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 49921 "hcs12x.cc"
)
{
#line 59 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		string mnem = "STOP";

		sink << mnem;
		return mnem;
	}
#line 49931 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 49935 "hcs12x.cc"
OpStop::execute(
#line 67 "hcs12x.isa"
CPU *
#line 49939 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 49942 "hcs12x.cc"
)
{
#line 66 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{

		if (cpu->ccr->getS() == 1) {
			stopDisabled = true;
			/*
			* if S control bit = 1, the STOP instruction is disabled and acts like two-cycle NOP
			*/
			// TODO: consume two cycles
			} else {
			stopDisabled = false;
			/*
			* (SP)  0x0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
			* (SP)  0x0002 => SP; YH : YL => (M(SP) : M(SP+1))
			* (SP)  0x0002 => SP; XH : XL => (M(SP) : M(SP+1))
			* (SP)  0x0002 => SP; B : A => (M(SP) : M(SP+1))
			* (SP)  0x0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
			* Stop All Clocks and puts the device in standby mode
			*/

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite16(cpu->getRegSP(), cpu->getRegPC());

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite16(cpu->getRegSP(), cpu->getRegY());

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite16(cpu->getRegSP(), cpu->getRegX());

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite16(cpu->getRegSP(), cpu->getRegD());

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite16(cpu->getRegSP(), cpu->ccr->getCCR());

		/* TODO:
			* Stop All Clocks and puts the device in standby mode.
			* Asserting the RESET, XIRQ, or IRQ signals ends standby mode.
			*/

			cpu->Sleep();

		/* TODO:
			* If XIRQ is asserted while the X mask bit = 0 (XIRQ interrupts enabled),
			* execution resumes with a vector fetch for the XIRQ interrupt.
			* While the X mask bit = 1 (XIRQ interrupts disabled),
			* a 2-cycle recovery sequence is used to adjust the instruction queue and the stack pointer,
			* and execution continues with the next instruction after STOP.
			*/



		}
	}
#line 49999 "hcs12x.cc"
}

static Operation *DecodeOpStop(CodeType const& code, uint16_t addr)
{
	return new OpStop(code, addr);
}

// WAIT
#line 88 "hcs12x.isa"
uint8_t
#line 50010 "hcs12x.cc"
OpWai::getCycles()
{
#line 123 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{ return 13; }
#line 50015 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 50019 "hcs12x.cc"
OpWai::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 50023 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 50026 "hcs12x.cc"
)
{
#line 125 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		string mnem = "WAI";

		sink << mnem;
		return mnem;
	}
#line 50036 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 50040 "hcs12x.cc"
OpWai::execute(
#line 67 "hcs12x.isa"
CPU *
#line 50044 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 50047 "hcs12x.cc"
)
{
#line 132 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{

		/*
		* (SP)  0x0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; YH : YL => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; XH : XL => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; B : A => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
		* The CPU12 then enters a wait state for an integer number of bus clock cycles.
		* During the wait state, CPU12 clocks are stopped, but otherMCUclocks can continue to run.
		* WAIT for not masked interrupt
		*/

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->getRegSP(), cpu->getRegPC());

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->getRegSP(), cpu->getRegY());

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->getRegSP(), cpu->getRegX());

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite8(cpu->getRegSP(), cpu->getRegB());
		cpu->memWrite8(cpu->getRegSP()+1, cpu->getRegA());

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->getRegSP(), cpu->ccr->getCCR());

	/* TODO:
		* Enter a wait state for an integer number of bus clock cycle
		* Only CPU12 clocks are stopped
		* Wait for not masked interrupt
		*/

		cpu->Wait();

		/*
		* If XIRQ is asserted while the X mask bit = 0 (XIRQ interrupts enabled),
		* execution resumes with a vector fetch for the XIRQ interrupt.
		* While the X mask bit = 1 (XIRQ interrupts disabled),
		* a 2-cycle recovery sequence is used to adjust the instruction queue and the stack pointer,
		* and execution continues with the next instruction after WAI.
		*/
	}
#line 50096 "hcs12x.cc"
}

static Operation *DecodeOpWai(CodeType const& code, uint16_t addr)
{
	return new OpWai(code, addr);
}

// BGND: Enter Background debug mode
#line 88 "hcs12x.isa"
uint8_t
#line 50107 "hcs12x.cc"
OpBgnd::getCycles()
{
#line 182 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{ return 5; }
#line 50112 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 50116 "hcs12x.cc"
OpBgnd::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 50120 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 50123 "hcs12x.cc"
)
{
#line 184 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		string mnem = "BGND";

		sink << mnem;
		return mnem;
	}
#line 50133 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 50137 "hcs12x.cc"
OpBgnd::execute(
#line 67 "hcs12x.isa"
CPU *
#line 50141 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 50144 "hcs12x.cc"
)
{
#line 191 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		// TODO
		cpu->ReportTrap();
	}
#line 50152 "hcs12x.cc"
}

static Operation *DecodeOpBgnd(CodeType const& code, uint16_t addr)
{
	return new OpBgnd(code, addr);
}

/* ********** Interrupt instructions ******** */
// RTI: Return from interrupt
#line 88 "hcs12x.isa"
uint8_t
#line 50164 "hcs12x.cc"
OpRti::getCycles()
{
#line 204 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{ if (isPending) return 10; else return 8; }
#line 50169 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 50173 "hcs12x.cc"
OpRti::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 50177 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 50180 "hcs12x.cc"
)
{
#line 206 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		string mnem = "RTI";

		sink << mnem;
		return mnem;
	}
#line 50190 "hcs12x.cc"
}
// TODO: check if there is interrupt pending and set "isPending"
#line 67 "hcs12x.isa"
void
#line 50195 "hcs12x.cc"
OpRti::execute(
#line 67 "hcs12x.isa"
CPU *
#line 50199 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 50202 "hcs12x.cc"
)
{
#line 215 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{

		/*
		* (M(SP) : M(SP+1)) => CCRH : CCRL; (SP) + 0x0002 => SP
		* (M(SP) : M(SP+1)) => B : A; (SP) + 0x0002 => SP
		* (M(SP) : M(SP+1)) => XH : XL; (SP) + 0x0004 => SP
		* (M(SP) : M(SP+1)) => PCH : PCL; (SP)  0x0002 => SP
		* (M(SP) : M(SP+1)) => YH : YL; (SP) + 0x0004 => SP
		* */

		address_t addr = cpu->getRegSP();

		/* Leave bit X unchanged.
		* X bit can be set only by a reset or by recognition of an (!XIRQ) interrupt
		*/
		cpu->ccr->setCCR(cpu->memRead16(addr));

		addr = addr + 2;
		cpu->setRegB(cpu->memRead8(addr));
		cpu->setRegA(cpu->memRead8(addr+1));

		addr = addr + 2;
		cpu->setRegX(cpu->memRead16(addr));

		addr = addr + 2;
		cpu->setRegY(cpu->memRead16(addr));

		addr = addr + 2;
		cpu->setRegPC(cpu->memRead16(addr));

		addr = addr + 2;
		cpu->setRegSP(addr);
	}
#line 50239 "hcs12x.cc"
}

static Operation *DecodeOpRti(CodeType const& code, uint16_t addr)
{
	return new OpRti(code, addr);
}

// SWI: Software Interrupt
#line 88 "hcs12x.isa"
uint8_t
#line 50250 "hcs12x.cc"
OpSwi::getCycles()
{
#line 253 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{ return 9; }
#line 50255 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 50259 "hcs12x.cc"
OpSwi::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 50263 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 50266 "hcs12x.cc"
)
{
#line 255 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		string mnem = "SWI";

		sink << mnem;
		return mnem;
	}
#line 50276 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 50280 "hcs12x.cc"
OpSwi::execute(
#line 67 "hcs12x.isa"
CPU *
#line 50284 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 50287 "hcs12x.cc"
)
{
#line 262 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		/* (SP)  0x0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; YH : YL => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; XH : XL => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; B : A=> (M(SP) : M(SP+1))
		* In case of CPU12
		* (SP)  0x0001 => SP; CCR => (M(SP) )
		* In case of CPU12X
		* (SP)  0x0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
		* 1 => I; 0 => U
		* (SWI Vector) => PC
		*/

		throw NonMaskableSWIInterrupt();
	}
#line 50306 "hcs12x.cc"
}

static Operation *DecodeOpSwi(CodeType const& code, uint16_t addr)
{
	return new OpSwi(code, addr);
}

// SYS: System Call Interrupt
// System call interrupt vector is 0xFF12:0xFF13
#line 88 "hcs12x.isa"
uint8_t
#line 50318 "hcs12x.cc"
OpSys::getCycles()
{
#line 347 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{ return 10; }
#line 50323 "hcs12x.cc"
}
#line 73 "hcs12x.isa"
string
#line 50327 "hcs12x.cc"
OpSys::disasm(
#line 73 "hcs12x.isa"
ostream&
#line 50331 "hcs12x.cc"
#line 73 "hcs12x.isa"
sink
#line 50334 "hcs12x.cc"
)
{
#line 349 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		string mnem = "SYS";

		sink << mnem;
		return mnem;
	}
#line 50344 "hcs12x.cc"
}
#line 67 "hcs12x.isa"
void
#line 50348 "hcs12x.cc"
OpSys::execute(
#line 67 "hcs12x.isa"
CPU *
#line 50352 "hcs12x.cc"
#line 67 "hcs12x.isa"
cpu
#line 50355 "hcs12x.cc"
)
{
#line 356 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{

		/*
		* (SP)  0x0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; YH : YL => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; XH : XL => (M(SP) : M(SP+1))
		* (SP)  0x0002 => SP; B : A => (M(SP) : M(SP+1))
		* In case of CPU12
		* (SP)  0x0001 => SP; CCR => (M(SP) )
		* In case of CPU12X
		* (SP)  0x0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
		* 1 => I; 0 => U
		* (Trap Vector) => PC
		*/

		throw SysCallInterrupt();

	}
#line 50377 "hcs12x.cc"
}

static Operation *DecodeOpSys(CodeType const& code, uint16_t addr)
{
	return new OpSys(code, addr);
}

OpCall_idx::OpCall_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "call_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		page = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpCall_idx::~OpCall_idx()
{
	delete xb;
}

OpTrap::OpTrap(CodeType const& code, uint16_t addr) : Operation(code, addr, "trap")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		trapnum = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLdaab_imm::OpLdaab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "ldaab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLdaab_dir::OpLdaab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "ldaab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLdaab_ext::OpLdaab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ldaab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLdaab_idx::OpLdaab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ldaab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLdaab_idx::~OpLdaab_idx()
{
	delete xb;
}

OpLd_dyxs_imm::OpLd_dyxs_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "ld_dyxs_imm")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLd_dyxs_dir::OpLd_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "ld_dyxs_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLd_dyxs_ext::OpLd_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ld_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLd_dyxs_idx::OpLd_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ld_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLd_dyxs_idx::~OpLd_dyxs_idx()
{
	delete xb;
}

OpLeay::OpLeay(CodeType const& code, uint16_t addr) : Operation(code, addr, "leay")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLeay::~OpLeay()
{
	delete xb;
}

OpLeax::OpLeax(CodeType const& code, uint16_t addr) : Operation(code, addr, "leax")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLeax::~OpLeax()
{
	delete xb;
}

OpLeas::OpLeas(CodeType const& code, uint16_t addr) : Operation(code, addr, "leas")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLeas::~OpLeas()
{
	delete xb;
}

OpStaab_dir::OpStaab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "staab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 8) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpStaab_ext::OpStaab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "staab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpStaab_idx::OpStaab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "staab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpStaab_idx::~OpStaab_idx()
{
	delete xb;
}

OpSt_dyxs_dir::OpSt_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "st_dyxs_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSt_dyxs_ext::OpSt_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "st_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSt_dyxs_idx::OpSt_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "st_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSt_dyxs_idx::~OpSt_dyxs_idx()
{
	delete xb;
}

OpGldaab_dir::OpGldaab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "gldaab_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGldaab_ext::OpGldaab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "gldaab_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGldaab_idx::OpGldaab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "gldaab_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpGldaab_idx::~OpGldaab_idx()
{
	delete xb;
}

OpGld_dyxs_dir::OpGld_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "gld_dyxs_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGld_dyxs_ext::OpGld_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "gld_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGld_dyxs_idx::OpGld_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "gld_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpGld_dyxs_idx::~OpGld_dyxs_idx()
{
	delete xb;
}

OpGstaab_dir::OpGstaab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "gstaab_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 8) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGstaab_ext::OpGstaab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "gstaab_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGstaab_idx::OpGstaab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "gstaab_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpGstaab_idx::~OpGstaab_idx()
{
	delete xb;
}

OpGst_dyxs_dir::OpGst_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "gst_dyxs_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGst_dyxs_ext::OpGst_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "gst_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGst_dyxs_idx::OpGst_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "gst_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpGst_dyxs_idx::~OpGst_dyxs_idx()
{
	delete xb;
}

OpT_ab_ba::OpT_ab_ba(CodeType const& code, uint16_t addr) : Operation(code, addr, "t_ab_ba")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpExg_hcs12::OpExg_hcs12(CodeType const& code, uint16_t addr) : Operation(code, addr, "exg_hcs12")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		lms = ((_subword_ >> 4) & 0x7ULL);
		lls = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpTfr_hcs12::OpTfr_hcs12(CodeType const& code, uint16_t addr) : Operation(code, addr, "tfr_hcs12")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		lms = ((_subword_ >> 4) & 0x7ULL);
		hls = ((_subword_ >> 3) & 0x1ULL);
		lls = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpExg_hcs12x::OpExg_hcs12x(CodeType const& code, uint16_t addr) : Operation(code, addr, "exg_hcs12x")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		lms = ((_subword_ >> 4) & 0x7ULL);
		lls = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpTfr_hcs12x::OpTfr_hcs12x(CodeType const& code, uint16_t addr) : Operation(code, addr, "tfr_hcs12x")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		lms = ((_subword_ >> 4) & 0x7ULL);
		lls = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpMovb_0B::OpMovb_0B(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_0B")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		ii = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovb_08::OpMovb_08(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_08")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		ii = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpMovb_08::~OpMovb_08()
{
	delete xb;
}

OpMovb_0C::OpMovb_0C(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_0C")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16asrc = ((_subword_ >> 16) & 0xffffULL);
		opr16adst = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpMovb_09::OpMovb_09(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_09")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16asrc = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovb_09::~OpMovb_09()
{
	delete xb;
}

OpMovb_0D::OpMovb_0D(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_0D")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovb_0D::~OpMovb_0D()
{
	delete xb;
}

OpMovb_0A::OpMovb_0A(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_0A")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xbsrc = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xbsrc->GetEncoding().size );
	xbdst = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xbdst->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMovb_0A::~OpMovb_0A()
{
	delete xbsrc;
	delete xbdst;
}

OpMovw_03::OpMovw_03(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_03")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovw_04::OpMovw_04(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_04")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16asrc = ((_subword_ >> 16) & 0xffffULL);
		opr16adst = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpMovw_00::OpMovw_00(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_00")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovw_00::~OpMovw_00()
{
	delete xb;
}

OpMovw_01::OpMovw_01(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_01")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16asrc = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovw_01::~OpMovw_01()
{
	delete xb;
}

OpMovw_05::OpMovw_05(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_05")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovw_05::~OpMovw_05()
{
	delete xb;
}

OpMovw_02::OpMovw_02(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_02")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xbsrc = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xbsrc->GetEncoding().size );
	xbdst = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xbdst->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMovw_02::~OpMovw_02()
{
	delete xbsrc;
	delete xbdst;
}

OpAba::OpAba(CodeType const& code, uint16_t addr) : Operation(code, addr, "aba")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAbx::OpAbx(CodeType const& code, uint16_t addr) : Operation(code, addr, "abx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAby::OpAby(CodeType const& code, uint16_t addr) : Operation(code, addr, "aby")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_imm::OpAdc_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "adc_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_dir::OpAdc_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "adc_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_ext::OpAdc_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "adc_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_idx::OpAdc_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "adc_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_idx::~OpAdc_ab_idx()
{
	delete xb;
}

OpAdd_ab_imm::OpAdd_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_ab_dir::OpAdd_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_ab_ext::OpAdd_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_ab_idx::OpAdd_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAdd_ab_idx::~OpAdd_ab_idx()
{
	delete xb;
}

OpAded_imm::OpAded_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "aded_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAded_dir::OpAded_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "aded_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAded_ext::OpAded_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "aded_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAded_idx::OpAded_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "aded_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAded_idx::~OpAded_idx()
{
	delete xb;
}

OpAde_xy_imm::OpAde_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "ade_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAde_xy_dir::OpAde_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "ade_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAde_xy_ext::OpAde_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ade_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAde_xy_idx::OpAde_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ade_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAde_xy_idx::~OpAde_xy_idx()
{
	delete xb;
}

OpAdd_xy_imm::OpAdd_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAdd_xy_dir::OpAdd_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_xy_ext::OpAdd_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_xy_idx::OpAdd_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAdd_xy_idx::~OpAdd_xy_idx()
{
	delete xb;
}

OpAdd_sub_d_imm::OpAdd_sub_d_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_sub_d_imm")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_sub_d_dir::OpAdd_sub_d_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_sub_d_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_sub_d_ext::OpAdd_sub_d_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_sub_d_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_sub_d_idx::OpAdd_sub_d_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_sub_d_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAdd_sub_d_idx::~OpAdd_sub_d_idx()
{
	delete xb;
}

OpSba::OpSba(CodeType const& code, uint16_t addr) : Operation(code, addr, "sba")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_imm::OpSbc_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbc_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_dir::OpSbc_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbc_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_ext::OpSbc_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbc_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_idx::OpSbc_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbc_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_idx::~OpSbc_ab_idx()
{
	delete xb;
}

OpSbed_imm::OpSbed_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbed_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpSbed_dir::OpSbed_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbed_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbed_ext::OpSbed_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbed_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbed_idx::OpSbed_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbed_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSbed_idx::~OpSbed_idx()
{
	delete xb;
}

OpSbe_xy_imm::OpSbe_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbe_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpSbe_xy_dir::OpSbe_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbe_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbe_xy_ext::OpSbe_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbe_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbe_xy_idx::OpSbe_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbe_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSbe_xy_idx::~OpSbe_xy_idx()
{
	delete xb;
}

OpSub_ab_imm::OpSub_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_ab_dir::OpSub_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_ab_ext::OpSub_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_ab_idx::OpSub_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSub_ab_idx::~OpSub_ab_idx()
{
	delete xb;
}

OpSub_xy_imm::OpSub_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpSub_xy_dir::OpSub_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_xy_ext::OpSub_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_xy_idx::OpSub_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSub_xy_idx::~OpSub_xy_idx()
{
	delete xb;
}

OpDaa::OpDaa(CodeType const& code, uint16_t addr) : Operation(code, addr, "daa")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpDec_ext::OpDec_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "dec_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpDec_idx::OpDec_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "dec_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpDec_idx::~OpDec_idx()
{
	delete xb;
}

OpDec_ab::OpDec_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "dec_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpDecw_ext::OpDecw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "decw_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpDecw_idx::OpDecw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "decw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpDecw_idx::~OpDecw_idx()
{
	delete xb;
}

OpDec_xy::OpDec_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "dec_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpDes::OpDes(CodeType const& code, uint16_t addr) : Operation(code, addr, "des")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpDex::OpDex(CodeType const& code, uint16_t addr) : Operation(code, addr, "dex")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpDey::OpDey(CodeType const& code, uint16_t addr) : Operation(code, addr, "dey")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpInc_ext::OpInc_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "inc_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpInc_idx::OpInc_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "inc_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpInc_idx::~OpInc_idx()
{
	delete xb;
}

OpInc_ab::OpInc_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "inc_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpIncw_ext::OpIncw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "incw_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpIncw_idx::OpIncw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "incw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpIncw_idx::~OpIncw_idx()
{
	delete xb;
}

OpInc_xy::OpInc_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "inc_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpIns::OpIns(CodeType const& code, uint16_t addr) : Operation(code, addr, "ins")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpInx::OpInx(CodeType const& code, uint16_t addr) : Operation(code, addr, "inx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpIny::OpIny(CodeType const& code, uint16_t addr) : Operation(code, addr, "iny")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpCba::OpCba(CodeType const& code, uint16_t addr) : Operation(code, addr, "cba")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_imm::OpCmp_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "cmp_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_dir::OpCmp_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "cmp_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_ext::OpCmp_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "cmp_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_idx::OpCmp_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "cmp_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_idx::~OpCmp_ab_idx()
{
	delete xb;
}

OpCp_dyxs_imm::OpCp_dyxs_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "cp_dyxs_imm")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCp_dyxs_dir::OpCp_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "cp_dyxs_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCp_dyxs_ext::OpCp_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "cp_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCp_dyxs_idx::OpCp_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "cp_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpCp_dyxs_idx::~OpCp_dyxs_idx()
{
	delete xb;
}

OpCpe_dyxs_imm::OpCpe_dyxs_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "cpe_dyxs_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCpe_dyxs_dir::OpCpe_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "cpe_dyxs_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCpe_dyxs_ext::OpCpe_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "cpe_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCpe_dyxs_idx::OpCpe_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "cpe_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpCpe_dyxs_idx::~OpCpe_dyxs_idx()
{
	delete xb;
}

OpTst_ext::OpTst_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "tst_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpTst_idx::OpTst_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "tst_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpTst_idx::~OpTst_idx()
{
	delete xb;
}

OpTst_ab::OpTst_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "tst_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpTstw_ext::OpTstw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "tstw_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpTstw_idx::OpTstw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "tstw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpTstw_idx::~OpTstw_idx()
{
	delete xb;
}

OpTst_xy::OpTst_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "tst_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEmind::OpEmind(CodeType const& code, uint16_t addr) : Operation(code, addr, "emind")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEmind::~OpEmind()
{
	delete xb;
}

OpEminm::OpEminm(CodeType const& code, uint16_t addr) : Operation(code, addr, "eminm")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEminm::~OpEminm()
{
	delete xb;
}

OpMina::OpMina(CodeType const& code, uint16_t addr) : Operation(code, addr, "mina")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMina::~OpMina()
{
	delete xb;
}

OpMinm::OpMinm(CodeType const& code, uint16_t addr) : Operation(code, addr, "minm")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMinm::~OpMinm()
{
	delete xb;
}

OpEmaxd::OpEmaxd(CodeType const& code, uint16_t addr) : Operation(code, addr, "emaxd")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEmaxd::~OpEmaxd()
{
	delete xb;
}

OpEmaxm::OpEmaxm(CodeType const& code, uint16_t addr) : Operation(code, addr, "emaxm")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEmaxm::~OpEmaxm()
{
	delete xb;
}

OpMaxa::OpMaxa(CodeType const& code, uint16_t addr) : Operation(code, addr, "maxa")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMaxa::~OpMaxa()
{
	delete xb;
}

OpMaxm::OpMaxm(CodeType const& code, uint16_t addr) : Operation(code, addr, "maxm")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMaxm::~OpMaxm()
{
	delete xb;
}

OpAnd_ab_imm::OpAnd_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAnd_ab_dir::OpAnd_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAnd_ab_ext::OpAnd_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAnd_ab_idx::OpAnd_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAnd_ab_idx::~OpAnd_ab_idx()
{
	delete xb;
}

OpAndcc_imm::OpAndcc_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "andcc_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_imm::OpAnd_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_dir::OpAnd_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_xy_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_ext::OpAnd_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_xy_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_idx::OpAnd_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_idx::~OpAnd_xy_idx()
{
	delete xb;
}

OpOra_ab_imm::OpOra_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "ora_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpOra_ab_dir::OpOra_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "ora_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpOra_ab_ext::OpOra_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ora_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpOra_ab_idx::OpOra_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ora_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpOra_ab_idx::~OpOra_ab_idx()
{
	delete xb;
}

OpOrcc_imm::OpOrcc_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "orcc_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpOr_xy_imm::OpOr_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "or_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpOr_xy_dir::OpOr_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "or_xy_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpOr_xy_ext::OpOr_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "or_xy_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpOr_xy_idx::OpOr_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "or_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpOr_xy_idx::~OpOr_xy_idx()
{
	delete xb;
}

OpEor_ab_imm::OpEor_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEor_ab_dir::OpEor_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEor_ab_ext::OpEor_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEor_ab_idx::OpEor_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEor_ab_idx::~OpEor_ab_idx()
{
	delete xb;
}

OpEor_xy_imm::OpEor_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpEor_xy_dir::OpEor_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_xy_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpEor_xy_ext::OpEor_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_xy_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpEor_xy_idx::OpEor_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEor_xy_idx::~OpEor_xy_idx()
{
	delete xb;
}

OpClc::OpClc(CodeType const& code, uint16_t addr) : Operation(code, addr, "clc")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCli::OpCli(CodeType const& code, uint16_t addr) : Operation(code, addr, "cli")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpClv::OpClv(CodeType const& code, uint16_t addr) : Operation(code, addr, "clv")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpClr_ext::OpClr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "clr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpClr_idx::OpClr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "clr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpClr_idx::~OpClr_idx()
{
	delete xb;
}

OpClrw_ext::OpClrw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "clrw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpClrw_idx::OpClrw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "clrw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpClrw_idx::~OpClrw_idx()
{
	delete xb;
}

OpClr_ab::OpClr_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "clr_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpClr_xy::OpClr_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "clr_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCom_ext::OpCom_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "com_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCom_idx::OpCom_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "com_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpCom_idx::~OpCom_idx()
{
	delete xb;
}

OpCom_ab::OpCom_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "com_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpComw_ext::OpComw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "comw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpComw_idx::OpComw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "comw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpComw_idx::~OpComw_idx()
{
	delete xb;
}

OpCom_xy::OpCom_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "com_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpNeg_ext::OpNeg_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "neg_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpNeg_idx::OpNeg_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "neg_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpNeg_idx::~OpNeg_idx()
{
	delete xb;
}

OpNeg_ab::OpNeg_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "neg_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpNegw_ext::OpNegw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "negw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpNegw_idx::OpNegw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "negw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpNegw_idx::~OpNegw_idx()
{
	delete xb;
}

OpNeg_xy::OpNeg_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "neg_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBclr_dir::OpBclr_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "bclr_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8a = ((_subword_ >> 8) & 0xffULL);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBclr_ext::OpBclr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "bclr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBclr_idx::OpBclr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "bclr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBclr_idx::~OpBclr_idx()
{
	delete xb;
}

OpBit_ab_imm::OpBit_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		ii = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_ab_dir::OpBit_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_ab_ext::OpBit_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_ab_idx::OpBit_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpBit_ab_idx::~OpBit_ab_idx()
{
	delete xb;
}

OpBit_xy_imm::OpBit_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBit_xy_dir::OpBit_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_xy_ext::OpBit_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_xy_idx::OpBit_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpBit_xy_idx::~OpBit_xy_idx()
{
	delete xb;
}

OpBset_dir::OpBset_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "bset_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8a = ((_subword_ >> 8) & 0xffULL);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBset_ext::OpBset_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "bset_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBset_idx::OpBset_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "bset_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBset_idx::~OpBset_idx()
{
	delete xb;
}

OpLsl_ext::OpLsl_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsl_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsl_idx::OpLsl_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsl_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLsl_idx::~OpLsl_idx()
{
	delete xb;
}

OpLsla::OpLsla(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsla")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLslb::OpLslb(CodeType const& code, uint16_t addr) : Operation(code, addr, "lslb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLsld::OpLsld(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsld")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLslw_ext::OpLslw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "lslw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLslw_idx::OpLslw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lslw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLslw_idx::~OpLslw_idx()
{
	delete xb;
}

OpLslx::OpLslx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lslx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsly::OpLsly(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsly")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRol_ext::OpRol_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "rol_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRol_idx::OpRol_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rol_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpRol_idx::~OpRol_idx()
{
	delete xb;
}

OpRola::OpRola(CodeType const& code, uint16_t addr) : Operation(code, addr, "rola")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRolb::OpRolb(CodeType const& code, uint16_t addr) : Operation(code, addr, "rolb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRolw_ext::OpRolw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "rolw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRolw_idx::OpRolw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rolw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpRolw_idx::~OpRolw_idx()
{
	delete xb;
}

OpRolx::OpRolx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rolx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRoly::OpRoly(CodeType const& code, uint16_t addr) : Operation(code, addr, "roly")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsr_ext::OpLsr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsr_idx::OpLsr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLsr_idx::~OpLsr_idx()
{
	delete xb;
}

OpLsra::OpLsra(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsra")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLsrb::OpLsrb(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLsrd::OpLsrd(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrd")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLsrw_ext::OpLsrw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsrw_idx::OpLsrw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLsrw_idx::~OpLsrw_idx()
{
	delete xb;
}

OpLsrx::OpLsrx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsry::OpLsry(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsry")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRor_ext::OpRor_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ror_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRor_idx::OpRor_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ror_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpRor_idx::~OpRor_idx()
{
	delete xb;
}

OpRora::OpRora(CodeType const& code, uint16_t addr) : Operation(code, addr, "rora")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRorb::OpRorb(CodeType const& code, uint16_t addr) : Operation(code, addr, "rorb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRorw_ext::OpRorw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "rorw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRorw_idx::OpRorw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rorw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpRorw_idx::~OpRorw_idx()
{
	delete xb;
}

OpRorx::OpRorx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rorx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRory::OpRory(CodeType const& code, uint16_t addr) : Operation(code, addr, "rory")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAsr_ext::OpAsr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "asr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAsr_idx::OpAsr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "asr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAsr_idx::~OpAsr_idx()
{
	delete xb;
}

OpAsra::OpAsra(CodeType const& code, uint16_t addr) : Operation(code, addr, "asra")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpAsrb::OpAsrb(CodeType const& code, uint16_t addr) : Operation(code, addr, "asrb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpAsrw_ext::OpAsrw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "asrw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAsrw_idx::OpAsrw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "asrw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAsrw_idx::~OpAsrw_idx()
{
	delete xb;
}

OpAsrx::OpAsrx(CodeType const& code, uint16_t addr) : Operation(code, addr, "asrx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAsry::OpAsry(CodeType const& code, uint16_t addr) : Operation(code, addr, "asry")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBtas_dir::OpBtas_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "btas_dir")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr8a = ((_subword_ >> 8) & 0xffULL);
		msk8 = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBtas_ext::OpBtas_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "btas_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 8) & 0xffffULL);
		msk8 = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBtas_idx::OpBtas_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "btas_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		msk8 = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBtas_idx::~OpBtas_idx()
{
	delete xb;
}

OpEmul::OpEmul(CodeType const& code, uint16_t addr) : Operation(code, addr, "emul")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpEmuls::OpEmuls(CodeType const& code, uint16_t addr) : Operation(code, addr, "emuls")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMul::OpMul(CodeType const& code, uint16_t addr) : Operation(code, addr, "mul")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpEdiv::OpEdiv(CodeType const& code, uint16_t addr) : Operation(code, addr, "ediv")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpEdivs::OpEdivs(CodeType const& code, uint16_t addr) : Operation(code, addr, "edivs")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpFdiv::OpFdiv(CodeType const& code, uint16_t addr) : Operation(code, addr, "fdiv")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpIdiv::OpIdiv(CodeType const& code, uint16_t addr) : Operation(code, addr, "idiv")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpIdivs::OpIdivs(CodeType const& code, uint16_t addr) : Operation(code, addr, "idivs")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEmacs::OpEmacs(CodeType const& code, uint16_t addr) : Operation(code, addr, "emacs")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpSbr::OpSbr(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbr")
,branch(
#line 44 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
false )
#line 53712 "hcs12x.cc"
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		sel = ((_subword_ >> 8) & 0xfULL);
		rel8 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLbr::OpLbr(CodeType const& code, uint16_t addr) : Operation(code, addr, "lbr")
,branch(
#line 144 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
false )
#line 53728 "hcs12x.cc"
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		sel = ((_subword_ >> 16) & 0xfULL);
		rel16 = (((int32_t((_subword_ >> 0) & 0xffffLL)) << 16) >> 16);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBr_clr_set_dir::OpBr_clr_set_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "br_clr_set_dir")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 24) & 0x1ULL);
		opr8a = ((_subword_ >> 16) & 0xffULL);
		msk8 = ((_subword_ >> 8) & 0xffULL);
		rel8 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBr_clr_set_ext::OpBr_clr_set_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "br_clr_set_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 16) & 0xffffULL);
		msk8 = ((_subword_ >> 8) & 0xffULL);
		rel8 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBr_clr_set_idx::OpBr_clr_set_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "br_clr_set_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		msk8 = ((_subword_ >> 8) & 0xffULL);
		rel8 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBr_clr_set_idx::~OpBr_clr_set_idx()
{
	delete xb;
}

OpBsr::OpBsr(CodeType const& code, uint16_t addr) : Operation(code, addr, "bsr")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		rel8 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCall_ext::OpCall_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "call_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 8) & 0xffffULL);
		page = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpCall_16offset_idx_ind::OpCall_16offset_idx_ind(CodeType const& code, uint16_t addr) : Operation(code, addr, "call_16offset_idx_ind")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		rr = ((_subword_ >> 3) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		n16 = (((int32_t((_subword_ >> 0) & 0xffffLL)) << 16) >> 16);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCall_accD_offset_idx_ind::OpCall_accD_offset_idx_ind(CodeType const& code, uint16_t addr) : Operation(code, addr, "call_accD_offset_idx_ind")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		rr = ((_subword_ >> 3) & 0x3ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpJmp_ext::OpJmp_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "jmp_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpJmp_idx::OpJmp_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "jmp_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpJmp_idx::~OpJmp_idx()
{
	delete xb;
}

OpJsr_dir::OpJsr_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "jsr_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpJsr_ext::OpJsr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "jsr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpJsr_idx::OpJsr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "jsr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpJsr_idx::~OpJsr_idx()
{
	delete xb;
}

OpRtc::OpRtc(CodeType const& code, uint16_t addr) : Operation(code, addr, "rtc")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRts::OpRts(CodeType const& code, uint16_t addr) : Operation(code, addr, "rts")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLoop::OpLoop(CodeType const& code, uint16_t addr) : Operation(code, addr, "loop")
,isBranch(
#line 771 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
false )
#line 53929 "hcs12x.cc"
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b765 = ((_subword_ >> 5) & 0x7ULL);
		b4 = ((_subword_ >> 4) & 0x1ULL);
		b3 = ((_subword_ >> 3) & 0x1ULL);
		b210 = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		rel9 = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPsha::OpPsha(CodeType const& code, uint16_t addr) : Operation(code, addr, "psha")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshb::OpPshb(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshc::OpPshc(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshc")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshcw::OpPshcw(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshcw")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpPshd::OpPshd(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshd")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshx::OpPshx(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshy::OpPshy(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshy")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPula::OpPula(CodeType const& code, uint16_t addr) : Operation(code, addr, "pula")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPulb::OpPulb(CodeType const& code, uint16_t addr) : Operation(code, addr, "pulb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPulc::OpPulc(CodeType const& code, uint16_t addr) : Operation(code, addr, "pulc")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPulcw::OpPulcw(CodeType const& code, uint16_t addr) : Operation(code, addr, "pulcw")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpPuld::OpPuld(CodeType const& code, uint16_t addr) : Operation(code, addr, "puld")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPulx::OpPulx(CodeType const& code, uint16_t addr) : Operation(code, addr, "pulx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPuly::OpPuly(CodeType const& code, uint16_t addr) : Operation(code, addr, "puly")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpMem::OpMem(CodeType const& code, uint16_t addr) : Operation(code, addr, "mem")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRev::OpRev(CodeType const& code, uint16_t addr) : Operation(code, addr, "rev")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRevw::OpRevw(CodeType const& code, uint16_t addr) : Operation(code, addr, "revw")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpWav::OpWav(CodeType const& code, uint16_t addr) : Operation(code, addr, "wav")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpWavr::OpWavr(CodeType const& code, uint16_t addr) : Operation(code, addr, "wavr")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpTbl::OpTbl(CodeType const& code, uint16_t addr) : Operation(code, addr, "tbl")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpTbl::~OpTbl()
{
	delete xb;
}

OpEtlb::OpEtlb(CodeType const& code, uint16_t addr) : Operation(code, addr, "etlb")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEtlb::~OpEtlb()
{
	delete xb;
}

OpNop::OpNop(CodeType const& code, uint16_t addr) : Operation(code, addr, "nop")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpStop::OpStop(CodeType const& code, uint16_t addr) : Operation(code, addr, "stop")
,stopDisabled(
#line 55 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
false )
#line 54120 "hcs12x.cc"
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpWai::OpWai(CodeType const& code, uint16_t addr) : Operation(code, addr, "wai")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBgnd::OpBgnd(CodeType const& code, uint16_t addr) : Operation(code, addr, "bgnd")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRti::OpRti(CodeType const& code, uint16_t addr) : Operation(code, addr, "rti")
,isPending(
#line 202 "/export/is010125/rnouacer/unisim/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
false )
#line 54145 "hcs12x.cc"
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpSwi::OpSwi(CodeType const& code, uint16_t addr) : Operation(code, addr, "swi")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpSys::OpSys(CodeType const& code, uint16_t addr) : Operation(code, addr, "sys")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

DecodeMapPage::DecodeMapPage(uint16_t key)
{
	this->key = key;
	memset(operation, 0, sizeof(operation));
	next = 0;
}

DecodeMapPage::~DecodeMapPage()
{
	unsigned int idx;
	for(idx = 0; idx < NUM_OPERATIONS_PER_PAGE; idx++)
	delete operation[idx];
}

DecodeTableEntry::DecodeTableEntry(CodeType const& opcode, CodeType const& opcode_mask, Operation *(*decode)(CodeType const&, uint16_t))
{
	this->opcode = opcode;
	this->opcode_mask = opcode_mask;
	this->decode = decode;
}

Decoder::Decoder()
: is_little_endian( false ), mru_page( 0 )
{
	memset(decode_hash_table, 0, sizeof(decode_hash_table));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa7" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSys));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3f" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpSwi));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x0b" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRti));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x00" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBgnd));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3e" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpWai));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3e" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpStop));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa7" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpNop));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3f" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEtlb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3d" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpTbl));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3c" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpWavr));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3c" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpWav));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3b" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRevw));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3a" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRev));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x01" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpMem));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x31" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPuly));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x30" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPulx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3a" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPuld));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x38" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpPulcw));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x38" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPulc));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x33" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPulb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x32" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPula));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x35" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x34" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3b" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshd));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x39" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpPshcw));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x39" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshc));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x37" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x36" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPsha));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x04" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLoop));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3d" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRts));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x0a" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRtc));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x15" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJsr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x16" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJsr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x17" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJsr_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x05" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJmp_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x06" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJmp_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4b\xe7" ), 2 ), CodeType( (uint8_t*)( "\xff\xe7" ), 2 ), DecodeOpCall_accD_offset_idx_ind));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4b\xe3" ), 2 ), CodeType( (uint8_t*)( "\xff\xe7" ), 2 ), DecodeOpCall_16offset_idx_ind));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4a" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpCall_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x07" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBsr));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x0e" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpBr_clr_set_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1e" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpBr_clr_set_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4e" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpBr_clr_set_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x20" ), 2 ), CodeType( (uint8_t*)( "\xff\xf0" ), 2 ), DecodeOpLbr));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x20" ), 1 ), CodeType( (uint8_t*)( "\xf0" ), 1 ), DecodeOpSbr));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x12" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEmacs));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x15" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIdivs));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x10" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIdiv));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x11" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpFdiv));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x14" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEdivs));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x11" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpEdiv));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x12" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpMul));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x13" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEmuls));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x13" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpEmul));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x37" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpBtas_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x36" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpBtas_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x35" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpBtas_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x57" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAsry));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x47" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAsrx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x67" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAsrw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x77" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAsrw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x57" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAsrb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x47" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAsra));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x67" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAsr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x77" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAsr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x56" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRory));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x46" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRorx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x66" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRorw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x76" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRorw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x56" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRorb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x46" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRora));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x66" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRor_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x76" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRor_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x54" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsry));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x44" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsrx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x64" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsrw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x74" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsrw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x49" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsrd));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x54" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsrb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x44" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsra));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x64" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x74" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x55" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRoly));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x45" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRolx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x65" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRolw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x75" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRolw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x55" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRolb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x45" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRola));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x65" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRol_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x75" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRol_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x58" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsly));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x48" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLslx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x68" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLslw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x78" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLslw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x59" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsld));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x58" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLslb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x48" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsla));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x68" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsl_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x78" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsl_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x0c" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBset_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1c" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBset_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4c" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBset_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa5" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpBit_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb5" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpBit_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x95" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpBit_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x85" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpBit_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa5" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpBit_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb5" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpBit_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x95" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpBit_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x85" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpBit_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x0d" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBclr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1d" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBclr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4d" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBclr_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x40" ), 2 ), CodeType( (uint8_t*)( "\xff\xef" ), 2 ), DecodeOpNeg_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x60" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpNegw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x70" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpNegw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x40" ), 1 ), CodeType( (uint8_t*)( "\xef" ), 1 ), DecodeOpNeg_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x60" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpNeg_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x70" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpNeg_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x41" ), 2 ), CodeType( (uint8_t*)( "\xff\xef" ), 2 ), DecodeOpCom_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x61" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpComw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x71" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpComw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x41" ), 1 ), CodeType( (uint8_t*)( "\xef" ), 1 ), DecodeOpCom_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x61" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpCom_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x71" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpCom_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x87" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpClr_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x87" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpClr_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x69" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpClrw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x79" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpClrw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x69" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpClr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x79" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpClr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x10\xfd" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpClv));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x10\xef" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpCli));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x10\xfe" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpClc));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa8" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpEor_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb8" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpEor_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x98" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpEor_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x88" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpEor_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa8" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpEor_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb8" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpEor_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x98" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpEor_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x88" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpEor_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xaa" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpOr_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xba" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpOr_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x9a" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpOr_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x8a" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpOr_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x14" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpOrcc_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xaa" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpOra_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xba" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpOra_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x9a" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpOra_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x8a" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpOra_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa4" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAnd_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb4" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAnd_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x94" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAnd_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x84" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAnd_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x10" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAndcc_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa4" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAnd_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb4" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAnd_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x94" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAnd_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x84" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAnd_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x1c" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMaxm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x18" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMaxa));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x1e" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEmaxm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x1a" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEmaxd));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x1d" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMinm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x19" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMina));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x1f" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEminm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x1b" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEmind));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x97" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpTst_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xe7" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpTstw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xf7" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpTstw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x97" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpTst_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xe7" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpTst_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xf7" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpTst_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xac" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpCpe_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xbc" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpCpe_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x9c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpCpe_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x8c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpCpe_dyxs_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xac" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpCp_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xbc" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpCp_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x9c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpCp_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x8c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpCp_dyxs_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa1" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpCmp_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb1" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpCmp_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x91" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpCmp_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x81" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpCmp_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x17" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpCba));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x02" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpIny));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x08" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpInx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1b\x81" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIns));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x42" ), 2 ), CodeType( (uint8_t*)( "\xff\xef" ), 2 ), DecodeOpInc_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x62" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIncw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x72" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIncw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x42" ), 1 ), CodeType( (uint8_t*)( "\xef" ), 1 ), DecodeOpInc_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x62" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpInc_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x72" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpInc_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x03" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpDey));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x09" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpDex));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1b\x9f" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpDes));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x43" ), 2 ), CodeType( (uint8_t*)( "\xff\xef" ), 2 ), DecodeOpDec_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x63" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpDecw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x73" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpDecw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x43" ), 1 ), CodeType( (uint8_t*)( "\xef" ), 1 ), DecodeOpDec_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x63" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpDec_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x73" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpDec_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x07" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpDaa));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa0" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSub_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb0" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSub_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x90" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSub_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x80" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSub_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa0" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSub_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb0" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSub_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x90" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSub_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x80" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSub_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa2" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSbe_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb2" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSbe_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x92" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSbe_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x82" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSbe_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSbed_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSbed_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x93" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSbed_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x83" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSbed_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa2" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSbc_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb2" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSbc_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x92" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSbc_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x82" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSbc_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x16" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSba));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa3" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_sub_d_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb3" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_sub_d_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x93" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_sub_d_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x83" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_sub_d_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xab" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAdd_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xbb" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAdd_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x9b" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAdd_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x8b" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAdd_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa9" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAde_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb9" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAde_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x99" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAde_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x89" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAde_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xe3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAded_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xf3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAded_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xd3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAded_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xc3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAded_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xab" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xbb" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x9b" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x8b" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa9" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdc_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb9" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdc_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x99" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdc_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x89" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdc_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x19\xed" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAby));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1a\xe5" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAbx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x06" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAba));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x02" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_02));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x05" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_05));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x01" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_01));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x00" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_00));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x04" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_04));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x03" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_03));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0a" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_0A));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0d" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_0D));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x09" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_09));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0c" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_0C));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x08" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_08));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0b" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_0B));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb7\x08" ), 2 ), CodeType( (uint8_t*)( "\xff\x88" ), 2 ), DecodeOpTfr_hcs12x));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb7\x88" ), 2 ), CodeType( (uint8_t*)( "\xff\x88" ), 2 ), DecodeOpExg_hcs12x));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb7\x00" ), 2 ), CodeType( (uint8_t*)( "\xff\x80" ), 2 ), DecodeOpTfr_hcs12));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb7\x80" ), 2 ), CodeType( (uint8_t*)( "\xff\x88" ), 2 ), DecodeOpExg_hcs12));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0e" ), 2 ), CodeType( (uint8_t*)( "\xff\xfe" ), 2 ), DecodeOpT_ab_ba));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x6c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGst_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x7c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGst_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x5c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGst_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x6a" ), 2 ), CodeType( (uint8_t*)( "\xff\xfe" ), 2 ), DecodeOpGstaab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x7a" ), 2 ), CodeType( (uint8_t*)( "\xff\xfe" ), 2 ), DecodeOpGstaab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x5a" ), 2 ), CodeType( (uint8_t*)( "\xff\xfe" ), 2 ), DecodeOpGstaab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xec" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGld_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xfc" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGld_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xdc" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGld_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa6" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpGldaab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb6" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpGldaab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x96" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpGldaab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x6c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpSt_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x7c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpSt_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x5c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpSt_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x6a" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpStaab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x7a" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpStaab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x5a" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpStaab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1b" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLeas));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1a" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLeax));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x19" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLeay));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xec" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpLd_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xfc" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpLd_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xdc" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpLd_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xcc" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpLd_dyxs_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa6" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpLdaab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb6" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpLdaab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x96" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpLdaab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x86" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpLdaab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpTrap));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4b" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpCall_idx));
}

Decoder::~Decoder()
{
	InvalidateDecodingCache();
}

Operation *Decoder::NCDecode(uint16_t addr, CodeType const& code)
{
	Operation *operation;
	unsigned int count = decode_table.size();
	unsigned int idx;
	for(idx = 0; idx < count; idx++)
	{
		if( code.match( decode_table[idx].opcode, decode_table[idx].opcode_mask) )
		{
			operation = decode_table[idx].decode(code, addr);
			return operation;
		}
	}
	operation = new Operation(code, addr, "???");
	return operation;
}

void Decoder::InvalidateDecodingCache()
{
	uint32_t index;
	mru_page = 0;
	for(index = 0; index < NUM_DECODE_HASH_TABLE_ENTRIES; index++)
	{
		DecodeMapPage *page, *next_page;
		page = decode_hash_table[index];
		if(page)
		{
			do
			{
				next_page = page->next;
				delete page;
				page = next_page;
			} while(page);
			decode_hash_table[index] = 0;
		}
	}
}

void Decoder::InvalidateDecodingCacheEntry(uint16_t addr)
{
	uint16_t page_key = addr / NUM_OPERATIONS_PER_PAGE;
	if(mru_page && mru_page->key == page_key) mru_page = 0;
	uint32_t index = page_key % NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key
	DecodeMapPage *prev, *cur;
	cur = decode_hash_table[index];
	if(cur)
	{
		if(cur->key == page_key)
		{
			decode_hash_table[index] = cur->next;
			delete cur;
			return;
		}
		prev = cur;
		cur = cur->next;
		if(cur)
		{
			do
			{
				if(cur->key == page_key)
				{
					prev->next = cur->next;
					cur->next = 0;
					delete cur;
					return;
				}
				prev = cur;
			} while((cur = cur->next) != 0);
		}
	}
}

inline DecodeMapPage *Decoder::FindPage(uint16_t page_key)
{
	if(mru_page && mru_page->key == page_key) return mru_page;
	uint32_t index = page_key % NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key
	DecodeMapPage *prev, *cur;
	cur = decode_hash_table[index];
	if(cur)
	{
		if(cur->key == page_key)
		{
			mru_page = cur;
			return cur;
		}
		prev = cur;
		cur = cur->next;
		if(cur)
		{
			do
			{
				if(cur->key == page_key)
				{
					prev->next = cur->next;
					cur->next= decode_hash_table[index];
					decode_hash_table[index] = cur;
					mru_page = cur;
					return cur;
				}
				prev = cur;
			} while((cur = cur->next) != 0);
		}
	}
	return 0;
}

Operation *Decoder::Decode(uint16_t addr, CodeType const& insn)
{
	Operation *operation;
	uint16_t page_key = addr / NUM_OPERATIONS_PER_PAGE;
	DecodeMapPage *page;
	page = FindPage(page_key);
	if(!page)
	{
		page = new DecodeMapPage (page_key);
		uint32_t index = page_key % NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key
		page->next = decode_hash_table[index];
		decode_hash_table[index] = page;
		mru_page = page;
	}
	operation = page->operation[(addr) & (NUM_OPERATIONS_PER_PAGE - 1)];
	if(operation)
	{
		if(insn.match( operation->GetEncoding() ) && operation->GetAddr() == addr)
		return operation;
		delete operation;
	}
	operation = NCDecode(addr, insn);
	page->operation[(addr) & (NUM_OPERATIONS_PER_PAGE - 1)] = operation;
	return operation;
}

void Decoder::SetLittleEndian()
{
	is_little_endian = true;
}

void Decoder::SetBigEndian()
{
	is_little_endian = false;
}

} } } } }
