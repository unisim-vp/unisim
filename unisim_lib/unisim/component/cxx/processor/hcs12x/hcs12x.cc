#include "hcs12x.hh"
#include <cassert>
#include <ostream>
#include <cstring>
#line 56 "hcs12x.isa"

#include <unisim/component/cxx/processor/hcs12x/xb.hh>
#line 9 "hcs12x.cc"
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x {
unsigned int const CodeType::maxsize;
std::ostream& operator << ( std::ostream& _sink, CodeType const& _ct ) {
	char const* xrepr = "0123456789abcdef";
	char const* sep = "";
	for( unsigned int idx = 0; idx < _ct.size; ++idx, sep = " " ) {
		uint32_t byte = _ct.str[idx];
		_sink << sep << xrepr[byte/16] << xrepr[byte%16];
	}
	return _sink;
}
Operation::Operation(CodeType const& _code, uint16_t _addr, const char *_name)
:
encoding(_code),
addr(_addr),
name(_name)
{
}

Operation::~Operation()
{
}

#line 65 "hcs12x.isa"
void
#line 35 "hcs12x.cc"
Operation::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 42 "hcs12x.cc"
)
{
#line 65 "hcs12x.isa"
	{
		sink << "?";
	}
#line 49 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 53 "hcs12x.cc"
Operation::execute(
#line 60 "hcs12x.isa"
CPU *
#line 57 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 60 "hcs12x.cc"
)
{
#line 60 "hcs12x.isa"
	{
		printf("Unknown instruction\n");
		exit(-1);
	}
#line 68 "hcs12x.cc"
}
class OpCall_idx : public Operation
{
public:
	OpCall_idx(CodeType const& code, uint16_t addr);
	~OpCall_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 77 "hcs12x.cc"
	* xb;
	uint32_t page;
	virtual
#line 65 "hcs12x.isa"
	void
#line 83 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 87 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 90 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 131 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 135 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 138 "hcs12x.cc"
	);
private:
};

class OpTrap : public Operation
{
public:
	OpTrap(CodeType const& code, uint16_t addr);
	uint32_t trapnum;
	virtual
#line 65 "hcs12x.isa"
	void
#line 151 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 155 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 158 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 199 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 203 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 206 "hcs12x.cc"
	);
private:
};

class OpLdaab_imm : public Operation
{
public:
	OpLdaab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 220 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 224 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 227 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 268 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 272 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 275 "hcs12x.cc"
	);
private:
};

class OpLdaab_dir : public Operation
{
public:
	OpLdaab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 289 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 293 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 296 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 337 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 341 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 344 "hcs12x.cc"
	);
private:
};

class OpLdaab_ext : public Operation
{
public:
	OpLdaab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 358 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 362 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 365 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 406 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 410 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 413 "hcs12x.cc"
	);
private:
};

class OpLdaab_idx : public Operation
{
public:
	OpLdaab_idx(CodeType const& code, uint16_t addr);
	~OpLdaab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 426 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 431 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 435 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 438 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 479 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 483 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 486 "hcs12x.cc"
	);
private:
};

class OpLd_dyxs_imm : public Operation
{
public:
	OpLd_dyxs_imm(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 500 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 504 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 507 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 548 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 552 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 555 "hcs12x.cc"
	);
private:
};

class OpLd_dyxs_dir : public Operation
{
public:
	OpLd_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t dd;
	virtual
#line 65 "hcs12x.isa"
	void
#line 569 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 573 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 576 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 617 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 621 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 624 "hcs12x.cc"
	);
private:
};

class OpLd_dyxs_ext : public Operation
{
public:
	OpLd_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 638 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 642 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 645 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 686 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 690 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 693 "hcs12x.cc"
	);
private:
};

class OpLd_dyxs_idx : public Operation
{
public:
	OpLd_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpLd_dyxs_idx();
	uint32_t dyxs;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 706 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 711 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 715 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 718 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 759 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 763 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 766 "hcs12x.cc"
	);
private:
};

class OpLeay : public Operation
{
public:
	OpLeay(CodeType const& code, uint16_t addr);
	~OpLeay();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 778 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 783 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 787 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 790 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 831 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 835 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 838 "hcs12x.cc"
	);
private:
};

class OpLeax : public Operation
{
public:
	OpLeax(CodeType const& code, uint16_t addr);
	~OpLeax();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 850 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 855 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 859 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 862 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 903 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 907 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 910 "hcs12x.cc"
	);
private:
};

class OpLeas : public Operation
{
public:
	OpLeas(CodeType const& code, uint16_t addr);
	~OpLeas();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 922 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 927 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 931 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 934 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 975 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 979 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 982 "hcs12x.cc"
	);
private:
};

class OpStaab_dir : public Operation
{
public:
	OpStaab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 996 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1000 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1003 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1044 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1048 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1051 "hcs12x.cc"
	);
private:
};

class OpStaab_ext : public Operation
{
public:
	OpStaab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1065 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1069 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1072 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1113 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1117 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1120 "hcs12x.cc"
	);
private:
};

class OpStaab_idx : public Operation
{
public:
	OpStaab_idx(CodeType const& code, uint16_t addr);
	~OpStaab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1133 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1138 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1142 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1145 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1186 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1190 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1193 "hcs12x.cc"
	);
private:
};

class OpSt_dyxs_dir : public Operation
{
public:
	OpSt_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1207 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1211 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1214 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1255 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1259 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1262 "hcs12x.cc"
	);
private:
};

class OpSt_dyxs_ext : public Operation
{
public:
	OpSt_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1276 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1280 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1283 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1324 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1328 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1331 "hcs12x.cc"
	);
private:
};

class OpSt_dyxs_idx : public Operation
{
public:
	OpSt_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpSt_dyxs_idx();
	uint32_t dyxs;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1344 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1349 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1353 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1356 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1397 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1401 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1404 "hcs12x.cc"
	);
private:
};

class OpGldaab_dir : public Operation
{
public:
	OpGldaab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1418 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1422 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1425 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1466 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1470 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1473 "hcs12x.cc"
	);
private:
};

class OpGldaab_ext : public Operation
{
public:
	OpGldaab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1487 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1491 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1494 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1535 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1539 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1542 "hcs12x.cc"
	);
private:
};

class OpGldaab_idx : public Operation
{
public:
	OpGldaab_idx(CodeType const& code, uint16_t addr);
	~OpGldaab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1555 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1560 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1564 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1567 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1608 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1612 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1615 "hcs12x.cc"
	);
private:
};

class OpGld_dyxs_dir : public Operation
{
public:
	OpGld_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t dd;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1629 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1633 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1636 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1677 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1681 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1684 "hcs12x.cc"
	);
private:
};

class OpGld_dyxs_ext : public Operation
{
public:
	OpGld_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1698 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1702 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1705 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1746 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1750 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1753 "hcs12x.cc"
	);
private:
};

class OpGld_dyxs_idx : public Operation
{
public:
	OpGld_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpGld_dyxs_idx();
	uint32_t dyxs;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1766 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1771 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1775 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1778 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1819 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1823 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1826 "hcs12x.cc"
	);
private:
};

class OpGstaab_dir : public Operation
{
public:
	OpGstaab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1840 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1844 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1847 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1888 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1892 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1895 "hcs12x.cc"
	);
private:
};

class OpGstaab_ext : public Operation
{
public:
	OpGstaab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1909 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1913 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1916 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 1957 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 1961 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 1964 "hcs12x.cc"
	);
private:
};

class OpGstaab_idx : public Operation
{
public:
	OpGstaab_idx(CodeType const& code, uint16_t addr);
	~OpGstaab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 1977 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 1982 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 1986 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 1989 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2030 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2034 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2037 "hcs12x.cc"
	);
private:
};

class OpGst_dyxs_dir : public Operation
{
public:
	OpGst_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2051 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2055 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2058 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2099 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2103 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2106 "hcs12x.cc"
	);
private:
};

class OpGst_dyxs_ext : public Operation
{
public:
	OpGst_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2120 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2124 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2127 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2168 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2172 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2175 "hcs12x.cc"
	);
private:
};

class OpGst_dyxs_idx : public Operation
{
public:
	OpGst_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpGst_dyxs_idx();
	uint32_t dyxs;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 2188 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2193 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2197 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2200 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2241 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2245 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2248 "hcs12x.cc"
	);
private:
};

class OpT_ab_ba : public Operation
{
public:
	OpT_ab_ba(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2261 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2265 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2268 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2309 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2313 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2316 "hcs12x.cc"
	);
private:
};

class OpExg_hcs12 : public Operation
{
public:
	OpExg_hcs12(CodeType const& code, uint16_t addr);
	uint32_t lms;
	uint32_t lls;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2330 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2334 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2337 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2378 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2382 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2385 "hcs12x.cc"
	);
private:
};

class OpTfr_hcs12 : public Operation
{
public:
	OpTfr_hcs12(CodeType const& code, uint16_t addr);
	uint32_t lms;
	uint32_t hls;
	uint32_t lls;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2400 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2404 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2407 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2448 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2452 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2455 "hcs12x.cc"
	);
private:
};

class OpExg_hcs12x : public Operation
{
public:
	OpExg_hcs12x(CodeType const& code, uint16_t addr);
	uint32_t lms;
	uint32_t lls;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2469 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2473 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2476 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2517 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2521 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2524 "hcs12x.cc"
	);
private:
};

class OpTfr_hcs12x : public Operation
{
public:
	OpTfr_hcs12x(CodeType const& code, uint16_t addr);
	uint32_t lms;
	uint32_t lls;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2538 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2542 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2545 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2586 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2590 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2593 "hcs12x.cc"
	);
private:
};

class OpMovb_0B : public Operation
{
public:
	OpMovb_0B(CodeType const& code, uint16_t addr);
	uint32_t ii;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2607 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2611 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2614 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2655 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2659 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2662 "hcs12x.cc"
	);
private:
};

class OpMovb_08 : public Operation
{
public:
	OpMovb_08(CodeType const& code, uint16_t addr);
	~OpMovb_08();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 2674 "hcs12x.cc"
	* xb;
	uint32_t ii;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2680 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2684 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2687 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2728 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2732 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2735 "hcs12x.cc"
	);
private:
};

class OpMovb_0C : public Operation
{
public:
	OpMovb_0C(CodeType const& code, uint16_t addr);
	uint32_t opr16asrc;
	uint32_t opr16adst;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2749 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2753 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2756 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2797 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2801 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2804 "hcs12x.cc"
	);
private:
};

class OpMovb_09 : public Operation
{
public:
	OpMovb_09(CodeType const& code, uint16_t addr);
	~OpMovb_09();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 2816 "hcs12x.cc"
	* xb;
	uint32_t opr16asrc;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2822 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2826 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2829 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2870 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2874 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2877 "hcs12x.cc"
	);
private:
};

class OpMovb_0D : public Operation
{
public:
	OpMovb_0D(CodeType const& code, uint16_t addr);
	~OpMovb_0D();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 2889 "hcs12x.cc"
	* xb;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2895 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2899 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2902 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 2943 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 2947 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 2950 "hcs12x.cc"
	);
private:
};

class OpMovb_0A : public Operation
{
public:
	OpMovb_0A(CodeType const& code, uint16_t addr);
	~OpMovb_0A();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 2962 "hcs12x.cc"
	* xbsrc;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 2966 "hcs12x.cc"
	* xbdst;
	virtual
#line 65 "hcs12x.isa"
	void
#line 2971 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 2975 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 2978 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3019 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3023 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3026 "hcs12x.cc"
	);
private:
};

class OpMovw_03 : public Operation
{
public:
	OpMovw_03(CodeType const& code, uint16_t addr);
	uint32_t opr16i;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3040 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3044 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3047 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3088 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3092 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3095 "hcs12x.cc"
	);
private:
};

class OpMovw_00 : public Operation
{
public:
	OpMovw_00(CodeType const& code, uint16_t addr);
	~OpMovw_00();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3107 "hcs12x.cc"
	* xb;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3113 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3117 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3120 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3161 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3165 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3168 "hcs12x.cc"
	);
private:
};

class OpMovw_04 : public Operation
{
public:
	OpMovw_04(CodeType const& code, uint16_t addr);
	uint32_t opr16asrc;
	uint32_t opr16adst;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3182 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3186 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3189 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3230 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3234 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3237 "hcs12x.cc"
	);
private:
};

class OpMovw_01 : public Operation
{
public:
	OpMovw_01(CodeType const& code, uint16_t addr);
	~OpMovw_01();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3249 "hcs12x.cc"
	* xb;
	uint32_t opr16asrc;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3255 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3259 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3262 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3303 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3307 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3310 "hcs12x.cc"
	);
private:
};

class OpMovw_05 : public Operation
{
public:
	OpMovw_05(CodeType const& code, uint16_t addr);
	~OpMovw_05();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3322 "hcs12x.cc"
	* xb;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3328 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3332 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3335 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3376 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3380 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3383 "hcs12x.cc"
	);
private:
};

class OpMovw_02 : public Operation
{
public:
	OpMovw_02(CodeType const& code, uint16_t addr);
	~OpMovw_02();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3395 "hcs12x.cc"
	* xbsrc;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3399 "hcs12x.cc"
	* xbdst;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3404 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3408 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3411 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3452 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3456 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3459 "hcs12x.cc"
	);
private:
};

class OpAba : public Operation
{
public:
	OpAba(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 3471 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3475 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3478 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3519 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3523 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3526 "hcs12x.cc"
	);
private:
};

class OpAbx : public Operation
{
public:
	OpAbx(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 3538 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3542 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3545 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3586 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3590 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3593 "hcs12x.cc"
	);
private:
};

class OpAby : public Operation
{
public:
	OpAby(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 3605 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3609 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3612 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3653 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3657 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3660 "hcs12x.cc"
	);
private:
};

class OpAdc_ab_imm : public Operation
{
public:
	OpAdc_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3674 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3678 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3681 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3722 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3726 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3729 "hcs12x.cc"
	);
private:
};

class OpAdc_ab_dir : public Operation
{
public:
	OpAdc_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3743 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3747 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3750 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3791 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3795 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3798 "hcs12x.cc"
	);
private:
};

class OpAdc_ab_ext : public Operation
{
public:
	OpAdc_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3812 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3816 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3819 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3860 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3864 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3867 "hcs12x.cc"
	);
private:
};

class OpAdc_ab_idx : public Operation
{
public:
	OpAdc_ab_idx(CodeType const& code, uint16_t addr);
	~OpAdc_ab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 3880 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3885 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3889 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3892 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 3933 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 3937 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 3940 "hcs12x.cc"
	);
private:
};

class OpAdd_ab_imm : public Operation
{
public:
	OpAdd_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 3954 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 3958 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 3961 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4002 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4006 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4009 "hcs12x.cc"
	);
private:
};

class OpAdd_ab_dir : public Operation
{
public:
	OpAdd_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4023 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4027 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4030 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4071 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4075 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4078 "hcs12x.cc"
	);
private:
};

class OpAdd_ab_ext : public Operation
{
public:
	OpAdd_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4092 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4096 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4099 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4140 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4144 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4147 "hcs12x.cc"
	);
private:
};

class OpAdd_ab_idx : public Operation
{
public:
	OpAdd_ab_idx(CodeType const& code, uint16_t addr);
	~OpAdd_ab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 4160 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4165 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4169 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4172 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4213 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4217 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4220 "hcs12x.cc"
	);
private:
};

class OpAded_imm : public Operation
{
public:
	OpAded_imm(CodeType const& code, uint16_t addr);
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4233 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4237 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4240 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4281 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4285 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4288 "hcs12x.cc"
	);
private:
};

class OpAded_dir : public Operation
{
public:
	OpAded_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4301 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4305 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4308 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4349 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4353 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4356 "hcs12x.cc"
	);
private:
};

class OpAded_ext : public Operation
{
public:
	OpAded_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4369 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4373 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4376 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4417 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4421 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4424 "hcs12x.cc"
	);
private:
};

class OpAded_idx : public Operation
{
public:
	OpAded_idx(CodeType const& code, uint16_t addr);
	~OpAded_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 4436 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4441 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4445 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4448 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4489 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4493 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4496 "hcs12x.cc"
	);
private:
};

class OpAde_xy_imm : public Operation
{
public:
	OpAde_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4510 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4514 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4517 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4558 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4562 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4565 "hcs12x.cc"
	);
private:
};

class OpAde_xy_dir : public Operation
{
public:
	OpAde_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4579 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4583 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4586 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4627 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4631 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4634 "hcs12x.cc"
	);
private:
};

class OpAde_xy_ext : public Operation
{
public:
	OpAde_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4648 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4652 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4655 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4696 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4700 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4703 "hcs12x.cc"
	);
private:
};

class OpAde_xy_idx : public Operation
{
public:
	OpAde_xy_idx(CodeType const& code, uint16_t addr);
	~OpAde_xy_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 4716 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4721 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4725 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4728 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4769 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4773 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4776 "hcs12x.cc"
	);
private:
};

class OpAdd_xy_imm : public Operation
{
public:
	OpAdd_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4790 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4794 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4797 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4838 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4842 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4845 "hcs12x.cc"
	);
private:
};

class OpAdd_xy_dir : public Operation
{
public:
	OpAdd_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4859 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4863 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4866 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4907 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4911 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4914 "hcs12x.cc"
	);
private:
};

class OpAdd_xy_ext : public Operation
{
public:
	OpAdd_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 4928 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 4932 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 4935 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 4976 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 4980 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 4983 "hcs12x.cc"
	);
private:
};

class OpAdd_xy_idx : public Operation
{
public:
	OpAdd_xy_idx(CodeType const& code, uint16_t addr);
	~OpAdd_xy_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 4996 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5001 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5005 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5008 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5049 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5053 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5056 "hcs12x.cc"
	);
private:
};

class OpAdd_sub_d_imm : public Operation
{
public:
	OpAdd_sub_d_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5070 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5074 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5077 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5118 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5122 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5125 "hcs12x.cc"
	);
private:
};

class OpAdd_sub_d_dir : public Operation
{
public:
	OpAdd_sub_d_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5139 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5143 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5146 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5187 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5191 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5194 "hcs12x.cc"
	);
private:
};

class OpAdd_sub_d_ext : public Operation
{
public:
	OpAdd_sub_d_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5208 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5212 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5215 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5256 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5260 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5263 "hcs12x.cc"
	);
private:
};

class OpAdd_sub_d_idx : public Operation
{
public:
	OpAdd_sub_d_idx(CodeType const& code, uint16_t addr);
	~OpAdd_sub_d_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 5276 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5281 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5285 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5288 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5329 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5333 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5336 "hcs12x.cc"
	);
private:
};

class OpSba : public Operation
{
public:
	OpSba(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 5348 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5352 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5355 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5396 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5400 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5403 "hcs12x.cc"
	);
private:
};

class OpSbc_ab_imm : public Operation
{
public:
	OpSbc_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5417 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5421 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5424 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5465 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5469 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5472 "hcs12x.cc"
	);
private:
};

class OpSbc_ab_dir : public Operation
{
public:
	OpSbc_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5486 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5490 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5493 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5534 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5538 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5541 "hcs12x.cc"
	);
private:
};

class OpSbc_ab_ext : public Operation
{
public:
	OpSbc_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5555 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5559 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5562 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5603 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5607 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5610 "hcs12x.cc"
	);
private:
};

class OpSbc_ab_idx : public Operation
{
public:
	OpSbc_ab_idx(CodeType const& code, uint16_t addr);
	~OpSbc_ab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 5623 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5628 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5632 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5635 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5676 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5680 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5683 "hcs12x.cc"
	);
private:
};

class OpSbed_imm : public Operation
{
public:
	OpSbed_imm(CodeType const& code, uint16_t addr);
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5696 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5700 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5703 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5744 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5748 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5751 "hcs12x.cc"
	);
private:
};

class OpSbed_dir : public Operation
{
public:
	OpSbed_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5764 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5768 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5771 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5812 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5816 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5819 "hcs12x.cc"
	);
private:
};

class OpSbed_ext : public Operation
{
public:
	OpSbed_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5832 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5836 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5839 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5880 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5884 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5887 "hcs12x.cc"
	);
private:
};

class OpSbed_idx : public Operation
{
public:
	OpSbed_idx(CodeType const& code, uint16_t addr);
	~OpSbed_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 5899 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5904 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5908 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5911 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 5952 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 5956 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 5959 "hcs12x.cc"
	);
private:
};

class OpSbe_xy_imm : public Operation
{
public:
	OpSbe_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 5973 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 5977 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 5980 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6021 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6025 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6028 "hcs12x.cc"
	);
private:
};

class OpSbe_xy_dir : public Operation
{
public:
	OpSbe_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6042 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6046 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6049 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6090 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6094 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6097 "hcs12x.cc"
	);
private:
};

class OpSbe_xy_ext : public Operation
{
public:
	OpSbe_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6111 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6115 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6118 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6159 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6163 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6166 "hcs12x.cc"
	);
private:
};

class OpSbe_xy_idx : public Operation
{
public:
	OpSbe_xy_idx(CodeType const& code, uint16_t addr);
	~OpSbe_xy_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 6179 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6184 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6188 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6191 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6232 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6236 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6239 "hcs12x.cc"
	);
private:
};

class OpSub_ab_imm : public Operation
{
public:
	OpSub_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6253 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6257 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6260 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6301 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6305 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6308 "hcs12x.cc"
	);
private:
};

class OpSub_ab_dir : public Operation
{
public:
	OpSub_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6322 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6326 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6329 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6370 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6374 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6377 "hcs12x.cc"
	);
private:
};

class OpSub_ab_ext : public Operation
{
public:
	OpSub_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6391 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6395 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6398 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6439 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6443 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6446 "hcs12x.cc"
	);
private:
};

class OpSub_ab_idx : public Operation
{
public:
	OpSub_ab_idx(CodeType const& code, uint16_t addr);
	~OpSub_ab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 6459 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6464 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6468 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6471 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6512 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6516 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6519 "hcs12x.cc"
	);
private:
};

class OpSub_xy_imm : public Operation
{
public:
	OpSub_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6533 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6537 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6540 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6581 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6585 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6588 "hcs12x.cc"
	);
private:
};

class OpSub_xy_dir : public Operation
{
public:
	OpSub_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6602 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6606 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6609 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6650 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6654 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6657 "hcs12x.cc"
	);
private:
};

class OpSub_xy_ext : public Operation
{
public:
	OpSub_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6671 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6675 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6678 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6719 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6723 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6726 "hcs12x.cc"
	);
private:
};

class OpSub_xy_idx : public Operation
{
public:
	OpSub_xy_idx(CodeType const& code, uint16_t addr);
	~OpSub_xy_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 6739 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6744 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6748 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6751 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6792 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6796 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6799 "hcs12x.cc"
	);
private:
};

class OpDaa : public Operation
{
public:
	OpDaa(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 6811 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6815 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6818 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6859 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6863 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6866 "hcs12x.cc"
	);
private:
};

class OpDec_ext : public Operation
{
public:
	OpDec_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6879 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6883 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6886 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6927 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 6931 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 6934 "hcs12x.cc"
	);
private:
};

class OpDec_idx : public Operation
{
public:
	OpDec_idx(CodeType const& code, uint16_t addr);
	~OpDec_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 6946 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 6951 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 6955 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 6958 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 6999 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7003 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7006 "hcs12x.cc"
	);
private:
};

class OpDec_ab : public Operation
{
public:
	OpDec_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7019 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7023 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7026 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7067 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7071 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7074 "hcs12x.cc"
	);
private:
};

class OpDecw_ext : public Operation
{
public:
	OpDecw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7087 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7091 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7094 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7135 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7139 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7142 "hcs12x.cc"
	);
private:
};

class OpDecw_idx : public Operation
{
public:
	OpDecw_idx(CodeType const& code, uint16_t addr);
	~OpDecw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 7154 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7159 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7163 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7166 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7207 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7211 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7214 "hcs12x.cc"
	);
private:
};

class OpDec_xy : public Operation
{
public:
	OpDec_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7227 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7231 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7234 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7275 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7279 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7282 "hcs12x.cc"
	);
private:
};

class OpDes : public Operation
{
public:
	OpDes(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 7294 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7298 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7301 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7342 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7346 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7349 "hcs12x.cc"
	);
private:
};

class OpDex : public Operation
{
public:
	OpDex(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 7361 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7365 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7368 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7409 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7413 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7416 "hcs12x.cc"
	);
private:
};

class OpDey : public Operation
{
public:
	OpDey(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 7428 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7432 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7435 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7476 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7480 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7483 "hcs12x.cc"
	);
private:
};

class OpInc_ext : public Operation
{
public:
	OpInc_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7496 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7500 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7503 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7544 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7548 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7551 "hcs12x.cc"
	);
private:
};

class OpInc_idx : public Operation
{
public:
	OpInc_idx(CodeType const& code, uint16_t addr);
	~OpInc_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 7563 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7568 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7572 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7575 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7616 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7620 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7623 "hcs12x.cc"
	);
private:
};

class OpInc_ab : public Operation
{
public:
	OpInc_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7636 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7640 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7643 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7684 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7688 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7691 "hcs12x.cc"
	);
private:
};

class OpIncw_ext : public Operation
{
public:
	OpIncw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7704 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7708 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7711 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7752 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7756 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7759 "hcs12x.cc"
	);
private:
};

class OpIncw_idx : public Operation
{
public:
	OpIncw_idx(CodeType const& code, uint16_t addr);
	~OpIncw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 7771 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7776 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7780 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7783 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7824 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7828 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7831 "hcs12x.cc"
	);
private:
};

class OpInc_xy : public Operation
{
public:
	OpInc_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 7844 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7848 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7851 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7892 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7896 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7899 "hcs12x.cc"
	);
private:
};

class OpIns : public Operation
{
public:
	OpIns(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 7911 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7915 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7918 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 7959 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 7963 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 7966 "hcs12x.cc"
	);
private:
};

class OpInx : public Operation
{
public:
	OpInx(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 7978 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 7982 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 7985 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8026 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8030 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8033 "hcs12x.cc"
	);
private:
};

class OpIny : public Operation
{
public:
	OpIny(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 8045 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8049 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8052 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8093 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8097 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8100 "hcs12x.cc"
	);
private:
};

class OpCba : public Operation
{
public:
	OpCba(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 8112 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8116 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8119 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8160 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8164 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8167 "hcs12x.cc"
	);
private:
};

class OpCmp_ab_imm : public Operation
{
public:
	OpCmp_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8181 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8185 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8188 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8229 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8233 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8236 "hcs12x.cc"
	);
private:
};

class OpCmp_ab_dir : public Operation
{
public:
	OpCmp_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8250 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8254 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8257 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8298 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8302 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8305 "hcs12x.cc"
	);
private:
};

class OpCmp_ab_ext : public Operation
{
public:
	OpCmp_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8319 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8323 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8326 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8367 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8371 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8374 "hcs12x.cc"
	);
private:
};

class OpCmp_ab_idx : public Operation
{
public:
	OpCmp_ab_idx(CodeType const& code, uint16_t addr);
	~OpCmp_ab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 8387 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8392 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8396 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8399 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8440 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8444 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8447 "hcs12x.cc"
	);
private:
};

class OpCp_dyxs_imm : public Operation
{
public:
	OpCp_dyxs_imm(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8461 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8465 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8468 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8509 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8513 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8516 "hcs12x.cc"
	);
private:
};

class OpCp_dyxs_dir : public Operation
{
public:
	OpCp_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8530 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8534 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8537 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8578 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8582 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8585 "hcs12x.cc"
	);
private:
};

class OpCp_dyxs_ext : public Operation
{
public:
	OpCp_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8599 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8603 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8606 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8647 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8651 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8654 "hcs12x.cc"
	);
private:
};

class OpCp_dyxs_idx : public Operation
{
public:
	OpCp_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpCp_dyxs_idx();
	uint32_t dyxs;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 8667 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8672 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8676 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8679 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8720 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8724 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8727 "hcs12x.cc"
	);
private:
};

class OpCpe_dyxs_imm : public Operation
{
public:
	OpCpe_dyxs_imm(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8741 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8745 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8748 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8789 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8793 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8796 "hcs12x.cc"
	);
private:
};

class OpCpe_dyxs_dir : public Operation
{
public:
	OpCpe_dyxs_dir(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8810 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8814 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8817 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8858 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8862 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8865 "hcs12x.cc"
	);
private:
};

class OpCpe_dyxs_ext : public Operation
{
public:
	OpCpe_dyxs_ext(CodeType const& code, uint16_t addr);
	uint32_t dyxs;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8879 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8883 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8886 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 8927 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 8931 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 8934 "hcs12x.cc"
	);
private:
};

class OpCpe_dyxs_idx : public Operation
{
public:
	OpCpe_dyxs_idx(CodeType const& code, uint16_t addr);
	~OpCpe_dyxs_idx();
	uint32_t dyxs;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 8947 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 8952 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 8956 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 8959 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9000 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9004 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9007 "hcs12x.cc"
	);
private:
};

class OpTst_ext : public Operation
{
public:
	OpTst_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9020 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9024 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9027 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9068 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9072 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9075 "hcs12x.cc"
	);
private:
};

class OpTst_idx : public Operation
{
public:
	OpTst_idx(CodeType const& code, uint16_t addr);
	~OpTst_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 9087 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9092 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9096 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9099 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9140 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9144 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9147 "hcs12x.cc"
	);
private:
};

class OpTst_ab : public Operation
{
public:
	OpTst_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9160 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9164 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9167 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9208 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9212 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9215 "hcs12x.cc"
	);
private:
};

class OpTstw_ext : public Operation
{
public:
	OpTstw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9228 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9232 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9235 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9276 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9280 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9283 "hcs12x.cc"
	);
private:
};

class OpTstw_idx : public Operation
{
public:
	OpTstw_idx(CodeType const& code, uint16_t addr);
	~OpTstw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 9295 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9300 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9304 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9307 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9348 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9352 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9355 "hcs12x.cc"
	);
private:
};

class OpTst_xy : public Operation
{
public:
	OpTst_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9368 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9372 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9375 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9416 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9420 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9423 "hcs12x.cc"
	);
private:
};

class OpEmin_dm : public Operation
{
public:
	OpEmin_dm(CodeType const& code, uint16_t addr);
	~OpEmin_dm();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 9436 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9441 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9445 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9448 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9489 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9493 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9496 "hcs12x.cc"
	);
private:
};

class OpMin_am : public Operation
{
public:
	OpMin_am(CodeType const& code, uint16_t addr);
	~OpMin_am();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 9509 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9514 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9518 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9521 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9562 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9566 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9569 "hcs12x.cc"
	);
private:
};

class OpEmax_dm : public Operation
{
public:
	OpEmax_dm(CodeType const& code, uint16_t addr);
	~OpEmax_dm();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 9582 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9587 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9591 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9594 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9635 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9639 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9642 "hcs12x.cc"
	);
private:
};

class OpMax_am : public Operation
{
public:
	OpMax_am(CodeType const& code, uint16_t addr);
	~OpMax_am();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 9655 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9660 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9664 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9667 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9708 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9712 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9715 "hcs12x.cc"
	);
private:
};

class OpAnd_ab_imm : public Operation
{
public:
	OpAnd_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9729 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9733 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9736 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9777 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9781 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9784 "hcs12x.cc"
	);
private:
};

class OpAnd_ab_dir : public Operation
{
public:
	OpAnd_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9798 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9802 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9805 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9846 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9850 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9853 "hcs12x.cc"
	);
private:
};

class OpAnd_ab_ext : public Operation
{
public:
	OpAnd_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9867 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9871 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9874 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9915 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9919 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9922 "hcs12x.cc"
	);
private:
};

class OpAnd_ab_idx : public Operation
{
public:
	OpAnd_ab_idx(CodeType const& code, uint16_t addr);
	~OpAnd_ab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 9935 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 9940 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 9944 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 9947 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 9988 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 9992 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 9995 "hcs12x.cc"
	);
private:
};

class OpAndcc_imm : public Operation
{
public:
	OpAndcc_imm(CodeType const& code, uint16_t addr);
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10008 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10012 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10015 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10056 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10060 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10063 "hcs12x.cc"
	);
private:
};

class OpAnd_xy_imm : public Operation
{
public:
	OpAnd_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10077 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10081 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10084 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10125 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10129 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10132 "hcs12x.cc"
	);
private:
};

class OpAnd_xy_dir : public Operation
{
public:
	OpAnd_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10146 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10150 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10153 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10194 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10198 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10201 "hcs12x.cc"
	);
private:
};

class OpAnd_xy_ext : public Operation
{
public:
	OpAnd_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10215 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10219 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10222 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10263 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10267 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10270 "hcs12x.cc"
	);
private:
};

class OpAnd_xy_idx : public Operation
{
public:
	OpAnd_xy_idx(CodeType const& code, uint16_t addr);
	~OpAnd_xy_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 10283 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10288 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10292 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10295 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10336 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10340 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10343 "hcs12x.cc"
	);
private:
};

class OpOra_ab_imm : public Operation
{
public:
	OpOra_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10357 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10361 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10364 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10405 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10409 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10412 "hcs12x.cc"
	);
private:
};

class OpOra_ab_dir : public Operation
{
public:
	OpOra_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10426 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10430 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10433 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10474 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10478 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10481 "hcs12x.cc"
	);
private:
};

class OpOra_ab_ext : public Operation
{
public:
	OpOra_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10495 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10499 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10502 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10543 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10547 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10550 "hcs12x.cc"
	);
private:
};

class OpOra_ab_idx : public Operation
{
public:
	OpOra_ab_idx(CodeType const& code, uint16_t addr);
	~OpOra_ab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 10563 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10568 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10572 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10575 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10616 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10620 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10623 "hcs12x.cc"
	);
private:
};

class OpOrcc_imm : public Operation
{
public:
	OpOrcc_imm(CodeType const& code, uint16_t addr);
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10636 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10640 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10643 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10684 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10688 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10691 "hcs12x.cc"
	);
private:
};

class OpOr_xy_imm : public Operation
{
public:
	OpOr_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10705 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10709 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10712 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10753 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10757 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10760 "hcs12x.cc"
	);
private:
};

class OpOr_xy_dir : public Operation
{
public:
	OpOr_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10774 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10778 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10781 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10822 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10826 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10829 "hcs12x.cc"
	);
private:
};

class OpOr_xy_ext : public Operation
{
public:
	OpOr_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10843 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10847 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10850 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10891 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10895 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10898 "hcs12x.cc"
	);
private:
};

class OpOr_xy_idx : public Operation
{
public:
	OpOr_xy_idx(CodeType const& code, uint16_t addr);
	~OpOr_xy_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 10911 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10916 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10920 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10923 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 10964 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 10968 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 10971 "hcs12x.cc"
	);
private:
};

class OpEor_ab_imm : public Operation
{
public:
	OpEor_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 10985 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 10989 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 10992 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11033 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11037 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11040 "hcs12x.cc"
	);
private:
};

class OpEor_ab_dir : public Operation
{
public:
	OpEor_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11054 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11058 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11061 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11102 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11106 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11109 "hcs12x.cc"
	);
private:
};

class OpEor_ab_ext : public Operation
{
public:
	OpEor_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11123 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11127 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11130 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11171 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11175 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11178 "hcs12x.cc"
	);
private:
};

class OpEor_ab_idx : public Operation
{
public:
	OpEor_ab_idx(CodeType const& code, uint16_t addr);
	~OpEor_ab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11191 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11196 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11200 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11203 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11244 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11248 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11251 "hcs12x.cc"
	);
private:
};

class OpEor_xy_imm : public Operation
{
public:
	OpEor_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11265 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11269 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11272 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11313 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11317 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11320 "hcs12x.cc"
	);
private:
};

class OpEor_xy_dir : public Operation
{
public:
	OpEor_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11334 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11338 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11341 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11382 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11386 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11389 "hcs12x.cc"
	);
private:
};

class OpEor_xy_ext : public Operation
{
public:
	OpEor_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11403 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11407 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11410 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11451 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11455 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11458 "hcs12x.cc"
	);
private:
};

class OpEor_xy_idx : public Operation
{
public:
	OpEor_xy_idx(CodeType const& code, uint16_t addr);
	~OpEor_xy_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11471 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11476 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11480 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11483 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11524 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11528 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11531 "hcs12x.cc"
	);
private:
};

class OpClc : public Operation
{
public:
	OpClc(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 11543 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11547 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11550 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11591 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11595 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11598 "hcs12x.cc"
	);
private:
};

class OpCli : public Operation
{
public:
	OpCli(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 11610 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11614 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11617 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11658 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11662 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11665 "hcs12x.cc"
	);
private:
};

class OpClv : public Operation
{
public:
	OpClv(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 11677 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11681 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11684 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11725 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11729 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11732 "hcs12x.cc"
	);
private:
};

class OpClr_ext : public Operation
{
public:
	OpClr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11745 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11749 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11752 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11793 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11797 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11800 "hcs12x.cc"
	);
private:
};

class OpClr_idx : public Operation
{
public:
	OpClr_idx(CodeType const& code, uint16_t addr);
	~OpClr_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11812 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11817 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11821 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11824 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11865 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11869 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11872 "hcs12x.cc"
	);
private:
};

class OpClrw_ext : public Operation
{
public:
	OpClrw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11885 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11889 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11892 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 11933 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 11937 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 11940 "hcs12x.cc"
	);
private:
};

class OpClrw_idx : public Operation
{
public:
	OpClrw_idx(CodeType const& code, uint16_t addr);
	~OpClrw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 11952 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 11957 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 11961 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 11964 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12005 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12009 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12012 "hcs12x.cc"
	);
private:
};

class OpClr_ab : public Operation
{
public:
	OpClr_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12025 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12029 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12032 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12073 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12077 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12080 "hcs12x.cc"
	);
private:
};

class OpClr_xy : public Operation
{
public:
	OpClr_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12093 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12097 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12100 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12141 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12145 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12148 "hcs12x.cc"
	);
private:
};

class OpCom_ext : public Operation
{
public:
	OpCom_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12161 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12165 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12168 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12209 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12213 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12216 "hcs12x.cc"
	);
private:
};

class OpCom_idx : public Operation
{
public:
	OpCom_idx(CodeType const& code, uint16_t addr);
	~OpCom_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 12228 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12233 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12237 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12240 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12281 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12285 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12288 "hcs12x.cc"
	);
private:
};

class OpCom_ab : public Operation
{
public:
	OpCom_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12301 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12305 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12308 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12349 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12353 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12356 "hcs12x.cc"
	);
private:
};

class OpComw_ext : public Operation
{
public:
	OpComw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12369 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12373 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12376 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12417 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12421 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12424 "hcs12x.cc"
	);
private:
};

class OpComw_idx : public Operation
{
public:
	OpComw_idx(CodeType const& code, uint16_t addr);
	~OpComw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 12436 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12441 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12445 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12448 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12489 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12493 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12496 "hcs12x.cc"
	);
private:
};

class OpCom_xy : public Operation
{
public:
	OpCom_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12509 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12513 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12516 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12557 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12561 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12564 "hcs12x.cc"
	);
private:
};

class OpNeg_ext : public Operation
{
public:
	OpNeg_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12577 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12581 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12584 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12625 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12629 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12632 "hcs12x.cc"
	);
private:
};

class OpNeg_idx : public Operation
{
public:
	OpNeg_idx(CodeType const& code, uint16_t addr);
	~OpNeg_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 12644 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12649 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12653 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12656 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12697 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12701 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12704 "hcs12x.cc"
	);
private:
};

class OpNeg_ab : public Operation
{
public:
	OpNeg_ab(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12717 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12721 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12724 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12765 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12769 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12772 "hcs12x.cc"
	);
private:
};

class OpNegw_ext : public Operation
{
public:
	OpNegw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12785 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12789 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12792 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12833 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12837 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12840 "hcs12x.cc"
	);
private:
};

class OpNegw_idx : public Operation
{
public:
	OpNegw_idx(CodeType const& code, uint16_t addr);
	~OpNegw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 12852 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12857 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12861 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12864 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12905 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12909 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12912 "hcs12x.cc"
	);
private:
};

class OpNeg_xy : public Operation
{
public:
	OpNeg_xy(CodeType const& code, uint16_t addr);
	uint32_t b;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12925 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12929 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 12932 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 12973 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 12977 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 12980 "hcs12x.cc"
	);
private:
};

class OpBclr_dir : public Operation
{
public:
	OpBclr_dir(CodeType const& code, uint16_t addr);
	uint32_t dd;
	uint32_t mm;
	virtual
#line 65 "hcs12x.isa"
	void
#line 12994 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 12998 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13001 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13042 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13046 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13049 "hcs12x.cc"
	);
private:
};

class OpBclr_ext : public Operation
{
public:
	OpBclr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	uint32_t mm;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13063 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13067 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13070 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13111 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13115 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13118 "hcs12x.cc"
	);
private:
};

class OpBclr_idx : public Operation
{
public:
	OpBclr_idx(CodeType const& code, uint16_t addr);
	~OpBclr_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 13130 "hcs12x.cc"
	* xb;
	uint32_t mm;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13136 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13140 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13143 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13184 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13188 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13191 "hcs12x.cc"
	);
private:
};

class OpBit_ab_imm : public Operation
{
public:
	OpBit_ab_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t ii;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13205 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13209 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13212 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13253 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13257 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13260 "hcs12x.cc"
	);
private:
};

class OpBit_ab_dir : public Operation
{
public:
	OpBit_ab_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13274 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13278 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13281 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13322 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13326 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13329 "hcs12x.cc"
	);
private:
};

class OpBit_ab_ext : public Operation
{
public:
	OpBit_ab_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13343 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13347 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13350 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13391 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13395 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13398 "hcs12x.cc"
	);
private:
};

class OpBit_ab_idx : public Operation
{
public:
	OpBit_ab_idx(CodeType const& code, uint16_t addr);
	~OpBit_ab_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 13411 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13416 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13420 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13423 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13464 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13468 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13471 "hcs12x.cc"
	);
private:
};

class OpBit_xy_imm : public Operation
{
public:
	OpBit_xy_imm(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16i;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13485 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13489 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13492 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13533 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13537 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13540 "hcs12x.cc"
	);
private:
};

class OpBit_xy_dir : public Operation
{
public:
	OpBit_xy_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13554 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13558 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13561 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13602 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13606 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13609 "hcs12x.cc"
	);
private:
};

class OpBit_xy_ext : public Operation
{
public:
	OpBit_xy_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13623 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13627 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13630 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13671 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13675 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13678 "hcs12x.cc"
	);
private:
};

class OpBit_xy_idx : public Operation
{
public:
	OpBit_xy_idx(CodeType const& code, uint16_t addr);
	~OpBit_xy_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 13691 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13696 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13700 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13703 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13744 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13748 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13751 "hcs12x.cc"
	);
private:
};

class OpBset_dir : public Operation
{
public:
	OpBset_dir(CodeType const& code, uint16_t addr);
	uint32_t dd;
	uint32_t mm;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13765 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13769 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13772 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13813 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13817 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13820 "hcs12x.cc"
	);
private:
};

class OpBset_ext : public Operation
{
public:
	OpBset_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	uint32_t mm;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13834 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13838 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13841 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13882 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13886 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13889 "hcs12x.cc"
	);
private:
};

class OpBset_idx : public Operation
{
public:
	OpBset_idx(CodeType const& code, uint16_t addr);
	~OpBset_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 13901 "hcs12x.cc"
	* xb;
	uint32_t mm;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13907 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13911 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13914 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 13955 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 13959 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 13962 "hcs12x.cc"
	);
private:
};

class OpLsl_ext : public Operation
{
public:
	OpLsl_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 13975 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 13979 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 13982 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14023 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14027 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14030 "hcs12x.cc"
	);
private:
};

class OpLsl_idx : public Operation
{
public:
	OpLsl_idx(CodeType const& code, uint16_t addr);
	~OpLsl_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 14042 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 14047 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14051 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14054 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14095 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14099 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14102 "hcs12x.cc"
	);
private:
};

class OpLsla : public Operation
{
public:
	OpLsla(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 14114 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14118 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14121 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14162 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14166 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14169 "hcs12x.cc"
	);
private:
};

class OpLslb : public Operation
{
public:
	OpLslb(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 14181 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14185 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14188 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14229 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14233 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14236 "hcs12x.cc"
	);
private:
};

class OpLsld : public Operation
{
public:
	OpLsld(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 14248 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14252 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14255 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14296 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14300 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14303 "hcs12x.cc"
	);
private:
};

class OpLslw_ext : public Operation
{
public:
	OpLslw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 14316 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14320 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14323 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14364 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14368 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14371 "hcs12x.cc"
	);
private:
};

class OpLslw_idx : public Operation
{
public:
	OpLslw_idx(CodeType const& code, uint16_t addr);
	~OpLslw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 14383 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 14388 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14392 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14395 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14436 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14440 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14443 "hcs12x.cc"
	);
private:
};

class OpLslx : public Operation
{
public:
	OpLslx(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 14455 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14459 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14462 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14503 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14507 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14510 "hcs12x.cc"
	);
private:
};

class OpLsly : public Operation
{
public:
	OpLsly(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 14522 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14526 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14529 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14570 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14574 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14577 "hcs12x.cc"
	);
private:
};

class OpRol_ext : public Operation
{
public:
	OpRol_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 14590 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14594 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14597 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14638 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14642 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14645 "hcs12x.cc"
	);
private:
};

class OpRol_idx : public Operation
{
public:
	OpRol_idx(CodeType const& code, uint16_t addr);
	~OpRol_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 14657 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 14662 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14666 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14669 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14710 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14714 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14717 "hcs12x.cc"
	);
private:
};

class OpRola : public Operation
{
public:
	OpRola(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 14729 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14733 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14736 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14777 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14781 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14784 "hcs12x.cc"
	);
private:
};

class OpRolb : public Operation
{
public:
	OpRolb(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 14796 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14800 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14803 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14844 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14848 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14851 "hcs12x.cc"
	);
private:
};

class OpRolw_ext : public Operation
{
public:
	OpRolw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 14864 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14868 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14871 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14912 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14916 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14919 "hcs12x.cc"
	);
private:
};

class OpRolw_idx : public Operation
{
public:
	OpRolw_idx(CodeType const& code, uint16_t addr);
	~OpRolw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 14931 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 14936 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 14940 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 14943 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 14984 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 14988 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 14991 "hcs12x.cc"
	);
private:
};

class OpRolx : public Operation
{
public:
	OpRolx(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 15003 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15007 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15010 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15051 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15055 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15058 "hcs12x.cc"
	);
private:
};

class OpRoly : public Operation
{
public:
	OpRoly(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 15070 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15074 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15077 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15118 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15122 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15125 "hcs12x.cc"
	);
private:
};

class OpLsr_ext : public Operation
{
public:
	OpLsr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 15138 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15142 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15145 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15186 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15190 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15193 "hcs12x.cc"
	);
private:
};

class OpLsr_idx : public Operation
{
public:
	OpLsr_idx(CodeType const& code, uint16_t addr);
	~OpLsr_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 15205 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 15210 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15214 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15217 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15258 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15262 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15265 "hcs12x.cc"
	);
private:
};

class OpLsra : public Operation
{
public:
	OpLsra(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 15277 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15281 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15284 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15325 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15329 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15332 "hcs12x.cc"
	);
private:
};

class OpLsrb : public Operation
{
public:
	OpLsrb(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 15344 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15348 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15351 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15392 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15396 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15399 "hcs12x.cc"
	);
private:
};

class OpLsrd : public Operation
{
public:
	OpLsrd(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 15411 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15415 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15418 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15459 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15463 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15466 "hcs12x.cc"
	);
private:
};

class OpLsrw_ext : public Operation
{
public:
	OpLsrw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 15479 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15483 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15486 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15527 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15531 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15534 "hcs12x.cc"
	);
private:
};

class OpLsrw_idx : public Operation
{
public:
	OpLsrw_idx(CodeType const& code, uint16_t addr);
	~OpLsrw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 15546 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 15551 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15555 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15558 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15599 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15603 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15606 "hcs12x.cc"
	);
private:
};

class OpLsrx : public Operation
{
public:
	OpLsrx(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 15618 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15622 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15625 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15666 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15670 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15673 "hcs12x.cc"
	);
private:
};

class OpLsry : public Operation
{
public:
	OpLsry(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 15685 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15689 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15692 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15733 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15737 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15740 "hcs12x.cc"
	);
private:
};

class OpRor_ext : public Operation
{
public:
	OpRor_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 15753 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15757 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15760 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15801 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15805 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15808 "hcs12x.cc"
	);
private:
};

class OpRor_idx : public Operation
{
public:
	OpRor_idx(CodeType const& code, uint16_t addr);
	~OpRor_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 15820 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 15825 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15829 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15832 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15873 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15877 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15880 "hcs12x.cc"
	);
private:
};

class OpRora : public Operation
{
public:
	OpRora(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 15892 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15896 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15899 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 15940 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 15944 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 15947 "hcs12x.cc"
	);
private:
};

class OpRorb : public Operation
{
public:
	OpRorb(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 15959 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 15963 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 15966 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16007 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16011 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16014 "hcs12x.cc"
	);
private:
};

class OpRorw_ext : public Operation
{
public:
	OpRorw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 16027 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16031 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16034 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16075 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16079 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16082 "hcs12x.cc"
	);
private:
};

class OpRorw_idx : public Operation
{
public:
	OpRorw_idx(CodeType const& code, uint16_t addr);
	~OpRorw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 16094 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 16099 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16103 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16106 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16147 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16151 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16154 "hcs12x.cc"
	);
private:
};

class OpRorx : public Operation
{
public:
	OpRorx(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 16166 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16170 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16173 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16214 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16218 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16221 "hcs12x.cc"
	);
private:
};

class OpRory : public Operation
{
public:
	OpRory(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 16233 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16237 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16240 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16281 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16285 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16288 "hcs12x.cc"
	);
private:
};

class OpAsr_ext : public Operation
{
public:
	OpAsr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 16301 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16305 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16308 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16349 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16353 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16356 "hcs12x.cc"
	);
private:
};

class OpAsr_idx : public Operation
{
public:
	OpAsr_idx(CodeType const& code, uint16_t addr);
	~OpAsr_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 16368 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 16373 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16377 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16380 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16421 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16425 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16428 "hcs12x.cc"
	);
private:
};

class OpAsra : public Operation
{
public:
	OpAsra(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 16440 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16444 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16447 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16488 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16492 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16495 "hcs12x.cc"
	);
private:
};

class OpAsrb : public Operation
{
public:
	OpAsrb(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 16507 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16511 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16514 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16555 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16559 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16562 "hcs12x.cc"
	);
private:
};

class OpAsrw_ext : public Operation
{
public:
	OpAsrw_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 16575 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16579 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16582 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16623 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16627 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16630 "hcs12x.cc"
	);
private:
};

class OpAsrw_idx : public Operation
{
public:
	OpAsrw_idx(CodeType const& code, uint16_t addr);
	~OpAsrw_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 16642 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 16647 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16651 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16654 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16695 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16699 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16702 "hcs12x.cc"
	);
private:
};

class OpAsrx : public Operation
{
public:
	OpAsrx(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 16714 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16718 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16721 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16762 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16766 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16769 "hcs12x.cc"
	);
private:
};

class OpAsry : public Operation
{
public:
	OpAsry(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 16781 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16785 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16788 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16829 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16833 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16836 "hcs12x.cc"
	);
private:
};

class OpBtas_dir : public Operation
{
public:
	OpBtas_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	uint32_t msk8;
	virtual
#line 65 "hcs12x.isa"
	void
#line 16850 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16854 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16857 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16898 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16902 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16905 "hcs12x.cc"
	);
private:
};

class OpBtas_ext : public Operation
{
public:
	OpBtas_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	uint32_t msk8;
	virtual
#line 65 "hcs12x.isa"
	void
#line 16919 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16923 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16926 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 16967 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 16971 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 16974 "hcs12x.cc"
	);
private:
};

class OpBtas_idx : public Operation
{
public:
	OpBtas_idx(CodeType const& code, uint16_t addr);
	~OpBtas_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 16986 "hcs12x.cc"
	* xb;
	uint32_t msk8;
	virtual
#line 65 "hcs12x.isa"
	void
#line 16992 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 16996 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 16999 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17040 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17044 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17047 "hcs12x.cc"
	);
private:
};

class OpEmul : public Operation
{
public:
	OpEmul(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 17059 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17063 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17066 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17107 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17111 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17114 "hcs12x.cc"
	);
private:
};

class OpEmuls : public Operation
{
public:
	OpEmuls(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 17126 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17130 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17133 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17174 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17178 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17181 "hcs12x.cc"
	);
private:
};

class OpMul : public Operation
{
public:
	OpMul(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 17193 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17197 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17200 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17241 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17245 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17248 "hcs12x.cc"
	);
private:
};

class OpEdiv : public Operation
{
public:
	OpEdiv(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 17260 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17264 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17267 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17308 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17312 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17315 "hcs12x.cc"
	);
private:
};

class OpEdivs : public Operation
{
public:
	OpEdivs(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 17327 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17331 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17334 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17375 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17379 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17382 "hcs12x.cc"
	);
private:
};

class OpFdiv : public Operation
{
public:
	OpFdiv(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 17394 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17398 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17401 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17442 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17446 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17449 "hcs12x.cc"
	);
private:
};

class OpIdiv : public Operation
{
public:
	OpIdiv(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 17461 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17465 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17468 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17509 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17513 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17516 "hcs12x.cc"
	);
private:
};

class OpIdivs : public Operation
{
public:
	OpIdivs(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 17528 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17532 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17535 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17576 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17580 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17583 "hcs12x.cc"
	);
private:
};

class OpEmacs : public Operation
{
public:
	OpEmacs(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 17596 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17600 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17603 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17644 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17648 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17651 "hcs12x.cc"
	);
private:
};

class OpSbr : public Operation
{
public:
	OpSbr(CodeType const& code, uint16_t addr);
	uint32_t sel;
	int32_t rel8;
	virtual
#line 65 "hcs12x.isa"
	void
#line 17665 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17669 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17672 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17713 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17717 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17720 "hcs12x.cc"
	);
private:
};

class OpLbr : public Operation
{
public:
	OpLbr(CodeType const& code, uint16_t addr);
	uint32_t sel;
	int32_t rel16;
	virtual
#line 65 "hcs12x.isa"
	void
#line 17734 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17738 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17741 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17782 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17786 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17789 "hcs12x.cc"
	);
private:
};

class OpBr_clr_set_dir : public Operation
{
public:
	OpBr_clr_set_dir(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr8a;
	uint32_t msk8;
	int32_t rel8;
	virtual
#line 65 "hcs12x.isa"
	void
#line 17805 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17809 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17812 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17853 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17857 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17860 "hcs12x.cc"
	);
private:
};

class OpBr_clr_set_ext : public Operation
{
public:
	OpBr_clr_set_ext(CodeType const& code, uint16_t addr);
	uint32_t b;
	uint32_t opr16a;
	uint32_t msk8;
	int32_t rel8;
	virtual
#line 65 "hcs12x.isa"
	void
#line 17876 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17880 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17883 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17924 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 17928 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 17931 "hcs12x.cc"
	);
private:
};

class OpBr_clr_set_idx : public Operation
{
public:
	OpBr_clr_set_idx(CodeType const& code, uint16_t addr);
	~OpBr_clr_set_idx();
	uint32_t b;
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 17944 "hcs12x.cc"
	* xb;
	uint32_t msk8;
	int32_t rel8;
	virtual
#line 65 "hcs12x.isa"
	void
#line 17951 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 17955 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 17958 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 17999 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18003 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18006 "hcs12x.cc"
	);
private:
};

class OpBsr : public Operation
{
public:
	OpBsr(CodeType const& code, uint16_t addr);
	uint32_t rel8;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18019 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18023 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18026 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18067 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18071 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18074 "hcs12x.cc"
	);
private:
};

class OpCall_ext : public Operation
{
public:
	OpCall_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	uint32_t page;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18088 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18092 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18095 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18136 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18140 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18143 "hcs12x.cc"
	);
private:
};

class OpCall_16offset_idx_ind : public Operation
{
public:
	OpCall_16offset_idx_ind(CodeType const& code, uint16_t addr);
	uint32_t rr;
	int32_t n16;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18157 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18161 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18164 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18205 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18209 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18212 "hcs12x.cc"
	);
private:
};

class OpCall_accD_offset_idx_ind : public Operation
{
public:
	OpCall_accD_offset_idx_ind(CodeType const& code, uint16_t addr);
	uint32_t rr;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18225 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18229 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18232 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18273 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18277 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18280 "hcs12x.cc"
	);
private:
};

class OpJmp_ext : public Operation
{
public:
	OpJmp_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18293 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18297 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18300 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18341 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18345 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18348 "hcs12x.cc"
	);
private:
};

class OpJmp_idx : public Operation
{
public:
	OpJmp_idx(CodeType const& code, uint16_t addr);
	~OpJmp_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 18360 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18365 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18369 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18372 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18413 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18417 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18420 "hcs12x.cc"
	);
private:
};

class OpJsr_dir : public Operation
{
public:
	OpJsr_dir(CodeType const& code, uint16_t addr);
	uint32_t opr8a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18433 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18437 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18440 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18481 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18485 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18488 "hcs12x.cc"
	);
private:
};

class OpJsr_ext : public Operation
{
public:
	OpJsr_ext(CodeType const& code, uint16_t addr);
	uint32_t opr16a;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18501 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18505 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18508 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18549 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18553 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18556 "hcs12x.cc"
	);
private:
};

class OpJsr_idx : public Operation
{
public:
	OpJsr_idx(CodeType const& code, uint16_t addr);
	~OpJsr_idx();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 18568 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18573 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18577 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18580 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18621 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18625 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18628 "hcs12x.cc"
	);
private:
};

class OpRtc : public Operation
{
public:
	OpRtc(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 18640 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18644 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18647 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18688 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18692 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18695 "hcs12x.cc"
	);
private:
};

class OpRts : public Operation
{
public:
	OpRts(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 18707 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18711 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18714 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18755 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18759 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18762 "hcs12x.cc"
	);
private:
};

class OpLoop : public Operation
{
public:
	OpLoop(CodeType const& code, uint16_t addr);
	uint32_t b765;
	uint32_t b4;
	uint32_t b3;
	uint32_t b210;
	int32_t rel9;
	virtual
#line 65 "hcs12x.isa"
	void
#line 18779 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18783 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18786 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18827 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18831 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18834 "hcs12x.cc"
	);
private:
};

class OpPsha : public Operation
{
public:
	OpPsha(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 18846 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18850 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18853 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18894 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18898 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18901 "hcs12x.cc"
	);
private:
};

class OpPshb : public Operation
{
public:
	OpPshb(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 18913 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18917 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18920 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 18961 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 18965 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 18968 "hcs12x.cc"
	);
private:
};

class OpPshc : public Operation
{
public:
	OpPshc(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 18980 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 18984 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 18987 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19028 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19032 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19035 "hcs12x.cc"
	);
private:
};

class OpPshcw : public Operation
{
public:
	OpPshcw(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19047 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19051 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19054 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19095 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19099 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19102 "hcs12x.cc"
	);
private:
};

class OpPshd : public Operation
{
public:
	OpPshd(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19114 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19118 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19121 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19162 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19166 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19169 "hcs12x.cc"
	);
private:
};

class OpPshx : public Operation
{
public:
	OpPshx(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19181 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19185 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19188 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19229 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19233 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19236 "hcs12x.cc"
	);
private:
};

class OpPshy : public Operation
{
public:
	OpPshy(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19248 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19252 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19255 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19296 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19300 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19303 "hcs12x.cc"
	);
private:
};

class OpPula : public Operation
{
public:
	OpPula(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19315 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19319 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19322 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19363 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19367 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19370 "hcs12x.cc"
	);
private:
};

class OpPulb : public Operation
{
public:
	OpPulb(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19382 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19386 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19389 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19430 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19434 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19437 "hcs12x.cc"
	);
private:
};

class OpPulc : public Operation
{
public:
	OpPulc(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19449 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19453 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19456 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19497 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19501 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19504 "hcs12x.cc"
	);
private:
};

class OpPulcw : public Operation
{
public:
	OpPulcw(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19516 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19520 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19523 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19564 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19568 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19571 "hcs12x.cc"
	);
private:
};

class OpPuld : public Operation
{
public:
	OpPuld(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19583 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19587 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19590 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19631 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19635 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19638 "hcs12x.cc"
	);
private:
};

class OpPulx : public Operation
{
public:
	OpPulx(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19650 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19654 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19657 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19698 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19702 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19705 "hcs12x.cc"
	);
private:
};

class OpPuly : public Operation
{
public:
	OpPuly(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19717 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19721 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19724 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19765 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19769 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19772 "hcs12x.cc"
	);
private:
};

class OpMem : public Operation
{
public:
	OpMem(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19784 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19788 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19791 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19832 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19836 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19839 "hcs12x.cc"
	);
private:
};

class OpRev : public Operation
{
public:
	OpRev(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19851 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19855 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19858 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19899 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19903 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19906 "hcs12x.cc"
	);
private:
};

class OpRevw : public Operation
{
public:
	OpRevw(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19918 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19922 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19925 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 19966 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 19970 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 19973 "hcs12x.cc"
	);
private:
};

class OpWav : public Operation
{
public:
	OpWav(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 19985 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 19989 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 19992 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20033 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20037 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20040 "hcs12x.cc"
	);
private:
};

class OpWavr : public Operation
{
public:
	OpWavr(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 20052 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20056 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20059 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20100 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20104 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20107 "hcs12x.cc"
	);
private:
};

class OpTbl : public Operation
{
public:
	OpTbl(CodeType const& code, uint16_t addr);
	~OpTbl();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 20119 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 20124 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20128 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20131 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20172 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20176 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20179 "hcs12x.cc"
	);
private:
};

class OpEtlb : public Operation
{
public:
	OpEtlb(CodeType const& code, uint16_t addr);
	~OpEtlb();
#line 1 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./xb_sub.isa"
	unisim::component::cxx::processor::hcs12x::XB::Operation
#line 20191 "hcs12x.cc"
	* xb;
	virtual
#line 65 "hcs12x.isa"
	void
#line 20196 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20200 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20203 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20244 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20248 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20251 "hcs12x.cc"
	);
private:
};

class OpNop : public Operation
{
public:
	OpNop(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 20263 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20267 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20270 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20311 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20315 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20318 "hcs12x.cc"
	);
private:
};

class OpStop : public Operation
{
public:
	OpStop(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 20330 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20334 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20337 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20378 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20382 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20385 "hcs12x.cc"
	);
private:
};

class OpWait : public Operation
{
public:
	OpWait(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 20397 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20401 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20404 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20445 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20449 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20452 "hcs12x.cc"
	);
private:
};

class OpBgnd : public Operation
{
public:
	OpBgnd(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 20464 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20468 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20471 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20512 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20516 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20519 "hcs12x.cc"
	);
private:
};

class OpRti : public Operation
{
public:
	OpRti(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 20531 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20535 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20538 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20579 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20583 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20586 "hcs12x.cc"
	);
private:
};

class OpSwi : public Operation
{
public:
	OpSwi(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 20598 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20602 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20605 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20646 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20650 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20653 "hcs12x.cc"
	);
private:
};

class OpSys : public Operation
{
public:
	OpSys(CodeType const& code, uint16_t addr);
	virtual
#line 65 "hcs12x.isa"
	void
#line 20665 "hcs12x.cc"
	disasm(
#line 65 "hcs12x.isa"
	ostream&
#line 20669 "hcs12x.cc"
#line 65 "hcs12x.isa"
	sink
#line 20672 "hcs12x.cc"
	);
	/*
	*  Copyright (c) 2008,
	*  Commissariat a l'Energie Atomique (CEA)
	*  All rights reserved.
	*
	*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
	*
	*   - Redistributions of source code must retain the above copyright notice, this
	*     list of conditions and the following disclaimer.
	*
	*   - Redistributions in binary form must reproduce the above copyright notice,
	*     this list of conditions and the following disclaimer in the documentation
	*     and/or other materials provided with the distribution.
	*
	*   - Neither the name of CEA nor the names of its contributors may be used to
	*     endorse or promote products derived from this software without specific prior
	*     written permission.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	*  DISCLAIMED.
	*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
	*/
	/* instruction endian */
	// subdecoder XB
	//subdecoder XB {unisim::component::cxx::processor::hcs12x::XB} [8;24]
	virtual
#line 60 "hcs12x.isa"
	void
#line 20713 "hcs12x.cc"
	execute(
#line 60 "hcs12x.isa"
	CPU *
#line 20717 "hcs12x.cc"
#line 60 "hcs12x.isa"
	cpu
#line 20720 "hcs12x.cc"
	);
private:
};

#line 65 "hcs12x.isa"
void
#line 20727 "hcs12x.cc"
OpCall_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 20731 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 20734 "hcs12x.cc"
)
{
#line 461 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "CALL ";
		xb->disasm(sink);
		sink << ", $" << std::hex << page;
	}
#line 20743 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 20747 "hcs12x.cc"
OpCall_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 20751 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 20754 "hcs12x.cc"
)
{
#line 467 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* (SP)-1 => SP
		* (PPAGE) => M[SP]
		* page => PPAGE
		* Subroutine address => PC
		* TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
		*/
		physical_address_t addr;

		cpu->setRegSP(cpu->getRegSP()-2);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));

		cpu->setRegSP(cpu->getRegSP()-1);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, cpu->mmc->getPpage());

		cpu->mmc->setPpage(page);
		cpu->setRegPC(xb->getEAddr(cpu));

		// TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
	}
#line 20785 "hcs12x.cc"
}

static Operation *DecodeOpCall_idx(CodeType const& code, uint16_t addr)
{
	return new OpCall_idx(code, addr);
}

// TRAP: unimplemented opcode trap
// trapnum: Trap number $30-$39 or $40-$FF
#line 65 "hcs12x.isa"
void
#line 20797 "hcs12x.cc"
OpTrap::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 20801 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 20804 "hcs12x.cc"
)
{
#line 262 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		sink << "TRAP $" << std::hex << trapnum;
	}
#line 20811 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 20815 "hcs12x.cc"
OpTrap::execute(
#line 60 "hcs12x.isa"
CPU *
#line 20819 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 20822 "hcs12x.cc"
)
{
#line 266 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{

		if (((trapnum >= 0x30) && (trapnum <= 0x39)) || ((trapnum >= 0x40) && (trapnum <= 0xFF))) {
			/*
			* (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
			* (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
			* (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
			* (SP) – $0002 => SP; B : A => (M(SP) : M(SP+1))
			* In case of CPU12
			* (SP) – $0001 => SP; CCR => (M(SP) )
			* In case of CPU12X
			* (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
			* 1 => I; 0 => U
			* (Trap Vector) => PC
			*/

			address_t addr = cpu->getRegSP();

			addr = addr - 2;
			cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());

			addr = addr - 2;
			cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());

			addr = addr - 2;
			cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());

			addr = addr - 2;
			cpu->memWrite8(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
			cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());

			addr = addr - 2;
			cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());

			// 1 => I; 0 => U
			cpu->ccr->setI();
			cpu->ccr->setCCRHigh(cpu->ccr->getCCRHigh() & 0x7F);

			// (Trap Vector) => PC
			cpu->setRegPC(cpu->memRead16(CONFIG::TRAP_VECTOR_ADDRESS));
		}
	}
#line 20868 "hcs12x.cc"
}

static Operation *DecodeOpTrap(CodeType const& code, uint16_t addr)
{
	return new OpTrap(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// LDAA or LDAB #opr8i
#line 65 "hcs12x.isa"
void
#line 20912 "hcs12x.cc"
OpLdaab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 20916 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 20919 "hcs12x.cc"
)
{
#line 38 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		if (b==0) {
			sink << "LDAA #$";
			} else {
			sink << "LDAB #$";
		}
		sink  << std::hex << opr8i;
	}
#line 20931 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 20935 "hcs12x.cc"
OpLdaab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 20939 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 20942 "hcs12x.cc"
)
{
#line 47 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		if (b==0) {
			cpu->setRegA(opr8i); // ldaa #<opr8i>
			} else {
			cpu->setRegB(opr8i); // ldab #<opr8i>
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (opr8i == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((opr8i & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
	}
#line 20957 "hcs12x.cc"
}

static Operation *DecodeOpLdaab_imm(CodeType const& code, uint16_t addr)
{
	return new OpLdaab_imm(code, addr);
}

// LDAA or LDAB opr8a
#line 65 "hcs12x.isa"
void
#line 20968 "hcs12x.cc"
OpLdaab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 20972 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 20975 "hcs12x.cc"
)
{
#line 62 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		if (b==0) {
			sink << "LDAA $";
			} else {
			sink << "LDAB $";
		}
		sink << std::hex << opr8a;
	}
#line 20987 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 20991 "hcs12x.cc"
OpLdaab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 20995 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 20998 "hcs12x.cc"
)
{
#line 71 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);
		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
	}
#line 21015 "hcs12x.cc"
}

static Operation *DecodeOpLdaab_dir(CodeType const& code, uint16_t addr)
{
	return new OpLdaab_dir(code, addr);
}

// LDAA or LDAB opr16a
#line 65 "hcs12x.isa"
void
#line 21026 "hcs12x.cc"
OpLdaab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21030 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21033 "hcs12x.cc"
)
{
#line 88 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		if (b==0) {
			sink << "LDAA $";
			} else {
			sink << "LDAB $";
		}
		sink << std::hex << opr16a;
	}
#line 21045 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21049 "hcs12x.cc"
OpLdaab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21053 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21056 "hcs12x.cc"
)
{
#line 97 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint8_t val = cpu->memRead8(addr);
		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21075 "hcs12x.cc"
}

static Operation *DecodeOpLdaab_ext(CodeType const& code, uint16_t addr)
{
	return new OpLdaab_ext(code, addr);
}

// LDAA or LDAB oprx0_xysp
// LDAA or LDAB oprx9,xysp
// LDAA or LDAB oprx16,xysp
// LDAA or LDAB [D,xysp]
// LDAA or LDAB [oprx16,xysp]
#line 65 "hcs12x.isa"
void
#line 21090 "hcs12x.cc"
OpLdaab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21094 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21097 "hcs12x.cc"
)
{
#line 120 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		if (b==0) {
			sink << "LDAA ";
			} else {
			sink << "LDAB ";
		}
		xb->disasm(sink);
	}
#line 21109 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21113 "hcs12x.cc"
OpLdaab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21117 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21120 "hcs12x.cc"
)
{
#line 129 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint8_t		val = cpu->memRead8(addr);

		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21141 "hcs12x.cc"
}

static Operation *DecodeOpLdaab_idx(CodeType const& code, uint16_t addr)
{
	return new OpLdaab_idx(code, addr);
}

// LDD or LDY or LDX or LDS #opr16i
#line 65 "hcs12x.isa"
void
#line 21152 "hcs12x.cc"
OpLd_dyxs_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21156 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21159 "hcs12x.cc"
)
{
#line 150 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "LDD #$"; break;
			case 1: sink << "LDY #$"; break;
			case 2: sink << "LDX #$"; break;
			case 3: sink << "LDS #$"; break;
		}
		sink << std::hex << opr16i;
	}
#line 21173 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21177 "hcs12x.cc"
OpLd_dyxs_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21181 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21184 "hcs12x.cc"
)
{
#line 161 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: cpu->setRegD(opr16i); break;
			case 1: cpu->setRegY(opr16i); break;
			case 2: cpu->setRegX(opr16i); break;
			case 3: cpu->setRegSP(opr16i); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (opr16i == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((opr16i & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21202 "hcs12x.cc"
}

static Operation *DecodeOpLd_dyxs_imm(CodeType const& code, uint16_t addr)
{
	return new OpLd_dyxs_imm(code, addr);
}

// LDD or LDY or LDX or LDS opr8a
#line 65 "hcs12x.isa"
void
#line 21213 "hcs12x.cc"
OpLd_dyxs_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21217 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21220 "hcs12x.cc"
)
{
#line 179 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "LDD $"; break;
			case 1: sink << "LDY $"; break;
			case 2: sink << "LDX $"; break;
			case 3: sink << "LDS $"; break;
		}
		sink << std::hex << dd;
	}
#line 21234 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21238 "hcs12x.cc"
OpLd_dyxs_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21242 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21245 "hcs12x.cc"
)
{
#line 190 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(dd, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);
		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21264 "hcs12x.cc"
}

static Operation *DecodeOpLd_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpLd_dyxs_dir(code, addr);
}

// LDD or LDY or LDX or LDS opr16a
#line 65 "hcs12x.isa"
void
#line 21275 "hcs12x.cc"
OpLd_dyxs_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21279 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21282 "hcs12x.cc"
)
{
#line 209 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "LDD $"; break;
			case 1: sink << "LDY $"; break;
			case 2: sink << "LDX $"; break;
			case 3: sink << "LDS $"; break;
		}

		sink << std::hex << opr16a;
	}
#line 21297 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21301 "hcs12x.cc"
OpLd_dyxs_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21305 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21308 "hcs12x.cc"
)
{
#line 221 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint16_t val = cpu->memRead16(addr);

		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21329 "hcs12x.cc"
}

static Operation *DecodeOpLd_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpLd_dyxs_ext(code, addr);
}

// LDD or LDY or LDX or LDS oprx0_xysp
// LDD or LDY or LDX or LDS oprx9,xysp
// LDD or LDY or LDX or LDS oprx16,xysp
// LDD or LDY or LDX or LDS [D,xysp]
// LDD or LDY or LDX or LDS [oprx16,xysp]
#line 65 "hcs12x.isa"
void
#line 21344 "hcs12x.cc"
OpLd_dyxs_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21348 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21351 "hcs12x.cc"
)
{
#line 246 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "LDD "; break;
			case 1: sink << "LDY "; break;
			case 2: sink << "LDX "; break;
			case 3: sink << "LDS "; break;
		}

		xb->disasm(sink);
	}
#line 21366 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21370 "hcs12x.cc"
OpLd_dyxs_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21374 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21377 "hcs12x.cc"
)
{
#line 258 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint16_t	val = cpu->memRead16(addr);

		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21399 "hcs12x.cc"
}

static Operation *DecodeOpLd_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpLd_dyxs_idx(code, addr);
}

// LEAY oprx0_xysp
// LEAY oprx9,xysp
// LEAY oprx16,xysp
#line 65 "hcs12x.isa"
void
#line 21412 "hcs12x.cc"
OpLeay::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21416 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21419 "hcs12x.cc"
)
{
#line 283 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		sink << "LEAY ";
		xb->disasm(sink);
	}
#line 21428 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21432 "hcs12x.cc"
OpLeay::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21436 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21439 "hcs12x.cc"
)
{
#line 289 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		address_t	addr = xb->getEAddr(cpu);

		cpu->setRegY(addr);

	}
#line 21450 "hcs12x.cc"
}

static Operation *DecodeOpLeay(CodeType const& code, uint16_t addr)
{
	return new OpLeay(code, addr);
}

// LEAX oprx0_xysp
// LEAX oprx9,xysp
// LEAX oprx16,xysp
#line 65 "hcs12x.isa"
void
#line 21463 "hcs12x.cc"
OpLeax::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21467 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21470 "hcs12x.cc"
)
{
#line 302 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		sink << "LEAX ";

		xb->disasm(sink);
	}
#line 21480 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21484 "hcs12x.cc"
OpLeax::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21488 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21491 "hcs12x.cc"
)
{
#line 309 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		address_t	addr = xb->getEAddr(cpu);

		cpu->setRegX(addr);

	}
#line 21502 "hcs12x.cc"
}

static Operation *DecodeOpLeax(CodeType const& code, uint16_t addr)
{
	return new OpLeax(code, addr);
}

// LEAS  oprx0_xysp
// LEAS  oprx9,xysp
// LEAS  oprx16,xysp
#line 65 "hcs12x.isa"
void
#line 21515 "hcs12x.cc"
OpLeas::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21519 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21522 "hcs12x.cc"
)
{
#line 322 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		sink << "LEAS ";

		xb->disasm(sink);
	}
#line 21532 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21536 "hcs12x.cc"
OpLeas::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21540 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21543 "hcs12x.cc"
)
{
#line 329 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		address_t	addr = xb->getEAddr(cpu);

		cpu->setRegSP(addr);

	}
#line 21554 "hcs12x.cc"
}

static Operation *DecodeOpLeas(CodeType const& code, uint16_t addr)
{
	return new OpLeas(code, addr);
}

// STAA or STAB opr8a
#line 65 "hcs12x.isa"
void
#line 21565 "hcs12x.cc"
OpStaab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21569 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21572 "hcs12x.cc"
)
{
#line 340 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		if (b==0) {
			sink << "STAA $";
			} else {
			sink << "STAB $";
		}
		sink << std::hex << opr8a;

	}
#line 21586 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21590 "hcs12x.cc"
OpStaab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21594 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21597 "hcs12x.cc"
)
{
#line 351 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t val;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);

		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }

		cpu->memWrite8(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21616 "hcs12x.cc"
}

static Operation *DecodeOpStaab_dir(CodeType const& code, uint16_t addr)
{
	return new OpStaab_dir(code, addr);
}

// STAA or STAB opr16a
#line 65 "hcs12x.isa"
void
#line 21627 "hcs12x.cc"
OpStaab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21631 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21634 "hcs12x.cc"
)
{
#line 370 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		if (b==0) {
			sink << "STAA $";
			} else {
			sink << "STAB $";
		}
		sink << std::hex << opr16a;

	}
#line 21648 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21652 "hcs12x.cc"
OpStaab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21656 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21659 "hcs12x.cc"
)
{
#line 381 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t	val;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }
		cpu->memWrite8(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21677 "hcs12x.cc"
}

static Operation *DecodeOpStaab_ext(CodeType const& code, uint16_t addr)
{
	return new OpStaab_ext(code, addr);
}

// STAA or STAB oprx0_xysp
// STAA or STAB oprx9,xysp
// STAA or STAB oprx16,xysp
// STAA or STAB [D,xysp]
// STAA or STAB [oprx16,xysp]
#line 65 "hcs12x.isa"
void
#line 21692 "hcs12x.cc"
OpStaab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21696 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21699 "hcs12x.cc"
)
{
#line 404 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		if (b==0) {
			sink << "STAA ";
			} else {
			sink << "STAB ";
		}
		xb->disasm(sink);

	}
#line 21713 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21717 "hcs12x.cc"
OpStaab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21721 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21724 "hcs12x.cc"
)
{
#line 415 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint8_t val;
		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }
		cpu->memWrite8(addr,val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21742 "hcs12x.cc"
}

static Operation *DecodeOpStaab_idx(CodeType const& code, uint16_t addr)
{
	return new OpStaab_idx(code, addr);
}

// STD or STY or STX or STS opr8a
#line 65 "hcs12x.isa"
void
#line 21753 "hcs12x.cc"
OpSt_dyxs_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21757 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21760 "hcs12x.cc"
)
{
#line 433 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "STD $"; break;
			case 1: sink << "STY $"; break;
			case 2: sink << "STX $"; break;
			case 3: sink << "STS $"; break;
		}

		sink << std::hex << opr8a;
	}
#line 21775 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21779 "hcs12x.cc"
OpSt_dyxs_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21783 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21786 "hcs12x.cc"
)
{
#line 445 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}

		cpu->memWrite16(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21810 "hcs12x.cc"
}

static Operation *DecodeOpSt_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpSt_dyxs_dir(code, addr);
}

// STD or STY or STX or STS opr16a
#line 65 "hcs12x.isa"
void
#line 21821 "hcs12x.cc"
OpSt_dyxs_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21825 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21828 "hcs12x.cc"
)
{
#line 469 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "STD $"; break;
			case 1: sink << "STY $"; break;
			case 2: sink << "STX $"; break;
			case 3: sink << "STS $"; break;
		}

		sink << std::hex << opr16a;

	}
#line 21844 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21848 "hcs12x.cc"
OpSt_dyxs_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21852 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21855 "hcs12x.cc"
)
{
#line 482 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val = 0;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}

		cpu->memWrite16(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21879 "hcs12x.cc"
}

static Operation *DecodeOpSt_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpSt_dyxs_ext(code, addr);
}

// STD or STY or STX or STS oprx0_xysp
// STD or STY or STX or STS oprx9,xysp
// STD or STY or STX or STS oprx16,xysp
// STD or STY or STX or STS [D,xysp]
// STD or STY or STX or STS [oprx16,xysp]
#line 65 "hcs12x.isa"
void
#line 21894 "hcs12x.cc"
OpSt_dyxs_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21898 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21901 "hcs12x.cc"
)
{
#line 511 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "STD "; break;
			case 1: sink << "STY "; break;
			case 2: sink << "STX "; break;
			case 3: sink << "STS "; break;
		}

		xb->disasm(sink);

	}
#line 21917 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21921 "hcs12x.cc"
OpSt_dyxs_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21925 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21928 "hcs12x.cc"
)
{
#line 524 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint16_t val = 0;

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}
		cpu->memWrite16(addr,val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 21952 "hcs12x.cc"
}

static Operation *DecodeOpSt_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpSt_dyxs_idx(code, addr);
}

// **********  GLOBAL MEMORY MODE ***************
// GLDAA or GLDAB opr8a
#line 65 "hcs12x.isa"
void
#line 21964 "hcs12x.cc"
OpGldaab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 21968 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 21971 "hcs12x.cc"
)
{
#line 550 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		if (b==0) {
			sink << "GLDAA $";
			} else {
			sink << "GLDAB $";
		}
		sink << std::hex << opr8a;
	}
#line 21983 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 21987 "hcs12x.cc"
OpGldaab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 21991 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 21994 "hcs12x.cc"
)
{
#line 559 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, W_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);
		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
	}
#line 22011 "hcs12x.cc"
}

static Operation *DecodeOpGldaab_dir(CodeType const& code, uint16_t addr)
{
	return new OpGldaab_dir(code, addr);
}

// GLDAA or GLDAB opr16a
#line 65 "hcs12x.isa"
void
#line 22022 "hcs12x.cc"
OpGldaab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22026 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22029 "hcs12x.cc"
)
{
#line 576 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		if (b==0) {
			sink << "GLDAA $";
			} else {
			sink << "GLDAB $";
		}
		sink << std::hex << opr16a;
	}
#line 22041 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22045 "hcs12x.cc"
OpGldaab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22049 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22052 "hcs12x.cc"
)
{
#line 585 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, W_GLOBAL_ADDRESS);

		uint8_t val = cpu->memRead8(addr);
		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22071 "hcs12x.cc"
}

static Operation *DecodeOpGldaab_ext(CodeType const& code, uint16_t addr)
{
	return new OpGldaab_ext(code, addr);
}

// GLDAA or GLDAB oprx0_xysp
// GLDAA or GLDAB oprx9,xysp
// GLDAA or GLDAB oprx16,xysp
// GLDAA or GLDAB [D,xysp]
// GLDAA or GLDAB [oprx16,xysp]
#line 65 "hcs12x.isa"
void
#line 22086 "hcs12x.cc"
OpGldaab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22090 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22093 "hcs12x.cc"
)
{
#line 608 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		if (b==0) {
			sink << "GLDAA ";
			} else {
			sink << "GLDAB ";
		}
		xb->disasm(sink);
	}
#line 22105 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22109 "hcs12x.cc"
OpGldaab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22113 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22116 "hcs12x.cc"
)
{
#line 617 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, W_GLOBAL_ADDRESS);

		uint8_t		val = cpu->memRead8(addr);

		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22137 "hcs12x.cc"
}

static Operation *DecodeOpGldaab_idx(CodeType const& code, uint16_t addr)
{
	return new OpGldaab_idx(code, addr);
}

// GLDD or GLDY or GLDX or GLDS opr8a
#line 65 "hcs12x.isa"
void
#line 22148 "hcs12x.cc"
OpGld_dyxs_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22152 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22155 "hcs12x.cc"
)
{
#line 638 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "GLDD $"; break;
			case 1: sink << "GLDY $"; break;
			case 2: sink << "GLDX $"; break;
			case 3: sink << "GLDS $"; break;
		}
		sink << std::hex << dd;
	}
#line 22169 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22173 "hcs12x.cc"
OpGld_dyxs_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22177 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22180 "hcs12x.cc"
)
{
#line 649 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(dd, MEMORY::DIRECT, W_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);
		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22199 "hcs12x.cc"
}

static Operation *DecodeOpGld_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpGld_dyxs_dir(code, addr);
}

// GLDD or GLDY or GLDX or GLDS opr16a
#line 65 "hcs12x.isa"
void
#line 22210 "hcs12x.cc"
OpGld_dyxs_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22214 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22217 "hcs12x.cc"
)
{
#line 668 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "GLDD $"; break;
			case 1: sink << "GLDY $"; break;
			case 2: sink << "GLDX $"; break;
			case 3: sink << "GLDS $"; break;
		}

		sink << std::hex << opr16a;
	}
#line 22232 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22236 "hcs12x.cc"
OpGld_dyxs_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22240 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22243 "hcs12x.cc"
)
{
#line 680 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, W_GLOBAL_ADDRESS);

		uint16_t val = cpu->memRead16(addr);

		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22264 "hcs12x.cc"
}

static Operation *DecodeOpGld_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpGld_dyxs_ext(code, addr);
}

// GLDD or GLDY or GLDX or GLDS oprx0_xysp
// GLDD or GLDY or GLDX or GLDS oprx9,xysp
// GLDD or GLDY or GLDX or GLDS oprx16,xysp
// GLDD or GLDY or GLDX or GLDS [D,xysp]
// GLDD or GLDY or GLDX or GLDS [oprx16,xysp]
#line 65 "hcs12x.isa"
void
#line 22279 "hcs12x.cc"
OpGld_dyxs_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22283 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22286 "hcs12x.cc"
)
{
#line 705 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "GLDD "; break;
			case 1: sink << "GLDY "; break;
			case 2: sink << "GLDX "; break;
			case 3: sink << "GLDS "; break;
		}

		xb->disasm(sink);
	}
#line 22301 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22305 "hcs12x.cc"
OpGld_dyxs_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22309 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22312 "hcs12x.cc"
)
{
#line 717 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, W_GLOBAL_ADDRESS);

		uint16_t	val = cpu->memRead16(addr);

		switch (dyxs) {
			case 0: cpu->setRegD(val); break;
			case 1: cpu->setRegY(val); break;
			case 2: cpu->setRegX(val); break;
			case 3: cpu->setRegSP(val); break;
		}
		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22334 "hcs12x.cc"
}

static Operation *DecodeOpGld_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpGld_dyxs_idx(code, addr);
}

// GSTAA or GSTAB opr8a
#line 65 "hcs12x.isa"
void
#line 22345 "hcs12x.cc"
OpGstaab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22349 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22352 "hcs12x.cc"
)
{
#line 739 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		if (b==0) {
			sink << "GSTAA $";
			} else {
			sink << "GSTAB $";
		}
		sink << std::hex << opr8a;

	}
#line 22366 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22370 "hcs12x.cc"
OpGstaab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22374 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22377 "hcs12x.cc"
)
{
#line 750 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t val;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, W_GLOBAL_ADDRESS);

		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }

		cpu->memWrite8(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22396 "hcs12x.cc"
}

static Operation *DecodeOpGstaab_dir(CodeType const& code, uint16_t addr)
{
	return new OpGstaab_dir(code, addr);
}

// GSTAA or GSTAB opr16a
#line 65 "hcs12x.isa"
void
#line 22407 "hcs12x.cc"
OpGstaab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22411 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22414 "hcs12x.cc"
)
{
#line 769 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		if (b==0) {
			sink << "GSTAA $";
			} else {
			sink << "GSTAB $";
		}
		sink << std::hex << opr16a;

	}
#line 22428 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22432 "hcs12x.cc"
OpGstaab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22436 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22439 "hcs12x.cc"
)
{
#line 780 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint8_t	val;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, W_GLOBAL_ADDRESS);

		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }
		cpu->memWrite8(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22457 "hcs12x.cc"
}

static Operation *DecodeOpGstaab_ext(CodeType const& code, uint16_t addr)
{
	return new OpGstaab_ext(code, addr);
}

// GSTAA or GSTAB oprx0_xysp
// GSTAA or GSTAB oprx9,xysp
// GSTAA or GSTAB oprx16,xysp
// GSTAA or GSTAB [D,xysp]
// GSTAA or GSTAB [oprx16,xysp]
#line 65 "hcs12x.isa"
void
#line 22472 "hcs12x.cc"
OpGstaab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22476 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22479 "hcs12x.cc"
)
{
#line 803 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		if (b==0) {
			sink << "GSTAA ";
			} else {
			sink << "GSTAB ";
		}
		xb->disasm(sink);

	}
#line 22493 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22497 "hcs12x.cc"
OpGstaab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22501 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22504 "hcs12x.cc"
)
{
#line 814 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, W_GLOBAL_ADDRESS);

		uint8_t val;
		if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }
		cpu->memWrite8(addr,val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22522 "hcs12x.cc"
}

static Operation *DecodeOpGstaab_idx(CodeType const& code, uint16_t addr)
{
	return new OpGstaab_idx(code, addr);
}

// GSTD or GSTY or GSTX or GSTS opr8a
#line 65 "hcs12x.isa"
void
#line 22533 "hcs12x.cc"
OpGst_dyxs_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22537 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22540 "hcs12x.cc"
)
{
#line 832 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "GSTD $"; break;
			case 1: sink << "GSTY $"; break;
			case 2: sink << "GSTX $"; break;
			case 3: sink << "GSTS $"; break;
		}

		sink << std::hex << opr8a;
	}
#line 22555 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22559 "hcs12x.cc"
OpGst_dyxs_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22563 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22566 "hcs12x.cc"
)
{
#line 844 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, W_GLOBAL_ADDRESS);

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}

		cpu->memWrite16(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22590 "hcs12x.cc"
}

static Operation *DecodeOpGst_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpGst_dyxs_dir(code, addr);
}

// GSTD or GSTY or GSTX or GSTS opr16a
#line 65 "hcs12x.isa"
void
#line 22601 "hcs12x.cc"
OpGst_dyxs_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22605 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22608 "hcs12x.cc"
)
{
#line 868 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "GSTD $"; break;
			case 1: sink << "GSTY $"; break;
			case 2: sink << "GSTX $"; break;
			case 3: sink << "GSTS $"; break;
		}

		sink << std::hex << opr16a;

	}
#line 22624 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22628 "hcs12x.cc"
OpGst_dyxs_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22632 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22635 "hcs12x.cc"
)
{
#line 881 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		uint16_t val = 0;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, W_GLOBAL_ADDRESS);

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}

		cpu->memWrite16(addr, val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22659 "hcs12x.cc"
}

static Operation *DecodeOpGst_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpGst_dyxs_ext(code, addr);
}

// GSTD or GSTY or GSTX or GSTS oprx0_xysp
// GSTD or GSTY or GSTX or GSTS oprx9,xysp
// GSTD or GSTY or GSTX or GSTS oprx16,xysp
// GSTD or GSTY or GSTX or GSTS [D,xysp]
// GSTD or GSTY or GSTX or GSTS [oprx16,xysp]
#line 65 "hcs12x.isa"
void
#line 22674 "hcs12x.cc"
OpGst_dyxs_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22678 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22681 "hcs12x.cc"
)
{
#line 910 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		switch (dyxs) {
			case 0: sink << "GSTD "; break;
			case 1: sink << "GSTY "; break;
			case 2: sink << "GSTX "; break;
			case 3: sink << "GSTS "; break;
		}

		xb->disasm(sink);

	}
#line 22697 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22701 "hcs12x.cc"
OpGst_dyxs_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22705 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22708 "hcs12x.cc"
)
{
#line 923 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./load_store.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, W_GLOBAL_ADDRESS);

		uint16_t val = 0;

		switch (dyxs) {
			case 0: val = cpu->getRegD(); break;
			case 1: val = cpu->getRegY(); break;
			case 2: val = cpu->getRegX(); break;
			case 3: val = cpu->getRegSP(); break;
		}
		cpu->memWrite16(addr,val);

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

	}
#line 22732 "hcs12x.cc"
}

static Operation *DecodeOpGst_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpGst_dyxs_idx(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// A->B  or B->A
#line 65 "hcs12x.isa"
void
#line 22776 "hcs12x.cc"
OpT_ab_ba::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22780 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22783 "hcs12x.cc"
)
{
#line 39 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		if (b == 0) { sink << "TAB"; } else { sink << "TBA";}
	}
#line 22790 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22794 "hcs12x.cc"
OpT_ab_ba::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22798 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22801 "hcs12x.cc"
)
{
#line 43 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		uint8_t val;

		if (b == 0) {
			val = cpu->getRegA();
			cpu->setRegB(val);
			} else {
			val = cpu->getRegB();
			cpu->setRegA(val);
		}

		// CRC flags 0->V; setZ; setN
		cpu->ccr->clrV();
		if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
	}
#line 22821 "hcs12x.cc"
}

static Operation *DecodeOpT_ab_ba(CodeType const& code, uint16_t addr)
{
	return new OpT_ab_ba(code, addr);
}

// ****************  Common Section to HCS12X ( HLS = 0 ) *************
// *************** HCS12 - EXCHANGE Instructions ************
// XGDX or XGDY or EXG
/*
* lms sourceRegister index
* lls destinationRegister index
* */
#line 65 "hcs12x.isa"
void
#line 22838 "hcs12x.cc"
OpExg_hcs12::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22842 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22845 "hcs12x.cc"
)
{
#line 69 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{

		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: rrSrc = EBLB::EBLBRegs::CCRL; break; // src is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrSrc = EBLB::EBLBRegs::TMP3; break; // src is 0x32 register
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: rrDst = EBLB::EBLBRegs::CCRL; break; // dst is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrDst = EBLB::EBLBRegs::TMP2; break; // dst is 0x31 register
			default: rrDst = lls;
		}

		// Exchange register Contents. There is no sign extension
		uint8_t eb = (1 << 8) | (lms << 4) | (0 << 3) | lls;

		switch (eb)
		{
			case 0xC5: sink << "XGDX "; break;
			case 0xC6: sink << "XGDY "; break;
			default: sink << "EXG ";
		}

		sink << EBLB::getRegName(rrSrc) << "," << EBLB::getRegName(rrDst);

	}
#line 22879 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 22883 "hcs12x.cc"
OpExg_hcs12::execute(
#line 60 "hcs12x.isa"
CPU *
#line 22887 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 22890 "hcs12x.cc"
)
{
#line 100 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		/* Legal "rr" value for EBLB::setter and EBLB::getter functions
		* 0x00:A; 0x01:B;
		* 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRW
		* 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
		* 0x04:D; 0x05:X; 0x06:Y; 0x07:SP
		*/

		uint8_t srcSize, dstSize;
		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: rrSrc = EBLB::EBLBRegs::CCRL; break; // src is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrSrc = EBLB::EBLBRegs::TMP3; break; // src is 0x32 register
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: rrDst = EBLB::EBLBRegs::CCRL; break; // dst is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrDst = EBLB::EBLBRegs::TMP2; break; // dst is 0x31 register
			default: rrDst = lls;
		}

		srcSize = EBLB::getRegSize(rrSrc);
		dstSize = EBLB::getRegSize(rrDst);

		// Exchange register Contents. EXG r1, r2
		// There is no sign extension
		// Only CCR[7:0] is used for HCS12

		if (srcSize == dstSize) {
			// (r1) <=> (r2)
			if (srcSize == 8) {
				cpu->eblb->exchange<uint8_t>(rrSrc, rrDst);
				} else {
				cpu->eblb->exchange<uint16_t>(rrSrc, rrDst);
			}
		}
		else if (((srcSize == 8) || (lms == 2)) && (dstSize == 16)) {
			// $00:(r1) => r2
			// if r2 isn't D then && (r2[7:0]) => r1
			uint16_t r1Val = 0x00FF & cpu->eblb->getter<uint8_t>(rrSrc);
			uint8_t r2Val = (uint8_t) cpu->eblb->getter<uint16_t>(rrDst); // only low 8 bits
			cpu->eblb->setter<uint16_t>(rrDst, r1Val);
			if (rrDst != 4 /* reg D*/) {
				cpu->eblb->setter<uint16_t>(rrDst, r2Val);
			}
		}
		else if ((srcSize == 16) && (dstSize == 8)) {
			// (r1[7:0]) => (r2)
			// if r2 is A then $00:(r2) => r1 else $FF:(r2) => r1
			uint8_t r1Val = cpu->eblb->getter<uint16_t>(rrSrc); // only low 8 bits
			uint8_t r2Val = cpu->eblb->getter<uint8_t>(rrDst);

			cpu->eblb->setter<uint8_t>(rrDst,r1Val);
			if (rrDst == 0 /*reg A*/) {
				cpu->eblb->setter<uint16_t>(rrSrc, 0x00FF & r2Val);
				} else {
				cpu->eblb->setter<uint16_t>(rrSrc, 0xFF00 | r2Val);
			}
		}

	}
#line 22958 "hcs12x.cc"
}

static Operation *DecodeOpExg_hcs12(CodeType const& code, uint16_t addr)
{
	return new OpExg_hcs12(code, addr);
}

// ***************************  TRANSFER Instructions
// TFR or TPA or TSX or TSY or TXS or TYS or SEX
/*
* lms sourceRegister index
* lls destinationRegister index
* */
#line 65 "hcs12x.isa"
void
#line 22974 "hcs12x.cc"
OpTfr_hcs12::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 22978 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 22981 "hcs12x.cc"
)
{
#line 173 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{

		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: rrSrc = EBLB::EBLBRegs::CCRL; break; // src is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrSrc = EBLB::EBLBRegs::TMP3; break; // src is 0x32 register
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: rrDst = EBLB::EBLBRegs::CCRL; break; // dst is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrDst = EBLB::EBLBRegs::TMP2; break; // dst is 0x31 register
			default: rrDst = lls;
		}

		// Transfer Register Content to Another register
		uint8_t eb = (0 << 8) | (lms << 4) | (0 << 3) | lls;

		switch (eb)
		{
			case 0x02: sink << "TAP "; break;
			case 0x20: sink << "TPA "; break;
			case 0x75: sink << "TSX "; break;
			case 0x76: sink << "TSY "; break;
			case 0x57: sink << "TXS "; break;
			case 0x67: sink << "TYS "; break;
			default: sink << "TFR " << EBLB::getRegName(rrSrc) << "," << EBLB::getRegName(rrDst);
		}

	}
#line 23017 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23021 "hcs12x.cc"
OpTfr_hcs12::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23025 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23028 "hcs12x.cc"
)
{
#line 207 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		/* Legal "rr" value for EBLB::setter and EBLB::getter functions
		* 0x00:A; 0x01:B;
		* 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRW
		* 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
		* 0x04:D; 0x05:X; 0x06:Y; 0x07:SP
		*/

		uint8_t srcSize, dstSize;
		uint8_t rrSrc, rrDst;
		uint8_t oldCCRLow = cpu->ccr->getCCRLow();

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: rrSrc = EBLB::EBLBRegs::CCRL; break; // src is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrSrc = EBLB::EBLBRegs::TMP3; break; // src is 0x32 register
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: rrDst = EBLB::EBLBRegs::CCRL; break; // dst is 0x21 register
			case EBLB::EBLBMSLSRegs::TMPx: rrDst = EBLB::EBLBRegs::TMP2; break; // dst is 0x31 register
			default: rrDst = lls;
		}

		srcSize = EBLB::getRegSize(rrSrc);
		dstSize = EBLB::getRegSize(rrDst);

		// Transfer Register Content to Another register
		// Only CCR[7:0] is used for HCS12

		/*
		if (sizeof(r1) && sizeof(r2) { (r1) => (r2)}
		else if ( (sizeof(r1)==8) && (sizeof(r2)==16) ) {sex:r1 => r2}
		else if ( (sizeof(r1)==16) && (sizeof(r2)==8) ) { (r1[7:0]) => (r2) }
		*/

		if (srcSize == dstSize) {
			// (r1) => (r2)
			if (srcSize == 8) {
				cpu->eblb->setter<uint8_t>(rrDst, cpu->eblb->getter<uint8_t>(rrSrc));
				} else {
				cpu->eblb->setter<uint16_t>(rrDst, cpu->eblb->getter<uint16_t>(rrSrc));
			}
		}
		else if (((srcSize == 8) || (lms == 2)) && (dstSize == 16)) {
			// sex:r1 => r2
			if ((cpu->eblb->getter<uint8_t>(rrSrc) & 0x80) == 0x80)
			{ // if r1 bit 7 = 1 then $FF:(r1) => r2
				cpu->eblb->setter<uint16_t>(rrDst, ((uint16_t) cpu->eblb->getter<uint8_t>(rrSrc)) | 0xFF00);
			} else
			{ // if r1 bit 7 = 1 then $00:(r1) => r2
				cpu->eblb->setter<uint16_t>(rrDst, ((uint16_t) cpu->eblb->getter<uint8_t>(rrSrc)) & 0x00FF);
			}
		}
		else if ((srcSize == 16) && (dstSize == 8)) {
			// (r1[7:0]) => (r2)
			uint8_t tmp = cpu->eblb->getter<uint16_t>(rrSrc) & 0x00FF;
			cpu->eblb->setter<uint8_t>(rrDst, tmp);
		}

		if ((oldCCRLow & 0x40) == 0x00) {
			cpu->ccr->setCCRLow(cpu->ccr->getCCRLow() & 0xBF);
		}
	}
#line 23097 "hcs12x.cc"
}

static Operation *DecodeOpTfr_hcs12(CodeType const& code, uint16_t addr)
{
	return new OpTfr_hcs12(code, addr);
}

// ****************  Specific Section to HCS12X ( HLS = 1 ) *************
// ***************  HCS12X - EXCHANGE Instructions ************
// XGDX or XGDY or EXG
/*
* lms sourceRegister index
* lls destinationRegister index
* */
#line 65 "hcs12x.isa"
void
#line 23114 "hcs12x.cc"
OpExg_hcs12x::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23118 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23121 "hcs12x.cc"
)
{
#line 283 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{

		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: // src is CCRW register
			if (lls == EBLB::EBLBMSLSRegs::A) {
				rrSrc = EBLB::EBLBRegs::CCRH; //0x22;
				} else if (lls = EBLB::EBLBMSLSRegs::B) {
				rrSrc = EBLB::EBLBRegs::CCRL; //0x21;
				} else {
				rrSrc = EBLB::EBLBRegs::CCRW; //0x23;
			}
			break;
			case EBLB::EBLBMSLSRegs::TMPx: // src is TMP register
			if (lls = EBLB::EBLBMSLSRegs::D) {
				rrSrc = EBLB::EBLBRegs::TMP1; //0x30; // TMP1
				} else {
				rrSrc = EBLB::EBLBRegs::TMP3; //0x32; // TMP3
			}
			break;
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: // dst is CCRW register
			if (lms == EBLB::EBLBMSLSRegs::A) {
				rrDst = EBLB::EBLBRegs::CCRH; //0x22;
				} else if (lms == EBLB::EBLBMSLSRegs::B) {
				rrDst = EBLB::EBLBRegs::CCRL; //0x21;
				} else {
				rrDst = EBLB::EBLBRegs::CCRW; //0x23;
			}

			break;
			case EBLB::EBLBMSLSRegs::TMPx: // dst is TMP2 register
			if (lms == EBLB::EBLBRegs::D ) {
				rrDst = EBLB::EBLBRegs::TMP1; //0x30; // TMP1
				} else {
				rrDst = EBLB::EBLBRegs::TMP2; //0x31; // TMP2
			}
			break;
			default: rrDst = lls;
		}

		// Exchange register Contents. There is no sign extension

		string srcName = EBLB::getRegName(rrSrc);
		string dstName = EBLB::getRegName(rrDst);

		if (lls == EBLB::EBLBMSLSRegs::A ) {
			if (lms == EBLB::EBLBMSLSRegs::CCR ) {
				srcName = EBLB::getRegName(EBLB::EBLBRegs::CCRH);
			}
			else if ((lms != EBLB::EBLBMSLSRegs::B ) && (lms != EBLB::EBLBMSLSRegs::D)) {
				srcName = srcName + "H";
			}
			} if (lls == EBLB::EBLBMSLSRegs::B) {
			if (lms == EBLB::EBLBMSLSRegs::CCR) {
				srcName = EBLB::getRegName(EBLB::EBLBRegs::CCRL);
			}
			else if ((lms != EBLB::EBLBMSLSRegs::A ) && (lms != EBLB::EBLBMSLSRegs::D)) {
				srcName = srcName + "L";
			}
		}

		if (lms == EBLB::EBLBMSLSRegs::A) {
			if (lls == EBLB::EBLBMSLSRegs::CCR /* reg CCR */) {
				dstName = EBLB::getRegName(EBLB::EBLBRegs::CCRH);
			}
			else if ((lls != EBLB::EBLBMSLSRegs::B) && (lls != EBLB::EBLBMSLSRegs::D)) {
				dstName = dstName + "H";
			}
			} if (lms == EBLB::EBLBMSLSRegs::B) {
			if (lls == EBLB::EBLBMSLSRegs::CCR) {
				dstName = EBLB::getRegName(EBLB::EBLBRegs::CCRL);
			}
			else if ((lls != EBLB::EBLBMSLSRegs::A) && (lls != EBLB::EBLBMSLSRegs::D)) {
				dstName = dstName + "L";
			}
		}

		// Exchange Registers Contents
		uint8_t eb = (1 << 8) | (lms << 4) | (1 << 3) | lls;

		switch (eb)
		{
			case 0xC5: sink << "XGDX "; break;
			case 0xC6: sink << "XGDY "; break;
			default: sink << "EXG ";
		}

		sink << srcName << "," << dstName;

	}
#line 23221 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23225 "hcs12x.cc"
OpExg_hcs12x::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23229 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23232 "hcs12x.cc"
)
{
#line 380 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		/* Legal "rr" value for EBLB::setter and EBLB::getter functions
		* 0x00:A; 0x01:B;
		* 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRWord
		* 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
		* 0x04:D; 0x05:X; 0x06:Y; 0x07:SP
		*/

		uint8_t srcSize, dstSize;
		uint8_t rrSrc, rrDst;
		uint8_t oldCCRLow = cpu->ccr->getCCRLow();

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
		case EBLB::EBLBMSLSRegs::CCR:
			rrSrc = EBLB::EBLBRegs::CCRW;  // src is 0x23 register
			break;
		case EBLB::EBLBMSLSRegs::TMPx:
			if (lls == EBLB::EBLBMSLSRegs::D) {
				rrSrc = EBLB::EBLBRegs::TMP1; /* src is 0x30 register*/
				} else {
				rrSrc = EBLB::EBLBRegs::TMP3; /* src is 0x32 register*/
			}
			break;
			default: rrSrc = lms;
		}

		switch (lls) {
		case EBLB::EBLBMSLSRegs::CCR:
			rrDst = EBLB::EBLBRegs::CCRW; // rrDst is 0x23 register
			break;
		case EBLB::EBLBMSLSRegs::TMPx:
			if (lms == EBLB::EBLBMSLSRegs::D) {
				rrDst = EBLB::EBLBRegs::TMP1; /* src is 0x30 register*/
				} else {
				rrDst = EBLB::EBLBRegs::TMP3; /* src is 0x32 register*/
			}
			break;
			default: rrDst = lls;
		}

		srcSize = EBLB::getRegSize(rrSrc);
		dstSize = EBLB::getRegSize(rrDst);

		// Exchange register Contents. There is no sign extension
		/*
		if (sizeof(r1) && sizeof(r2) { (r1) <=> (r2)}
		else if ( (sizeof(r1)==8) && (sizeof(r2)==16) ) {$00:(r1) => r2}
		else if ( (sizeof(r1)==16) && (sizeof(r2)==8) ) { (r1[7:0]) <=> (r2) }
		*/

		if ( srcSize == dstSize)
		{
			// (r1) <=> (r2)
			if (srcSize == 8)
			{
				cpu->eblb->exchange<uint8_t>(rrSrc,rrDst);
			}
			else if (srcSize == 16)
			{
				cpu->eblb->exchange<uint16_t>(rrSrc,rrDst);
			}
		}
		else if ((srcSize == 8) && (dstSize == 16))
		{
			// $00:(r1) => r2
			/* if (r2 is D) $00:(r1) => D
			* else
			*  if (r1 is A) (r1) => r2H
			*  else if (r1 is B) (r1) => r2L
			*/
			if (rrDst == EBLB::EBLBRegs::D /* reg D */)
			{
				cpu->eblb->setter<uint16_t>(rrDst, 0x00FF & cpu->eblb->getter<uint8_t>(rrSrc));
			}
			else if (rrSrc == EBLB::EBLBRegs::A)
			{
				uint16_t tmp = cpu->eblb->getter<uint16_t>(rrDst) & 0x00FF;  // get the lower bits
				tmp = tmp | (((uint16_t) cpu->eblb->getter<uint8_t>(rrSrc)) << 8);
				cpu->eblb->setter<uint16_t>(rrDst, tmp);
			}
			else if (rrSrc == EBLB::EBLBRegs::B)
			{
				uint16_t tmp = cpu->eblb->getter<uint16_t>(rrDst) & 0xFF00; // get higher bits
				tmp = tmp | ( 0x00FF & cpu->eblb->getter<uint8_t>(rrSrc));
				cpu->eblb->setter<uint16_t>(rrDst, tmp);
			}
		}
		else if ((srcSize == 16) && (dstSize == 8))
		{
			// (r1[7:0]) <=> (r2)
			/*
			* if (r1 is D)
			* 	 if (r2 is A) (B) <=> (A)
			* 	 else $FF => A // r2 is B
			* else
			* 	 if (r2 is A) (r1H) <=> A
			* 	 else (r1L) <=> B
			*/
			if (rrSrc == EBLB::EBLBRegs::D) {
				if (rrDst == EBLB::EBLBRegs::A) {
					cpu->eblb->exchange<uint8_t>(EBLB::EBLBRegs::B, EBLB::EBLBRegs::A);
					} else if (rrDst == EBLB::EBLBRegs::B) {
					cpu->eblb->setter<uint8_t>(EBLB::EBLBRegs::A, 0xFF);
				}
				} else {
				if (rrDst == EBLB::EBLBRegs::A) {
					uint16_t a16 = ((uint16_t) cpu->eblb->getter<uint16_t>(EBLB::EBLBRegs::A)) << 8;
					uint8_t r1h = cpu->eblb->getter<uint16_t>(rrSrc) >> 8;
					uint16_t r1l = cpu->eblb->getter<uint16_t>(rrSrc) & 0x00FF;

					cpu->eblb->setter<uint16_t>(rrSrc, a16 | r1l);
					cpu->eblb->setter<uint8_t>(rrDst, r1h);

					} else if (rrDst == EBLB::EBLBRegs::B) {
					uint16_t r1h = cpu->eblb->getter<uint16_t>(rrSrc) & 0xFF00;
					uint8_t r1l = cpu->eblb->getter<uint16_t>(rrSrc) & 0x00FF;
					uint16_t b16 = 0x00FF & cpu->eblb->getter<uint8_t>(rrDst);

					cpu->eblb->setter<uint16_t>(rrSrc, r1h | b16);
					cpu->eblb->setter<uint16_t>(rrDst, r1l);
				}
			}
		}

		if ((oldCCRLow & 0x40) == 0x00) {
			cpu->ccr->setCCRLow(cpu->ccr->getCCRLow() & 0xBF);
		}
	}
#line 23365 "hcs12x.cc"
}

static Operation *DecodeOpExg_hcs12x(CodeType const& code, uint16_t addr)
{
	return new OpExg_hcs12x(code, addr);
}

// *************************** HCS12X - TRANSFER Instructions
// TAP or TFR or TPA or TSX or TSY or TXS or TYS or SEX
/*
* lms sourceRegister index
* lls destinationRegister index
* */
#line 65 "hcs12x.isa"
void
#line 23381 "hcs12x.cc"
OpTfr_hcs12x::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23385 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23388 "hcs12x.cc"
)
{
#line 518 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{

		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
			case EBLB::EBLBMSLSRegs::CCR: // src is CCRW register
			if (lls == EBLB::EBLBMSLSRegs::A) {
				rrSrc = EBLB::EBLBRegs::CCRH; //0x22;
				} else if (lls = EBLB::EBLBMSLSRegs::B) {
				rrSrc = EBLB::EBLBRegs::CCRL; //0x21;
				} else {
				rrSrc = EBLB::EBLBRegs::CCRW; //0x23;
			}
			break;
			case EBLB::EBLBMSLSRegs::TMPx: // src is TMP register
			if (lls = EBLB::EBLBMSLSRegs::D) {
				rrSrc = EBLB::EBLBRegs::TMP1; //0x30; // TMP1
				} else {
				rrSrc = EBLB::EBLBRegs::TMP3; //0x32; // TMP3
			}
			break;
			default: rrSrc = lms;
		}

		switch (lls) {
			case EBLB::EBLBMSLSRegs::CCR: // dst is CCRW register
			if (lms == EBLB::EBLBMSLSRegs::A) {
				rrDst = EBLB::EBLBRegs::CCRH; //0x22;
				} else if (lms == EBLB::EBLBMSLSRegs::B) {
				rrDst = EBLB::EBLBRegs::CCRL; //0x21;
				} else {
				rrDst = EBLB::EBLBRegs::CCRW; //0x23;
			}

			break;
			case EBLB::EBLBMSLSRegs::TMPx: // dst is TMP2 register
			if (lms == EBLB::EBLBRegs::D ) {
				rrDst = EBLB::EBLBRegs::TMP1; //0x30; // TMP1
				} else {
				rrDst = EBLB::EBLBRegs::TMP2; //0x31; // TMP2
			}
			break;
			default: rrDst = lls;
		}

		// Transfer register Contents. TFR r1,r2

		string srcName = EBLB::getRegName(rrSrc);
		string dstName = EBLB::getRegName(rrDst);

		if (lls == EBLB::EBLBMSLSRegs::A ) {
			if (lms == EBLB::EBLBMSLSRegs::CCR ) {
				srcName = EBLB::getRegName(EBLB::EBLBRegs::CCRH);
			}
			else if ((lms != EBLB::EBLBMSLSRegs::B ) && (lms != EBLB::EBLBMSLSRegs::D)) {
				srcName = srcName + "H";
			}
			} if (lls == EBLB::EBLBMSLSRegs::B) {
			if (lms == EBLB::EBLBMSLSRegs::CCR) {
				srcName = EBLB::getRegName(EBLB::EBLBRegs::CCRL);
			}
			else if ((lms != EBLB::EBLBMSLSRegs::A ) && (lms != EBLB::EBLBMSLSRegs::D)) {
				srcName = srcName + "L";
			}
		}

		if (lms == EBLB::EBLBMSLSRegs::A) {
			if (lls == EBLB::EBLBMSLSRegs::CCR /* reg CCR */) {
				dstName = EBLB::getRegName(EBLB::EBLBRegs::CCRH);
			}
			else if ((lls != EBLB::EBLBMSLSRegs::B) && (lls != EBLB::EBLBMSLSRegs::D)) {
				dstName = dstName + "H";
			}
			} if (lms == EBLB::EBLBMSLSRegs::B) {
			if (lls == EBLB::EBLBMSLSRegs::CCR) {
				dstName = EBLB::getRegName(EBLB::EBLBRegs::CCRL);
			}
			else if ((lls != EBLB::EBLBMSLSRegs::A) && (lls != EBLB::EBLBMSLSRegs::D)) {
				dstName = dstName + "L";
			}
		}

		// Transfer Register Content to Another register
		uint8_t eb = (0 << 8) | (lms << 4) | (1 << 3) | lls;

		switch (eb)
		{
			case 0x02: sink << "TAP "; break;
			case 0x20: sink << "TPA "; break;
			case 0x75: sink << "TSX "; break;
			case 0x76: sink << "TSY "; break;
			case 0x57: sink << "TXS "; break;
			case 0x67: sink << "TYS "; break;
			default: sink << "TFR ";
		}

		sink << EBLB::getRegName(rrSrc) << "," << EBLB::getRegName(rrDst);
	}
#line 23491 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23495 "hcs12x.cc"
OpTfr_hcs12x::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23499 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23502 "hcs12x.cc"
)
{
#line 618 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./transfer_exchange.isa"
	{
		/* Legal "rr" value for EBLB::setter and EBLB::getter functions
		* 0x00:A; 0x01:B;
		* 0x20:CCR; 0x21:CCRlow; 0x22:CCRhigh; 0x23:CCRW
		* 0x30:TMP1; 0x31:TMP2; 0x32:TMP3;
		* 0x04:D; 0x05:X; 0x06:Y; 0x07:SP
		*/

		uint8_t srcSize, dstSize;
		uint8_t rrSrc, rrDst;

		// Test du num de registre pour choisir TMP1, TMP2, TMP3, CCR, CCRL, CCRH, CCRW
		switch (lms) {
		case EBLB::EBLBMSLSRegs::CCR:
			rrSrc = EBLB::EBLBRegs::CCRW;  // src is 0x23 register
			break;
		case EBLB::EBLBMSLSRegs::TMPx:
			if (lls == EBLB::EBLBMSLSRegs::D) {
				rrSrc = EBLB::EBLBRegs::TMP1; /* src is 0x30 register*/
				} else {
				rrSrc = EBLB::EBLBRegs::TMP3; /* src is 0x32 register*/
			}
			break;
			default: rrSrc = lms;
		}

		switch (lls) {
		case EBLB::EBLBMSLSRegs::CCR:
			rrDst = EBLB::EBLBRegs::CCRW; // rrDst is 0x23 register
			break;
		case EBLB::EBLBMSLSRegs::TMPx:
			if (lms == EBLB::EBLBMSLSRegs::D) {
				rrDst = EBLB::EBLBRegs::TMP1; /* src is 0x30 register*/
				} else {
				rrDst = EBLB::EBLBRegs::TMP3; /* src is 0x32 register*/
			}
			break;
			default: rrDst = lls;
		}

		srcSize = EBLB::getRegSize(rrSrc);
		dstSize = EBLB::getRegSize(rrDst);

		// Transfer Register Content to Another register
		/*
		if (sizeof(r1) && sizeof(r2) { (r1) => r2}
		else if ( (sizeof(r1)==8) && (sizeof(r2)==16) ) {sex:(r1) => r2}
		else if ( (sizeof(r1)==16) && (sizeof(r2)==8) ) { (r1[7:0]) => r2 }
		*/

		if (srcSize == dstSize)
		{
			/*
			* if ((r1 is D) && ((r2 is X) || (r2 is Y))) then sex:D => r2
			* else (r1) => r2
			*/
			if ((rrSrc == EBLB::EBLBRegs::D) && ((rrDst == EBLB::EBLBRegs::X) || (rrDst == EBLB::EBLBRegs::Y)))
			{
				uint16_t tmp = cpu->eblb->getter<uint16_t>(rrSrc);
				if ((tmp & 0x8000) == 0x8000) {
					cpu->eblb->setter<uint16_t>(rrDst, 0xFFFF);
					} else {
					cpu->eblb->setter<uint16_t>(rrDst, 0x0000);
				}
				} else {
				if (srcSize == 8) {
					cpu->eblb->setter<uint8_t>(rrDst, cpu->eblb->getter<uint8_t>(rrSrc));
					} else {
					cpu->eblb->setter<uint16_t>(rrDst, cpu->eblb->getter<uint16_t>(rrSrc));
				}
			}

		} else if ((srcSize == 8) && (dstSize == 16))
		{
			/*
			* if (r2 is D) then sex:(r1) => r2
			* else
			*    if (r1 is A) then (r1) => r2H
			*    else (r1) => r2L
			* */
			if (rrDst == EBLB::EBLBRegs::D) {
				uint8_t tmp = cpu->eblb->getter<uint8_t>(rrSrc);
				if ((tmp & 0x80) == 0x80) {
					cpu->eblb->setter<uint16_t>(rrDst, ((uint16_t) tmp) | 0xFF00);
					} else {
					cpu->eblb->setter<uint16_t>(rrDst, ((uint16_t) tmp) & 0x00FF);
				}
				} else {
				uint8_t r1 = cpu->eblb->getter<uint8_t>(rrSrc);
				if (rrSrc == EBLB::EBLBRegs::A) {
					uint16_t r2l = cpu->eblb->getter<uint16_t>(rrDst) & 0x00FF;
					cpu->eblb->setter<uint16_t>(rrDst, (((uint16_t) r1) << 8) | r2l);
					} else {
					uint16_t r2h = cpu->eblb->getter<uint16_t>(rrDst) & 0xFF00;
					cpu->eblb->setter<uint16_t>(rrDst, r2h | r1);
				}
			}
		} else if ((srcSize == 16) && (dstSize == 8))
		{
			/*
			* if (r2 is A) then
			*   if (r1 is D) then B => A
			*   else r1H => A
			* else
			*   r1L => B
			*/
			if (rrDst == EBLB::EBLBRegs::A) {
				if (rrSrc == EBLB::EBLBRegs::D) {
					cpu->eblb->setter<uint8_t>(EBLB::EBLBRegs::A, cpu->eblb->getter<uint8_t>(EBLB::EBLBRegs::B));
					} else {
					cpu->eblb->setter<uint8_t>(EBLB::EBLBRegs::A, (uint8_t) (cpu->eblb->getter<uint8_t>(rrSrc) >> 8));
				}
				} else {
				cpu->eblb->setter<uint8_t>(EBLB::EBLBRegs::B, (uint8_t) (cpu->eblb->getter<uint8_t>(rrSrc) & 0x00FF));
			}
		}
	}
#line 23623 "hcs12x.cc"
}

static Operation *DecodeOpTfr_hcs12x(CodeType const& code, uint16_t addr)
{
	return new OpTfr_hcs12x(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
#line 65 "hcs12x.isa"
void
#line 23666 "hcs12x.cc"
OpMovb_0B::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23670 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23673 "hcs12x.cc"
)
{
#line 38 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVB #$" << std::hex << ii << ",$" << std::hex << opr16a;
	}
#line 23680 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23684 "hcs12x.cc"
OpMovb_0B::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23688 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23691 "hcs12x.cc"
)
{
#line 42 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		cpu->memWrite8(addr,ii);
	}
#line 23700 "hcs12x.cc"
}

static Operation *DecodeOpMovb_0B(CodeType const& code, uint16_t addr)
{
	return new OpMovb_0B(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 23710 "hcs12x.cc"
OpMovb_08::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23714 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23717 "hcs12x.cc"
)
{
#line 50 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{

		sink << "MOVB #$" << std::hex << ii << ",";
		xb->disasm(sink);
	}
#line 23726 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23730 "hcs12x.cc"
OpMovb_08::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23734 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23737 "hcs12x.cc"
)
{
#line 56 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		cpu->memWrite8(addr,ii);
	}
#line 23746 "hcs12x.cc"
}

static Operation *DecodeOpMovb_08(CodeType const& code, uint16_t addr)
{
	return new OpMovb_08(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 23756 "hcs12x.cc"
OpMovb_0C::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23760 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23763 "hcs12x.cc"
)
{
#line 65 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVB $" << std::hex << opr16asrc << ",$" << std::hex << opr16adst;
	}
#line 23770 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23774 "hcs12x.cc"
OpMovb_0C::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23778 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23781 "hcs12x.cc"
)
{
#line 69 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrsrc = cpu->mmc->getPhysicalAddress(opr16asrc, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		physical_address_t addrdst = cpu->mmc->getPhysicalAddress(opr16adst, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint8_t tmp = cpu->memRead8(addrsrc);
		cpu->memWrite8(addrdst, tmp);
	}
#line 23792 "hcs12x.cc"
}

static Operation *DecodeOpMovb_0C(CodeType const& code, uint16_t addr)
{
	return new OpMovb_0C(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 23802 "hcs12x.cc"
OpMovb_09::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23806 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23809 "hcs12x.cc"
)
{
#line 79 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVB $" <<  std::hex << opr16asrc << ",";
		xb->disasm(sink);
	}
#line 23817 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23821 "hcs12x.cc"
OpMovb_09::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23825 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23828 "hcs12x.cc"
)
{
#line 84 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		uint16_t addr = xb->getEAddr(cpu);
		uint8_t tmp = cpu->memRead8(opr16asrc);
		cpu->memWrite8(addr, tmp);
	}
#line 23837 "hcs12x.cc"
}

static Operation *DecodeOpMovb_09(CodeType const& code, uint16_t addr)
{
	return new OpMovb_09(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 23847 "hcs12x.cc"
OpMovb_0D::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23851 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23854 "hcs12x.cc"
)
{
#line 92 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVB ";
		xb->disasm(sink);
		sink << ",$" << std::hex << opr16a;
	}
#line 23863 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23867 "hcs12x.cc"
OpMovb_0D::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23871 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23874 "hcs12x.cc"
)
{
#line 98 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrxb = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		physical_address_t addropr16a = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint8_t tmp = cpu->memRead8(addrxb);
		cpu->memWrite8(addropr16a, tmp);
	}
#line 23885 "hcs12x.cc"
}

static Operation *DecodeOpMovb_0D(CodeType const& code, uint16_t addr)
{
	return new OpMovb_0D(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 23895 "hcs12x.cc"
OpMovb_0A::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23899 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23902 "hcs12x.cc"
)
{
#line 108 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVB ";
		xbsrc->disasm(sink);
		sink << ",";
		xbdst->disasm(sink);
	}
#line 23912 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23916 "hcs12x.cc"
OpMovb_0A::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23920 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23923 "hcs12x.cc"
)
{
#line 115 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		uint16_t addrsrc = xbsrc->getEAddr(cpu);
		uint16_t addrdst = xbdst->getEAddr(cpu);
		uint8_t  tmp = cpu->memRead8(addrsrc);
		cpu->memWrite8(addrdst, tmp);
	}
#line 23933 "hcs12x.cc"
}

static Operation *DecodeOpMovb_0A(CodeType const& code, uint16_t addr)
{
	return new OpMovb_0A(code, addr);
}

// ---------
#line 65 "hcs12x.isa"
void
#line 23944 "hcs12x.cc"
OpMovw_03::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23948 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23951 "hcs12x.cc"
)
{
#line 126 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVW #$" << std::hex << opr16i << ",$" << std::hex << opr16a;
	}
#line 23958 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 23962 "hcs12x.cc"
OpMovw_03::execute(
#line 60 "hcs12x.isa"
CPU *
#line 23966 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 23969 "hcs12x.cc"
)
{
#line 130 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		cpu->memWrite16(addr,opr16i);
	}
#line 23978 "hcs12x.cc"
}

static Operation *DecodeOpMovw_03(CodeType const& code, uint16_t addr)
{
	return new OpMovw_03(code, addr);
}

// Movw_18_00 IDX IDX1 IDX2 [D,IDX] [IDX2]
#line 65 "hcs12x.isa"
void
#line 23989 "hcs12x.cc"
OpMovw_00::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 23993 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 23996 "hcs12x.cc"
)
{
#line 140 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{

		sink << "MOVW #$" << std::hex << opr16i << ",";
		xb->disasm(sink);
	}
#line 24005 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24009 "hcs12x.cc"
OpMovw_00::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24013 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24016 "hcs12x.cc"
)
{
#line 146 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		cpu->memWrite16(addr,opr16i);
	}
#line 24025 "hcs12x.cc"
}

static Operation *DecodeOpMovw_00(CodeType const& code, uint16_t addr)
{
	return new OpMovw_00(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 24035 "hcs12x.cc"
OpMovw_04::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24039 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24042 "hcs12x.cc"
)
{
#line 155 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVW $" << std::hex << opr16asrc << ",$" << std::hex << opr16adst;
	}
#line 24049 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24053 "hcs12x.cc"
OpMovw_04::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24057 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24060 "hcs12x.cc"
)
{
#line 159 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrsrc = cpu->mmc->getPhysicalAddress(opr16asrc, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		physical_address_t addrdst = cpu->mmc->getPhysicalAddress(opr16adst, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint16_t tmp = cpu->memRead16(addrsrc);
		cpu->memWrite16(addrdst, tmp);
	}
#line 24071 "hcs12x.cc"
}

static Operation *DecodeOpMovw_04(CodeType const& code, uint16_t addr)
{
	return new OpMovw_04(code, addr);
}

/*
* Movbw_18_01 IDX IDX1 IDX2 [D,IDX] [IDX2]
* */
#line 65 "hcs12x.isa"
void
#line 24084 "hcs12x.cc"
OpMovw_01::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24088 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24091 "hcs12x.cc"
)
{
#line 172 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVW $" <<  std::hex << opr16asrc << ",";
		xb->disasm(sink);
	}
#line 24099 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24103 "hcs12x.cc"
OpMovw_01::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24107 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24110 "hcs12x.cc"
)
{
#line 177 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		physical_address_t addrsrc = cpu->mmc->getPhysicalAddress(opr16asrc, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint16_t tmp = cpu->memRead16(addrsrc);
		cpu->memWrite16(addr, tmp);
	}
#line 24121 "hcs12x.cc"
}

static Operation *DecodeOpMovw_01(CodeType const& code, uint16_t addr)
{
	return new OpMovw_01(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 24131 "hcs12x.cc"
OpMovw_05::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24135 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24138 "hcs12x.cc"
)
{
#line 188 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVW ";
		xb->disasm(sink);
		sink << ",$" << std::hex << opr16a;
	}
#line 24147 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24151 "hcs12x.cc"
OpMovw_05::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24155 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24158 "hcs12x.cc"
)
{
#line 194 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrxb = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		physical_address_t addrdst = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint16_t tmp = cpu->memRead16(addrxb);
		cpu->memWrite16(addrdst, tmp);
	}
#line 24169 "hcs12x.cc"
}

static Operation *DecodeOpMovw_05(CodeType const& code, uint16_t addr)
{
	return new OpMovw_05(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 24179 "hcs12x.cc"
OpMovw_02::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24183 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24186 "hcs12x.cc"
)
{
#line 204 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		sink << "MOVW ";
		xbsrc->disasm(sink);
		sink << ",";
		xbdst->disasm(sink);
	}
#line 24196 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24200 "hcs12x.cc"
OpMovw_02::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24204 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24207 "hcs12x.cc"
)
{
#line 211 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./move.isa"
	{
		physical_address_t addrsrc = cpu->mmc->getPhysicalAddress(xbsrc->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		physical_address_t addrdst = cpu->mmc->getPhysicalAddress(xbdst->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint16_t  tmp = cpu->memRead16(addrsrc);
		cpu->memWrite16(addrdst, tmp);
	}
#line 24218 "hcs12x.cc"
}

static Operation *DecodeOpMovw_02(CodeType const& code, uint16_t addr)
{
	return new OpMovw_02(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
/* ***** Addition Instructions ****** */
// ABA ( A+B => A)
#line 65 "hcs12x.isa"
void
#line 24263 "hcs12x.cc"
OpAba::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24267 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24270 "hcs12x.cc"
)
{
#line 41 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "ABA";
	}
#line 24277 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24281 "hcs12x.cc"
OpAba::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24285 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24288 "hcs12x.cc"
)
{
#line 45 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in=0;
		uint8_t aVal = cpu->getRegA();
		uint8_t bVal = cpu->getRegB();

		Add8(result, carry_out, overflow, aVal, bVal, carry_in);

		cpu->setRegA(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((aVal & 0x0F)+(bVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (cpu->getRegA() & 0x08);
		uint8_t b3 = (cpu->getRegB() & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & b3) | (b3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();
	}
#line 24317 "hcs12x.cc"
}

static Operation *DecodeOpAba(CodeType const& code, uint16_t addr)
{
	return new OpAba(code, addr);
}

// ABX  (X+B => X)
#line 65 "hcs12x.isa"
void
#line 24328 "hcs12x.cc"
OpAbx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24332 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24335 "hcs12x.cc"
)
{
#line 74 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "ABX";
	}
#line 24342 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24346 "hcs12x.cc"
OpAbx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24350 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24353 "hcs12x.cc"
)
{
#line 78 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{

		uint16_t result;
		uint8_t carry_out, overflow;

		uint8_t carry_in=0;
		uint8_t bVal = cpu->getRegB();
		uint16_t xVal = cpu->getRegX();

		Add16(result, carry_out, overflow,(uint16_t) bVal, xVal, carry_in);

		cpu->setRegX(result);

	}
#line 24371 "hcs12x.cc"
}

static Operation *DecodeOpAbx(CodeType const& code, uint16_t addr)
{
	return new OpAbx(code, addr);
}

// ABY (Y+B=>Y)
#line 65 "hcs12x.isa"
void
#line 24382 "hcs12x.cc"
OpAby::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24386 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24389 "hcs12x.cc"
)
{
#line 96 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "ABY";
	}
#line 24396 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24400 "hcs12x.cc"
OpAby::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24404 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24407 "hcs12x.cc"
)
{
#line 99 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint16_t result;
		uint8_t carry_out, overflow;

		uint8_t carry_in=0;
		uint8_t bVal = cpu->getRegB();
		uint16_t yVal = cpu->getRegY();

		Add16(result, carry_out, overflow, (uint16_t) bVal, yVal, carry_in);

		cpu->setRegY(result);

	}
#line 24424 "hcs12x.cc"
}

static Operation *DecodeOpAby(CodeType const& code, uint16_t addr)
{
	return new OpAby(code, addr);
}

// ADCab IMM  (regAB + ii + carry => regAB)
#line 65 "hcs12x.isa"
void
#line 24435 "hcs12x.cc"
OpAdc_ab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24439 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24442 "hcs12x.cc"
)
{
#line 116 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADCA #$";
			} else {
			sink << "ADCB #$";
		}
		sink << std::hex << opr8i;
	}
#line 24454 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24458 "hcs12x.cc"
OpAdc_ab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24462 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24465 "hcs12x.cc"
)
{
#line 125 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Add8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr8i & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();
	}
#line 24502 "hcs12x.cc"
}

static Operation *DecodeOpAdc_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpAdc_ab_imm(code, addr);
}

// ADCab DIR  (regAB + mem[regDirect:opr8a] + carry => regAB)
#line 65 "hcs12x.isa"
void
#line 24513 "hcs12x.cc"
OpAdc_ab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24517 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24520 "hcs12x.cc"
)
{
#line 162 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADCA $";
			} else {
			sink << "ADCB $";
		}
		sink << std::hex << opr8a;
	}
#line 24532 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24536 "hcs12x.cc"
OpAdc_ab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24540 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24543 "hcs12x.cc"
)
{
#line 171 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr8aVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 24584 "hcs12x.cc"
}

static Operation *DecodeOpAdc_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpAdc_ab_dir(code, addr);
}

// ADCab EXT (regAB + mem[opr16a] + carry => regAB)
#line 65 "hcs12x.isa"
void
#line 24595 "hcs12x.cc"
OpAdc_ab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24599 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24602 "hcs12x.cc"
)
{
#line 212 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADCA $";
			} else {
			sink << "ADCB $";
		}
		sink << std::hex << opr16a;
	}
#line 24614 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24618 "hcs12x.cc"
OpAdc_ab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24622 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24625 "hcs12x.cc"
)
{
#line 221 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr16aVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 24666 "hcs12x.cc"
}

static Operation *DecodeOpAdc_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpAdc_ab_ext(code, addr);
}

// ADCab IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB + mem[xb->addrE] + carry => regAB)
#line 65 "hcs12x.isa"
void
#line 24677 "hcs12x.cc"
OpAdc_ab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24681 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24684 "hcs12x.cc"
)
{
#line 262 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0){
			sink << "ADCA ";
			} else {
			sink << "ADCB ";
		}

		xb->disasm(sink);
	}
#line 24697 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24701 "hcs12x.cc"
OpAdc_ab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24705 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24708 "hcs12x.cc"
)
{
#line 272 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (xbVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 24750 "hcs12x.cc"
}

static Operation *DecodeOpAdc_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpAdc_ab_idx(code, addr);
}

// ADDab IMM (regAB + ii => regAB)
#line 65 "hcs12x.isa"
void
#line 24761 "hcs12x.cc"
OpAdd_ab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24765 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24768 "hcs12x.cc"
)
{
#line 314 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADDA #$";
			} else {
			sink << "ADDB #$";
		}
		sink << std::hex << opr8i;
	}
#line 24780 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24784 "hcs12x.cc"
OpAdd_ab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24788 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24791 "hcs12x.cc"
)
{
#line 323 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Add8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr8i & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr8i & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 24829 "hcs12x.cc"
}

static Operation *DecodeOpAdd_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpAdd_ab_imm(code, addr);
}

// ADDab DIR  (regAB + mem[regDirect:opr8a] => regAB)
#line 65 "hcs12x.isa"
void
#line 24840 "hcs12x.cc"
OpAdd_ab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24844 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24847 "hcs12x.cc"
)
{
#line 361 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADDA $";
			} else {
			sink << "ADDB $";
		}
		sink << std::hex << opr8a;
	}
#line 24859 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24863 "hcs12x.cc"
OpAdd_ab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24867 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24870 "hcs12x.cc"
)
{
#line 370 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr8aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr8aVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 24911 "hcs12x.cc"
}

static Operation *DecodeOpAdd_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpAdd_ab_dir(code, addr);
}

// ADDab EXT  (regAB + mem[opr16a] => regAB)
#line 65 "hcs12x.isa"
void
#line 24922 "hcs12x.cc"
OpAdd_ab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 24926 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 24929 "hcs12x.cc"
)
{
#line 411 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADDA $";
			} else {
			sink << "ADDB $";
		}
		sink << std::hex << opr16a;
	}
#line 24941 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 24945 "hcs12x.cc"
OpAdd_ab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 24949 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 24952 "hcs12x.cc"
)
{
#line 420 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(opr16aVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (opr16aVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 24993 "hcs12x.cc"
}

static Operation *DecodeOpAdd_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpAdd_ab_ext(code, addr);
}

// ADDab  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB + mem[xb->addrE] => regAB)
#line 65 "hcs12x.isa"
void
#line 25004 "hcs12x.cc"
OpAdd_ab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25008 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25011 "hcs12x.cc"
)
{
#line 461 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0){
			sink << "ADDA ";
			} else {
			sink << "ADDB ";
		}

		xb->disasm(sink);
	}
#line 25024 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25028 "hcs12x.cc"
OpAdd_ab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25032 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25035 "hcs12x.cc"
)
{
#line 471 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		Add8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

		//	if (((regVal & 0x0F)+(xbVal & 0x0F)) > 0x09) cpu->ccr->setH(); else cpu->ccr->clrH();

		uint8_t a3 = (regVal & 0x08);
		uint8_t m3 = (xbVal & 0x08);
		uint8_t _r3 = ~(result & 0x08);

		if ((a3 & m3) | (m3 & _r3) | (_r3 & a3)) cpu->ccr->setH(); else cpu->ccr->clrH();

	}
#line 25077 "hcs12x.cc"
}

static Operation *DecodeOpAdd_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpAdd_ab_idx(code, addr);
}

// ADED IMM  (regD + #opr16i + carry => regD)
#line 65 "hcs12x.isa"
void
#line 25088 "hcs12x.cc"
OpAded_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25092 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25095 "hcs12x.cc"
)
{
#line 513 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "ADED #$" << std::hex << opr16i;
	}
#line 25102 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25106 "hcs12x.cc"
OpAded_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25110 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25113 "hcs12x.cc"
)
{
#line 517 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal = cpu->getRegD();

		Add16(result, carry_out, overflow, regVal, opr16i, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 25135 "hcs12x.cc"
}

static Operation *DecodeOpAded_imm(CodeType const& code, uint16_t addr)
{
	return new OpAded_imm(code, addr);
}

// ADED DIR  (regD + mem16[regDirect:opr8a] + carry => regD)
#line 65 "hcs12x.isa"
void
#line 25146 "hcs12x.cc"
OpAded_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25150 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25153 "hcs12x.cc"
)
{
#line 539 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "ADED $" << std::hex << opr8a;
	}
#line 25160 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25164 "hcs12x.cc"
OpAded_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25168 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25171 "hcs12x.cc"
)
{
#line 543 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 25195 "hcs12x.cc"
}

static Operation *DecodeOpAded_dir(CodeType const& code, uint16_t addr)
{
	return new OpAded_dir(code, addr);
}

// ADED EXT (regD + mem16[opr16a] + carry => regD)
#line 65 "hcs12x.isa"
void
#line 25206 "hcs12x.cc"
OpAded_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25210 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25213 "hcs12x.cc"
)
{
#line 567 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "ADED $" << std::hex << opr16a;
	}
#line 25220 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25224 "hcs12x.cc"
OpAded_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25228 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25231 "hcs12x.cc"
)
{
#line 571 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 25257 "hcs12x.cc"
}

static Operation *DecodeOpAded_ext(CodeType const& code, uint16_t addr)
{
	return new OpAded_ext(code, addr);
}

// ADED IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD + mem16[xb->addrE] + carry => regD)
#line 65 "hcs12x.isa"
void
#line 25268 "hcs12x.cc"
OpAded_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25272 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25275 "hcs12x.cc"
)
{
#line 597 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "ADED ";
		xb->disasm(sink);
	}
#line 25283 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25287 "hcs12x.cc"
OpAded_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25291 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25294 "hcs12x.cc"
)
{
#line 602 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, xbVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 25319 "hcs12x.cc"
}

static Operation *DecodeOpAded_idx(CodeType const& code, uint16_t addr)
{
	return new OpAded_idx(code, addr);
}

// ADExy IMM  (regXY + #opr16i + carry => regXY)
#line 65 "hcs12x.isa"
void
#line 25330 "hcs12x.cc"
OpAde_xy_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25334 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25337 "hcs12x.cc"
)
{
#line 627 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADEX #$";
			} else {
			sink << "ADEY #$";
		}
		sink << std::hex << opr16i;
	}
#line 25349 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25353 "hcs12x.cc"
OpAde_xy_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25357 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25360 "hcs12x.cc"
)
{
#line 636 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		Add16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 25391 "hcs12x.cc"
}

static Operation *DecodeOpAde_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpAde_xy_imm(code, addr);
}

// ADExy DIR  (regXY + mem16[regDirect:opr8a] + carry => regXY)
#line 65 "hcs12x.isa"
void
#line 25402 "hcs12x.cc"
OpAde_xy_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25406 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25409 "hcs12x.cc"
)
{
#line 667 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADEX $";
			} else {
			sink << "ADEY $";
		}
		sink << std::hex << opr8a;
	}
#line 25421 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25425 "hcs12x.cc"
OpAde_xy_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25429 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25432 "hcs12x.cc"
)
{
#line 676 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 25465 "hcs12x.cc"
}

static Operation *DecodeOpAde_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpAde_xy_dir(code, addr);
}

// ADExy EXT (regXY + mem16[opr16a] + carry => regXY)
#line 65 "hcs12x.isa"
void
#line 25476 "hcs12x.cc"
OpAde_xy_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25480 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25483 "hcs12x.cc"
)
{
#line 709 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADEX $";
			} else {
			sink << "ADEY $";
		}
		sink << std::hex << opr16a;
	}
#line 25495 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25499 "hcs12x.cc"
OpAde_xy_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25503 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25506 "hcs12x.cc"
)
{
#line 718 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 25540 "hcs12x.cc"
}

static Operation *DecodeOpAde_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpAde_xy_ext(code, addr);
}

// ADExy IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY + mem16[xb->addrE] + carry => regXY)
#line 65 "hcs12x.isa"
void
#line 25551 "hcs12x.cc"
OpAde_xy_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25555 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25558 "hcs12x.cc"
)
{
#line 752 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0){
			sink << "ADEX ";
			} else {
			sink << "ADEY ";
		}

		xb->disasm(sink);
	}
#line 25571 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25575 "hcs12x.cc"
OpAde_xy_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25579 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25582 "hcs12x.cc"
)
{
#line 762 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 25616 "hcs12x.cc"
}

static Operation *DecodeOpAde_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpAde_xy_idx(code, addr);
}

// ADDxy IMM (regXY + #opr16i => regXY)
#line 65 "hcs12x.isa"
void
#line 25627 "hcs12x.cc"
OpAdd_xy_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25631 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25634 "hcs12x.cc"
)
{
#line 797 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADDX #$";
			} else {
			sink << "ADDY #$";
		}
		sink << std::hex << opr16i;
	}
#line 25646 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25650 "hcs12x.cc"
OpAdd_xy_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25654 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25657 "hcs12x.cc"
)
{
#line 806 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		Add16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 25688 "hcs12x.cc"
}

static Operation *DecodeOpAdd_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpAdd_xy_imm(code, addr);
}

// ADDxy DIR  (regXY + mem16[regDirect:opr8a] => regXY)
#line 65 "hcs12x.isa"
void
#line 25699 "hcs12x.cc"
OpAdd_xy_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25703 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25706 "hcs12x.cc"
)
{
#line 837 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADDX $";
			} else {
			sink << "ADDY $";
		}
		sink << std::hex << opr8a;
	}
#line 25718 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25722 "hcs12x.cc"
OpAdd_xy_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25726 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25729 "hcs12x.cc"
)
{
#line 846 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;
		uint8_t carry_in = 0;
		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 25762 "hcs12x.cc"
}

static Operation *DecodeOpAdd_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpAdd_xy_dir(code, addr);
}

// ADDxy EXT  (regXY + mem16[opr16a] => regXY)
#line 65 "hcs12x.isa"
void
#line 25773 "hcs12x.cc"
OpAdd_xy_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25777 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25780 "hcs12x.cc"
)
{
#line 879 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "ADDX $";
			} else {
			sink << "ADDY $";
		}
		sink << std::hex << opr16a;
	}
#line 25792 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25796 "hcs12x.cc"
OpAdd_xy_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25800 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25803 "hcs12x.cc"
)
{
#line 888 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 25837 "hcs12x.cc"
}

static Operation *DecodeOpAdd_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpAdd_xy_ext(code, addr);
}

// ADDxy  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY + mem16[xb->addrE] => regXY)
#line 65 "hcs12x.isa"
void
#line 25848 "hcs12x.cc"
OpAdd_xy_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25852 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25855 "hcs12x.cc"
)
{
#line 922 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0){
			sink << "ADDX ";
			} else {
			sink << "ADDY ";
		}

		xb->disasm(sink);
	}
#line 25868 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25872 "hcs12x.cc"
OpAdd_xy_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25876 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25879 "hcs12x.cc"
)
{
#line 932 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		Add16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 25913 "hcs12x.cc"
}

static Operation *DecodeOpAdd_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpAdd_xy_idx(code, addr);
}

// SUBD IMM or ADDD IMM (regD -+ ii => regD)
#line 65 "hcs12x.isa"
void
#line 25924 "hcs12x.cc"
OpAdd_sub_d_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25928 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25931 "hcs12x.cc"
)
{
#line 969 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBD #$";
			} else {
			sink << "ADDD #$";
		}
		sink << std::hex << opr16i;
	}
#line 25943 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 25947 "hcs12x.cc"
OpAdd_sub_d_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 25951 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 25954 "hcs12x.cc"
)
{
#line 978 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal = cpu->getRegD();

		if (b==0) {
			Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);
			} else {
			Add16(result, carry_out, overflow, regVal, opr16i, carry_in);
		}

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 25979 "hcs12x.cc"
}

static Operation *DecodeOpAdd_sub_d_imm(CodeType const& code, uint16_t addr)
{
	return new OpAdd_sub_d_imm(code, addr);
}

// SUBD DIR or ADDD DIR  (regD -+ mem[regDirect+opr8a])
#line 65 "hcs12x.isa"
void
#line 25990 "hcs12x.cc"
OpAdd_sub_d_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 25994 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 25997 "hcs12x.cc"
)
{
#line 1003 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBD $";
			} else {
			sink << "ADDD $";
		}
		sink << std::hex << opr8a;
	}
#line 26009 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26013 "hcs12x.cc"
OpAdd_sub_d_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26017 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26020 "hcs12x.cc"
)
{
#line 1012 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		if (b==0) {
			Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
			} else {
			Add16(result, carry_out, overflow, regVal, opr8aVal, carry_in);
		}

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26048 "hcs12x.cc"
}

static Operation *DecodeOpAdd_sub_d_dir(CodeType const& code, uint16_t addr)
{
	return new OpAdd_sub_d_dir(code, addr);
}

// SUBD EXT or ADDD EXT (regD -+ mem[opr16a]) => regD)
#line 65 "hcs12x.isa"
void
#line 26059 "hcs12x.cc"
OpAdd_sub_d_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26063 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26066 "hcs12x.cc"
)
{
#line 1040 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBD $";
			} else {
			sink << "ADDD $";
		}

		sink << std::hex << opr16a;

	}
#line 26080 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26084 "hcs12x.cc"
OpAdd_sub_d_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26088 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26091 "hcs12x.cc"
)
{
#line 1051 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal = cpu->getRegD();
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		if (b==0) {
			Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
			} else {
			Add16(result, carry_out, overflow, regVal, opr16aVal, carry_in);
		}

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26119 "hcs12x.cc"
}

static Operation *DecodeOpAdd_sub_d_ext(CodeType const& code, uint16_t addr)
{
	return new OpAdd_sub_d_ext(code, addr);
}

// SUBD/ADDD  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD -+ mem[xb->addrE] => regD)
#line 65 "hcs12x.isa"
void
#line 26130 "hcs12x.cc"
OpAdd_sub_d_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26134 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26137 "hcs12x.cc"
)
{
#line 1079 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBD ";
			} else {
			sink << "ADDD ";
		}

		xb->disasm(sink);
	}
#line 26150 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26154 "hcs12x.cc"
OpAdd_sub_d_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26158 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26161 "hcs12x.cc"
)
{
#line 1089 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal = cpu->getRegD();
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		if (b==0) {
			Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);
			} else {
			Add16(result, carry_out, overflow, regVal, xbVal, carry_in);
		}

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26189 "hcs12x.cc"
}

static Operation *DecodeOpAdd_sub_d_idx(CodeType const& code, uint16_t addr)
{
	return new OpAdd_sub_d_idx(code, addr);
}

/* ****** Subtraction Instructions **** */
// SBA  (regA - regB => regA)
#line 65 "hcs12x.isa"
void
#line 26201 "hcs12x.cc"
OpSba::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26205 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26208 "hcs12x.cc"
)
{
#line 1119 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "SBA";
	}
#line 26215 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26219 "hcs12x.cc"
OpSba::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26223 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26226 "hcs12x.cc"
)
{
#line 1123 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in=0;
		uint8_t aVal = cpu->getRegA();
		uint8_t bVal = cpu->getRegB();

		Sub8(result, carry_out, overflow, aVal, bVal, carry_in);

		cpu->setRegA(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26247 "hcs12x.cc"
}

static Operation *DecodeOpSba(CodeType const& code, uint16_t addr)
{
	return new OpSba(code, addr);
}

// SBCA/SBCB  IMM (regAB - ii - carry => regAB)
#line 65 "hcs12x.isa"
void
#line 26258 "hcs12x.cc"
OpSbc_ab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26262 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26265 "hcs12x.cc"
)
{
#line 1144 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SBCA #$";
			} else {
			sink << "SBCB #$";
		}
		sink << std::hex << opr8i;
	}
#line 26277 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26281 "hcs12x.cc"
OpSbc_ab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26285 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26288 "hcs12x.cc"
)
{
#line 1153 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26317 "hcs12x.cc"
}

static Operation *DecodeOpSbc_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpSbc_ab_imm(code, addr);
}

// SBCA/SBCB  DIR  (regAB - mem[regDirect:opr8a] - carry => regAB)
#line 65 "hcs12x.isa"
void
#line 26328 "hcs12x.cc"
OpSbc_ab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26332 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26335 "hcs12x.cc"
)
{
#line 1182 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SBCA $";
			} else {
			sink << "SBCB $";
		}
		sink << std::hex << opr8a;
	}
#line 26347 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26351 "hcs12x.cc"
OpSbc_ab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26355 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26358 "hcs12x.cc"
)
{
#line 1191 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26389 "hcs12x.cc"
}

static Operation *DecodeOpSbc_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpSbc_ab_dir(code, addr);
}

// SBCA/SBCB  EXT (regAB - mem[opr16a] - carry => regAB)
#line 65 "hcs12x.isa"
void
#line 26400 "hcs12x.cc"
OpSbc_ab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26404 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26407 "hcs12x.cc"
)
{
#line 1222 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SBCA $";
			} else {
			sink << "SBCB $";
		}
		sink << std::hex << opr16a;
	}
#line 26419 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26423 "hcs12x.cc"
OpSbc_ab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26427 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26430 "hcs12x.cc"
)
{
#line 1231 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26462 "hcs12x.cc"
}

static Operation *DecodeOpSbc_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpSbc_ab_ext(code, addr);
}

// SBCA/SBCB IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB - mem[xb->addrE] - carry => regAB)
#line 65 "hcs12x.isa"
void
#line 26473 "hcs12x.cc"
OpSbc_ab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26477 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26480 "hcs12x.cc"
)
{
#line 1263 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0){
			sink << "SBCA ";
			} else {
			sink << "SBCB ";
		}

		xb->disasm(sink);
	}
#line 26493 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26497 "hcs12x.cc"
OpSbc_ab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26501 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26504 "hcs12x.cc"
)
{
#line 1273 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = cpu->ccr->getC();

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26537 "hcs12x.cc"
}

static Operation *DecodeOpSbc_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpSbc_ab_idx(code, addr);
}

// SBED  IMM (regD - #opr16i - carry => regD)
#line 65 "hcs12x.isa"
void
#line 26548 "hcs12x.cc"
OpSbed_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26552 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26555 "hcs12x.cc"
)
{
#line 1306 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "SBED #$" << std::hex << opr16i;
	}
#line 26562 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26566 "hcs12x.cc"
OpSbed_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26570 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26573 "hcs12x.cc"
)
{
#line 1310 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal = cpu->getRegD();

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26594 "hcs12x.cc"
}

static Operation *DecodeOpSbed_imm(CodeType const& code, uint16_t addr)
{
	return new OpSbed_imm(code, addr);
}

// SBED  DIR  (regD - mem16[regDirect:opr8a] - carry => regD)
#line 65 "hcs12x.isa"
void
#line 26605 "hcs12x.cc"
OpSbed_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26609 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26612 "hcs12x.cc"
)
{
#line 1331 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "SBED $" << std::hex << opr8a;
	}
#line 26619 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26623 "hcs12x.cc"
OpSbed_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26627 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26630 "hcs12x.cc"
)
{
#line 1335 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26654 "hcs12x.cc"
}

static Operation *DecodeOpSbed_dir(CodeType const& code, uint16_t addr)
{
	return new OpSbed_dir(code, addr);
}

// SBED  EXT (regD - mem16[opr16a] - carry => regD)
#line 65 "hcs12x.isa"
void
#line 26665 "hcs12x.cc"
OpSbed_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26669 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26672 "hcs12x.cc"
)
{
#line 1359 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "SBED $" << std::hex << opr16a;
	}
#line 26679 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26683 "hcs12x.cc"
OpSbed_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26687 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26690 "hcs12x.cc"
)
{
#line 1363 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26715 "hcs12x.cc"
}

static Operation *DecodeOpSbed_ext(CodeType const& code, uint16_t addr)
{
	return new OpSbed_ext(code, addr);
}

// SBED IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regD - mem16[xb->addrE] - carry => regD)
#line 65 "hcs12x.isa"
void
#line 26726 "hcs12x.cc"
OpSbed_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26730 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26733 "hcs12x.cc"
)
{
#line 1388 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "SBED ";
		xb->disasm(sink);
	}
#line 26741 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26745 "hcs12x.cc"
OpSbed_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26749 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26752 "hcs12x.cc"
)
{
#line 1393 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal = cpu->getRegD();

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		cpu->setRegD(result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26777 "hcs12x.cc"
}

static Operation *DecodeOpSbed_idx(CodeType const& code, uint16_t addr)
{
	return new OpSbed_idx(code, addr);
}

// SBEX/SBEY  IMM (regXY - #opr16i - carry => regXY)
#line 65 "hcs12x.isa"
void
#line 26788 "hcs12x.cc"
OpSbe_xy_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26792 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26795 "hcs12x.cc"
)
{
#line 1418 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SBEX #$";
			} else {
			sink << "SBEY #$";
		}
		sink << std::hex << opr16i;
	}
#line 26807 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26811 "hcs12x.cc"
OpSbe_xy_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26815 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26818 "hcs12x.cc"
)
{
#line 1427 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26848 "hcs12x.cc"
}

static Operation *DecodeOpSbe_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpSbe_xy_imm(code, addr);
}

// SBEX/SBEY  DIR  (regXY - mem16[regDirect:opr8a] - carry => regXY)
#line 65 "hcs12x.isa"
void
#line 26859 "hcs12x.cc"
OpSbe_xy_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26863 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26866 "hcs12x.cc"
)
{
#line 1457 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SBEX $";
			} else {
			sink << "SBEY $";
		}
		sink << std::hex << opr8a;
	}
#line 26878 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26882 "hcs12x.cc"
OpSbe_xy_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26886 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26889 "hcs12x.cc"
)
{
#line 1466 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26921 "hcs12x.cc"
}

static Operation *DecodeOpSbe_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpSbe_xy_dir(code, addr);
}

// SBEX/SBEY  EXT (regXY - mem16[opr16a] - carry => regXY)
#line 65 "hcs12x.isa"
void
#line 26932 "hcs12x.cc"
OpSbe_xy_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 26936 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 26939 "hcs12x.cc"
)
{
#line 1498 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SBEX $";
			} else {
			sink << "SBEY $";
		}
		sink << std::hex << opr16a;
	}
#line 26951 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 26955 "hcs12x.cc"
OpSbe_xy_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 26959 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 26962 "hcs12x.cc"
)
{
#line 1507 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 26995 "hcs12x.cc"
}

static Operation *DecodeOpSbe_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpSbe_xy_ext(code, addr);
}

// SBEX/SBEY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY - mem16[xb->addrE] - carry => regXY)
#line 65 "hcs12x.isa"
void
#line 27006 "hcs12x.cc"
OpSbe_xy_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27010 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27013 "hcs12x.cc"
)
{
#line 1540 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0){
			sink << "SBEX ";
			} else {
			sink << "SBEY ";
		}

		xb->disasm(sink);
	}
#line 27026 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27030 "hcs12x.cc"
OpSbe_xy_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27034 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27037 "hcs12x.cc"
)
{
#line 1550 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = cpu->ccr->getC();

		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 27071 "hcs12x.cc"
}

static Operation *DecodeOpSbe_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpSbe_xy_idx(code, addr);
}

// SUBA/SUBB  IMM (regAB - ii => regAB)
#line 65 "hcs12x.isa"
void
#line 27082 "hcs12x.cc"
OpSub_ab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27086 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27089 "hcs12x.cc"
)
{
#line 1584 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBA #$";
			} else {
			sink << "SUBB #$";
		}
		sink << std::hex << opr8i;
	}
#line 27101 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27105 "hcs12x.cc"
OpSub_ab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27109 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27112 "hcs12x.cc"
)
{
#line 1593 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 27142 "hcs12x.cc"
}

static Operation *DecodeOpSub_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpSub_ab_imm(code, addr);
}

// SUBA/SUBB  DIR  (regAB - mem[regDirect:opr8a] => regAB)
#line 65 "hcs12x.isa"
void
#line 27153 "hcs12x.cc"
OpSub_ab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27157 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27160 "hcs12x.cc"
)
{
#line 1623 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBA $";
			} else {
			sink << "SUBB $";
		}
		sink << std::hex << opr8a;
	}
#line 27172 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27176 "hcs12x.cc"
OpSub_ab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27180 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27183 "hcs12x.cc"
)
{
#line 1632 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;
		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 27215 "hcs12x.cc"
}

static Operation *DecodeOpSub_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpSub_ab_dir(code, addr);
}

// SUBA/SUBB  EXT (regAB - mem[opr16a] => regAB)
#line 65 "hcs12x.isa"
void
#line 27226 "hcs12x.cc"
OpSub_ab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27230 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27233 "hcs12x.cc"
)
{
#line 1664 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBA $";
			} else {
			sink << "SUBB $";
		}
		sink << std::hex << opr16a;
	}
#line 27245 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27249 "hcs12x.cc"
OpSub_ab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27253 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27256 "hcs12x.cc"
)
{
#line 1673 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 27289 "hcs12x.cc"
}

static Operation *DecodeOpSub_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpSub_ab_ext(code, addr);
}

// SUBA/SUBB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regAB - mem[xb->addrE] => regAB)
#line 65 "hcs12x.isa"
void
#line 27300 "hcs12x.cc"
OpSub_ab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27304 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27307 "hcs12x.cc"
)
{
#line 1706 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0){
			sink << "SUBA ";
			} else {
			sink << "SUBB ";
		}

		xb->disasm(sink);
	}
#line 27320 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27324 "hcs12x.cc"
OpSub_ab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27328 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27331 "hcs12x.cc"
)
{
#line 1716 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t result, carry_out, overflow;

		uint8_t carry_in = 0;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 27364 "hcs12x.cc"
}

static Operation *DecodeOpSub_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpSub_ab_idx(code, addr);
}

// ******************************
// SUBX/SUBY  IMM (regXy - opr16i => regXY)
#line 65 "hcs12x.isa"
void
#line 27376 "hcs12x.cc"
OpSub_xy_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27380 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27383 "hcs12x.cc"
)
{
#line 1751 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBX #$";
			} else {
			sink << "SUBY #$";
		}
		sink << std::hex << opr16i;
	}
#line 27395 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27399 "hcs12x.cc"
OpSub_xy_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27403 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27406 "hcs12x.cc"
)
{
#line 1760 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 27437 "hcs12x.cc"
}

static Operation *DecodeOpSub_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpSub_xy_imm(code, addr);
}

// SUBX/SUBY  DIR  (regXY - mem16[regDirect:opr8a] => regXY)
#line 65 "hcs12x.isa"
void
#line 27448 "hcs12x.cc"
OpSub_xy_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27452 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27455 "hcs12x.cc"
)
{
#line 1791 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBX $";
			} else {
			sink << "SUBY $";
		}
		sink << std::hex << opr8a;
	}
#line 27467 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27471 "hcs12x.cc"
OpSub_xy_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27475 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27478 "hcs12x.cc"
)
{
#line 1800 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;
		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}


		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 27511 "hcs12x.cc"
}

static Operation *DecodeOpSub_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpSub_xy_dir(code, addr);
}

// SUBX/SUBY  EXT (regXY - mem16[opr16a] => regXY)
#line 65 "hcs12x.isa"
void
#line 27522 "hcs12x.cc"
OpSub_xy_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27526 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27529 "hcs12x.cc"
)
{
#line 1833 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0) {
			sink << "SUBX $";
			} else {
			sink << "SUBY $";
		}
		sink << std::hex << opr16a;
	}
#line 27541 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27545 "hcs12x.cc"
OpSub_xy_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27549 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27552 "hcs12x.cc"
)
{
#line 1842 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal;
		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 27586 "hcs12x.cc"
}

static Operation *DecodeOpSub_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpSub_xy_ext(code, addr);
}

// SUBX/SUBY  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]  (regXY - mem16[xb->addrE] => regXY)
#line 65 "hcs12x.isa"
void
#line 27597 "hcs12x.cc"
OpSub_xy_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27601 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27604 "hcs12x.cc"
)
{
#line 1876 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		if (b==0){
			sink << "SUBX ";
			} else {
			sink << "SUBY ";
		}

		xb->disasm(sink);
	}
#line 27617 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27621 "hcs12x.cc"
OpSub_xy_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27625 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27628 "hcs12x.cc"
)
{
#line 1886 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		uint8_t carry_in = 0;

		uint16_t regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 27662 "hcs12x.cc"
}

static Operation *DecodeOpSub_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpSub_xy_idx(code, addr);
}

// ******************************
/* ***** Binary-Coded Decimal Instructions ****** */
// DAA (if (ccr.H) then regA + 0x6 => regA)
#line 65 "hcs12x.isa"
void
#line 27675 "hcs12x.cc"
OpDaa::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27679 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27682 "hcs12x.cc"
)
{
#line 1924 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		sink << "DAA";
	}
#line 27689 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27693 "hcs12x.cc"
OpDaa::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27697 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27700 "hcs12x.cc"
)
{
#line 1928 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./addition_substraction.isa"
	{
		uint8_t hBit = cpu->ccr->getH();
		uint8_t cBit = cpu->ccr->getC();

		uint8_t overflow, carry_out, result;

		uint8_t aVal = cpu->getRegA();
		uint8_t a74 =  aVal >> 4;
		uint8_t a30 = aVal & 0x0F;


		if ((cBit == 0) &&
		(a74 < 0x9) &&
		(hBit == 0) &&
		(a30 > 0x9))
		{
			Add8(result, carry_out, overflow, aVal, 0x06, 0x00);
			cpu->setRegA(result);
			cpu->ccr->clrC();
		}

		if ((cBit == 0) &&
		(a74 < 0xA) &&
		(hBit == 1) &&
		(a30 < 0x4))
		{
			Add8(result, carry_out, overflow, aVal, 0x06, 0x00);
			cpu->setRegA(result);
			cpu->ccr->clrC();
		}

		if ((cBit == 0) &&
		(a74 > 0x9) &&
		(hBit == 0) &&
		(a30 < 0xA))
		{
			Add8(result, carry_out, overflow, aVal, 0x60, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 0) &&
		(a74 > 0x8) &&
		(hBit == 0) &&
		(a30 > 0x9))
		{
			Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 0) &&
		(a74 > 0x9) &&
		(hBit == 1) &&
		(a30 < 0x4))
		{
			Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 1) &&
		(a74 < 0x3) &&
		(hBit == 0) &&
		(a30 < 0xA))
		{
			Add8(result, carry_out, overflow, aVal, 0x60, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 1) &&
		(a74 < 0x3) &&
		(hBit == 0) &&
		(a30 > 0x9))
		{
			Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((cBit == 1) &&
		(a74 < 0x4) &&
		(hBit == 1) &&
		(a30 < 0x4))
		{
			Add8(result, carry_out, overflow, aVal, 0x66, 0x00);
			cpu->setRegA(result);
			cpu->ccr->setC();
		}

		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
		if (result == 0x00) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if (overflow == 1) cpu->ccr->setV(); else cpu->ccr->clrV();
	}
#line 27799 "hcs12x.cc"
}

static Operation *DecodeOpDaa(CodeType const& code, uint16_t addr)
{
	return new OpDaa(code, addr);
}

// -*- C++ -*-
// DEC EXT
#line 65 "hcs12x.isa"
void
#line 27811 "hcs12x.cc"
OpDec_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27815 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27818 "hcs12x.cc"
)
{
#line 6 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "DEC $" << std::hex << opr16a;
	}
#line 27825 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27829 "hcs12x.cc"
OpDec_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27833 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27836 "hcs12x.cc"
)
{
#line 10 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);
		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Sub8(result, carry_out, overflow, opr16aVal, 1, carry_in);

		cpu->memWrite8(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 27854 "hcs12x.cc"
}

static Operation *DecodeOpDec_ext(CodeType const& code, uint16_t addr)
{
	return new OpDec_ext(code, addr);
}

// DEC IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 65 "hcs12x.isa"
void
#line 27865 "hcs12x.cc"
OpDec_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27869 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27872 "hcs12x.cc"
)
{
#line 28 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "DEC ";
		xb->disasm(sink);
	}
#line 27880 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27884 "hcs12x.cc"
OpDec_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27888 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27891 "hcs12x.cc"
)
{
#line 33 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Sub8(result, carry_out, overflow, val, 1, carry_in);

		cpu->memWrite8(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 27911 "hcs12x.cc"
}

static Operation *DecodeOpDec_idx(CodeType const& code, uint16_t addr)
{
	return new OpDec_idx(code, addr);
}

// DECA  or DECB
#line 65 "hcs12x.isa"
void
#line 27922 "hcs12x.cc"
OpDec_ab::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27926 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27929 "hcs12x.cc"
)
{
#line 53 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		if (b == 0) {
			sink << "DECA";
			} else {
			sink << "DECB";
		}
	}
#line 27940 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 27944 "hcs12x.cc"
OpDec_ab::execute(
#line 60 "hcs12x.isa"
CPU *
#line 27948 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 27951 "hcs12x.cc"
)
{
#line 61 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		uint8_t result, carry_out, overflow, carry_in;

		uint8_t val;
		if (b==0) {
			val = cpu->getRegA();
			} else {
			val = cpu->getRegB();
		}

		carry_in = 0;
		Sub8(result, carry_out, overflow, val, 1, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 27981 "hcs12x.cc"
}

static Operation *DecodeOpDec_ab(CodeType const& code, uint16_t addr)
{
	return new OpDec_ab(code, addr);
}

// DECW  EXT
#line 65 "hcs12x.isa"
void
#line 27992 "hcs12x.cc"
OpDecw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 27996 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 27999 "hcs12x.cc"
)
{
#line 91 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "DECW $" << std::hex << opr16a;
	}
#line 28006 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28010 "hcs12x.cc"
OpDecw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28014 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28017 "hcs12x.cc"
)
{
#line 95 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);
		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Sub16(result, carry_out, overflow, opr16aVal, 1, carry_in);

		cpu->memWrite16(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 28037 "hcs12x.cc"
}

static Operation *DecodeOpDecw_ext(CodeType const& code, uint16_t addr)
{
	return new OpDecw_ext(code, addr);
}

// DECW  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 65 "hcs12x.isa"
void
#line 28048 "hcs12x.cc"
OpDecw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28052 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28055 "hcs12x.cc"
)
{
#line 115 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "DECW ";
		xb->disasm(sink);
	}
#line 28063 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28067 "hcs12x.cc"
OpDecw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28071 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28074 "hcs12x.cc"
)
{
#line 120 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Sub16(result, carry_out, overflow, val, 1, carry_in);

		cpu->memWrite16(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 28095 "hcs12x.cc"
}

static Operation *DecodeOpDecw_idx(CodeType const& code, uint16_t addr)
{
	return new OpDecw_idx(code, addr);
}

// DECX or DECY
#line 65 "hcs12x.isa"
void
#line 28106 "hcs12x.cc"
OpDec_xy::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28110 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28113 "hcs12x.cc"
)
{
#line 141 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		if (b==0) {
			sink << "DECX";
			} else {
			sink << "DECY";
		}
	}
#line 28124 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28128 "hcs12x.cc"
OpDec_xy::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28132 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28135 "hcs12x.cc"
)
{
#line 149 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		uint16_t val;
		if (b==0) {
			val = cpu->getRegX();
			} else {
			val = cpu->getRegY();
		}

		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Sub16(result, carry_out, overflow, val, 1, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 28166 "hcs12x.cc"
}

static Operation *DecodeOpDec_xy(CodeType const& code, uint16_t addr)
{
	return new OpDec_xy(code, addr);
}

// DES
#line 65 "hcs12x.isa"
void
#line 28177 "hcs12x.cc"
OpDes::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28181 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28184 "hcs12x.cc"
)
{
#line 180 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "DES";
	}
#line 28191 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28195 "hcs12x.cc"
OpDes::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28199 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28202 "hcs12x.cc"
)
{
#line 184 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		cpu->setRegSP(cpu->getRegSP() - 1);
	}
#line 28209 "hcs12x.cc"
}

static Operation *DecodeOpDes(CodeType const& code, uint16_t addr)
{
	return new OpDes(code, addr);
}

// DEX
#line 65 "hcs12x.isa"
void
#line 28220 "hcs12x.cc"
OpDex::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28224 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28227 "hcs12x.cc"
)
{
#line 191 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "DEX";
	}
#line 28234 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28238 "hcs12x.cc"
OpDex::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28242 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28245 "hcs12x.cc"
)
{
#line 195 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		uint16_t val = cpu->getRegX();
		val--;
		cpu->setRegX(val);
		if (val == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	}
#line 28255 "hcs12x.cc"
}

static Operation *DecodeOpDex(CodeType const& code, uint16_t addr)
{
	return new OpDex(code, addr);
}

// DEY
#line 65 "hcs12x.isa"
void
#line 28266 "hcs12x.cc"
OpDey::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28270 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28273 "hcs12x.cc"
)
{
#line 205 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "DEY";
	}
#line 28280 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28284 "hcs12x.cc"
OpDey::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28288 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28291 "hcs12x.cc"
)
{
#line 209 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		uint16_t val = cpu->getRegY();
		val--;
		cpu->setRegY(val);
		if (val == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	}
#line 28301 "hcs12x.cc"
}

static Operation *DecodeOpDey(CodeType const& code, uint16_t addr)
{
	return new OpDey(code, addr);
}

/* ********* Increment Instructions ****** */
// INC EXT
#line 65 "hcs12x.isa"
void
#line 28313 "hcs12x.cc"
OpInc_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28317 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28320 "hcs12x.cc"
)
{
#line 221 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "INC $" << std::hex << opr16a;
	}
#line 28327 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28331 "hcs12x.cc"
OpInc_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28335 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28338 "hcs12x.cc"
)
{
#line 225 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);
		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Add8(result, carry_out, overflow, opr16aVal, 1, carry_in);

		cpu->memWrite8(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 28357 "hcs12x.cc"
}

static Operation *DecodeOpInc_ext(CodeType const& code, uint16_t addr)
{
	return new OpInc_ext(code, addr);
}

// INC IDX or IDX or IDX2 or [D,IDX] or [IDX2]
#line 65 "hcs12x.isa"
void
#line 28368 "hcs12x.cc"
OpInc_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28372 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28375 "hcs12x.cc"
)
{
#line 244 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "INC ";
		xb->disasm(sink);
	}
#line 28383 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28387 "hcs12x.cc"
OpInc_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28391 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28394 "hcs12x.cc"
)
{
#line 249 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Add8(result, carry_out, overflow, val, 1, carry_in);

		cpu->memWrite8(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 28414 "hcs12x.cc"
}

static Operation *DecodeOpInc_idx(CodeType const& code, uint16_t addr)
{
	return new OpInc_idx(code, addr);
}

// INCA  or INCB
#line 65 "hcs12x.isa"
void
#line 28425 "hcs12x.cc"
OpInc_ab::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28429 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28432 "hcs12x.cc"
)
{
#line 269 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		if (b == 0) {
			sink << "INCA";
			} else {
			sink << "INCB";
		}
	}
#line 28443 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28447 "hcs12x.cc"
OpInc_ab::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28451 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28454 "hcs12x.cc"
)
{
#line 277 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		uint8_t result, carry_out, overflow, carry_in;

		uint8_t val;
		if (b==0) {
			val = cpu->getRegA();
			} else {
			val = cpu->getRegB();
		}

		carry_in = 0;
		Add8(result, carry_out, overflow, val, 1, carry_in);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 28484 "hcs12x.cc"
}

static Operation *DecodeOpInc_ab(CodeType const& code, uint16_t addr)
{
	return new OpInc_ab(code, addr);
}

// INCW EXT
#line 65 "hcs12x.isa"
void
#line 28495 "hcs12x.cc"
OpIncw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28499 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28502 "hcs12x.cc"
)
{
#line 307 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "INCW $" << std::hex << opr16a;
	}
#line 28509 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28513 "hcs12x.cc"
OpIncw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28517 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28520 "hcs12x.cc"
)
{
#line 311 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);
		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Add16(result, carry_out, overflow, opr16aVal, 1, carry_in);

		cpu->memWrite16(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 28540 "hcs12x.cc"
}

static Operation *DecodeOpIncw_ext(CodeType const& code, uint16_t addr)
{
	return new OpIncw_ext(code, addr);
}

// INCW  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 65 "hcs12x.isa"
void
#line 28551 "hcs12x.cc"
OpIncw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28555 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28558 "hcs12x.cc"
)
{
#line 331 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "INCW ";
		xb->disasm(sink);
	}
#line 28566 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28570 "hcs12x.cc"
OpIncw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28574 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28577 "hcs12x.cc"
)
{
#line 336 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Add16(result, carry_out, overflow, val, 1, carry_in);

		cpu->memWrite16(addr, result);

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 28598 "hcs12x.cc"
}

static Operation *DecodeOpIncw_idx(CodeType const& code, uint16_t addr)
{
	return new OpIncw_idx(code, addr);
}

// INX or INCY
#line 65 "hcs12x.isa"
void
#line 28609 "hcs12x.cc"
OpInc_xy::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28613 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28616 "hcs12x.cc"
)
{
#line 357 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		if (b==0) {
			sink << "INCX";
			} else {
			sink << "INCY";
		}
	}
#line 28627 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28631 "hcs12x.cc"
OpInc_xy::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28635 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28638 "hcs12x.cc"
)
{
#line 365 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{

		uint16_t val;
		if (b==0) {
			val = cpu->getRegX();
			} else {
			val = cpu->getRegY();
		}

		uint16_t result;
		uint8_t carry_out, overflow, carry_in;

		carry_in = 0;
		Add16(result, carry_out, overflow, val, 1, carry_in);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 28669 "hcs12x.cc"
}

static Operation *DecodeOpInc_xy(CodeType const& code, uint16_t addr)
{
	return new OpInc_xy(code, addr);
}

// INS
#line 65 "hcs12x.isa"
void
#line 28680 "hcs12x.cc"
OpIns::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28684 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28687 "hcs12x.cc"
)
{
#line 396 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "INS";
	}
#line 28694 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28698 "hcs12x.cc"
OpIns::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28702 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28705 "hcs12x.cc"
)
{
#line 400 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		cpu->setRegSP(cpu->getRegSP() + 1);
	}
#line 28712 "hcs12x.cc"
}

static Operation *DecodeOpIns(CodeType const& code, uint16_t addr)
{
	return new OpIns(code, addr);
}

// INX
#line 65 "hcs12x.isa"
void
#line 28723 "hcs12x.cc"
OpInx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28727 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28730 "hcs12x.cc"
)
{
#line 407 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "INX";
	}
#line 28737 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28741 "hcs12x.cc"
OpInx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28745 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28748 "hcs12x.cc"
)
{
#line 411 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		uint16_t val = cpu->getRegX();
		val++;
		cpu->setRegX(val);
		if (val == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	}
#line 28758 "hcs12x.cc"
}

static Operation *DecodeOpInx(CodeType const& code, uint16_t addr)
{
	return new OpInx(code, addr);
}

// INY
#line 65 "hcs12x.isa"
void
#line 28769 "hcs12x.cc"
OpIny::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28773 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28776 "hcs12x.cc"
)
{
#line 421 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		sink << "INY";
	}
#line 28783 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28787 "hcs12x.cc"
OpIny::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28791 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28794 "hcs12x.cc"
)
{
#line 425 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./decrement_increment.isa"
	{
		uint16_t val = cpu->getRegY();
		val++;
		cpu->setRegY(val);
		if (val == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	}
#line 28804 "hcs12x.cc"
}

static Operation *DecodeOpIny(CodeType const& code, uint16_t addr)
{
	return new OpIny(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// CBA
#line 65 "hcs12x.isa"
void
#line 28848 "hcs12x.cc"
OpCba::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28852 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28855 "hcs12x.cc"
)
{
#line 39 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		sink << "CBA";
	}
#line 28862 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28866 "hcs12x.cc"
OpCba::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28870 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28873 "hcs12x.cc"
)
{
#line 43 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;

		carry_in = 0;
		Sub8(result, carry_out, overflow, cpu->getRegA(), cpu->getRegB(), carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 28888 "hcs12x.cc"
}

static Operation *DecodeOpCba(CodeType const& code, uint16_t addr)
{
	return new OpCba(code, addr);
}

//  CMPab  IMM
#line 65 "hcs12x.isa"
void
#line 28899 "hcs12x.cc"
OpCmp_ab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28903 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28906 "hcs12x.cc"
)
{
#line 59 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		if (b==0) {
			sink << "CMPA #$";
			} else {
			sink << "CMPB #$";
		}
		sink << std::hex << opr8i;
	}
#line 28918 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28922 "hcs12x.cc"
OpCmp_ab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28926 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28929 "hcs12x.cc"
)
{
#line 68 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr8i, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 28951 "hcs12x.cc"
}

static Operation *DecodeOpCmp_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpCmp_ab_imm(code, addr);
}

// CMPab  DIR
#line 65 "hcs12x.isa"
void
#line 28962 "hcs12x.cc"
OpCmp_ab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 28966 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 28969 "hcs12x.cc"
)
{
#line 90 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		if (b==0) {
			sink << "CMPA $";
			} else {
			sink << "CMPB $";
		}
		sink << std::hex << opr8a;
	}
#line 28981 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 28985 "hcs12x.cc"
OpCmp_ab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 28989 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 28992 "hcs12x.cc"
)
{
#line 99 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 29016 "hcs12x.cc"
}

static Operation *DecodeOpCmp_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpCmp_ab_dir(code, addr);
}

// CMPab  EXT
#line 65 "hcs12x.isa"
void
#line 29027 "hcs12x.cc"
OpCmp_ab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29031 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29034 "hcs12x.cc"
)
{
#line 123 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		if (b==0) {
			sink << "CMPA $";
			} else {
			sink << "CMPB $";
		}
		sink << std::hex << opr16a;
	}
#line 29046 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29050 "hcs12x.cc"
OpCmp_ab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29054 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29057 "hcs12x.cc"
)
{
#line 132 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint8_t opr16aVal = cpu->memRead8(addr);

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 29082 "hcs12x.cc"
}

static Operation *DecodeOpCmp_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpCmp_ab_ext(code, addr);
}

// CMPab  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 65 "hcs12x.isa"
void
#line 29093 "hcs12x.cc"
OpCmp_ab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29097 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29100 "hcs12x.cc"
)
{
#line 157 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		if (b==0) {
			sink << "CMPA ";
			} else {
			sink << "CMPB ";
		}
		xb->disasm(sink);
	}
#line 29112 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29116 "hcs12x.cc"
OpCmp_ab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29120 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29123 "hcs12x.cc"
)
{
#line 166 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 29147 "hcs12x.cc"
}

static Operation *DecodeOpCmp_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpCmp_ab_idx(code, addr);
}

// CPdyxs  IMM
#line 65 "hcs12x.isa"
void
#line 29158 "hcs12x.cc"
OpCp_dyxs_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29162 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29165 "hcs12x.cc"
)
{
#line 190 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		switch (dyxs) {
			case 0: sink << "CPD #$"; break;
			case 1: sink << "CPY #$"; break;
			case 2: sink << "CPX #$"; break;
			case 3: sink << "CPS #$";
		}
		sink << std::hex << opr16i;
	}
#line 29178 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29182 "hcs12x.cc"
OpCp_dyxs_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29186 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29189 "hcs12x.cc"
)
{
#line 200 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;

		carry_in = 0;
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 29213 "hcs12x.cc"
}

static Operation *DecodeOpCp_dyxs_imm(CodeType const& code, uint16_t addr)
{
	return new OpCp_dyxs_imm(code, addr);
}

// CPdyxs DIR
#line 65 "hcs12x.isa"
void
#line 29224 "hcs12x.cc"
OpCp_dyxs_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29228 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29231 "hcs12x.cc"
)
{
#line 224 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		switch (dyxs) {
			case 0: sink << "CPD $"; break;
			case 1: sink << "CPY $"; break;
			case 2: sink << "CPX $"; break;
			case 3: sink << "CPS $";
		}
		sink << std::hex << opr8a;
	}
#line 29244 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29248 "hcs12x.cc"
OpCp_dyxs_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29252 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29255 "hcs12x.cc"
)
{
#line 234 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;
		uint16_t opr8aVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		opr8aVal = cpu->memRead16(addr);

		carry_in = 0;
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 29282 "hcs12x.cc"
}

static Operation *DecodeOpCp_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpCp_dyxs_dir(code, addr);
}

// CPdyxs EXT
#line 65 "hcs12x.isa"
void
#line 29293 "hcs12x.cc"
OpCp_dyxs_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29297 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29300 "hcs12x.cc"
)
{
#line 261 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		switch (dyxs) {
			case 0: sink << "CPD $"; break;
			case 1: sink << "CPY $"; break;
			case 2: sink << "CPX $"; break;
			case 3: sink << "CPS $";
		}
		sink << std::hex << opr16a;
	}
#line 29313 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29317 "hcs12x.cc"
OpCp_dyxs_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29321 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29324 "hcs12x.cc"
)
{
#line 271 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;
		uint16_t opr16aVal = cpu->memRead16(opr16a);

		carry_in = 0;
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 29349 "hcs12x.cc"
}

static Operation *DecodeOpCp_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpCp_dyxs_ext(code, addr);
}

// CPdyxs  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 65 "hcs12x.isa"
void
#line 29360 "hcs12x.cc"
OpCp_dyxs_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29364 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29367 "hcs12x.cc"
)
{
#line 296 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		switch (dyxs) {
			case 0: sink << "CPD "; break;
			case 1: sink << "CPY "; break;
			case 2: sink << "CPX "; break;
			case 3: sink << "CPS ";
		}
		xb->disasm(sink);
	}
#line 29380 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29384 "hcs12x.cc"
OpCp_dyxs_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29388 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29391 "hcs12x.cc"
)
{
#line 306 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		carry_in = 0;
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 29416 "hcs12x.cc"
}

static Operation *DecodeOpCp_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpCp_dyxs_idx(code, addr);
}

/* ****** Compare to memory with Borrow ********** */
// CPE_dyxs  IMM
#line 65 "hcs12x.isa"
void
#line 29428 "hcs12x.cc"
OpCpe_dyxs_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29432 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29435 "hcs12x.cc"
)
{
#line 333 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		switch (dyxs) {
			case 0: sink << "CPED #$"; break;
			case 1: sink << "CPEY #$"; break;
			case 2: sink << "CPEX #$"; break;
			case 3: sink << "CPES #$";
		}
		sink << std::hex << opr16i;
	}
#line 29448 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29452 "hcs12x.cc"
OpCpe_dyxs_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29456 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29459 "hcs12x.cc"
)
{
#line 343 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in, zeroBit;
		uint16_t result, regVal;

		zeroBit = cpu->ccr->getZ();
		carry_in = cpu->ccr->getC();
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr16i, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (zeroBit && (result == 0)) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 29484 "hcs12x.cc"
}

static Operation *DecodeOpCpe_dyxs_imm(CodeType const& code, uint16_t addr)
{
	return new OpCpe_dyxs_imm(code, addr);
}

// CPE_dyxs DIR
#line 65 "hcs12x.isa"
void
#line 29495 "hcs12x.cc"
OpCpe_dyxs_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29499 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29502 "hcs12x.cc"
)
{
#line 368 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		switch (dyxs) {
			case 0: sink << "CPED $"; break;
			case 1: sink << "CPEY $"; break;
			case 2: sink << "CPEX $"; break;
			case 3: sink << "CPES $";
		}
		sink << std::hex << opr8a;
	}
#line 29515 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29519 "hcs12x.cc"
OpCpe_dyxs_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29523 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29526 "hcs12x.cc"
)
{
#line 378 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in, zeroBit;
		uint16_t result, regVal;
		uint16_t opr8aVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		opr8aVal = cpu->memRead16(addr);

		zeroBit =  cpu->ccr->getZ();
		carry_in = cpu->ccr->getC();
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr8aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (zeroBit && (result == 0)) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 29554 "hcs12x.cc"
}

static Operation *DecodeOpCpe_dyxs_dir(CodeType const& code, uint16_t addr)
{
	return new OpCpe_dyxs_dir(code, addr);
}

// CPE_dyxs EXT
#line 65 "hcs12x.isa"
void
#line 29565 "hcs12x.cc"
OpCpe_dyxs_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29569 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29572 "hcs12x.cc"
)
{
#line 406 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		switch (dyxs) {
			case 0: sink << "CPED $"; break;
			case 1: sink << "CPEY $"; break;
			case 2: sink << "CPEX $"; break;
			case 3: sink << "CPES $";
		}
		sink << std::hex << opr16a;
	}
#line 29585 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29589 "hcs12x.cc"
OpCpe_dyxs_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29593 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29596 "hcs12x.cc"
)
{
#line 416 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in, zeroBit;
		uint16_t result, regVal;
		uint16_t opr16aVal = cpu->memRead16(opr16a);

		zeroBit =  cpu->ccr->getZ();
		carry_in = cpu->ccr->getC();
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, opr16aVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (zeroBit && (result == 0)) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 29622 "hcs12x.cc"
}

static Operation *DecodeOpCpe_dyxs_ext(CodeType const& code, uint16_t addr)
{
	return new OpCpe_dyxs_ext(code, addr);
}

// CPE_dyxs  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 65 "hcs12x.isa"
void
#line 29633 "hcs12x.cc"
OpCpe_dyxs_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29637 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29640 "hcs12x.cc"
)
{
#line 442 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		switch (dyxs) {
			case 0: sink << "CPED "; break;
			case 1: sink << "CPEY "; break;
			case 2: sink << "CPEX "; break;
			case 3: sink << "CPES ";
		}
		xb->disasm(sink);
	}
#line 29653 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29657 "hcs12x.cc"
OpCpe_dyxs_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29661 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29664 "hcs12x.cc"
)
{
#line 452 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in, zeroBit;
		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		zeroBit =  cpu->ccr->getZ();
		carry_in = cpu->ccr->getC();
		switch (dyxs) {
			case 0: regVal = cpu->getRegD(); break;
			case 1: regVal = cpu->getRegY(); break;
			case 2: regVal = cpu->getRegX(); break;
			case 3: regVal = cpu->getRegSP();
		}

		Sub16(result, carry_out, overflow, regVal, xbVal, carry_in);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (zeroBit && (result == 0)) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 29690 "hcs12x.cc"
}

static Operation *DecodeOpCpe_dyxs_idx(CodeType const& code, uint16_t addr)
{
	return new OpCpe_dyxs_idx(code, addr);
}

/* ************ Test Instructions **************** */
// TST EXT
#line 65 "hcs12x.isa"
void
#line 29702 "hcs12x.cc"
OpTst_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29706 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29709 "hcs12x.cc"
)
{
#line 481 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		sink << "TST $" << std::hex << opr16a;
	}
#line 29716 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29720 "hcs12x.cc"
OpTst_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29724 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29727 "hcs12x.cc"
)
{
#line 485 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint8_t result;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);
		carry_in = 0;

		Sub8(result, carry_out, overflow, opr16aVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 29746 "hcs12x.cc"
}

static Operation *DecodeOpTst_ext(CodeType const& code, uint16_t addr)
{
	return new OpTst_ext(code, addr);
}

// TST IDX or IDX1 or IDX2 or [D,IDX] or [IDX2]
#line 65 "hcs12x.isa"
void
#line 29757 "hcs12x.cc"
OpTst_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29761 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29764 "hcs12x.cc"
)
{
#line 504 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		sink << "TST ";
		xb->disasm(sink);
	}
#line 29772 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29776 "hcs12x.cc"
OpTst_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29780 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29783 "hcs12x.cc"
)
{
#line 509 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint8_t result;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		carry_in = 0;

		Sub8(result, carry_out, overflow, xbVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 29802 "hcs12x.cc"
}

static Operation *DecodeOpTst_idx(CodeType const& code, uint16_t addr)
{
	return new OpTst_idx(code, addr);
}

// TSTA or TSTB
#line 65 "hcs12x.isa"
void
#line 29813 "hcs12x.cc"
OpTst_ab::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29817 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29820 "hcs12x.cc"
)
{
#line 528 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		if (b==0) {
			sink << "TSTA ";
			} else {
			sink << "TSTB ";
		}
	}
#line 29831 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29835 "hcs12x.cc"
OpTst_ab::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29839 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29842 "hcs12x.cc"
)
{
#line 536 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t result, carry_out, overflow, carry_in;
		uint8_t regVal;

		carry_in = 0;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, regVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 29864 "hcs12x.cc"
}

static Operation *DecodeOpTst_ab(CodeType const& code, uint16_t addr)
{
	return new OpTst_ab(code, addr);
}

// TSTW EXT
#line 65 "hcs12x.isa"
void
#line 29875 "hcs12x.cc"
OpTstw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29879 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29882 "hcs12x.cc"
)
{
#line 558 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		sink << "TSTW $" << std::hex << opr16a;
	}
#line 29889 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29893 "hcs12x.cc"
OpTstw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29897 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29900 "hcs12x.cc"
)
{
#line 562 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		carry_in = 0;

		Sub16(result, carry_out, overflow, opr16aVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 29920 "hcs12x.cc"
}

static Operation *DecodeOpTstw_ext(CodeType const& code, uint16_t addr)
{
	return new OpTstw_ext(code, addr);
}

// TSTW IDX or IDX1 or IDX2 or [D, IDX] or [IDX2]
#line 65 "hcs12x.isa"
void
#line 29931 "hcs12x.cc"
OpTstw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29935 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29938 "hcs12x.cc"
)
{
#line 582 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		sink << "TSTW ";
		xb->disasm(sink);
	}
#line 29946 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 29950 "hcs12x.cc"
OpTstw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 29954 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 29957 "hcs12x.cc"
)
{
#line 587 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		carry_in = 0;

		Sub16(result, carry_out, overflow, xbVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 29976 "hcs12x.cc"
}

static Operation *DecodeOpTstw_idx(CodeType const& code, uint16_t addr)
{
	return new OpTstw_idx(code, addr);
}

// TSTX or TSTY
#line 65 "hcs12x.isa"
void
#line 29987 "hcs12x.cc"
OpTst_xy::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 29991 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 29994 "hcs12x.cc"
)
{
#line 606 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		switch (b) {
			case 0: sink << "TSTX "; break;
			case 1: sink << "TSTY "; break;
		}
	}
#line 30004 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30008 "hcs12x.cc"
OpTst_xy::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30012 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30015 "hcs12x.cc"
)
{
#line 613 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		uint8_t carry_out, overflow, carry_in;
		uint16_t result, regVal;

		carry_in = 0;
		switch (b) {
			case 0: regVal = cpu->getRegY(); break;
			case 1: regVal = cpu->getRegY();; break;
		}

		Sub16(result, carry_out, overflow, regVal, 0, carry_in);

		cpu->ccr->clrC();
		cpu->ccr->clrV();
		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30036 "hcs12x.cc"
}

static Operation *DecodeOpTst_xy(CodeType const& code, uint16_t addr)
{
	return new OpTst_xy(code, addr);
}

/* ************ Minimum Instructions ************* */
// EMIND: MIN ((D), (M : M + 1)) ⇒ D
// EMINM: MIN ((D), (M : M + 1)) ⇒ M : M + 1
// opcode(EMIND)-> 0x18 0x1B  opcode(EMINM)-> 0x18 0x1F
#line 65 "hcs12x.isa"
void
#line 30050 "hcs12x.cc"
OpEmin_dm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30054 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30057 "hcs12x.cc"
)
{
#line 640 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		if (b == 0) {
			sink << "EMIND ";
			} else {
			sink << "EMINM ";
		}

		xb->disasm(sink);
	}
#line 30070 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30074 "hcs12x.cc"
OpEmin_dm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30078 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30081 "hcs12x.cc"
)
{
#line 650 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint16_t dVal = cpu->getRegD();
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t mVal = cpu->memRead16(addr);

		uint16_t min;
		if (dVal > mVal) { min == mVal; } else { min = dVal; }

		uint16_t result = dVal - mVal;

		if (b == 0) {
			cpu->setRegD(min);
			} else {
			cpu->memWrite16(addr, min);
		}

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is $0000; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: D15 • !M15 • !R15 + !D15 • M15 • R15
		* Set if a two’s complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((dVal & 0x8000) & ~(mVal & 0x8000) & ~(result & 0x8000) | ~(dVal & 0x8000) & (mVal & 0x8000) & (result & 0x8000)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !D15 • M15 + M15 • R15 + R15 • !D15
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > dVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 30120 "hcs12x.cc"
}

static Operation *DecodeOpEmin_dm(CodeType const& code, uint16_t addr)
{
	return new OpEmin_dm(code, addr);
}

// MINA: MIN ((A), (M)) ⇒ A
// MINM: MIN ((A), (M)) ⇒ M
// opcode(MINA)-> 0x18 0x19  opcode(MINM)->0x18 0x1D
#line 65 "hcs12x.isa"
void
#line 30133 "hcs12x.cc"
OpMin_am::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30137 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30140 "hcs12x.cc"
)
{
#line 692 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		if (b == 0) {
			sink << "MINA ";
			} else {
			sink << "MINM ";
		}

		xb->disasm(sink);
	}
#line 30153 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30157 "hcs12x.cc"
OpMin_am::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30161 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30164 "hcs12x.cc"
)
{
#line 702 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint8_t aVal = cpu->getRegA();
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t mVal = cpu->memRead8(addr);

		uint8_t min;
		if (aVal > mVal) { min == mVal; } else { min = aVal; }

		uint8_t result = aVal - mVal;

		if (b == 0) {
			cpu->setRegA(min);
			} else {
			cpu->memWrite8(addr, min);
		}

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is $00; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: A7 • !M7 • !R7 + !A7 • M7 • R7
		* Set if a two’s complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((aVal & 0x80) & ~(mVal & 0x80) & ~(result & 0x80) | ~(aVal & 0x80) & (mVal & 0x80) & (result & 0x80)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !A7 • M7 + M7 • R7 + R7 • !A7
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > aVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 30203 "hcs12x.cc"
}

static Operation *DecodeOpMin_am(CodeType const& code, uint16_t addr)
{
	return new OpMin_am(code, addr);
}

/* ************ Maximum Instructions ************* */
// EMAND: MAX ((D), (M : M + 1)) ⇒ D
// EMANM: MAX ((D), (M : M + 1)) ⇒ M : M + 1
// opcode(EMAXD)-> 0x18 0x1A  opcode(EMAXM)-> 0x18 0x1E
#line 65 "hcs12x.isa"
void
#line 30217 "hcs12x.cc"
OpEmax_dm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30221 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30224 "hcs12x.cc"
)
{
#line 746 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		if (b == 0) {
			sink << "EMAXD ";
			} else {
			sink << "EMAXM ";
		}

		xb->disasm(sink);
	}
#line 30237 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30241 "hcs12x.cc"
OpEmax_dm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30245 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30248 "hcs12x.cc"
)
{
#line 756 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint16_t dVal = cpu->getRegD();
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint16_t mVal = cpu->memRead16(addr);

		uint16_t max;
		if (mVal > dVal) { max == mVal; } else { max = dVal; }

		uint16_t result = dVal - mVal;

		if (b == 0) {
			cpu->setRegD(max);
			} else {
			cpu->memWrite16(addr, max);
		}

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is $0000; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: D15 • !M15 • !R15 + !D15 • M15 • R15
		* Set if a two’s complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((dVal & 0x8000) & ~(mVal & 0x8000) & ~(result & 0x8000) | ~(dVal & 0x8000) & (mVal & 0x8000) & (result & 0x8000)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !D15 • M15 + M15 • R15 + R15 • !D15
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > dVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 30288 "hcs12x.cc"
}

static Operation *DecodeOpEmax_dm(CodeType const& code, uint16_t addr)
{
	return new OpEmax_dm(code, addr);
}

// MAXA: MAX ((A), (M)) ⇒ A
// MAXM: MAx ((A), (M)) ⇒ M
// opcode(MAXA)-> 0x18 0x18  opcode(MAXM)->0x18 0x1C
#line 65 "hcs12x.isa"
void
#line 30301 "hcs12x.cc"
OpMax_am::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30305 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30308 "hcs12x.cc"
)
{
#line 799 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{
		if (b == 0) {
			sink << "MAXA ";
			} else {
			sink << "MAXM ";
		}

		xb->disasm(sink);
	}
#line 30321 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30325 "hcs12x.cc"
OpMax_am::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30329 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30332 "hcs12x.cc"
)
{
#line 809 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./compare_test.isa"
	{

		uint8_t aVal = cpu->getRegA();
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t mVal = cpu->memRead8(addr);

		uint8_t max;
		if (mVal > aVal) { max == mVal; } else { max = aVal; }

		uint8_t result = aVal - mVal;

		if (b == 0) {
			cpu->setRegA(max);
			} else {
			cpu->memWrite8(addr, max);
		}

		// N: Set if MSB of result is set; cleared otherwise
		if ((result & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
		// Z: Set if result is $00; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* V: A7 • !M7 • !R7 + !A7 • M7 • R7
		* Set if a two’s complement overflow resulted from the operation; cleared
		* otherwise
		*/
		if ((aVal & 0x80) & ~(mVal & 0x80) & ~(result & 0x80) | ~(aVal & 0x80) & (mVal & 0x80) & (result & 0x80)) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		/*
		* C: !A7 • M7 + M7 • R7 + R7 • !A7
		* Set if the value of the content of memory is larger than the value of the
		* accumulator; cleared otherwise
		*/
		if (mVal > aVal) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 30371 "hcs12x.cc"
}

static Operation *DecodeOpMax_am(CodeType const& code, uint16_t addr)
{
	return new OpMax_am(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// ANDA/ANDB  IMM  (regAB & ii => regAB)
#line 65 "hcs12x.isa"
void
#line 30415 "hcs12x.cc"
OpAnd_ab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30419 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30422 "hcs12x.cc"
)
{
#line 39 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ANDA #$";
			} else {
			sink << "ANDB #$";
		}
		sink << std::hex << opr8i;
	}
#line 30434 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30438 "hcs12x.cc"
OpAnd_ab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30442 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30445 "hcs12x.cc"
)
{
#line 48 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		result = regVal & opr8i;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 30473 "hcs12x.cc"
}

static Operation *DecodeOpAnd_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpAnd_ab_imm(code, addr);
}

// ANDA/ANDB  DIR  (regAB & mem[regDirect:opr8a] => regAB)s
#line 65 "hcs12x.isa"
void
#line 30484 "hcs12x.cc"
OpAnd_ab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30488 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30491 "hcs12x.cc"
)
{
#line 76 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ANDA $";
			} else {
			sink << "ANDB $";
		}
		sink << std::hex << opr8a;
	}
#line 30503 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30507 "hcs12x.cc"
OpAnd_ab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30511 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30514 "hcs12x.cc"
)
{
#line 85 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		result = regVal & opr8aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30543 "hcs12x.cc"
}

static Operation *DecodeOpAnd_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpAnd_ab_dir(code, addr);
}

// ANDA/ANDB EXT (regAB & mem[opr16a] => regAB)
#line 65 "hcs12x.isa"
void
#line 30554 "hcs12x.cc"
OpAnd_ab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30558 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30561 "hcs12x.cc"
)
{
#line 114 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ANDA $";
			} else {
			sink << "ANDB $";
		}
		sink << std::hex << opr16a;
	}
#line 30573 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30577 "hcs12x.cc"
OpAnd_ab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30581 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30584 "hcs12x.cc"
)
{
#line 123 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		result = regVal & opr16aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30613 "hcs12x.cc"
}

static Operation *DecodeOpAnd_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpAnd_ab_ext(code, addr);
}

// ANDA/ANDB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regAB & mem[xb->addrE] => regAB)
#line 65 "hcs12x.isa"
void
#line 30624 "hcs12x.cc"
OpAnd_ab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30628 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30631 "hcs12x.cc"
)
{
#line 152 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0){
			sink << "ANDA ";
			} else {
			sink << "ANDB ";
		}

		xb->disasm(sink);
	}
#line 30644 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30648 "hcs12x.cc"
OpAnd_ab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30652 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30655 "hcs12x.cc"
)
{
#line 162 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		result = regVal & xbVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30685 "hcs12x.cc"
}

static Operation *DecodeOpAnd_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpAnd_ab_idx(code, addr);
}

// ANDCC  IMM  (ccr & ii => ccr)
#line 65 "hcs12x.isa"
void
#line 30696 "hcs12x.cc"
OpAndcc_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30700 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30703 "hcs12x.cc"
)
{
#line 192 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		sink << "ANDCC #$" << std::hex << opr8i;
	}
#line 30711 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30715 "hcs12x.cc"
OpAndcc_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30719 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30722 "hcs12x.cc"
)
{
#line 197 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal = cpu->ccr->getCCRLow();

		result = regVal & opr8i;

		cpu->ccr->setCCRLow(result);

	}
#line 30736 "hcs12x.cc"
}

static Operation *DecodeOpAndcc_imm(CodeType const& code, uint16_t addr)
{
	return new OpAndcc_imm(code, addr);
}

// ANDX/ANDY IMM (regXY & opr16i => regXY)
#line 65 "hcs12x.isa"
void
#line 30747 "hcs12x.cc"
OpAnd_xy_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30751 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30754 "hcs12x.cc"
)
{
#line 211 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ANDX #$";
			} else {
			sink << "ANDY #$";
		}

		sink << std::hex << opr16i;
	}
#line 30767 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30771 "hcs12x.cc"
OpAnd_xy_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30775 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30778 "hcs12x.cc"
)
{
#line 221 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal & opr16i;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30805 "hcs12x.cc"
}

static Operation *DecodeOpAnd_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpAnd_xy_imm(code, addr);
}

// ANDX/ANDY DIR (regXY & mem[regDirect:opr8a]:mem[regDirect:opr8a+1] => regXY)
#line 65 "hcs12x.isa"
void
#line 30816 "hcs12x.cc"
OpAnd_xy_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30820 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30823 "hcs12x.cc"
)
{
#line 248 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ANDX $";
			} else {
			sink << "ANDY $";
		}

		sink << std::hex << opr8a;
	}
#line 30836 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30840 "hcs12x.cc"
OpAnd_xy_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30844 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30847 "hcs12x.cc"
)
{
#line 258 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal & opr8aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30876 "hcs12x.cc"
}

static Operation *DecodeOpAnd_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpAnd_xy_dir(code, addr);
}

// ANDX/ANDY EXT (regXY & mem[opr16a]:mem[opr16a+1] => regXY)
#line 65 "hcs12x.isa"
void
#line 30887 "hcs12x.cc"
OpAnd_xy_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30891 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30894 "hcs12x.cc"
)
{
#line 287 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ANDX $";
			} else {
			sink << "ANDY $";
		}

		sink << std::hex << opr16a;
	}
#line 30907 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30911 "hcs12x.cc"
OpAnd_xy_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30915 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30918 "hcs12x.cc"
)
{
#line 297 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal & opr16aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 30947 "hcs12x.cc"
}

static Operation *DecodeOpAnd_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpAnd_xy_ext(code, addr);
}

// ANDX/ANDY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regXY & mem[xb->addrE]:mem[xb->addrE+1] => regXY)
#line 65 "hcs12x.isa"
void
#line 30958 "hcs12x.cc"
OpAnd_xy_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 30962 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 30965 "hcs12x.cc"
)
{
#line 326 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ANDX ";
			} else {
			sink << "ANDY ";
		}

		xb->disasm(sink);
	}
#line 30978 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 30982 "hcs12x.cc"
OpAnd_xy_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 30986 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 30989 "hcs12x.cc"
)
{
#line 336 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal & xbVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31018 "hcs12x.cc"
}

static Operation *DecodeOpAnd_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpAnd_xy_idx(code, addr);
}

// ORAA/ORAB IMM (regAB or opr8i => regAB)
#line 65 "hcs12x.isa"
void
#line 31029 "hcs12x.cc"
OpOra_ab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31033 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31036 "hcs12x.cc"
)
{
#line 366 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ORA #$";
			} else {
			sink << "ORB #$";
		}
		sink << std::hex << opr8i;
	}
#line 31048 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31052 "hcs12x.cc"
OpOra_ab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31056 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31059 "hcs12x.cc"
)
{
#line 375 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		result = regVal | opr8i;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();

	}
#line 31087 "hcs12x.cc"
}

static Operation *DecodeOpOra_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpOra_ab_imm(code, addr);
}

// ORAA/ORAB  DIR  (regAB | mem[regDirect:opr8a] => regAB)s
#line 65 "hcs12x.isa"
void
#line 31098 "hcs12x.cc"
OpOra_ab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31102 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31105 "hcs12x.cc"
)
{
#line 403 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ORAA $";
			} else {
			sink << "ORAB $";
		}
		sink << std::hex << opr8a;
	}
#line 31117 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31121 "hcs12x.cc"
OpOra_ab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31125 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31128 "hcs12x.cc"
)
{
#line 412 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		result = regVal | opr8aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31157 "hcs12x.cc"
}

static Operation *DecodeOpOra_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpOra_ab_dir(code, addr);
}

// ORAA/ORAB EXT (regAB | mem[opr16a] => regAB)
#line 65 "hcs12x.isa"
void
#line 31168 "hcs12x.cc"
OpOra_ab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31172 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31175 "hcs12x.cc"
)
{
#line 441 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ORAA $";
			} else {
			sink << "ORAB $";
		}
		sink << std::hex << opr16a;
	}
#line 31187 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31191 "hcs12x.cc"
OpOra_ab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31195 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31198 "hcs12x.cc"
)
{
#line 450 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		result = regVal | opr16aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31227 "hcs12x.cc"
}

static Operation *DecodeOpOra_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpOra_ab_ext(code, addr);
}

// ORAA/ORAB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regAB | mem[xb->addrE] => regAB)
#line 65 "hcs12x.isa"
void
#line 31238 "hcs12x.cc"
OpOra_ab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31242 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31245 "hcs12x.cc"
)
{
#line 479 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0){
			sink << "ORAA ";
			} else {
			sink << "ORAB ";
		}

		xb->disasm(sink);
	}
#line 31258 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31262 "hcs12x.cc"
OpOra_ab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31266 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31269 "hcs12x.cc"
)
{
#line 489 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		result = regVal | xbVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31299 "hcs12x.cc"
}

static Operation *DecodeOpOra_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpOra_ab_idx(code, addr);
}

// ORCC  IMM  (ccr & ii => ccr)
#line 65 "hcs12x.isa"
void
#line 31310 "hcs12x.cc"
OpOrcc_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31314 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31317 "hcs12x.cc"
)
{
#line 519 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		sink << "ORCC #$" << std::hex << opr8i;
	}
#line 31325 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31329 "hcs12x.cc"
OpOrcc_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31333 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31336 "hcs12x.cc"
)
{
#line 524 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result, xFlag;

		uint8_t regVal = cpu->ccr->getCCRLow();

		// get ccr.X which may not be affected by ORCC instruction
		// if (ccr.X==1) then xFlag=0xFF else xFlag=0xBF;  0xBF = 0b10111111
		xFlag = regVal | 0xBF;

		result = (regVal | opr8i) & xFlag;

		cpu->ccr->setCCRLow(result);

	}
#line 31354 "hcs12x.cc"
}

static Operation *DecodeOpOrcc_imm(CodeType const& code, uint16_t addr)
{
	return new OpOrcc_imm(code, addr);
}

// TODO: implement specialization ++++++++++++++
// SEC: set carry
// use specialize orcc_imm with opr8i=0x01
// SEI: set I (inhibit I interrupts)
// use specialize orcc_imm with opr8i=0x10
// SEV: set overflow
// use specialize orcc_imm with opr8i=0x02
// end todo specialization ++++++++++++++++++++++
// ORX/ORY IMM (regXY | opr16i => regXY)
#line 65 "hcs12x.isa"
void
#line 31373 "hcs12x.cc"
OpOr_xy_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31377 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31380 "hcs12x.cc"
)
{
#line 556 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ORX #$";
			} else {
			sink << "ORY #$";
		}

		sink << std::hex << opr16i;
	}
#line 31393 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31397 "hcs12x.cc"
OpOr_xy_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31401 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31404 "hcs12x.cc"
)
{
#line 566 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal | opr16i;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31431 "hcs12x.cc"
}

static Operation *DecodeOpOr_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpOr_xy_imm(code, addr);
}

// ORX/ORY DIR (regXY | mem[regDirect:opr8a]:mem[regDirect:opr8a+1] => regXY)
#line 65 "hcs12x.isa"
void
#line 31442 "hcs12x.cc"
OpOr_xy_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31446 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31449 "hcs12x.cc"
)
{
#line 593 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ORX $";
			} else {
			sink << "ORY $";
		}

		sink << std::hex << opr8a;
	}
#line 31462 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31466 "hcs12x.cc"
OpOr_xy_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31470 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31473 "hcs12x.cc"
)
{
#line 603 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal | opr8aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31502 "hcs12x.cc"
}

static Operation *DecodeOpOr_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpOr_xy_dir(code, addr);
}

// ORX/ORY EXT (regXY | mem[opr16a]:mem[opr16a+1] => regXY)
#line 65 "hcs12x.isa"
void
#line 31513 "hcs12x.cc"
OpOr_xy_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31517 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31520 "hcs12x.cc"
)
{
#line 632 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ORX $";
			} else {
			sink << "ORY $";
		}

		sink << std::hex << opr16a;
	}
#line 31533 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31537 "hcs12x.cc"
OpOr_xy_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31541 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31544 "hcs12x.cc"
)
{
#line 642 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal | opr16aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31573 "hcs12x.cc"
}

static Operation *DecodeOpOr_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpOr_xy_ext(code, addr);
}

// ORX/ORY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regXY | mem[xb->addrE]:mem[xb->addrE+1] => regXY)
#line 65 "hcs12x.isa"
void
#line 31584 "hcs12x.cc"
OpOr_xy_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31588 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31591 "hcs12x.cc"
)
{
#line 671 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ORX ";
			} else {
			sink << "ORY ";
		}

		xb->disasm(sink);
	}
#line 31604 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31608 "hcs12x.cc"
OpOr_xy_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31612 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31615 "hcs12x.cc"
)
{
#line 681 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal | xbVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31644 "hcs12x.cc"
}

static Operation *DecodeOpOr_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpOr_xy_idx(code, addr);
}

// EORA/EORB IMM (regAB ^ opr8i => regAB)
#line 65 "hcs12x.isa"
void
#line 31655 "hcs12x.cc"
OpEor_ab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31659 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31662 "hcs12x.cc"
)
{
#line 711 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "EOR #$";
			} else {
			sink << "EOR #$";
		}
		sink << std::hex << opr8i;
	}
#line 31674 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31678 "hcs12x.cc"
OpEor_ab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31682 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31685 "hcs12x.cc"
)
{
#line 720 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}

		result = regVal ^ opr8i;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31712 "hcs12x.cc"
}

static Operation *DecodeOpEor_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpEor_ab_imm(code, addr);
}

// EORA/EORB  DIR  (regAB ^ mem[regDirect:opr8a] => regAB)s
#line 65 "hcs12x.isa"
void
#line 31723 "hcs12x.cc"
OpEor_ab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31727 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31730 "hcs12x.cc"
)
{
#line 747 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "ORAA $";
			} else {
			sink << "ORAB $";
		}
		sink << std::hex << opr8a;
	}
#line 31742 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31746 "hcs12x.cc"
OpEor_ab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31750 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31753 "hcs12x.cc"
)
{
#line 756 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		result = regVal ^ opr8aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31782 "hcs12x.cc"
}

static Operation *DecodeOpEor_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpEor_ab_dir(code, addr);
}

// EORA/EORB EXT (regAB ^ mem[opr16a] => regAB)
#line 65 "hcs12x.isa"
void
#line 31793 "hcs12x.cc"
OpEor_ab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31797 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31800 "hcs12x.cc"
)
{
#line 785 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "EORA $";
			} else {
			sink << "EORB $";
		}
		sink << std::hex << opr16a;
	}
#line 31812 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31816 "hcs12x.cc"
OpEor_ab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31820 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31823 "hcs12x.cc"
)
{
#line 794 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;
		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		result = regVal ^ opr16aVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31852 "hcs12x.cc"
}

static Operation *DecodeOpEor_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpEor_ab_ext(code, addr);
}

// EORA/EORB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regAB ^ mem[xb->addrE] => regAB)
#line 65 "hcs12x.isa"
void
#line 31863 "hcs12x.cc"
OpEor_ab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31867 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31870 "hcs12x.cc"
)
{
#line 823 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0){
			sink << "EORA ";
			} else {
			sink << "EORB ";
		}

		xb->disasm(sink);
	}
#line 31883 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31887 "hcs12x.cc"
OpEor_ab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31891 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31894 "hcs12x.cc"
)
{
#line 833 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		uint8_t result;

		uint8_t regVal;

		if (b==0) {
			regVal = cpu->getRegA();
			} else {
			regVal = cpu->getRegB();
		}
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		result = regVal ^ xbVal;

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31924 "hcs12x.cc"
}

static Operation *DecodeOpEor_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpEor_ab_idx(code, addr);
}

// EORX/EORY IMM (regXY ^ opr16i => regXY)
#line 65 "hcs12x.isa"
void
#line 31935 "hcs12x.cc"
OpEor_xy_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 31939 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 31942 "hcs12x.cc"
)
{
#line 863 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "EORX #$";
			} else {
			sink << "EORY #$";
		}

		sink << std::hex << opr16i;
	}
#line 31955 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 31959 "hcs12x.cc"
OpEor_xy_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 31963 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 31966 "hcs12x.cc"
)
{
#line 873 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal ^ opr16i;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 31993 "hcs12x.cc"
}

static Operation *DecodeOpEor_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpEor_xy_imm(code, addr);
}

// EORX/EORY DIR (regXY ^ mem[regDirect:opr8a]:mem[regDirect:opr8a+1] => regXY)
#line 65 "hcs12x.isa"
void
#line 32004 "hcs12x.cc"
OpEor_xy_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32008 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32011 "hcs12x.cc"
)
{
#line 900 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "EORX $";
			} else {
			sink << "eORY $";
		}

		sink << std::hex << opr8a;
	}
#line 32024 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32028 "hcs12x.cc"
OpEor_xy_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32032 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32035 "hcs12x.cc"
)
{
#line 910 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t opr8aVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal ^ opr8aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 32064 "hcs12x.cc"
}

static Operation *DecodeOpEor_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpEor_xy_dir(code, addr);
}

// EORX/EORY EXT (regXY ^ mem[opr16a]:mem[opr16a+1] => regXY)
#line 65 "hcs12x.isa"
void
#line 32075 "hcs12x.cc"
OpEor_xy_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32079 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32082 "hcs12x.cc"
)
{
#line 939 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "EORX $";
			} else {
			sink << "EORY $";
		}

		sink << std::hex << opr16a;
	}
#line 32095 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32099 "hcs12x.cc"
OpEor_xy_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32103 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32106 "hcs12x.cc"
)
{
#line 949 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t opr16aVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal ^ opr16aVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 32135 "hcs12x.cc"
}

static Operation *DecodeOpEor_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpEor_xy_ext(code, addr);
}

// EORX/EORY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regXY ^ mem[xb->addrE]:mem[xb->addrE+1] => regXY)
#line 65 "hcs12x.isa"
void
#line 32146 "hcs12x.cc"
OpEor_xy_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32150 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32153 "hcs12x.cc"
)
{
#line 978 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{
		if (b==0) {
			sink << "EORX ";
			} else {
			sink << "EORY ";
		}

		xb->disasm(sink);
	}
#line 32166 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32170 "hcs12x.cc"
OpEor_xy_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32174 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32177 "hcs12x.cc"
)
{
#line 988 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./boolean-logic.isa"
	{

		uint16_t result, regVal;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t xbVal = cpu->memRead16(addr);

		if (b==0) {
			regVal = cpu->getRegX();
			} else {
			regVal = cpu->getRegY();
		}

		result = regVal ^ xbVal;

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		cpu->ccr->clrV();

		if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
		if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
	}
#line 32206 "hcs12x.cc"
}

static Operation *DecodeOpEor_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpEor_xy_idx(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
/* ********** Clear, Complement, and Negate instructions ********* */
// CLC: clear bit C
#line 65 "hcs12x.isa"
void
#line 32251 "hcs12x.cc"
OpClc::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32255 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32258 "hcs12x.cc"
)
{
#line 41 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "CLC";
	}
#line 32265 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32269 "hcs12x.cc"
OpClc::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32273 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32276 "hcs12x.cc"
)
{
#line 45 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		cpu->ccr->clrC();
	}
#line 32283 "hcs12x.cc"
}

static Operation *DecodeOpClc(CodeType const& code, uint16_t addr)
{
	return new OpClc(code, addr);
}

// CLI: clear bit I
#line 65 "hcs12x.isa"
void
#line 32294 "hcs12x.cc"
OpCli::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32298 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32301 "hcs12x.cc"
)
{
#line 52 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "CLI";
	}
#line 32308 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32312 "hcs12x.cc"
OpCli::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32316 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32319 "hcs12x.cc"
)
{
#line 56 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		cpu->ccr->clrI();
	}
#line 32326 "hcs12x.cc"
}

static Operation *DecodeOpCli(CodeType const& code, uint16_t addr)
{
	return new OpCli(code, addr);
}

// CLV: clear bit V
#line 65 "hcs12x.isa"
void
#line 32337 "hcs12x.cc"
OpClv::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32341 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32344 "hcs12x.cc"
)
{
#line 63 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "CLV";
	}
#line 32351 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32355 "hcs12x.cc"
OpClv::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32359 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32362 "hcs12x.cc"
)
{
#line 67 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		cpu->ccr->clrV();
	}
#line 32369 "hcs12x.cc"
}

static Operation *DecodeOpClv(CodeType const& code, uint16_t addr)
{
	return new OpClv(code, addr);
}

// clear Memory
#line 65 "hcs12x.isa"
void
#line 32380 "hcs12x.cc"
OpClr_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32384 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32387 "hcs12x.cc"
)
{
#line 74 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "CLR $" << std::hex << opr16a;
	}
#line 32394 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32398 "hcs12x.cc"
OpClr_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32402 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32405 "hcs12x.cc"
)
{
#line 78 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, 0);

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 32418 "hcs12x.cc"
}

static Operation *DecodeOpClr_ext(CodeType const& code, uint16_t addr)
{
	return new OpClr_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32428 "hcs12x.cc"
OpClr_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32432 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32435 "hcs12x.cc"
)
{
#line 90 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "CLR ";
		xb->disasm(sink);
	}
#line 32443 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32447 "hcs12x.cc"
OpClr_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32451 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32454 "hcs12x.cc"
)
{
#line 95 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, 0);

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 32467 "hcs12x.cc"
}

static Operation *DecodeOpClr_idx(CodeType const& code, uint16_t addr)
{
	return new OpClr_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32477 "hcs12x.cc"
OpClrw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32481 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32484 "hcs12x.cc"
)
{
#line 107 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "CLRW $" << std::hex << opr16a;
	}
#line 32491 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32495 "hcs12x.cc"
OpClrw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32499 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32502 "hcs12x.cc"
)
{
#line 111 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite16(addr, 0);

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 32515 "hcs12x.cc"
}

static Operation *DecodeOpClrw_ext(CodeType const& code, uint16_t addr)
{
	return new OpClrw_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32525 "hcs12x.cc"
OpClrw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32529 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32532 "hcs12x.cc"
)
{
#line 123 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "CLRW ";
		xb->disasm(sink);
	}
#line 32540 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32544 "hcs12x.cc"
OpClrw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32548 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32551 "hcs12x.cc"
)
{
#line 128 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite16(addr, 0);

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 32564 "hcs12x.cc"
}

static Operation *DecodeOpClrw_idx(CodeType const& code, uint16_t addr)
{
	return new OpClrw_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32574 "hcs12x.cc"
OpClr_ab::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32578 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32581 "hcs12x.cc"
)
{
#line 140 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "CLRA";
			} else {
			sink << "CLRB";
		}
	}
#line 32592 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32596 "hcs12x.cc"
OpClr_ab::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32600 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32603 "hcs12x.cc"
)
{
#line 148 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		if (b==0) {
			cpu->setRegA(0);
			} else {
			cpu->setRegB(0);
		}

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 32620 "hcs12x.cc"
}

static Operation *DecodeOpClr_ab(CodeType const& code, uint16_t addr)
{
	return new OpClr_ab(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32630 "hcs12x.cc"
OpClr_xy::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32634 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32637 "hcs12x.cc"
)
{
#line 164 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "CLRX";
			} else {
			sink << "CLRY";
		}
	}
#line 32648 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32652 "hcs12x.cc"
OpClr_xy::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32656 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32659 "hcs12x.cc"
)
{
#line 172 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		if (b==0) {
			cpu->setRegX(0);
			} else {
			cpu->setRegY(0);
		}

		cpu->ccr->clrN();
		cpu->ccr->setZ();
		cpu->ccr->clrV();
		cpu->ccr->clrC();
	}
#line 32676 "hcs12x.cc"
}

static Operation *DecodeOpClr_xy(CodeType const& code, uint16_t addr)
{
	return new OpClr_xy(code, addr);
}

// COM: One's complement memory Location
#line 65 "hcs12x.isa"
void
#line 32687 "hcs12x.cc"
OpCom_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32691 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32694 "hcs12x.cc"
)
{
#line 189 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "COM $" << std::hex << opr16a;
	}
#line 32701 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32705 "hcs12x.cc"
OpCom_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32709 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32712 "hcs12x.cc"
)
{
#line 193 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = ~cpu->memRead8(addr);
		cpu->memWrite8(addr, val);

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 32726 "hcs12x.cc"
}

static Operation *DecodeOpCom_ext(CodeType const& code, uint16_t addr)
{
	return new OpCom_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32736 "hcs12x.cc"
OpCom_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32740 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32743 "hcs12x.cc"
)
{
#line 206 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "COM ";
		xb->disasm(sink);
	}
#line 32751 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32755 "hcs12x.cc"
OpCom_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32759 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32762 "hcs12x.cc"
)
{
#line 211 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = ~cpu->memRead8(addr);
		cpu->memWrite8(addr, val);

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 32777 "hcs12x.cc"
}

static Operation *DecodeOpCom_idx(CodeType const& code, uint16_t addr)
{
	return new OpCom_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32787 "hcs12x.cc"
OpCom_ab::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32791 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32794 "hcs12x.cc"
)
{
#line 225 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "COMA";
			} else {
			sink << "COMB";
		}
	}
#line 32805 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32809 "hcs12x.cc"
OpCom_ab::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32813 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32816 "hcs12x.cc"
)
{
#line 233 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint8_t val;
		if (b==0) {
			val = cpu->getRegA();
			} else {
			val = cpu->getRegB();
		}

		val = ~val;

		if (b==0) {
			cpu->setRegA(val);
			} else {
			cpu->setRegB(val);
		}

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 32842 "hcs12x.cc"
}

static Operation *DecodeOpCom_ab(CodeType const& code, uint16_t addr)
{
	return new OpCom_ab(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32852 "hcs12x.cc"
OpComw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32856 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32859 "hcs12x.cc"
)
{
#line 258 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "COMW $" << std::hex << opr16a;
	}
#line 32866 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32870 "hcs12x.cc"
OpComw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32874 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32877 "hcs12x.cc"
)
{
#line 262 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = ~cpu->memRead16(addr);
		cpu->memWrite16(addr, val);

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 32891 "hcs12x.cc"
}

static Operation *DecodeOpComw_ext(CodeType const& code, uint16_t addr)
{
	return new OpComw_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32901 "hcs12x.cc"
OpComw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32905 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32908 "hcs12x.cc"
)
{
#line 275 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "COMW ";
		xb->disasm(sink);
	}
#line 32916 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32920 "hcs12x.cc"
OpComw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32924 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32927 "hcs12x.cc"
)
{
#line 280 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = ~cpu->memRead16(addr);
		cpu->memWrite16(addr, val);

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 32942 "hcs12x.cc"
}

static Operation *DecodeOpComw_idx(CodeType const& code, uint16_t addr)
{
	return new OpComw_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 32952 "hcs12x.cc"
OpCom_xy::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 32956 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 32959 "hcs12x.cc"
)
{
#line 294 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "COMX";
			} else {
			sink << "COMY";
		}
	}
#line 32970 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 32974 "hcs12x.cc"
OpCom_xy::execute(
#line 60 "hcs12x.isa"
CPU *
#line 32978 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 32981 "hcs12x.cc"
)
{
#line 302 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint16_t val;
		if (b==0) {
			val = cpu->getRegX();
			} else {
			val = cpu->getRegY();
		}

		val = ~val;

		if (b==0) {
			cpu->setRegX(val);
			} else {
			cpu->setRegY(val);
		}

		cpu->ccr->setC();
		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
	}
#line 33007 "hcs12x.cc"
}

static Operation *DecodeOpCom_xy(CodeType const& code, uint16_t addr)
{
	return new OpCom_xy(code, addr);
}

// NEG: Two's Complement Negate
#line 65 "hcs12x.isa"
void
#line 33018 "hcs12x.cc"
OpNeg_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33022 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33025 "hcs12x.cc"
)
{
#line 328 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "NEG $" << std::hex << opr16a;
	}
#line 33032 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33036 "hcs12x.cc"
OpNeg_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33040 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33043 "hcs12x.cc"
)
{
#line 332 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t result, carry_out, overflow;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		Sub8(result, carry_out, overflow, 0, cpu->memRead8(addr), 0);
		cpu->memWrite8(addr, result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 33058 "hcs12x.cc"
}

static Operation *DecodeOpNeg_ext(CodeType const& code, uint16_t addr)
{
	return new OpNeg_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33068 "hcs12x.cc"
OpNeg_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33072 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33075 "hcs12x.cc"
)
{
#line 346 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "NEG $";
		xb->disasm(sink);
	}
#line 33083 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33087 "hcs12x.cc"
OpNeg_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33091 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33094 "hcs12x.cc"
)
{
#line 351 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint8_t result, carry_out, overflow;
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		Sub8(result, carry_out, overflow, 0, cpu->memRead8(addr), 0);
		cpu->memWrite8(addr, result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();}

	}
#line 33112 "hcs12x.cc"
}

static Operation *DecodeOpNeg_idx(CodeType const& code, uint16_t addr)
{
	return new OpNeg_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33122 "hcs12x.cc"
OpNeg_ab::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33126 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33129 "hcs12x.cc"
)
{
#line 368 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "NEGA";
			} else {
			sink << "NEGB";
		}
	}
#line 33140 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33144 "hcs12x.cc"
OpNeg_ab::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33148 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33151 "hcs12x.cc"
)
{
#line 376 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val, result, carry_out, overflow;

		if (b==0) {
			val = cpu->getRegA();
			} else {
			val = cpu->getRegB();
		}

		Sub8(result, carry_out, overflow, 0, val, 0);

		if (b==0) {
			cpu->setRegA(result);
			} else {
			cpu->setRegB(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 33177 "hcs12x.cc"
}

static Operation *DecodeOpNeg_ab(CodeType const& code, uint16_t addr)
{
	return new OpNeg_ab(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33187 "hcs12x.cc"
OpNegw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33191 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33194 "hcs12x.cc"
)
{
#line 401 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "NEGW $" << std::hex << opr16a;
	}
#line 33201 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33205 "hcs12x.cc"
OpNegw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33209 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33212 "hcs12x.cc"
)
{
#line 405 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t result;

		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		Sub16(result, carry_out, overflow, 0, cpu->memRead16(addr), 0);
		cpu->memWrite16(addr, result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x8000) == 0x8000) {cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 33230 "hcs12x.cc"
}

static Operation *DecodeOpNegw_ext(CodeType const& code, uint16_t addr)
{
	return new OpNegw_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33240 "hcs12x.cc"
OpNegw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33244 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33247 "hcs12x.cc"
)
{
#line 422 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "NEGW $";
		xb->disasm(sink);
	}
#line 33255 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33259 "hcs12x.cc"
OpNegw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33263 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33266 "hcs12x.cc"
)
{
#line 427 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		uint8_t carry_out, overflow;
		uint16_t result;

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		Sub16(result, carry_out, overflow, 0, cpu->memRead16(addr), 0);
		cpu->memWrite16(addr, result);

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x8000) == 0x8000) {cpu->ccr->setN();} else { cpu->ccr->clrN();}

	}
#line 33286 "hcs12x.cc"
}

static Operation *DecodeOpNegw_idx(CodeType const& code, uint16_t addr)
{
	return new OpNegw_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33296 "hcs12x.cc"
OpNeg_xy::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33300 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33303 "hcs12x.cc"
)
{
#line 446 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "NEGX";
			} else {
			sink << "NEGY";
		}
	}
#line 33314 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33318 "hcs12x.cc"
OpNeg_xy::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33322 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33325 "hcs12x.cc"
)
{
#line 454 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t carry_out, overflow;
		uint16_t val, result;

		if (b==0) {
			val = cpu->getRegX();
			} else {
			val = cpu->getRegY();
		}

		Sub16(result, carry_out, overflow, 0, val, 0);

		if (b==0) {
			cpu->setRegX(result);
			} else {
			cpu->setRegY(result);
		}

		if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
		if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((result & 0x8000) == 0x8000) {cpu->ccr->setN();} else { cpu->ccr->clrN();}
	}
#line 33352 "hcs12x.cc"
}

static Operation *DecodeOpNeg_xy(CodeType const& code, uint16_t addr)
{
	return new OpNeg_xy(code, addr);
}

/* ********** Bit Test and Manipulation Instructions ************* */
// BCLR: Clear bit(s) in memory
#line 65 "hcs12x.isa"
void
#line 33364 "hcs12x.cc"
OpBclr_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33368 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33371 "hcs12x.cc"
)
{
#line 484 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "BCLR $" << std::hex << dd << ", $" << std::hex << mm;
	}
#line 33378 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33382 "hcs12x.cc"
OpBclr_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33386 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33389 "hcs12x.cc"
)
{
#line 488 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(dd, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t ddVal = cpu->memRead8(addr);
		uint8_t mmCom = ~mm;

		uint8_t val = ddVal & mmCom;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 33406 "hcs12x.cc"
}

static Operation *DecodeOpBclr_dir(CodeType const& code, uint16_t addr)
{
	return new OpBclr_dir(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33416 "hcs12x.cc"
OpBclr_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33420 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33423 "hcs12x.cc"
)
{
#line 504 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "BCLR $" << std::hex << opr16a << ", $" << std::hex << mm;
	}
#line 33430 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33434 "hcs12x.cc"
OpBclr_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33438 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33441 "hcs12x.cc"
)
{
#line 508 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);
		uint8_t mmCom = ~mm;

		uint8_t val = opr16aVal & mmCom;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 33458 "hcs12x.cc"
}

static Operation *DecodeOpBclr_ext(CodeType const& code, uint16_t addr)
{
	return new OpBclr_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33468 "hcs12x.cc"
OpBclr_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33472 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33475 "hcs12x.cc"
)
{
#line 524 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "BCLR ";
		xb->disasm(sink);
		sink << ", $" << std::hex << mm;
	}
#line 33484 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33488 "hcs12x.cc"
OpBclr_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33492 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33495 "hcs12x.cc"
)
{
#line 530 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);
		uint8_t mmCom = ~mm;

		uint8_t val = xbVal & mmCom;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 33513 "hcs12x.cc"
}

static Operation *DecodeOpBclr_idx(CodeType const& code, uint16_t addr)
{
	return new OpBclr_idx(code, addr);
}

// BITA or BITB: bit test A/B (Logical 'AND' A/B with Memory
#line 65 "hcs12x.isa"
void
#line 33524 "hcs12x.cc"
OpBit_ab_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33528 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33531 "hcs12x.cc"
)
{
#line 548 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "BITA #$";
			} else {
			sink << "BITB #$";
		}
		sink << std::hex << ii;
	}
#line 33543 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33547 "hcs12x.cc"
OpBit_ab_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33551 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33554 "hcs12x.cc"
)
{
#line 557 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val;

		if (b==0) {
			val = cpu->getRegA() & ii;
			} else {
			val = cpu->getRegB() & ii;
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 33572 "hcs12x.cc"
}

static Operation *DecodeOpBit_ab_imm(CodeType const& code, uint16_t addr)
{
	return new OpBit_ab_imm(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33582 "hcs12x.cc"
OpBit_ab_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33586 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33589 "hcs12x.cc"
)
{
#line 574 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "BITA $";
			} else {
			sink << "BITB $";
		}
		sink << std::hex << opr8a;
	}
#line 33601 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33605 "hcs12x.cc"
OpBit_ab_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33609 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33612 "hcs12x.cc"
)
{
#line 583 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t val;

		if (b==0) {
			val = cpu->getRegA() & cpu->memRead8(addr);
			} else {
			val = cpu->getRegB() & cpu->memRead8(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 33631 "hcs12x.cc"
}

static Operation *DecodeOpBit_ab_dir(CodeType const& code, uint16_t addr)
{
	return new OpBit_ab_dir(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33641 "hcs12x.cc"
OpBit_ab_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33645 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33648 "hcs12x.cc"
)
{
#line 601 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "BITA $";
			} else {
			sink << "BITB $";
		}
		sink << std::hex << opr16a;
	}
#line 33660 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33664 "hcs12x.cc"
OpBit_ab_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33668 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33671 "hcs12x.cc"
)
{
#line 610 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val;

		if (b==0) {
			val = cpu->getRegA() & cpu->memRead8(addr);
			} else {
			val = cpu->getRegB() & cpu->memRead8(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 33690 "hcs12x.cc"
}

static Operation *DecodeOpBit_ab_ext(CodeType const& code, uint16_t addr)
{
	return new OpBit_ab_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33700 "hcs12x.cc"
OpBit_ab_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33704 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33707 "hcs12x.cc"
)
{
#line 628 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "BITA ";
			} else {
			sink << "BITB ";
		}
		xb->disasm(sink);
	}
#line 33719 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33723 "hcs12x.cc"
OpBit_ab_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33727 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33730 "hcs12x.cc"
)
{
#line 637 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val;

		if (b==0) {
			val = cpu->getRegA() & cpu->memRead8(addr);
			} else {
			val = cpu->getRegB() & cpu->memRead8(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 33749 "hcs12x.cc"
}

static Operation *DecodeOpBit_ab_idx(CodeType const& code, uint16_t addr)
{
	return new OpBit_ab_idx(code, addr);
}

// BITX or BITY: bit test X/Y (Logical 'AND' X/Y with Memory
#line 65 "hcs12x.isa"
void
#line 33760 "hcs12x.cc"
OpBit_xy_imm::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33764 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33767 "hcs12x.cc"
)
{
#line 656 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "BITX #$";
			} else {
			sink << "BITY #$";
		}
		sink << std::hex << opr16i;
	}
#line 33779 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33783 "hcs12x.cc"
OpBit_xy_imm::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33787 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33790 "hcs12x.cc"
)
{
#line 665 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val;

		if (b==0) {
			val = cpu->getRegX() & opr16i;
			} else {
			val = cpu->getRegY() & opr16i;
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 33808 "hcs12x.cc"
}

static Operation *DecodeOpBit_xy_imm(CodeType const& code, uint16_t addr)
{
	return new OpBit_xy_imm(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33818 "hcs12x.cc"
OpBit_xy_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33822 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33825 "hcs12x.cc"
)
{
#line 682 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "BITA $";
			} else {
			sink << "BITB $";
		}
		sink << std::hex << opr8a;
	}
#line 33837 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33841 "hcs12x.cc"
OpBit_xy_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33845 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33848 "hcs12x.cc"
)
{
#line 691 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint16_t val;

		if (b==0) {
			val = cpu->getRegX() & cpu->memRead16(addr);
			} else {
			val = cpu->getRegY() & cpu->memRead16(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 33867 "hcs12x.cc"
}

static Operation *DecodeOpBit_xy_dir(CodeType const& code, uint16_t addr)
{
	return new OpBit_xy_dir(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33877 "hcs12x.cc"
OpBit_xy_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33881 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33884 "hcs12x.cc"
)
{
#line 709 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "BITX $";
			} else {
			sink << "BITY $";
		}
		sink << std::hex << opr16a;
	}
#line 33896 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33900 "hcs12x.cc"
OpBit_xy_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33904 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33907 "hcs12x.cc"
)
{
#line 718 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val;

		if (b==0) {
			val = cpu->getRegX() & cpu->memRead16(addr);
			} else {
			val = cpu->getRegY() & cpu->memRead16(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 33926 "hcs12x.cc"
}

static Operation *DecodeOpBit_xy_ext(CodeType const& code, uint16_t addr)
{
	return new OpBit_xy_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 33936 "hcs12x.cc"
OpBit_xy_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 33940 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 33943 "hcs12x.cc"
)
{
#line 736 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		if (b==0) {
			sink << "BITX ";
			} else {
			sink << "BITY ";
		}
		xb->disasm(sink);
	}
#line 33955 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 33959 "hcs12x.cc"
OpBit_xy_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 33963 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 33966 "hcs12x.cc"
)
{
#line 745 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val;

		if (b==0) {
			val = cpu->getRegX() & cpu->memRead16(addr);
			} else {
			val = cpu->getRegY() & cpu->memRead16(addr);
		}

		cpu->ccr->clrV();

		if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
	}
#line 33985 "hcs12x.cc"
}

static Operation *DecodeOpBit_xy_idx(CodeType const& code, uint16_t addr)
{
	return new OpBit_xy_idx(code, addr);
}

// BSET: Set bits in memory
#line 65 "hcs12x.isa"
void
#line 33996 "hcs12x.cc"
OpBset_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34000 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34003 "hcs12x.cc"
)
{
#line 764 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "BSET $" << std::hex << dd << ", $" << std::hex << mm;
	}
#line 34010 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34014 "hcs12x.cc"
OpBset_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34018 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34021 "hcs12x.cc"
)
{
#line 768 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(dd, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t ddVal = cpu->memRead8(addr);

		uint8_t val = ddVal | mm;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 34037 "hcs12x.cc"
}

static Operation *DecodeOpBset_dir(CodeType const& code, uint16_t addr)
{
	return new OpBset_dir(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34047 "hcs12x.cc"
OpBset_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34051 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34054 "hcs12x.cc"
)
{
#line 783 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "BSET $" << std::hex << opr16a << ", $" << std::hex << mm;
	}
#line 34061 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34065 "hcs12x.cc"
OpBset_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34069 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34072 "hcs12x.cc"
)
{
#line 787 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		uint8_t val = opr16aVal | mm;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 34088 "hcs12x.cc"
}

static Operation *DecodeOpBset_ext(CodeType const& code, uint16_t addr)
{
	return new OpBset_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34098 "hcs12x.cc"
OpBset_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34102 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34105 "hcs12x.cc"
)
{
#line 802 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "BSET ";
		xb->disasm(sink);
		sink << ", $" << std::hex << mm;
	}
#line 34114 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34118 "hcs12x.cc"
OpBset_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34122 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34125 "hcs12x.cc"
)
{
#line 808 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		uint8_t val = xbVal | mm;

		cpu->memWrite8(addr, val);

		cpu->ccr->clrV();
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 34142 "hcs12x.cc"
}

static Operation *DecodeOpBset_idx(CodeType const& code, uint16_t addr)
{
	return new OpBset_idx(code, addr);
}

/* ********** Shift and Rotate instructions ********************** */
// LSL: Logical Shift Left
// ASL: Arithmetic Shift Left
#line 65 "hcs12x.isa"
void
#line 34155 "hcs12x.cc"
OpLsl_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34159 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34162 "hcs12x.cc"
)
{
#line 828 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSL $" << std::hex << opr16a;
	}
#line 34169 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34173 "hcs12x.cc"
OpLsl_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34177 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34180 "hcs12x.cc"
)
{
#line 832 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		if ((val & 0x80) == 0x80) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }

		val = val << 1;
		cpu->memWrite8(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34198 "hcs12x.cc"
}

static Operation *DecodeOpLsl_ext(CodeType const& code, uint16_t addr)
{
	return new OpLsl_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34208 "hcs12x.cc"
OpLsl_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34212 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34215 "hcs12x.cc"
)
{
#line 849 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSL ";
		xb->disasm(sink);
	}
#line 34223 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34227 "hcs12x.cc"
OpLsl_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34231 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34234 "hcs12x.cc"
)
{
#line 854 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->memWrite8(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34253 "hcs12x.cc"
}

static Operation *DecodeOpLsl_idx(CodeType const& code, uint16_t addr)
{
	return new OpLsl_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34263 "hcs12x.cc"
OpLsla::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34267 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34270 "hcs12x.cc"
)
{
#line 872 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSLA";
	}
#line 34277 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34281 "hcs12x.cc"
OpLsla::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34285 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34288 "hcs12x.cc"
)
{
#line 876 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegA(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34305 "hcs12x.cc"
}

static Operation *DecodeOpLsla(CodeType const& code, uint16_t addr)
{
	return new OpLsla(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34315 "hcs12x.cc"
OpLslb::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34319 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34322 "hcs12x.cc"
)
{
#line 892 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSLB";
	}
#line 34329 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34333 "hcs12x.cc"
OpLslb::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34337 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34340 "hcs12x.cc"
)
{
#line 896 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegB(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34357 "hcs12x.cc"
}

static Operation *DecodeOpLslb(CodeType const& code, uint16_t addr)
{
	return new OpLslb(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34367 "hcs12x.cc"
OpLsld::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34371 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34374 "hcs12x.cc"
)
{
#line 912 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSLD";
	}
#line 34381 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34385 "hcs12x.cc"
OpLsld::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34389 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34392 "hcs12x.cc"
)
{
#line 916 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegD();

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegD(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34409 "hcs12x.cc"
}

static Operation *DecodeOpLsld(CodeType const& code, uint16_t addr)
{
	return new OpLsld(code, addr);
}

// LSLW: Logical Shift Left
// ASLW: Arithmetic Shift Left
#line 65 "hcs12x.isa"
void
#line 34421 "hcs12x.cc"
OpLslw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34425 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34428 "hcs12x.cc"
)
{
#line 935 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSLW $" << std::hex << opr16a;
	}
#line 34435 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34439 "hcs12x.cc"
OpLslw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34443 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34446 "hcs12x.cc"
)
{
#line 939 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }

		val = val << 1;
		cpu->memWrite16(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34464 "hcs12x.cc"
}

static Operation *DecodeOpLslw_ext(CodeType const& code, uint16_t addr)
{
	return new OpLslw_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34474 "hcs12x.cc"
OpLslw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34478 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34481 "hcs12x.cc"
)
{
#line 956 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSLW ";
		xb->disasm(sink);
	}
#line 34489 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34493 "hcs12x.cc"
OpLslw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34497 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34500 "hcs12x.cc"
)
{
#line 961 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->memWrite16(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34519 "hcs12x.cc"
}

static Operation *DecodeOpLslw_idx(CodeType const& code, uint16_t addr)
{
	return new OpLslw_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34529 "hcs12x.cc"
OpLslx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34533 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34536 "hcs12x.cc"
)
{
#line 979 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSLX";
	}
#line 34543 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34547 "hcs12x.cc"
OpLslx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34551 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34554 "hcs12x.cc"
)
{
#line 983 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegX(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34571 "hcs12x.cc"
}

static Operation *DecodeOpLslx(CodeType const& code, uint16_t addr)
{
	return new OpLslx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34581 "hcs12x.cc"
OpLsly::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34585 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34588 "hcs12x.cc"
)
{
#line 999 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSLY";
	}
#line 34595 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34599 "hcs12x.cc"
OpLsly::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34603 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34606 "hcs12x.cc"
)
{
#line 1003 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val << 1;
		cpu->setRegY(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34623 "hcs12x.cc"
}

static Operation *DecodeOpLsly(CodeType const& code, uint16_t addr)
{
	return new OpLsly(code, addr);
}

// ROL: Rotate Memory/Accumulator Left through carry
#line 65 "hcs12x.isa"
void
#line 34634 "hcs12x.cc"
OpRol_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34638 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34641 "hcs12x.cc"
)
{
#line 1020 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROL $" << std::hex << opr16a;
	}
#line 34648 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34652 "hcs12x.cc"
OpRol_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34656 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34659 "hcs12x.cc"
)
{
#line 1024 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		uint8_t carry = 0;
		if ((val & 0x80) == 0x80) { carry = 1; }
		val = (val << 1) | carry;
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34678 "hcs12x.cc"
}

static Operation *DecodeOpRol_ext(CodeType const& code, uint16_t addr)
{
	return new OpRol_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34688 "hcs12x.cc"
OpRol_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34692 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34695 "hcs12x.cc"
)
{
#line 1042 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROL ";
		xb->disasm(sink);
	}
#line 34703 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34707 "hcs12x.cc"
OpRol_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34711 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34714 "hcs12x.cc"
)
{
#line 1047 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		uint8_t carry = 0;
		if ((val & 0x80) == 0x80) { carry = 1; }
		val = (val << 1) | carry;
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34734 "hcs12x.cc"
}

static Operation *DecodeOpRol_idx(CodeType const& code, uint16_t addr)
{
	return new OpRol_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34744 "hcs12x.cc"
OpRola::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34748 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34751 "hcs12x.cc"
)
{
#line 1066 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROLA";
	}
#line 34758 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34762 "hcs12x.cc"
OpRola::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34766 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34769 "hcs12x.cc"
)
{
#line 1070 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		uint8_t carry = 0;
		if ((val & 0x80) == 0x80) { carry = 1; }
		val = (val << 1) | carry;
		cpu->setRegA(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34787 "hcs12x.cc"
}

static Operation *DecodeOpRola(CodeType const& code, uint16_t addr)
{
	return new OpRola(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34797 "hcs12x.cc"
OpRolb::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34801 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34804 "hcs12x.cc"
)
{
#line 1087 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROLB";
	}
#line 34811 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34815 "hcs12x.cc"
OpRolb::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34819 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34822 "hcs12x.cc"
)
{
#line 1091 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		uint8_t carry = 0;
		if ((val & 0x80) == 0x80) { carry = 1; }
		val = (val << 1) | carry;
		cpu->setRegB(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34840 "hcs12x.cc"
}

static Operation *DecodeOpRolb(CodeType const& code, uint16_t addr)
{
	return new OpRolb(code, addr);
}

// ROLW: Rotate word Memory/Accumulator Left through carry
#line 65 "hcs12x.isa"
void
#line 34851 "hcs12x.cc"
OpRolw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34855 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34858 "hcs12x.cc"
)
{
#line 1110 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROLw $" << std::hex << opr16a;
	}
#line 34865 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34869 "hcs12x.cc"
OpRolw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34873 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34876 "hcs12x.cc"
)
{
#line 1114 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		uint16_t carry = 0;
		if ((val & 0x8000) == 0x8000) { carry = 1; }
		val = (val << 1) | carry;
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34895 "hcs12x.cc"
}

static Operation *DecodeOpRolw_ext(CodeType const& code, uint16_t addr)
{
	return new OpRolw_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34905 "hcs12x.cc"
OpRolw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34909 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34912 "hcs12x.cc"
)
{
#line 1132 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROLW ";
		xb->disasm(sink);
	}
#line 34920 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34924 "hcs12x.cc"
OpRolw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34928 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34931 "hcs12x.cc"
)
{
#line 1137 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		uint16_t carry = 0;
		if ((val & 0x8000) == 0x8000) { carry = 1; }
		val = (val << 1) | carry;
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 34951 "hcs12x.cc"
}

static Operation *DecodeOpRolw_idx(CodeType const& code, uint16_t addr)
{
	return new OpRolw_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 34961 "hcs12x.cc"
OpRolx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 34965 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 34968 "hcs12x.cc"
)
{
#line 1156 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROLX";
	}
#line 34975 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 34979 "hcs12x.cc"
OpRolx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 34983 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 34986 "hcs12x.cc"
)
{
#line 1160 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		uint16_t carry = 0;
		if ((val & 0x8000) == 0x8000) { carry = 1; }
		val = (val << 1) | carry;
		cpu->setRegX(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35004 "hcs12x.cc"
}

static Operation *DecodeOpRolx(CodeType const& code, uint16_t addr)
{
	return new OpRolx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35014 "hcs12x.cc"
OpRoly::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35018 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35021 "hcs12x.cc"
)
{
#line 1177 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROLY";
	}
#line 35028 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35032 "hcs12x.cc"
OpRoly::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35036 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35039 "hcs12x.cc"
)
{
#line 1181 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		uint16_t carry = 0;
		if ((val & 0x8000) == 0x8000) { carry = 1; }
		val = (val << 1) | carry;
		cpu->setRegY(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35057 "hcs12x.cc"
}

static Operation *DecodeOpRoly(CodeType const& code, uint16_t addr)
{
	return new OpRoly(code, addr);
}

// LSR: Logical Shift Right
#line 65 "hcs12x.isa"
void
#line 35068 "hcs12x.cc"
OpLsr_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35072 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35075 "hcs12x.cc"
)
{
#line 1199 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSR $" << std::hex << opr16a;
	}
#line 35082 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35086 "hcs12x.cc"
OpLsr_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35090 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35093 "hcs12x.cc"
)
{
#line 1203 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		if ((val & 0x01) == 0x01) { cpu->ccr->setC();}	else  { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->memWrite8(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35111 "hcs12x.cc"
}

static Operation *DecodeOpLsr_ext(CodeType const& code, uint16_t addr)
{
	return new OpLsr_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35121 "hcs12x.cc"
OpLsr_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35125 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35128 "hcs12x.cc"
)
{
#line 1220 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSR ";
		xb->disasm(sink);
	}
#line 35136 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35140 "hcs12x.cc"
OpLsr_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35144 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35147 "hcs12x.cc"
)
{
#line 1225 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->memWrite8(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35166 "hcs12x.cc"
}

static Operation *DecodeOpLsr_idx(CodeType const& code, uint16_t addr)
{
	return new OpLsr_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35176 "hcs12x.cc"
OpLsra::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35180 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35183 "hcs12x.cc"
)
{
#line 1243 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSRA";
	}
#line 35190 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35194 "hcs12x.cc"
OpLsra::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35198 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35201 "hcs12x.cc"
)
{
#line 1247 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegA(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35218 "hcs12x.cc"
}

static Operation *DecodeOpLsra(CodeType const& code, uint16_t addr)
{
	return new OpLsra(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35228 "hcs12x.cc"
OpLsrb::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35232 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35235 "hcs12x.cc"
)
{
#line 1263 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSRB";
	}
#line 35242 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35246 "hcs12x.cc"
OpLsrb::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35250 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35253 "hcs12x.cc"
)
{
#line 1267 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegB(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35270 "hcs12x.cc"
}

static Operation *DecodeOpLsrb(CodeType const& code, uint16_t addr)
{
	return new OpLsrb(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35280 "hcs12x.cc"
OpLsrd::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35284 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35287 "hcs12x.cc"
)
{
#line 1283 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSRD";
	}
#line 35294 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35298 "hcs12x.cc"
OpLsrd::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35302 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35305 "hcs12x.cc"
)
{
#line 1287 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegD();

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();}	else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegD(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35322 "hcs12x.cc"
}

static Operation *DecodeOpLsrd(CodeType const& code, uint16_t addr)
{
	return new OpLsrd(code, addr);
}

// LSRW: Logical Shift Right word
#line 65 "hcs12x.isa"
void
#line 35333 "hcs12x.cc"
OpLsrw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35337 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35340 "hcs12x.cc"
)
{
#line 1304 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSRW $" << std::hex << opr16a;
	}
#line 35347 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35351 "hcs12x.cc"
OpLsrw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35355 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35358 "hcs12x.cc"
)
{
#line 1308 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();}	else  { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->memWrite16(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35376 "hcs12x.cc"
}

static Operation *DecodeOpLsrw_ext(CodeType const& code, uint16_t addr)
{
	return new OpLsrw_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35386 "hcs12x.cc"
OpLsrw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35390 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35393 "hcs12x.cc"
)
{
#line 1325 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSRW ";
		xb->disasm(sink);
	}
#line 35401 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35405 "hcs12x.cc"
OpLsrw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35409 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35412 "hcs12x.cc"
)
{
#line 1330 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->memWrite16(addr, val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35431 "hcs12x.cc"
}

static Operation *DecodeOpLsrw_idx(CodeType const& code, uint16_t addr)
{
	return new OpLsrw_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35441 "hcs12x.cc"
OpLsrx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35445 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35448 "hcs12x.cc"
)
{
#line 1348 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSRX";
	}
#line 35455 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35459 "hcs12x.cc"
OpLsrx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35463 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35466 "hcs12x.cc"
)
{
#line 1352 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegX(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35483 "hcs12x.cc"
}

static Operation *DecodeOpLsrx(CodeType const& code, uint16_t addr)
{
	return new OpLsrx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35493 "hcs12x.cc"
OpLsry::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35497 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35500 "hcs12x.cc"
)
{
#line 1368 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "LSRY";
	}
#line 35507 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35511 "hcs12x.cc"
OpLsry::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35515 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35518 "hcs12x.cc"
)
{
#line 1372 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

		val = val >> 1;
		cpu->setRegY(val);

		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35535 "hcs12x.cc"
}

static Operation *DecodeOpLsry(CodeType const& code, uint16_t addr)
{
	return new OpLsry(code, addr);
}

// ROR: Rotate Memory/Accumulator Right through Carry
#line 65 "hcs12x.isa"
void
#line 35546 "hcs12x.cc"
OpRor_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35550 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35553 "hcs12x.cc"
)
{
#line 1389 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROR $" << std::hex << opr16a;
	}
#line 35560 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35564 "hcs12x.cc"
OpRor_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35568 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35571 "hcs12x.cc"
)
{
#line 1393 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }
		val = (carry << 7) | (val >> 1);
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		cpu->ccr->clrN();

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35590 "hcs12x.cc"
}

static Operation *DecodeOpRor_ext(CodeType const& code, uint16_t addr)
{
	return new OpRor_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35600 "hcs12x.cc"
OpRor_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35604 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35607 "hcs12x.cc"
)
{
#line 1411 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ROR ";
		xb->disasm(sink);
	}
#line 35615 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35619 "hcs12x.cc"
OpRor_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35623 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35626 "hcs12x.cc"
)
{
#line 1416 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }
		val = (carry << 7) | (val >> 1);
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35646 "hcs12x.cc"
}

static Operation *DecodeOpRor_idx(CodeType const& code, uint16_t addr)
{
	return new OpRor_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35656 "hcs12x.cc"
OpRora::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35660 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35663 "hcs12x.cc"
)
{
#line 1435 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "RORA";
	}
#line 35670 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35674 "hcs12x.cc"
OpRora::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35678 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35681 "hcs12x.cc"
)
{
#line 1439 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }
		val = (carry << 7) | (val >> 1);
		cpu->setRegA(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35699 "hcs12x.cc"
}

static Operation *DecodeOpRora(CodeType const& code, uint16_t addr)
{
	return new OpRora(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35709 "hcs12x.cc"
OpRorb::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35713 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35716 "hcs12x.cc"
)
{
#line 1456 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "RORB";
	}
#line 35723 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35727 "hcs12x.cc"
OpRorb::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35731 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35734 "hcs12x.cc"
)
{
#line 1460 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }
		val = (carry << 7) | (val >> 1);
		cpu->setRegB(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35752 "hcs12x.cc"
}

static Operation *DecodeOpRorb(CodeType const& code, uint16_t addr)
{
	return new OpRorb(code, addr);
}

// RORW: Rotate word Memory/Accumulator Right through Carry
#line 65 "hcs12x.isa"
void
#line 35763 "hcs12x.cc"
OpRorw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35767 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35770 "hcs12x.cc"
)
{
#line 1479 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "RORW $" << std::hex << opr16a;
	}
#line 35777 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35781 "hcs12x.cc"
OpRorw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35785 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35788 "hcs12x.cc"
)
{
#line 1483 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }
		val = (carry << 15) | (val >> 1);
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35807 "hcs12x.cc"
}

static Operation *DecodeOpRorw_ext(CodeType const& code, uint16_t addr)
{
	return new OpRorw_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35817 "hcs12x.cc"
OpRorw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35821 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35824 "hcs12x.cc"
)
{
#line 1501 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "RORW ";
		xb->disasm(sink);
	}
#line 35832 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35836 "hcs12x.cc"
OpRorw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35840 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35843 "hcs12x.cc"
)
{
#line 1506 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }
		val = (carry << 15) | (val >> 1);
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35863 "hcs12x.cc"
}

static Operation *DecodeOpRorw_idx(CodeType const& code, uint16_t addr)
{
	return new OpRorw_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35873 "hcs12x.cc"
OpRorx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35877 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35880 "hcs12x.cc"
)
{
#line 1525 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "RORX";
	}
#line 35887 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35891 "hcs12x.cc"
OpRorx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35895 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35898 "hcs12x.cc"
)
{
#line 1529 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }
		val = (carry << 15) | (val >> 1);
		cpu->setRegX(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35916 "hcs12x.cc"
}

static Operation *DecodeOpRorx(CodeType const& code, uint16_t addr)
{
	return new OpRorx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 35926 "hcs12x.cc"
OpRory::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35930 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35933 "hcs12x.cc"
)
{
#line 1546 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "RORY";
	}
#line 35940 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35944 "hcs12x.cc"
OpRory::execute(
#line 60 "hcs12x.isa"
CPU *
#line 35948 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 35951 "hcs12x.cc"
)
{
#line 1550 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }
		val = (carry << 15) | (val >> 1);
		cpu->setRegY(val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 35969 "hcs12x.cc"
}

static Operation *DecodeOpRory(CodeType const& code, uint16_t addr)
{
	return new OpRory(code, addr);
}

// ASR: Arithmetic Shift Right
#line 65 "hcs12x.isa"
void
#line 35980 "hcs12x.cc"
OpAsr_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 35984 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 35987 "hcs12x.cc"
)
{
#line 1568 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ASR $" << std::hex << opr16a;
	}
#line 35994 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 35998 "hcs12x.cc"
OpAsr_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36002 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36005 "hcs12x.cc"
)
{
#line 1572 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		uint8_t msb = val & 0x80;

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 36027 "hcs12x.cc"
}

static Operation *DecodeOpAsr_ext(CodeType const& code, uint16_t addr)
{
	return new OpAsr_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 36037 "hcs12x.cc"
OpAsr_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36041 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36044 "hcs12x.cc"
)
{
#line 1593 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ASR ";
		xb->disasm(sink);
	}
#line 36052 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36056 "hcs12x.cc"
OpAsr_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36060 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36063 "hcs12x.cc"
)
{
#line 1598 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t val = cpu->memRead8(addr);

		uint8_t msb = val & 0x80;

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->memWrite8(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 36086 "hcs12x.cc"
}

static Operation *DecodeOpAsr_idx(CodeType const& code, uint16_t addr)
{
	return new OpAsr_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 36096 "hcs12x.cc"
OpAsra::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36100 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36103 "hcs12x.cc"
)
{
#line 1620 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ASRA";
	}
#line 36110 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36114 "hcs12x.cc"
OpAsra::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36118 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36121 "hcs12x.cc"
)
{
#line 1624 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegA();

		uint8_t msb = val & 0x80;

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->setRegA(val);

		if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 36142 "hcs12x.cc"
}

static Operation *DecodeOpAsra(CodeType const& code, uint16_t addr)
{
	return new OpAsra(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 36152 "hcs12x.cc"
OpAsrb::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36156 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36159 "hcs12x.cc"
)
{
#line 1644 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ASRB";
	}
#line 36166 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36170 "hcs12x.cc"
OpAsrb::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36174 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36177 "hcs12x.cc"
)
{
#line 1648 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint8_t val = cpu->getRegB();

		uint8_t msb = val & 0x80;

		uint8_t carry = 0;
		if ((val & 0x01) == 0x01) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->setRegB(val);

		if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 36198 "hcs12x.cc"
}

static Operation *DecodeOpAsrb(CodeType const& code, uint16_t addr)
{
	return new OpAsrb(code, addr);
}

// ASRW: Arithmetic Shift Right word
#line 65 "hcs12x.isa"
void
#line 36209 "hcs12x.cc"
OpAsrw_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36213 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36216 "hcs12x.cc"
)
{
#line 1669 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ASRW $" << std::hex << opr16a;
	}
#line 36223 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36227 "hcs12x.cc"
OpAsrw_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36231 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36234 "hcs12x.cc"
)
{
#line 1673 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		uint16_t msb = val & 0x8000;

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 36256 "hcs12x.cc"
}

static Operation *DecodeOpAsrw_ext(CodeType const& code, uint16_t addr)
{
	return new OpAsrw_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 36266 "hcs12x.cc"
OpAsrw_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36270 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36273 "hcs12x.cc"
)
{
#line 1694 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ASRW ";
		xb->disasm(sink);
	}
#line 36281 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36285 "hcs12x.cc"
OpAsrw_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36289 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36292 "hcs12x.cc"
)
{
#line 1699 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint16_t val = cpu->memRead16(addr);

		uint16_t msb = val & 0x8000;

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->memWrite16(addr, val);

		if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 36315 "hcs12x.cc"
}

static Operation *DecodeOpAsrw_idx(CodeType const& code, uint16_t addr)
{
	return new OpAsrw_idx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 36325 "hcs12x.cc"
OpAsrx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36329 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36332 "hcs12x.cc"
)
{
#line 1721 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ASRX";
	}
#line 36339 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36343 "hcs12x.cc"
OpAsrx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36347 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36350 "hcs12x.cc"
)
{
#line 1725 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegX();

		uint16_t msb = val & 0x8000;

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->setRegX(val);

		if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 36371 "hcs12x.cc"
}

static Operation *DecodeOpAsrx(CodeType const& code, uint16_t addr)
{
	return new OpAsrx(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 36381 "hcs12x.cc"
OpAsry::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36385 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36388 "hcs12x.cc"
)
{
#line 1745 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "ASRY";
	}
#line 36395 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36399 "hcs12x.cc"
OpAsry::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36403 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36406 "hcs12x.cc"
)
{
#line 1749 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		uint16_t val = cpu->getRegY();

		uint16_t msb = val & 0x8000;

		uint16_t carry = 0;
		if ((val & 0x0001) == 0x0001) { carry = 1; }

		val = (val >> 1) | msb;
		cpu->setRegY(val);

		if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
		if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		if (cpu->ccr->getN() ^ cpu->ccr->getC()) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	}
#line 36427 "hcs12x.cc"
}

static Operation *DecodeOpAsry(CodeType const& code, uint16_t addr)
{
	return new OpAsry(code, addr);
}

// BTAS: Bit(s) Test and Set in Memory
#line 65 "hcs12x.isa"
void
#line 36438 "hcs12x.cc"
OpBtas_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36442 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36445 "hcs12x.cc"
)
{
#line 1771 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "BTAS $" << std::hex << opr8a << ", $" << std::hex << msk8;
	}
#line 36452 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36456 "hcs12x.cc"
OpBtas_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36460 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36463 "hcs12x.cc"
)
{
#line 1775 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		/*
		If (M) & (Mask) = 0, then set Z, else clear Z
		(M) | (Mask) => M

		N: Set if MSB of test is set; cleared otherwise
		Z: Set if test is $00; cleared otherwise
		V: 0; cleared
		*/
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		uint8_t test = opr8aVal & msk8;
		if (test == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((test & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
		cpu->ccr->clrV();

		cpu->memWrite8(addr, opr8aVal | msk8);
	}
#line 36486 "hcs12x.cc"
}

static Operation *DecodeOpBtas_dir(CodeType const& code, uint16_t addr)
{
	return new OpBtas_dir(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 36496 "hcs12x.cc"
OpBtas_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36500 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36503 "hcs12x.cc"
)
{
#line 1797 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "BTAS $" << std::hex << opr16a << ", $" << std::hex << msk8;
	}
#line 36510 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36514 "hcs12x.cc"
OpBtas_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36518 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36521 "hcs12x.cc"
)
{
#line 1801 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		uint8_t test = opr16aVal & msk8;
		if (test == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((test & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
		cpu->ccr->clrV();

		cpu->memWrite8(addr, opr16aVal | msk8);
	}
#line 36537 "hcs12x.cc"
}

static Operation *DecodeOpBtas_ext(CodeType const& code, uint16_t addr)
{
	return new OpBtas_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 36547 "hcs12x.cc"
OpBtas_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36551 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36554 "hcs12x.cc"
)
{
#line 1816 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{
		sink << "BTAS ";
		xb->disasm(sink);
		sink << ", $" << std::hex << msk8;
	}
#line 36563 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36567 "hcs12x.cc"
OpBtas_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36571 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36574 "hcs12x.cc"
)
{
#line 1822 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./bit.isa"
	{

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		uint8_t test = xbVal & msk8;
		if (test == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
		if ((test & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
		cpu->ccr->clrV();

		cpu->memWrite8(addr, xbVal | msk8);
	}
#line 36590 "hcs12x.cc"
}

static Operation *DecodeOpBtas_idx(CodeType const& code, uint16_t addr)
{
	return new OpBtas_idx(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// EMUL: 16 by 16 Bit Multiply (unsigned) (D) x (Y) => Y:D
#line 65 "hcs12x.isa"
void
#line 36634 "hcs12x.cc"
OpEmul::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36638 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36641 "hcs12x.cc"
)
{
#line 39 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		sink << "EMUL";
	}
#line 36648 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36652 "hcs12x.cc"
OpEmul::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36656 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36659 "hcs12x.cc"
)
{
#line 43 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		uint32_t result = (uint32_t) cpu->getRegD() * cpu->getRegY();

		cpu->setRegY(result >> 16);
		cpu->setRegD((uint16_t) result);

		if ((result & 0x00008000) == 0x00008000) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		if ((result & 0x80000000) == 0x80000000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 36673 "hcs12x.cc"
}

static Operation *DecodeOpEmul(CodeType const& code, uint16_t addr)
{
	return new OpEmul(code, addr);
}

// EMULS: 16 by 16 Bit Multiply (signed) (D) x (Y) => Y:D
#line 65 "hcs12x.isa"
void
#line 36684 "hcs12x.cc"
OpEmuls::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36688 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36691 "hcs12x.cc"
)
{
#line 57 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		sink << "EMULS";
	}
#line 36698 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36702 "hcs12x.cc"
OpEmuls::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36706 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36709 "hcs12x.cc"
)
{
#line 61 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		uint32_t result = (uint32_t) cpu->getRegD() * cpu->getRegY();

		cpu->setRegY((uint16_t) (result >> 16));
		cpu->setRegD((uint16_t) result);

		/*
		* C: Set if bit 15 of the result is set; cleared otherwise
		*/
		if ((result & 0x8000) == 0x8000) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }

		/*
		* Z: Set if result is $00000000; cleared otherwise
		*/
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

		/*
		* N: Set if the MSB of the result is set; cleared otherwise
		*/
		if ((result & 0x80000000) == 0x80000000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }


	}
#line 36736 "hcs12x.cc"
}

static Operation *DecodeOpEmuls(CodeType const& code, uint16_t addr)
{
	return new OpEmuls(code, addr);
}

// MUL: 8 by 8 Bit Multiply (unsigned) (A) x (B) => A:B
#line 65 "hcs12x.isa"
void
#line 36747 "hcs12x.cc"
OpMul::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36751 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36754 "hcs12x.cc"
)
{
#line 88 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		sink << "MUL";
	}
#line 36761 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36765 "hcs12x.cc"
OpMul::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36769 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36772 "hcs12x.cc"
)
{
#line 92 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		uint16_t result = cpu->getRegA() * cpu->getRegB();

		cpu->setRegD(result);

		if ((result & 0x0080) == 0x0080) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	}
#line 36783 "hcs12x.cc"
}

static Operation *DecodeOpMul(CodeType const& code, uint16_t addr)
{
	return new OpMul(code, addr);
}

// EDIV: 32 by 16 bit to 16 bit divide (unsigned) (Y:D) div (X) => Y remainder => D
#line 65 "hcs12x.isa"
void
#line 36794 "hcs12x.cc"
OpEdiv::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36798 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36801 "hcs12x.cc"
)
{
#line 103 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		sink << "EDIV";
	}
#line 36808 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36812 "hcs12x.cc"
OpEdiv::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36816 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36819 "hcs12x.cc"
)
{
#line 107 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		// TODO
		/*
		* source_url: http://www.embeddedrelated.com/groups/68hc12/show/3775.php
		*
		* U16 X, Y, Z;
		* X = (U16)(((U32)Y * 1000) / (U16)Z);
		*
		* with an EMUL and an EDIV is that if the 32/16 bit EDIV division overflows, then the
		* HC12 does not generate a result at all (it just sets the V flag).
		* Therefore using a simple EDIV does not generate the same result
		* for all possible Y and Z's as calculating it with longs.
		*/
		uint32_t dividend = ((uint32_t) cpu->getRegY() << 16) | (0x00FF & cpu->getRegD());
		uint16_t divisor = cpu->getRegX();
		uint32_t quotion = cpu->getRegY();
		uint16_t remind = cpu->getRegD();

		if (divisor == 0) {
			// TODO: throw an exception "division by 0"
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();
			quotion = dividend / divisor;
			remind = dividend % divisor;

			if (quotion > 0xFFFF) {
				cpu->ccr->setV();
				} else {
				cpu->ccr->clrV();

				cpu->setRegY((uint16_t) quotion);
				cpu->setRegD(remind);

				if (quotion == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
				if ((cpu->getRegY() & 0x8000) == 0x8000 ) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
			}
		}

	}
#line 36863 "hcs12x.cc"
}

static Operation *DecodeOpEdiv(CodeType const& code, uint16_t addr)
{
	return new OpEdiv(code, addr);
}

// EDIVS: 32 by 16 bit to 16 bit divide (signed)  (Y:D) div (X) => Y remainder => D
#line 65 "hcs12x.isa"
void
#line 36874 "hcs12x.cc"
OpEdivs::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36878 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36881 "hcs12x.cc"
)
{
#line 151 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		sink << "EDIVS";
	}
#line 36888 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36892 "hcs12x.cc"
OpEdivs::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36896 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36899 "hcs12x.cc"
)
{
#line 155 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{

		uint32_t dividend = ((uint32_t) cpu->getRegY() << 16) | (0x00FF & cpu->getRegD());
		uint16_t divisor = cpu->getRegX();
		uint32_t quotion = cpu->getRegY();
		uint16_t remind = cpu->getRegD();

		if (divisor == 0) {
			// TODO: throw an exception "division by 0"
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();

			quotion = dividend / divisor;
			remind = dividend % divisor;

			if (quotion > 0x7FFF) {
			/* NOTA:
				* For EDIVS, there is a mistake in specification about setting V.
				*/
				cpu->ccr->setV();
				} else {
				cpu->ccr->clrV();

				cpu->setRegY((uint16_t) quotion); // cpu->setRegY((uint16_t) quotion | ((quotion >> 16) & 0x8000));
				cpu->setRegD(remind);

				if (quotion == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }

				if (cpu->getRegY() & 0x8000 == 0x8000 ) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
			}
		}
	}
#line 36936 "hcs12x.cc"
}

static Operation *DecodeOpEdivs(CodeType const& code, uint16_t addr)
{
	return new OpEdivs(code, addr);
}

// FDIV: 16 by 16 fractional divide
#line 65 "hcs12x.isa"
void
#line 36947 "hcs12x.cc"
OpFdiv::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 36951 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 36954 "hcs12x.cc"
)
{
#line 192 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		sink << "FDIV";
	}
#line 36961 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 36965 "hcs12x.cc"
OpFdiv::execute(
#line 60 "hcs12x.isa"
CPU *
#line 36969 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 36972 "hcs12x.cc"
)
{
#line 196 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		/* FDIV is equivalent to multiplying the numerator by 2^16 and then performing 32 by 16-bit integer division. */

		uint32_t dividend = (uint32_t) cpu->getRegD() << 16;
		uint16_t divisor = cpu->getRegX();
		uint16_t quotion = 0xFFFF;
		uint16_t remind = dividend;

		if (divisor == 0) {
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();
			if (dividend >= divisor) {
				cpu->ccr->setV();
				} else {
				cpu->ccr->clrV();
				quotion = dividend / divisor;
				remind = dividend % divisor;
			}
		}

		cpu->setRegX(quotion);
		cpu->setRegD(remind);
		if (quotion == 0) { cpu->ccr->setZ(); }  else { cpu->ccr->clrZ(); }
	}
#line 37001 "hcs12x.cc"
}

static Operation *DecodeOpFdiv(CodeType const& code, uint16_t addr)
{
	return new OpFdiv(code, addr);
}

// IDIV: 16 by 16 integer divide (unsigned)
#line 65 "hcs12x.isa"
void
#line 37012 "hcs12x.cc"
OpIdiv::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37016 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37019 "hcs12x.cc"
)
{
#line 225 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		sink << "IDIV";
	}
#line 37026 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37030 "hcs12x.cc"
OpIdiv::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37034 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37037 "hcs12x.cc"
)
{
#line 229 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		/* In the case of division by zero, C is set, the quotient is set to $FFFF,
		and the remainder is indeterminate. */

		uint16_t dividend = cpu->getRegD();
		uint16_t divisor = cpu->getRegX();
		uint16_t quotion = 0xFFFF;
		uint16_t remind = dividend;

		cpu->ccr->clrV();
		if (divisor == 0) {
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();
			quotion = dividend / divisor;
			remind = dividend % divisor;
		}

		cpu->setRegX(quotion);
		cpu->setRegD(remind);
		if (quotion == 0) { cpu->ccr->setZ(); }  else { cpu->ccr->clrZ(); }
	}
#line 37063 "hcs12x.cc"
}

static Operation *DecodeOpIdiv(CodeType const& code, uint16_t addr)
{
	return new OpIdiv(code, addr);
}

// IDIVS: 16 by 16 integer divide (signed)
#line 65 "hcs12x.isa"
void
#line 37074 "hcs12x.cc"
OpIdivs::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37078 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37081 "hcs12x.cc"
)
{
#line 255 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		sink << "IDIVS";
	}
#line 37088 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37092 "hcs12x.cc"
OpIdivs::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37096 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37099 "hcs12x.cc"
)
{
#line 259 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		/* In the case of division by zero, C is set, the quotient is set to $FFFF,
		and the remainder is indeterminate. */

		uint16_t dividend = cpu->getRegD();
		uint16_t divisor = cpu->getRegX();
		uint16_t quotion = 0xFFFF;
		uint16_t remind = dividend;

		cpu->ccr->clrV();
		if (divisor == 0) {
			cpu->ccr->setC();
			} else {
			cpu->ccr->clrC();
			quotion = dividend / divisor;
			remind = dividend % divisor;
		}

		cpu->setRegX(quotion);
		cpu->setRegD(remind);
		/*
		* V: Set if the result was > $7FFF or < $8000; cleared otherwise
		* V: Set for numerator $8000 (-32768) and denominator $FFFF (-1) result is (+32768)
		* Undefined after division by zero
		*/
		if ((dividend == 0x8000) && (divisor == 0xFFFF)) { cpu->ccr->setV(); } else { cpu->ccr->clrV();}
		if (quotion == 0) { cpu->ccr->setZ(); }  else { cpu->ccr->clrZ(); }
		if ((quotion & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
	}
#line 37132 "hcs12x.cc"
}

static Operation *DecodeOpIdivs(CodeType const& code, uint16_t addr)
{
	return new OpIdivs(code, addr);
}

/* ********* Multiply and Accumulate instruction ********* */
// EMACS: Multiply an Accumulate Instruction
#line 65 "hcs12x.isa"
void
#line 37144 "hcs12x.cc"
OpEmacs::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37148 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37151 "hcs12x.cc"
)
{
#line 295 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		sink << "EMACS $" << std::hex << opr16a;
	}
#line 37158 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37162 "hcs12x.cc"
OpEmacs::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37166 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37169 "hcs12x.cc"
)
{
#line 299 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./multiplication_division.isa"
	{
		/* operation: (M(X) : M(X+1)) × (M(Y) : M(Y+1)) + (M ~ M+3) ⇒ M ~ M+3 */

		uint16_t xOpr, yOpr;
		uint32_t accOpr, result, inter;


		xOpr = cpu->memRead16(cpu->mmc->getPhysicalAddress(cpu->getRegX(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
		yOpr = cpu->memRead16(cpu->mmc->getPhysicalAddress(cpu->getRegY(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
		accOpr = cpu->memRead16(cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
		accOpr = (accOpr << 16) | cpu->memRead16(cpu->mmc->getPhysicalAddress(opr16a+2, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));

		inter = (uint32_t) xOpr * yOpr;
		result =  inter + accOpr;

		cpu->memWrite16(cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), (uint16_t) (accOpr >> 16));
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(opr16a+2, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), (uint16_t) accOpr);

		// N: Set if MSB of result is set; cleared otherwise
		if (result & 0x80000000 == 0x80000000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }

		// Z: Set if result is $00000000; cleared otherwise
		if (result == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
		/*
		* I: Intermediate result
		* R: Result
		* M: 32 bit accumulator in memory (second operand in the addition)
		* */

		/* V: M31 • I31 • !R31 + !M31 • !I31 • R31
		* Set if result > $7FFFFFFF (+ overflow) or < $80000000 (– underflow)
		* Indicates two’s complement overflow
		*/
		// if (result > 0x7FFFFFFF) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
		if (((accOpr & 0x80000000) & (inter & 0x80000000) & ~(result & 0x80000000) | ~(accOpr & 0x80000000) & ~(inter & 0x80000000) & (result & 0x80000000)) >> 31) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

		/* C: M15 • I15 + I15 • !R15 + !R15 • M15
		* Set if there was a carry from bit 15 of the result; cleared otherwise
		* Indicates a carry from low word to high word of the result occurred
		*/
		if (((accOpr & 0x00008000) & (inter & 0x00008000) | (inter & 0x00008000) & ~(result & 0x00008000) | ~(result & 0x00008000) & (accOpr & 0x00008000)) >> 15) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

	}
#line 37216 "hcs12x.cc"
}

static Operation *DecodeOpEmacs(CodeType const& code, uint16_t addr)
{
	return new OpEmacs(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// TODO: Very Important
// relied to instruction Queue
// Do not forgot to perform three program word fetches to refill the queue after a branch or subroutine call
/* ********* Short Branch Instructions ******** */
#line 65 "hcs12x.isa"
void
#line 37263 "hcs12x.cc"
OpSbr::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37267 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37270 "hcs12x.cc"
)
{
#line 44 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		switch (sel) {
			case 0x0: sink << "BRA ";break;
			case 0x1: sink << "BRN ";break;
			case 0x2: sink << "BHI ";break;
			case 0x3: sink << "BLS ";break;
			case 0x4: sink << "BCC "; /* same opcode for BHS */ break;
			case 0x5: sink << "BCS "; /* same opcode for BLO */ break;
			case 0x6: sink << "BNE ";break;
			case 0x7: sink << "BEQ ";break;
			case 0x8: sink << "BVC ";break;
			case 0x9: sink << "BVS ";break;
			case 0xA: sink << "BPL ";break;
			case 0xB: sink << "BMI ";break;
			case 0xC: sink << "BGE ";break;
			case 0xD: sink << "BLT ";break;
			case 0xE: sink << "BGT ";break;
			case 0xF: sink << "BLE ";break;
		}
		sink << rel8;
	}
#line 37296 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37300 "hcs12x.cc"
OpSbr::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37304 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37307 "hcs12x.cc"
)
{
#line 67 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		bool branch = false;

		switch (sel) {
			case 0x0: // BRA: branch always
			branch = true;
			break;
			case 0x1: // BRN: branch never
			// Nothing to do
			break;
			case 0x2: // BHI: branch if higher (C+Z=0)
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 0) branch = true;
			break;
			case 0x3: // BLS: branch if lower or same
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 1) branch = true;
			break;
			case 0x4: // BCC: branch if carel8y clear or BHS: branch if higher or same
			if (cpu->ccr->getC() == 0) branch = true;
			break;
			case 0x5: // BCS: branch if carel8y set or BLO: branch if lower
			if (cpu->ccr->getC() == 1) branch = true;
			break;
			case 0x6: // BNE: branch if not equal
			if (cpu->ccr->getZ() == 0) branch = true;
			break;
			case 0x7: // BEQ: branch if equal
			if (cpu->ccr->getZ() == 1) branch = true;
			break;
			case 0x8: // BVC: branch if overflow clear
			if (cpu->ccr->getV() == 0) branch = true;
			break;
			case 0x9: // BVS: branch if overflow set
			if (cpu->ccr->getV() == 1) branch = true;
			break;
			case 0xA: // BPL: branch if plus
			if (cpu->ccr->getN() == 0) branch = true;
			break;
			case 0xB: // BMI: branch if minus
			if (cpu->ccr->getN() == 1) branch = true;
			break;
			case 0xC: // BGE: branch if greater than or equal
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 0) branch = true;
			break;
			case 0xD: // BLT: branch if less than
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 1) branch = true;
			break;
			case 0xE: { // BGT: branch if greater than
				if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 0) branch = true;
			}
			break;
			case 0xF: // BLE: branch if less than or equal
			if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 1) branch = true;
			break;
		}

		if (branch) {
			cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);

			// TODO: Refill the instruction queue with three program words from the new address
		}
	}
#line 37372 "hcs12x.cc"
}

static Operation *DecodeOpSbr(CodeType const& code, uint16_t addr)
{
	return new OpSbr(code, addr);
}

/* ******** Long Branch Instructions ******* */
#line 65 "hcs12x.isa"
void
#line 37383 "hcs12x.cc"
OpLbr::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37387 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37390 "hcs12x.cc"
)
{
#line 133 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		switch (sel) {
			case 0x0: sink << "LBRA ";break;
			case 0x1: sink << "LBRN ";break;
			case 0x2: sink << "LBHI ";break;
			case 0x3: sink << "LBLS ";break;
			case 0x4: sink << "LBCC "; /* same opcode for LBHS */ break;
			case 0x5: sink << "LBCS "; /* same opcode for LBLO */ break;
			case 0x6: sink << "LBNE ";break;
			case 0x7: sink << "LBEQ ";break;
			case 0x8: sink << "LBVC ";break;
			case 0x9: sink << "LBVS ";break;
			case 0xA: sink << "LBPL ";break;
			case 0xB: sink << "LBMI ";break;
			case 0xC: sink << "LBGE ";break;
			case 0xD: sink << "LBLT ";break;
			case 0xE: sink << "LBGT ";break;
			case 0xF: sink << "LBLE ";break;
		}
		sink << rel16;
	}
#line 37416 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37420 "hcs12x.cc"
OpLbr::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37424 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37427 "hcs12x.cc"
)
{
#line 156 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		bool branch = false;

		switch (sel) {
			case 0x0: // LBRA: branch always
			branch = true;
			break;
			case 0x1: // LBRN: branch never
			// Nothing to do
			break;
			case 0x2: // LBHI: branch if higher (C+Z=0)
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 0) branch = true;
			break;
			case 0x3: // LBLS: branch if lower or same
			if ((cpu->ccr->getC() | cpu->ccr->getZ()) == 1) branch = true;
			break;
			case 0x4: // LBCC: branch if carel8y clear or LBHS: branch if higher or same
			if (cpu->ccr->getC() == 0) branch = true;
			break;
			case 0x5: // LBCS: branch if carel8y set or LBLO: branch if lower
			if (cpu->ccr->getC() == 1) branch = true;
			break;
			case 0x6: // LBNE: branch if not equal
			if (cpu->ccr->getZ() == 0) branch = true;
			break;
			case 0x7: // LBEQ: branch if equal
			if (cpu->ccr->getZ() == 1) branch = true;
			break;
			case 0x8: // LBVC: branch if overflow clear
			if (cpu->ccr->getV() == 0) branch = true;
			break;
			case 0x9: // LBVS: branch if overflow set
			if (cpu->ccr->getV() == 1) branch = true;
			break;
			case 0xA: // LBPL: branch if plus
			if (cpu->ccr->getN() == 0) branch = true;
			break;
			case 0xB: // LBMI: branch if minus
			if (cpu->ccr->getN() == 1) branch = true;
			break;
			case 0xC: // LBGE: branch if greater than or equal
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 0) branch = true;
			break;
			case 0xD: // LBLT: branch if less than
			if ((cpu->ccr->getN() ^ cpu->ccr->getV()) == 1) branch = true;
			break;
			case 0xE: // LBGT: branch if greater than
			if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 0) branch = true;
			break;
			case 0xF: // LBLE: branch if less than or equal
			if ((cpu->ccr->getZ() | (cpu->ccr->getN() ^ cpu->ccr->getV())) == 1) branch = true;
			break;
		}

		if (branch) {
			cpu->setRegPC((int16_t) cpu->getRegPC() + rel16);

			// TODO: Refill the instruction queue with three program words from the new address
		}
	}
#line 37491 "hcs12x.cc"
}

static Operation *DecodeOpLbr(CodeType const& code, uint16_t addr)
{
	return new OpLbr(code, addr);
}

/* ******** Bit Condition Branch instructions *********** */
// if (b==1) BRCLR_instruction else BRSET_instruction;
#line 65 "hcs12x.isa"
void
#line 37503 "hcs12x.cc"
OpBr_clr_set_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37507 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37510 "hcs12x.cc"
)
{
#line 223 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		if (b==1) {
			sink << "BRCLR $";
			} else {
			sink << "BRSET $";
		}

		sink << std::hex << opr8a << ", $" << std::hex << msk8 << ", " << rel8;
	}
#line 37523 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37527 "hcs12x.cc"
OpBr_clr_set_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37531 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37534 "hcs12x.cc"
)
{
#line 233 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		uint8_t opr8aVal = cpu->memRead8(addr);

		if (b==0) {
			opr8aVal = ~opr8aVal;
		}

		if ((opr8aVal & msk8) == 0) {
			cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);

			// TODO: Refill the instruction queue with three program words from the new address
		}
	}
#line 37552 "hcs12x.cc"
}

static Operation *DecodeOpBr_clr_set_dir(CodeType const& code, uint16_t addr)
{
	return new OpBr_clr_set_dir(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 37562 "hcs12x.cc"
OpBr_clr_set_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37566 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37569 "hcs12x.cc"
)
{
#line 250 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		if (b==1) {
			sink << "BRCLR $";
			} else {
			sink << "BRSET $";
		}

		sink << std::hex << opr16a << ", $" << std::hex << msk8 << ", " << rel8;
	}
#line 37582 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37586 "hcs12x.cc"
OpBr_clr_set_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37590 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37593 "hcs12x.cc"
)
{
#line 260 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t opr16aVal = cpu->memRead8(addr);

		if (b==0) {
			opr16aVal = ~opr16aVal;
		}

		if ((opr16aVal & msk8) == 0) {
			cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);

			// TODO: Refill the instruction queue with three program words from the new address
		}
	}
#line 37611 "hcs12x.cc"
}

static Operation *DecodeOpBr_clr_set_ext(CodeType const& code, uint16_t addr)
{
	return new OpBr_clr_set_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 37621 "hcs12x.cc"
OpBr_clr_set_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37625 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37628 "hcs12x.cc"
)
{
#line 277 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		if (b==1) {
			sink << "BRCLR ";
			} else {
			sink << "BRSET ";
		}

		xb->disasm(sink);
		sink << ", $" << std::hex << msk8 << ", " << rel8;
	}
#line 37642 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37646 "hcs12x.cc"
OpBr_clr_set_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37650 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37653 "hcs12x.cc"
)
{
#line 288 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		uint8_t xbVal = cpu->memRead8(addr);

		if (b==0) {
			xbVal = ~xbVal;
		}

		if ((xbVal & msk8) == 0) {
			cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);

			// TODO: Refill the instruction queue with three program words from the new address
		}
	}
#line 37671 "hcs12x.cc"
}

static Operation *DecodeOpBr_clr_set_idx(CodeType const& code, uint16_t addr)
{
	return new OpBr_clr_set_idx(code, addr);
}

/* ********** Jump and subroutine instructions ******** */
// BSR: Branch to subroutine
#line 65 "hcs12x.isa"
void
#line 37683 "hcs12x.cc"
OpBsr::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37687 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37690 "hcs12x.cc"
)
{
#line 308 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "BSR " << rel8;
	}
#line 37697 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37701 "hcs12x.cc"
OpBsr::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37705 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37708 "hcs12x.cc"
)
{
#line 312 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* Subroutine address fi PC
		*/
		physical_address_t addr;

		cpu->setRegSP(cpu->getRegSP()-2);

		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));

		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));

		cpu->setRegPC((int16_t) cpu->getRegPC() + rel8);

		// TODO: Refill the instruction queue with three program words from the new address
	}
#line 37732 "hcs12x.cc"
}

static Operation *DecodeOpBsr(CodeType const& code, uint16_t addr)
{
	return new OpBsr(code, addr);
}

// CALL: Call subroutine in Expanded Memory
#line 65 "hcs12x.isa"
void
#line 37743 "hcs12x.cc"
OpCall_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37747 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37750 "hcs12x.cc"
)
{
#line 336 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "CALL $" << std::hex << opr16a << ", $" << std::hex << page;
	}
#line 37757 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37761 "hcs12x.cc"
OpCall_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37765 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37768 "hcs12x.cc"
)
{
#line 340 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* (SP)-1 => SP
		* (PPAGE) => M[SP]
		* page => PPAGE
		* Subroutine address => PC
		* TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
		*/
		physical_address_t addr;

		cpu->setRegSP(cpu->getRegSP()-2);

		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));

		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));

		cpu->setRegSP(cpu->getRegSP()-1);

		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, cpu->mmc->getPpage());

		cpu->mmc->setPpage(page);
		cpu->setRegPC(opr16a);

		// TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
	}
#line 37802 "hcs12x.cc"
}

static Operation *DecodeOpCall_ext(CodeType const& code, uint16_t addr)
{
	return new OpCall_ext(code, addr);
}

// I have to decode indexed-indirect addressing here,
// because in the case of indexed-indirect the value of PPAGE is stored in memory after the subroutine address
// XB decoder return only one address
#line 65 "hcs12x.isa"
void
#line 37815 "hcs12x.cc"
OpCall_16offset_idx_ind::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37819 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37822 "hcs12x.cc"
)
{
#line 377 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		sink << "CALL ";
		sink << "[" << std::dec << n16 << "," << CPU::xb_getAddrRegLabel(rr) << "]";
	}
#line 37831 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37835 "hcs12x.cc"
OpCall_16offset_idx_ind::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37839 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37842 "hcs12x.cc"
)
{
#line 383 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* (SP)-1 => SP
		* (PPAGE) => M[SP]
		* page => PPAGE
		* Subroutine address => PC
		* TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
		*/

		physical_address_t addr;

		cpu->setRegSP(cpu->getRegSP()-2);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));

		cpu->setRegSP(cpu->getRegSP()-1);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, cpu->mmc->getPpage());

		physical_address_t idxAddr = cpu->mmc->getPhysicalAddress(cpu->xb_getAddrRegValue(rr) + n16, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		address_t subAddr = cpu->memRead16(idxAddr);
		uint8_t   ppageVal = cpu->memRead16(idxAddr+2);

		cpu->mmc->setPpage(ppageVal);
		cpu->setRegPC(subAddr);

		// TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
	}
#line 37879 "hcs12x.cc"
}

static Operation *DecodeOpCall_16offset_idx_ind(CodeType const& code, uint16_t addr)
{
	return new OpCall_16offset_idx_ind(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 37889 "hcs12x.cc"
OpCall_accD_offset_idx_ind::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37893 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37896 "hcs12x.cc"
)
{
#line 419 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{

		sink << "CALL ";
		sink << "[D," << CPU::xb_getAddrRegLabel(rr) << "]";
	}
#line 37905 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37909 "hcs12x.cc"
OpCall_accD_offset_idx_ind::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37913 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37916 "hcs12x.cc"
)
{
#line 425 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* (SP)-1 => SP
		* (PPAGE) => M[SP]
		* page => PPAGE
		* Subroutine address => PC
		* TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
		*/

		physical_address_t addr;

		cpu->setRegSP(cpu->getRegSP()-2);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));

		cpu->setRegSP(cpu->getRegSP()-1);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, cpu->mmc->getPpage());

		physical_address_t idxAddr = cpu->mmc->getPhysicalAddress(cpu->getRegD() + cpu->xb_getAddrRegValue(rr), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		address_t subAddr = cpu->memRead16(idxAddr);
		uint8_t   ppageVal = cpu->memRead16(idxAddr+2);

		cpu->mmc->setPpage(ppageVal);
		cpu->setRegPC(subAddr);

		// TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
	}
#line 37953 "hcs12x.cc"
}

static Operation *DecodeOpCall_accD_offset_idx_ind(CodeType const& code, uint16_t addr)
{
	return new OpCall_accD_offset_idx_ind(code, addr);
}

// JMP: JUMP
#line 65 "hcs12x.isa"
void
#line 37964 "hcs12x.cc"
OpJmp_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 37968 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 37971 "hcs12x.cc"
)
{
#line 498 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "JMP $" << std::hex << opr16a;
	}
#line 37978 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 37982 "hcs12x.cc"
OpJmp_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 37986 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 37989 "hcs12x.cc"
)
{
#line 502 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		cpu->setRegPC(opr16a);

		// TODO: Refill the instruction queue with three program words from the new address
	}
#line 37998 "hcs12x.cc"
}

static Operation *DecodeOpJmp_ext(CodeType const& code, uint16_t addr)
{
	return new OpJmp_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 38008 "hcs12x.cc"
OpJmp_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38012 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38015 "hcs12x.cc"
)
{
#line 510 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "JMP ";
		xb->disasm(sink);
	}
#line 38023 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38027 "hcs12x.cc"
OpJmp_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38031 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38034 "hcs12x.cc"
)
{
#line 515 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		cpu->setRegPC(xb->getEAddr(cpu));

		// TODO: Refill the instruction queue with three program words from the new address
	}
#line 38043 "hcs12x.cc"
}

static Operation *DecodeOpJmp_idx(CodeType const& code, uint16_t addr)
{
	return new OpJmp_idx(code, addr);
}

// JSR: Jump to subroutine
#line 65 "hcs12x.isa"
void
#line 38054 "hcs12x.cc"
OpJsr_dir::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38058 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38061 "hcs12x.cc"
)
{
#line 524 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "JSR $" << std::hex << opr8a;
	}
#line 38068 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38072 "hcs12x.cc"
OpJsr_dir::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38076 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38079 "hcs12x.cc"
)
{
#line 528 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (SP)-2 => SP
		* RTNh:RTNl => M[SP]:M[SP+1]
		* subroutine address => PC
		*/
		physical_address_t addr;

		cpu->setRegSP(cpu->getRegSP()-2);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));

		addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
		cpu->setRegPC((address_t) addr);

		// TODO: Refill the instruction queue with three program words from the new address
	}
#line 38102 "hcs12x.cc"
}

static Operation *DecodeOpJsr_dir(CodeType const& code, uint16_t addr)
{
	return new OpJsr_dir(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 38112 "hcs12x.cc"
OpJsr_ext::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38116 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38119 "hcs12x.cc"
)
{
#line 550 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "JSR $" << std::hex << opr16a;
	}
#line 38126 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38130 "hcs12x.cc"
OpJsr_ext::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38134 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38137 "hcs12x.cc"
)
{
#line 554 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		physical_address_t addr;

		cpu->setRegSP(cpu->getRegSP()-2);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));

		cpu->setRegPC(opr16a);

		// TODO: Refill the instruction queue with three program words from the new address
	}
#line 38154 "hcs12x.cc"
}

static Operation *DecodeOpJsr_ext(CodeType const& code, uint16_t addr)
{
	return new OpJsr_ext(code, addr);
}

#line 65 "hcs12x.isa"
void
#line 38164 "hcs12x.cc"
OpJsr_idx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38168 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38171 "hcs12x.cc"
)
{
#line 570 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "JSR ";
		xb->disasm(sink);
	}
#line 38179 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38183 "hcs12x.cc"
OpJsr_idx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38187 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38190 "hcs12x.cc"
)
{
#line 575 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		physical_address_t addr;

		cpu->setRegSP(cpu->getRegSP()-2);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() >> 8));
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->memWrite8(addr, (uint8_t) (cpu->getRegPC() & 0x00FF));

		cpu->setRegPC(xb->getEAddr(cpu));

		// TODO: Refill the instruction queue with three program words from the new address
	}
#line 38207 "hcs12x.cc"
}

static Operation *DecodeOpJsr_idx(CodeType const& code, uint16_t addr)
{
	return new OpJsr_idx(code, addr);
}

// RTC: Return from call
#line 65 "hcs12x.isa"
void
#line 38218 "hcs12x.cc"
OpRtc::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38222 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38225 "hcs12x.cc"
)
{
#line 592 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "RTC";
	}
#line 38232 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38236 "hcs12x.cc"
OpRtc::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38240 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38243 "hcs12x.cc"
)
{
#line 596 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		* (M[SP]) => PPage
		* (SP)+1 => SP
		* (M[SP]):(M[SP+1]) => PCh:PCl
		* (SP)+2 => SP
		* TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
		*/

		uint8_t hByte, lByte;
		physical_address_t addr;

		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		cpu->mmc->setPpage(cpu->memRead8(addr));
		cpu->setRegSP(cpu->getRegSP() + 1);

		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		hByte = cpu->memRead8(addr);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		lByte = cpu->memRead8(addr);
		cpu->setRegPC(((uint16_t) hByte << 8) | (0x00FF & lByte));

		cpu->setRegSP(cpu->getRegSP() + 2);

		// TODO: Refill the instruction queue with three program words from the new address (PPAGE:PC)
	}
#line 38273 "hcs12x.cc"
}

static Operation *DecodeOpRtc(CodeType const& code, uint16_t addr)
{
	return new OpRtc(code, addr);
}

// RTS: Return from subroutine
#line 65 "hcs12x.isa"
void
#line 38284 "hcs12x.cc"
OpRts::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38288 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38291 "hcs12x.cc"
)
{
#line 626 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		sink << "RTS";
	}
#line 38298 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38302 "hcs12x.cc"
OpRts::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38306 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38309 "hcs12x.cc"
)
{
#line 630 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		uint8_t hByte, lByte;
		physical_address_t addr;

		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		hByte = cpu->memRead8(addr);
		addr = cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);
		lByte = cpu->memRead8(addr);
		cpu->setRegPC(((uint16_t) hByte << 8) | (0x00FF & lByte));

		cpu->setRegSP(cpu->getRegSP() + 2);
	}
#line 38325 "hcs12x.cc"
}

static Operation *DecodeOpRts(CodeType const& code, uint16_t addr)
{
	return new OpRts(code, addr);
}

/* ************ Loop Primitive ********* */
#line 65 "hcs12x.isa"
void
#line 38336 "hcs12x.cc"
OpLoop::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38340 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38343 "hcs12x.cc"
)
{
#line 648 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		/*
		Encoding for lb is summarized in the following table.
		Bit 3 is not used (don’t care),
		Bit 5 selects branch on zero (DBEQ – 0) or not zero (DBNE – 1) versions,
		and bit 4 is the sign bit of the 9-bit relative offset.
		Bits 7 and 6 would be 0:0 for DBNE.
		*/
		uint8_t abdxys = (b765 << 5) | (b4 << 4) | (b3 << 3) | b210;

		switch (b765) {
			case 0x00: sink << "DBEQ "; break;
			case 0x01: sink << "DBNE "; break;
			case 0x02: sink << "TBEQ "; break;
			case 0x03: sink << "TBNE "; break;
			case 0x04: sink << "IBEQ "; break;
			case 0x05: sink << "IBNE "; break;
			default: sink << "??? ";
		}

		sink << EBLB::getRegName(b210) << " , " << std::dec << rel9;
	}
#line 38369 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38373 "hcs12x.cc"
OpLoop::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38377 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38380 "hcs12x.cc"
)
{
#line 671 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./branch.isa"
	{
		address_t branchAddr;
		bool		isBranch = false;

		branchAddr = cpu->getRegPC() + rel9;

		switch (b765) {
			case 0x00: /*DBEQ*/{
				uint16_t val;
				if (b210 < 0x4) {
					val = cpu->eblb->getter<uint8_t>(b210);
					if (val != 0) { val = val - 1;}
					cpu->eblb->setter<uint8_t>(b210, val);
					} else {
					val = cpu->eblb->getter<uint16_t>(b210);
					if (val != 0) { val = val - 1;}
					cpu->eblb->setter<uint16_t>(b210, val);
				}
				isBranch = (val == 0);
			} break;
			case 0x01: /*DBNE*/{
				uint16_t val;
				if (b210 < 0x4) {
					val = cpu->eblb->getter<uint8_t>(b210);
					if (val != 0) { val = val - 1;}
					cpu->eblb->setter<uint8_t>(b210, val);
					} else {
					val = cpu->eblb->getter<uint16_t>(b210);
					if (val != 0) { val = val - 1;}
					cpu->eblb->setter<uint16_t>(b210, val);
				}
				isBranch = (val != 0);

			} break;
			case 0x02: /*TBEQ*/{
				isBranch = (cpu->eblb->getter<uint8_t>(b210) == 0);
			} break;
			case 0x03: /*TBNE*/{
				isBranch = (cpu->eblb->getter<uint8_t>(b210) != 0);
			} break;
			case 0x04: /*IBEQ*/{
				uint16_t val;
				if (b210 < 0x4) {
					val = cpu->eblb->getter<uint8_t>(b210);
					if (val != 0) { val = val + 1;}
					cpu->eblb->setter<uint8_t>(b210, val);
					} else {
					val = cpu->eblb->getter<uint16_t>(b210);
					if (val != 0) { val = val + 1;}
					cpu->eblb->setter<uint16_t>(b210, val);
				}
				isBranch = (val == 0);

			} break;
			case 0x05: /*IBNE*/{
				uint16_t val;
				if (b210 < 0x4) {
					val = cpu->eblb->getter<uint8_t>(b210);
					if (val != 0) { val = val + 1;}
					cpu->eblb->setter<uint8_t>(b210, val);
					} else {
					val = cpu->eblb->getter<uint16_t>(b210);
					if (val != 0) { val = val + 1;}
					cpu->eblb->setter<uint16_t>(b210, val);
				}
				isBranch = (val != 0);

			} break;
			default: /*???*/;
		}

		if (isBranch) {
			cpu->setRegPC(branchAddr);

			// TODO: Refill the instruction queue with three program words from the new address
		}

	}
#line 38462 "hcs12x.cc"
}

static Operation *DecodeOpLoop(CodeType const& code, uint16_t addr)
{
	return new OpLoop(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
/* ********** Stack Pointer instructions ******** */
// CPS: Compare SP to memory
// is emulated in compare_test.isa
// DES: Decrement Sp
// is emulated in decrement_increment.isa
// INS: Increment SP
// is emulated in decrement_increment.isa
// LDS: load SP
// is emulated in load_store.isa
// LEAS: load effective address into SP
// is emulated in load_store.isa
// STS: store SP
// is emulated in load_store.isa
// TSX: transfer SP to X
// is emulated in transfer_exchange.isa
// TSY: transfer SP to Y
// is emulated in transfer_exchange.isa
// TXS: transfer X to SP
// is emulated in transfer_exchange.isa
// TYS: transfer Y to Sp
// is emulated in transfer_exchange.isa
/* ********** stack Operation instructions ********** */
// PSHA: Push A
#line 65 "hcs12x.isa"
void
#line 38528 "hcs12x.cc"
OpPsha::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38532 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38535 "hcs12x.cc"
)
{
#line 75 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PSHA";
	}
#line 38542 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38546 "hcs12x.cc"
OpPsha::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38550 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38553 "hcs12x.cc"
)
{
#line 79 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{

		cpu->setRegSP(cpu->getRegSP()-1);
		cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());
	}
#line 38562 "hcs12x.cc"
}

static Operation *DecodeOpPsha(CodeType const& code, uint16_t addr)
{
	return new OpPsha(code, addr);
}

// PSHB: Push B
#line 65 "hcs12x.isa"
void
#line 38573 "hcs12x.cc"
OpPshb::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38577 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38580 "hcs12x.cc"
)
{
#line 89 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PSHB";
	}
#line 38587 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38591 "hcs12x.cc"
OpPshb::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38595 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38598 "hcs12x.cc"
)
{
#line 93 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-1);
		cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
	}
#line 38606 "hcs12x.cc"
}

static Operation *DecodeOpPshb(CodeType const& code, uint16_t addr)
{
	return new OpPshb(code, addr);
}

// PSHC: Push CCR (8 lower bits)
#line 65 "hcs12x.isa"
void
#line 38617 "hcs12x.cc"
OpPshc::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38621 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38624 "hcs12x.cc"
)
{
#line 102 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PSHC";
	}
#line 38631 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38635 "hcs12x.cc"
OpPshc::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38639 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38642 "hcs12x.cc"
)
{
#line 106 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-1);
		cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCRLow());
	}
#line 38650 "hcs12x.cc"
}

static Operation *DecodeOpPshc(CodeType const& code, uint16_t addr)
{
	return new OpPshc(code, addr);
}

// PSHCW: Push CCR word (16 bits)
#line 65 "hcs12x.isa"
void
#line 38661 "hcs12x.cc"
OpPshcw::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38665 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38668 "hcs12x.cc"
)
{
#line 115 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PSHCW";
	}
#line 38675 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38679 "hcs12x.cc"
OpPshcw::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38683 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38686 "hcs12x.cc"
)
{
#line 119 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());
	}
#line 38694 "hcs12x.cc"
}

static Operation *DecodeOpPshcw(CodeType const& code, uint16_t addr)
{
	return new OpPshcw(code, addr);
}

// PSHD: Push D
#line 65 "hcs12x.isa"
void
#line 38705 "hcs12x.cc"
OpPshd::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38709 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38712 "hcs12x.cc"
)
{
#line 128 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PSHD";
	}
#line 38719 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38723 "hcs12x.cc"
OpPshd::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38727 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38730 "hcs12x.cc"
)
{
#line 132 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegD());
	}
#line 38738 "hcs12x.cc"
}

static Operation *DecodeOpPshd(CodeType const& code, uint16_t addr)
{
	return new OpPshd(code, addr);
}

// PSHX: Push X
#line 65 "hcs12x.isa"
void
#line 38749 "hcs12x.cc"
OpPshx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38753 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38756 "hcs12x.cc"
)
{
#line 141 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PSHX";
	}
#line 38763 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38767 "hcs12x.cc"
OpPshx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38771 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38774 "hcs12x.cc"
)
{
#line 145 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());
	}
#line 38782 "hcs12x.cc"
}

static Operation *DecodeOpPshx(CodeType const& code, uint16_t addr)
{
	return new OpPshx(code, addr);
}

// PSHY: Push Y
#line 65 "hcs12x.isa"
void
#line 38793 "hcs12x.cc"
OpPshy::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38797 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38800 "hcs12x.cc"
)
{
#line 154 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PSHY";
	}
#line 38807 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38811 "hcs12x.cc"
OpPshy::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38815 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38818 "hcs12x.cc"
)
{
#line 158 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());
	}
#line 38826 "hcs12x.cc"
}

static Operation *DecodeOpPshy(CodeType const& code, uint16_t addr)
{
	return new OpPshy(code, addr);
}

// PULA: Pull A
#line 65 "hcs12x.isa"
void
#line 38837 "hcs12x.cc"
OpPula::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38841 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38844 "hcs12x.cc"
)
{
#line 167 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PULA";
	}
#line 38851 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38855 "hcs12x.cc"
OpPula::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38859 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38862 "hcs12x.cc"
)
{
#line 171 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegA(cpu->memRead8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegSP(cpu->getRegSP()+1);
	}
#line 38870 "hcs12x.cc"
}

static Operation *DecodeOpPula(CodeType const& code, uint16_t addr)
{
	return new OpPula(code, addr);
}

// PULB: Pull B
#line 65 "hcs12x.isa"
void
#line 38881 "hcs12x.cc"
OpPulb::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38885 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38888 "hcs12x.cc"
)
{
#line 180 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PULB";
	}
#line 38895 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38899 "hcs12x.cc"
OpPulb::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38903 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38906 "hcs12x.cc"
)
{
#line 184 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegB(cpu->memRead8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegSP(cpu->getRegSP()+1);
	}
#line 38914 "hcs12x.cc"
}

static Operation *DecodeOpPulb(CodeType const& code, uint16_t addr)
{
	return new OpPulb(code, addr);
}

// PULC: Pull CCR (16 lower bits)
#line 65 "hcs12x.isa"
void
#line 38925 "hcs12x.cc"
OpPulc::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38929 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38932 "hcs12x.cc"
)
{
#line 193 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PULC";
	}
#line 38939 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38943 "hcs12x.cc"
OpPulc::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38947 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38950 "hcs12x.cc"
)
{
#line 197 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->ccr->setCCRLow(cpu->memRead8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegSP(cpu->getRegSP()+1);
	}
#line 38958 "hcs12x.cc"
}

static Operation *DecodeOpPulc(CodeType const& code, uint16_t addr)
{
	return new OpPulc(code, addr);
}

// PULCW: Pull CCR word
#line 65 "hcs12x.isa"
void
#line 38969 "hcs12x.cc"
OpPulcw::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 38973 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 38976 "hcs12x.cc"
)
{
#line 206 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PULCW";
	}
#line 38983 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 38987 "hcs12x.cc"
OpPulcw::execute(
#line 60 "hcs12x.isa"
CPU *
#line 38991 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 38994 "hcs12x.cc"
)
{
#line 210 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->ccr->setCCR(cpu->memRead16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegSP(cpu->getRegSP()+2);
	}
#line 39002 "hcs12x.cc"
}

static Operation *DecodeOpPulcw(CodeType const& code, uint16_t addr)
{
	return new OpPulcw(code, addr);
}

// PULD: Pull D
#line 65 "hcs12x.isa"
void
#line 39013 "hcs12x.cc"
OpPuld::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39017 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39020 "hcs12x.cc"
)
{
#line 219 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PULD";
	}
#line 39027 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39031 "hcs12x.cc"
OpPuld::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39035 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39038 "hcs12x.cc"
)
{
#line 223 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegD(cpu->memRead16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegSP(cpu->getRegSP()+2);
	}
#line 39046 "hcs12x.cc"
}

static Operation *DecodeOpPuld(CodeType const& code, uint16_t addr)
{
	return new OpPuld(code, addr);
}

// PULX: Pull X
#line 65 "hcs12x.isa"
void
#line 39057 "hcs12x.cc"
OpPulx::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39061 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39064 "hcs12x.cc"
)
{
#line 232 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PULX";
	}
#line 39071 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39075 "hcs12x.cc"
OpPulx::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39079 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39082 "hcs12x.cc"
)
{
#line 236 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegX(cpu->memRead16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegSP(cpu->getRegSP()+2);
	}
#line 39090 "hcs12x.cc"
}

static Operation *DecodeOpPulx(CodeType const& code, uint16_t addr)
{
	return new OpPulx(code, addr);
}

// PULY: Pull Y
#line 65 "hcs12x.isa"
void
#line 39101 "hcs12x.cc"
OpPuly::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39105 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39108 "hcs12x.cc"
)
{
#line 245 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		sink << "PULY";
	}
#line 39115 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39119 "hcs12x.cc"
OpPuly::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39123 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39126 "hcs12x.cc"
)
{
#line 249 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./stacking.isa"
	{
		cpu->setRegY(cpu->memRead16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegSP(cpu->getRegSP()+2);
	}
#line 39134 "hcs12x.cc"
}

static Operation *DecodeOpPuly(CodeType const& code, uint16_t addr)
{
	return new OpPuly(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// MEM: Membership function
#line 65 "hcs12x.isa"
void
#line 39178 "hcs12x.cc"
OpMem::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39182 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39185 "hcs12x.cc"
)
{
#line 39 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		sink << "MEM";
	}
#line 39192 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39196 "hcs12x.cc"
OpMem::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39200 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39203 "hcs12x.cc"
)
{
#line 43 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		// The final state of CCR flags is not defined

		/*

		Operation
		---------
		Grade of Membership ⇒ M(Y)
		(Y) + $0001 ⇒ Y
		(X) + $0004 ⇒ X

		Description
		-----------
		Before executing MEM, initialize A, X, and Y. Load A with the current crisp value of a system input
		variable. Load Y with the fuzzy input RAM location where the grade of membership is to be stored.
		Load X with the first address of a 4-byte data structure that describes a trapezoidal membership
	function. The data structure consists of:
		Point_1 — The x-axis starting point for the leading side (at MX)
		Point_2 — The x-axis position of the rightmost point (at MX+1)
		Slope_1 — The slope of the leading side (at MX+2)
		Slope_2—The slope of the trailing side (atMX+3); the right side slopes up and to the left from
		Point_2
		A Slope_1 or Slope_2 value of $00 is a special case in which the membership function either starts
		with a grade of $FF at input = Point_1, or ends with a grade of $FF at input = Point_2 (infinite slope).
		During execution, the value of A remains unchanged. X is incremented by four and Y is incremented
		by one.

		*/

		// Grade of Membership (gm) ⇒ M(Y)
		uint8_t gm;
		uint8_t p1, p2;

		uint8_t aVal = cpu->getRegA();
		address_t xVal = cpu->getRegX();
		address_t yVal = cpu->getRegY();

		p1 = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
		p2 = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));

		if ((aVal < p1) or (aVal > p2)) {
			gm = 0;
			} else {
			uint8_t s1, s2, min1, min2;


			s1 = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal+2, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
			s2 = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal+3, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));

			min1 = (aVal - p1) * s1;
			min2 = (p2 - aVal) * s2;
			if (min1 < min2) {
				cpu->memWrite8(cpu->mmc->getPhysicalAddress(yVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), min1);
				} else {
				cpu->memWrite8(cpu->mmc->getPhysicalAddress(yVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), min2);
			}
		}

		// (Y) + $0001 ⇒ Y
		cpu->setRegY(yVal + 1);

		// (X) + $0004 ⇒ X
		cpu->setRegX(xVal + 4);

	}
#line 39272 "hcs12x.cc"
}

static Operation *DecodeOpMem(CodeType const& code, uint16_t addr)
{
	return new OpMem(code, addr);
}

// REV: (8bits) MIN-MAX rule evaluation
// this instruction can be interrupted.
#line 65 "hcs12x.isa"
void
#line 39284 "hcs12x.cc"
OpRev::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39288 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39291 "hcs12x.cc"
)
{
#line 113 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		sink << "REV";
	}
#line 39298 "hcs12x.cc"
}
// *** INTERRUPTIBLE ***
#line 60 "hcs12x.isa"
void
#line 39303 "hcs12x.cc"
OpRev::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39307 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39310 "hcs12x.cc"
)
{
#line 118 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/* The V flag is affected by operation.
		* The final state for the others CCR flags is not defined.
		*/

		uint8_t aVal, ccrV, memX, memYX;
		address_t  xVal, yVal;

		xVal = cpu->getRegX();
		yVal = cpu->getRegY();

		memX = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
		while (memX != 0xFF) {

			ccrV = 0;
			aVal = 0xFF;
			while ((memX != 0xFE) && (memX != 0xFF)) {
				memYX = cpu->memRead8(cpu->mmc->getPhysicalAddress(yVal+memX, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
				if (memYX < aVal) {
					aVal = memYX;
				}
				xVal++;
				memX = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
			}

			if (memX != 0xFF) {

				ccrV = 1;
				xVal++;
				memX = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
				while ((memX != 0xFE) && (memX != 0xFF)) {
					memYX = cpu->memRead8(cpu->mmc->getPhysicalAddress(yVal+memX, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
					if (aVal > memYX) {
						cpu->memWrite8(cpu->mmc->getPhysicalAddress(yVal+memX, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), aVal);
					}
					xVal++;
					memX = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
				}

				if (memX != 0xFF) {
					xVal++;
					memX = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
				}
			}
		}

		xVal++;

		cpu->setRegA(aVal);
		cpu->setRegX(xVal);
		cpu->setRegY(yVal);
		if (ccrV) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	}
#line 39367 "hcs12x.cc"
}

static Operation *DecodeOpRev(CodeType const& code, uint16_t addr)
{
	return new OpRev(code, addr);
}

// REVW: (16bits) MIN-MAX rule evaluation
// this instruction can be interrupted.
#line 65 "hcs12x.isa"
void
#line 39379 "hcs12x.cc"
OpRevw::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39383 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39386 "hcs12x.cc"
)
{
#line 176 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		sink << "REVW";
	}
#line 39393 "hcs12x.cc"
}
// *** INTERRUPTIBLE ***
#line 60 "hcs12x.isa"
void
#line 39398 "hcs12x.cc"
OpRevw::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39402 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39405 "hcs12x.cc"
)
{
#line 181 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/* The V flag is affected by operation.
		* The C flag is used for special purpose.
		* The final state for the others CCR flags is not defined.
		*/

		uint8_t aVal, ccrV, ccrC, memOfMemX, memY;
		address_t memX, xVal, yVal;

		xVal = cpu->getRegX();
		yVal = cpu->getRegY(); cpu->setRegTMP(1, yVal);  // (Y) weight pointer kept in TMP2
		ccrC = cpu->ccr->getC();

		memX = cpu->memRead16(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
		while (memX != 0xFFFF) {

			ccrV = 0;
			aVal = 0xFF;
			while ((memX != 0xFFFE) && (memX != 0xFFFF)) {
				memOfMemX = cpu->memRead8(cpu->mmc->getPhysicalAddress(memX, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
				if (memOfMemX < aVal) {
					aVal = memOfMemX;
				}
				xVal++;
				memX = cpu->memRead16(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
			}

			if (memX != 0xFFFF) {
				// *** Apply weight	***
				if (ccrC == 1) {
					memY = cpu->memRead8(cpu->mmc->getPhysicalAddress(yVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
					aVal = (uint8_t) ((uint16_t) aVal * (memY+1)) >> 8;  // cpu->setRegA(aVal);
					yVal++;  cpu->setRegTMP(1, yVal); // cpu->setRegY(yVal);
				}

				ccrV = 1;
				xVal++;
				memX = cpu->memRead16(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
				while ((memX != 0xFFFE) && (memX != 0xFFFF)) {
					memOfMemX = cpu->memRead16(cpu->mmc->getPhysicalAddress(memX, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
					if (aVal > memOfMemX) {
						cpu->memWrite8(cpu->mmc->getPhysicalAddress(memX, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), aVal);
					}
					xVal++;
					memX = cpu->memRead16(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
				}

				if (memX != 0xFFFF) {
					xVal++;
					memX = cpu->memRead16(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
				}
			}
		}

		xVal++;

		cpu->setRegA(aVal);
		cpu->setRegX(xVal);
		cpu->setRegY(yVal);
		if (ccrV) { cpu->ccr->setV();} else { cpu->ccr->clrV();}

	}
#line 39471 "hcs12x.cc"
}

static Operation *DecodeOpRevw(CodeType const& code, uint16_t addr)
{
	return new OpRevw(code, addr);
}

// WAV: Weighted Average Calculation
/*
This instruction can be interrupted.
New WAV instructions can be started and interrupted while a previous WAV instruction is interrupted
*/
#line 65 "hcs12x.isa"
void
#line 39486 "hcs12x.cc"
OpWav::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39490 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39493 "hcs12x.cc"
)
{
#line 252 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		sink << "WAV";
	}
#line 39500 "hcs12x.cc"
}
// *** INTERRUPTIBLE ***
#line 60 "hcs12x.isa"
void
#line 39505 "hcs12x.cc"
OpWav::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39509 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39512 "hcs12x.cc"
)
{
#line 257 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/* The Z flag is affected by operation.
		* The final state for the others CCR flags is not defined.
		*/

		/*
		* Do until B = 0, leave SOP in Y : D, SOW in X
		*   Partial Product = (M pointed to by X) × (M pointed to by Y)
		*   Sum-of-Products (24-bit SOP) = Previous SOP + Partial Product
		*   Sum-of-Weights (16-bit SOW) = Previous SOW + (M pointed to by Y)
		*   (X) + $0001 ⇒ X; (Y) + $0001 ⇒ Y
		*   (B) – $01 ⇒ B
		**/

		uint8_t bVal, memX, memY;
		address_t xVal, yVal;
		uint32_t sop;
		uint16_t pp, sow;

		bVal = cpu->getRegB();
		xVal = cpu->getRegX();
		yVal = cpu->getRegY();
		sop = 0;
		sow = 0;
		cpu->setRegTMP(0, 0x0000);
		cpu->setRegTMP(1, 0x0000);
		cpu->setRegTMP(2, 0x0000);

		while (bVal > 0) {

			/** TODO: WAV is interruptible only at this point and not after.
			* if (InterruptPending)
			* {
				*   Write word @ -2,SP (stack TMP3); SP = SP - 2;
				*   Write word @ -2,SP (stack TMP2); SP = SP - 2;
				*   Write word @ -2,SP (stack TMP1); SP = SP - 2;
				*   Adjust PC to point at $3C wavr pseudo-opcode
				* }
			**/

			memY = cpu->memRead8(cpu->mmc->getPhysicalAddress(yVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));
			memX = cpu->memRead8(cpu->mmc->getPhysicalAddress(xVal, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS));

			pp = memX * memY;
			sop += pp;
			cpu->setRegTMP(2, (uint16_t) (sop >> 16));
			cpu->setRegTMP(1, (uint16_t) sop);

			sow += memY;
			cpu->setRegTMP(0, sow);

			xVal++;
			yVal++;
			bVal--;

		}

		cpu->setRegB(bVal);
		cpu->setRegY(cpu->getRegTMP(2));
		cpu->setRegD(cpu->getRegTMP(1));
		cpu->setRegX(cpu->getRegTMP(0));

		cpu->ccr->setZ();
	}
#line 39580 "hcs12x.cc"
}

static Operation *DecodeOpWav(CodeType const& code, uint16_t addr)
{
	return new OpWav(code, addr);
}

// WAVR pseudo instruction: Resume execution of interrupted WAV instruction
#line 65 "hcs12x.isa"
void
#line 39591 "hcs12x.cc"
OpWavr::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39595 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39598 "hcs12x.cc"
)
{
#line 325 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		sink << "WAVR";
	}
#line 39605 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39609 "hcs12x.cc"
OpWavr::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39613 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39616 "hcs12x.cc"
)
{
#line 329 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/* The Z flag is affected by operation.
		* The final state for the others CCR flags is not defined.
		*/

		address_t sp = cpu->getRegSP();
		cpu->setRegTMP(0, cpu->memRead16(cpu->mmc->getPhysicalAddress(sp, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegTMP(1, cpu->memRead16(cpu->mmc->getPhysicalAddress(sp+2, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegTMP(2, cpu->memRead16(cpu->mmc->getPhysicalAddress(sp+4, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegSP(sp+6);

		if ((cpu->getRegTMP(0) == 0) ||
		(cpu->getRegTMP(1) == 0) ||
		(cpu->getRegTMP(2) == 0))
		{
			cpu->ccr->setZ();
			} else {
			cpu->ccr->clrZ();
		}
	}
#line 39640 "hcs12x.cc"
}

static Operation *DecodeOpWavr(CodeType const& code, uint16_t addr)
{
	return new OpWavr(code, addr);
}

/* ********  TABLE INTERPOLATION Instructions ********* */
// TBL: 8-bit Table lookup and Interpolate
#line 65 "hcs12x.isa"
void
#line 39652 "hcs12x.cc"
OpTbl::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39656 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39659 "hcs12x.cc"
)
{
#line 355 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		sink << "TBL ";
		xb->disasm(sink);
	}
#line 39667 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39671 "hcs12x.cc"
OpTbl::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39675 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39678 "hcs12x.cc"
)
{
#line 360 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/*
		Operation: (M) + [(B) * ((M+1) - (M))] => A
		The intermediate value [(B) * (Y2 - Y1)] produces a 16-bit result
		with the radix point between bits 7 and 8.

		N: Set if MSB of result is set; cleared otherwise
		Z: Set if result is $00; cleared otherwise
		C: Set if result can be rounded up; cleared otherwise
		*/

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint8_t bVal = cpu->getRegB();
		uint8_t mVal = cpu->memRead8(addr);
		uint8_t m1Val = cpu->memRead8(addr+1);

		uint16_t result = (uint16_t) mVal + (bVal * (m1Val - mVal));
		uint8_t msBits = (uint8_t) (result >> 8);
		uint8_t lowBits = (uint8_t) result;

		cpu->setRegA(msBits);
		if ((msBits & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN();}
		if (msBits == 0x00) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ();}
		if (lowBits > 0x7F) { cpu->ccr->setC(); } else { cpu->ccr->clrC();}
	}
#line 39708 "hcs12x.cc"
}

static Operation *DecodeOpTbl(CodeType const& code, uint16_t addr)
{
	return new OpTbl(code, addr);
}

// ETBL: 16-bit Table lookup and Interpolate
#line 65 "hcs12x.isa"
void
#line 39719 "hcs12x.cc"
OpEtlb::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39723 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39726 "hcs12x.cc"
)
{
#line 391 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		sink << "ETLB ";
		xb->disasm(sink);
	}
#line 39734 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39738 "hcs12x.cc"
OpEtlb::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39742 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39745 "hcs12x.cc"
)
{
#line 396 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./fuzzy-logic.isa"
	{
		/*
		Operation: D = M + [(B) * ((M+2) - (M))]
		The intermediate value [(B) * ((M+2) - (M))] produces a 24-bit result
		with the radix point between bits 7 and 8.
		*/

		physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);

		uint8_t bVal = cpu->getRegB();
		uint16_t mVal = cpu->memRead16(addr);
		uint16_t m1Val = cpu->memRead16(addr+2);

		uint32_t result = (uint32_t) mVal + (bVal * (m1Val - mVal));
		uint16_t msBits = (uint16_t) (result >> 8);
		uint8_t lowBits = (uint8_t) result;

		cpu->setRegD(msBits);
		if ((msBits & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN();}
		if (result == 0x0000) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ();}
		if (lowBits > 0x7F) { cpu->ccr->setC(); } else { cpu->ccr->clrC();}
	}
#line 39771 "hcs12x.cc"
}

static Operation *DecodeOpEtlb(CodeType const& code, uint16_t addr)
{
	return new OpEtlb(code, addr);
}

/*
*  Copyright (c) 2008,
*  Commissariat a l'Energie Atomique (CEA)
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*   - Redistributions of source code must retain the above copyright notice, this
*     list of conditions and the following disclaimer.
*
*   - Redistributions in binary form must reproduce the above copyright notice,
*     this list of conditions and the following disclaimer in the documentation
*     and/or other materials provided with the distribution.
*
*   - Neither the name of CEA nor the names of its contributors may be used to
*     endorse or promote products derived from this software without specific prior
*     written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED.
*  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
*/
// NOP:
#line 65 "hcs12x.isa"
void
#line 39815 "hcs12x.cc"
OpNop::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39819 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39822 "hcs12x.cc"
)
{
#line 39 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		sink << "NOP";
	}
#line 39829 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39833 "hcs12x.cc"
OpNop::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39837 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39840 "hcs12x.cc"
)
{
#line 43 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		// This single-byte instruction increments the PC and does nothing else.
	}
#line 39847 "hcs12x.cc"
}

static Operation *DecodeOpNop(CodeType const& code, uint16_t addr)
{
	return new OpNop(code, addr);
}

// STOP:
#line 65 "hcs12x.isa"
void
#line 39858 "hcs12x.cc"
OpStop::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39862 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39865 "hcs12x.cc"
)
{
#line 50 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		sink << "STOP";
	}
#line 39872 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39876 "hcs12x.cc"
OpStop::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39880 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39883 "hcs12x.cc"
)
{
#line 54 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{

		if (cpu->ccr->getS() == 1) {
			/*
			* if S control bit = 1, the STOP instruction is disabled and acts like two-cycle NOP
			*/
			// TODO: consume two cycles
			} else {
			/*
			* (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
			* (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
			* (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
			* (SP) – $0002 => SP; B : A => (M(SP) : M(SP+1))
			* (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
			* Stop All Clocks and puts the device in standby mode
			*/

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
			cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());

			cpu->setRegSP(cpu->getRegSP()-2);
			cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());

		/* TODO:
			* Stop All Clocks and puts the device in standby mode.
			* Asserting the RESET, XIRQ, or IRQ signals ends standby mode.
			*/

			cpu->Sleep();

		/* TODO:
			* If XIRQ is asserted while the X mask bit = 0 (XIRQ interrupts enabled),
			* execution resumes with a vector fetch for the XIRQ interrupt.
			* While the X mask bit = 1 (XIRQ interrupts disabled),
			* a 2-cycle recovery sequence is used to adjust the instruction queue and the stack pointer,
			* and execution continues with the next instruction after STOP.
			*/
		}
	}
#line 39936 "hcs12x.cc"
}

static Operation *DecodeOpStop(CodeType const& code, uint16_t addr)
{
	return new OpStop(code, addr);
}

// WAIT
#line 65 "hcs12x.isa"
void
#line 39947 "hcs12x.cc"
OpWait::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 39951 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 39954 "hcs12x.cc"
)
{
#line 107 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		sink << "WAI";
	}
#line 39961 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 39965 "hcs12x.cc"
OpWait::execute(
#line 60 "hcs12x.isa"
CPU *
#line 39969 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 39972 "hcs12x.cc"
)
{
#line 111 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{

		/*
		* (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; B : A => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
		* The CPU12 then enters a wait state for an integer number of bus clock cycles.
		* During the wait state, CPU12 clocks are stopped, but otherMCUclocks can continue to run.
		* WAIT for not masked interrupt
		*/

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
		cpu->memWrite8(cpu->mmc->getPhysicalAddress(cpu->getRegSP()+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());

		cpu->setRegSP(cpu->getRegSP()-2);
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(cpu->getRegSP(), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());

	/* TODO:
		* Enter a wait state for an integer number of bus clock cycle
		* Only CPU12 clocks are stopped
		* Wait for not masked interrupt
		*/

		cpu->Wait();

		/*
		* If XIRQ is asserted while the X mask bit = 0 (XIRQ interrupts enabled),
		* execution resumes with a vector fetch for the XIRQ interrupt.
		* While the X mask bit = 1 (XIRQ interrupts disabled),
		* a 2-cycle recovery sequence is used to adjust the instruction queue and the stack pointer,
		* and execution continues with the next instruction after WAI.
		*/
	}
#line 40021 "hcs12x.cc"
}

static Operation *DecodeOpWait(CodeType const& code, uint16_t addr)
{
	return new OpWait(code, addr);
}

// BGND: Enter Background debug mode
#line 65 "hcs12x.isa"
void
#line 40032 "hcs12x.cc"
OpBgnd::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 40036 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 40039 "hcs12x.cc"
)
{
#line 161 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		sink << "BGND";
	}
#line 40046 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 40050 "hcs12x.cc"
OpBgnd::execute(
#line 60 "hcs12x.isa"
CPU *
#line 40054 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 40057 "hcs12x.cc"
)
{
#line 165 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		// TODO
	}
#line 40064 "hcs12x.cc"
}

static Operation *DecodeOpBgnd(CodeType const& code, uint16_t addr)
{
	return new OpBgnd(code, addr);
}

/* ********** Interrupt instructions ******** */
// RTI: Return from interrupt
#line 65 "hcs12x.isa"
void
#line 40076 "hcs12x.cc"
OpRti::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 40080 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 40083 "hcs12x.cc"
)
{
#line 175 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		sink << "RTI";
	}
#line 40090 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 40094 "hcs12x.cc"
OpRti::execute(
#line 60 "hcs12x.isa"
CPU *
#line 40098 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 40101 "hcs12x.cc"
)
{
#line 179 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		/*
		* (M(SP) : M(SP+1)) => CCRH : CCRL; (SP) + $0002 => SP
		* (M(SP) : M(SP+1)) => B : A; (SP) + $0002 => SP
		* (M(SP) : M(SP+1)) => XH : XL; (SP) + $0004 => SP
		* (M(SP) : M(SP+1)) => PCH : PCL; (SP) – $0002 => SP
		* (M(SP) : M(SP+1)) => YH : YL; (SP) + $0004 => SP
		* */

		address_t addr = cpu->getRegSP();

		/* Leave bit X unchanged.
		* X bit can be set only by a reset or by recognition of an (!XIRQ) interrupt
		*/
		cpu->ccr->setCCR((cpu->memRead16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)) & 0xFFBF) | (cpu->ccr->getCCR() & 0x0040));

		addr = addr + 2;
		cpu->setRegB(cpu->memRead8(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));
		cpu->setRegA(cpu->memRead8(cpu->mmc->getPhysicalAddress(addr+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));

		addr = addr + 2;
		cpu->setRegX(cpu->memRead16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));

		addr = addr + 2;
		cpu->setRegY(cpu->memRead16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));

		addr = addr + 2;
		cpu->setRegPC(cpu->memRead16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS)));

		addr = addr + 2;
		cpu->setRegSP(addr);
	}
#line 40137 "hcs12x.cc"
}

static Operation *DecodeOpRti(CodeType const& code, uint16_t addr)
{
	return new OpRti(code, addr);
}

// SWI: Software Interrupt
#line 65 "hcs12x.isa"
void
#line 40148 "hcs12x.cc"
OpSwi::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 40152 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 40155 "hcs12x.cc"
)
{
#line 216 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		sink << "SWI";
	}
#line 40162 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 40166 "hcs12x.cc"
OpSwi::execute(
#line 60 "hcs12x.isa"
CPU *
#line 40170 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 40173 "hcs12x.cc"
)
{
#line 220 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		/* (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; B : A=> (M(SP) : M(SP+1))
		* In case of CPU12
		* (SP) – $0001 => SP; CCR => (M(SP) )
		* In case of CPU12X
		* (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
		* 1 => I; 0 => U
		* (SWI Vector) => PC
		*/

		address_t addr = cpu->getRegSP();

		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());

		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());

		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());

		addr = addr - 2;
		cpu->memWrite8(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());

		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());

		cpu->ccr->setI();
		cpu->ccr->setCCRHigh(cpu->ccr->getCCRHigh() & 0x7F);

		// TODO: (SWI Vector) => PC
	}
#line 40213 "hcs12x.cc"
}

static Operation *DecodeOpSwi(CodeType const& code, uint16_t addr)
{
	return new OpSwi(code, addr);
}

// SYS: System Call Interrupt
// System call interrupt vector is $FF12:$FF13
#line 65 "hcs12x.isa"
void
#line 40225 "hcs12x.cc"
OpSys::disasm(
#line 65 "hcs12x.isa"
ostream&
#line 40229 "hcs12x.cc"
#line 65 "hcs12x.isa"
sink
#line 40232 "hcs12x.cc"
)
{
#line 314 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{
		sink << "SYS";
	}
#line 40239 "hcs12x.cc"
}
#line 60 "hcs12x.isa"
void
#line 40243 "hcs12x.cc"
OpSys::execute(
#line 60 "hcs12x.isa"
CPU *
#line 40247 "hcs12x.cc"
#line 60 "hcs12x.isa"
cpu
#line 40250 "hcs12x.cc"
)
{
#line 318 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/./others.isa"
	{

		/*
		* (SP) – $0002 => SP; RTNH : RTNL => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; YH : YL => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; XH : XL => (M(SP) : M(SP+1))
		* (SP) – $0002 => SP; B : A => (M(SP) : M(SP+1))
		* In case of CPU12
		* (SP) – $0001 => SP; CCR => (M(SP) )
		* In case of CPU12X
		* (SP) – $0002 => SP; CCRH : CCRL => (M(SP) : M(SP+1))
		* 1 => I; 0 => U
		* (Trap Vector) => PC
		*/

		address_t addr = cpu->getRegSP();

		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegPC());

		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegY());

		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegX());

		addr = addr - 2;
		cpu->memWrite8(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegB());
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr+1, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->getRegA());

		addr = addr - 2;
		cpu->memWrite16(cpu->mmc->getPhysicalAddress(addr, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS), cpu->ccr->getCCR());

		// 1 => I; 0 => U
		cpu->ccr->setI();
		cpu->ccr->setCCRHigh(cpu->ccr->getCCRHigh() & 0x7F);

		// (Sys Vector) => PC
		cpu->setRegPC(cpu->memRead16(CONFIG::SYS_VECTOR_ADDRESS));
	}
#line 40294 "hcs12x.cc"
}

static Operation *DecodeOpSys(CodeType const& code, uint16_t addr)
{
	return new OpSys(code, addr);
}

OpCall_idx::OpCall_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "call_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		page = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpCall_idx::~OpCall_idx()
{
	delete xb;
}

OpTrap::OpTrap(CodeType const& code, uint16_t addr) : Operation(code, addr, "trap")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		trapnum = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLdaab_imm::OpLdaab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "ldaab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLdaab_dir::OpLdaab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "ldaab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLdaab_ext::OpLdaab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ldaab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLdaab_idx::OpLdaab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ldaab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLdaab_idx::~OpLdaab_idx()
{
	delete xb;
}

OpLd_dyxs_imm::OpLd_dyxs_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "ld_dyxs_imm")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLd_dyxs_dir::OpLd_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "ld_dyxs_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		dd = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLd_dyxs_ext::OpLd_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ld_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLd_dyxs_idx::OpLd_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ld_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLd_dyxs_idx::~OpLd_dyxs_idx()
{
	delete xb;
}

OpLeay::OpLeay(CodeType const& code, uint16_t addr) : Operation(code, addr, "leay")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLeay::~OpLeay()
{
	delete xb;
}

OpLeax::OpLeax(CodeType const& code, uint16_t addr) : Operation(code, addr, "leax")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLeax::~OpLeax()
{
	delete xb;
}

OpLeas::OpLeas(CodeType const& code, uint16_t addr) : Operation(code, addr, "leas")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLeas::~OpLeas()
{
	delete xb;
}

OpStaab_dir::OpStaab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "staab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 8) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpStaab_ext::OpStaab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "staab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpStaab_idx::OpStaab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "staab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpStaab_idx::~OpStaab_idx()
{
	delete xb;
}

OpSt_dyxs_dir::OpSt_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "st_dyxs_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSt_dyxs_ext::OpSt_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "st_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSt_dyxs_idx::OpSt_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "st_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSt_dyxs_idx::~OpSt_dyxs_idx()
{
	delete xb;
}

OpGldaab_dir::OpGldaab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "gldaab_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGldaab_ext::OpGldaab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "gldaab_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGldaab_idx::OpGldaab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "gldaab_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpGldaab_idx::~OpGldaab_idx()
{
	delete xb;
}

OpGld_dyxs_dir::OpGld_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "gld_dyxs_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		dd = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGld_dyxs_ext::OpGld_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "gld_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGld_dyxs_idx::OpGld_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "gld_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpGld_dyxs_idx::~OpGld_dyxs_idx()
{
	delete xb;
}

OpGstaab_dir::OpGstaab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "gstaab_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 8) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGstaab_ext::OpGstaab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "gstaab_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGstaab_idx::OpGstaab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "gstaab_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpGstaab_idx::~OpGstaab_idx()
{
	delete xb;
}

OpGst_dyxs_dir::OpGst_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "gst_dyxs_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGst_dyxs_ext::OpGst_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "gst_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpGst_dyxs_idx::OpGst_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "gst_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpGst_dyxs_idx::~OpGst_dyxs_idx()
{
	delete xb;
}

OpT_ab_ba::OpT_ab_ba(CodeType const& code, uint16_t addr) : Operation(code, addr, "t_ab_ba")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpExg_hcs12::OpExg_hcs12(CodeType const& code, uint16_t addr) : Operation(code, addr, "exg_hcs12")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		lms = ((_subword_ >> 4) & 0x7ULL);
		lls = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpTfr_hcs12::OpTfr_hcs12(CodeType const& code, uint16_t addr) : Operation(code, addr, "tfr_hcs12")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		lms = ((_subword_ >> 4) & 0x7ULL);
		hls = ((_subword_ >> 3) & 0x1ULL);
		lls = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpExg_hcs12x::OpExg_hcs12x(CodeType const& code, uint16_t addr) : Operation(code, addr, "exg_hcs12x")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		lms = ((_subword_ >> 4) & 0x7ULL);
		lls = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpTfr_hcs12x::OpTfr_hcs12x(CodeType const& code, uint16_t addr) : Operation(code, addr, "tfr_hcs12x")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		lms = ((_subword_ >> 4) & 0x7ULL);
		lls = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpMovb_0B::OpMovb_0B(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_0B")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		ii = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovb_08::OpMovb_08(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_08")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		ii = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpMovb_08::~OpMovb_08()
{
	delete xb;
}

OpMovb_0C::OpMovb_0C(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_0C")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16asrc = ((_subword_ >> 16) & 0xffffULL);
		opr16adst = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpMovb_09::OpMovb_09(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_09")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16asrc = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovb_09::~OpMovb_09()
{
	delete xb;
}

OpMovb_0D::OpMovb_0D(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_0D")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovb_0D::~OpMovb_0D()
{
	delete xb;
}

OpMovb_0A::OpMovb_0A(CodeType const& code, uint16_t addr) : Operation(code, addr, "movb_0A")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xbsrc = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xbsrc->GetEncoding().size );
	xbdst = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xbdst->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMovb_0A::~OpMovb_0A()
{
	delete xbsrc;
	delete xbdst;
}

OpMovw_03::OpMovw_03(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_03")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovw_00::OpMovw_00(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_00")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovw_00::~OpMovw_00()
{
	delete xb;
}

OpMovw_04::OpMovw_04(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_04")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16asrc = ((_subword_ >> 16) & 0xffffULL);
		opr16adst = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpMovw_01::OpMovw_01(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_01")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16asrc = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovw_01::~OpMovw_01()
{
	delete xb;
}

OpMovw_05::OpMovw_05(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_05")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMovw_05::~OpMovw_05()
{
	delete xb;
}

OpMovw_02::OpMovw_02(CodeType const& code, uint16_t addr) : Operation(code, addr, "movw_02")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xbsrc = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xbsrc->GetEncoding().size );
	xbdst = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xbdst->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMovw_02::~OpMovw_02()
{
	delete xbsrc;
	delete xbdst;
}

OpAba::OpAba(CodeType const& code, uint16_t addr) : Operation(code, addr, "aba")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAbx::OpAbx(CodeType const& code, uint16_t addr) : Operation(code, addr, "abx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAby::OpAby(CodeType const& code, uint16_t addr) : Operation(code, addr, "aby")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_imm::OpAdc_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "adc_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_dir::OpAdc_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "adc_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_ext::OpAdc_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "adc_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_idx::OpAdc_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "adc_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAdc_ab_idx::~OpAdc_ab_idx()
{
	delete xb;
}

OpAdd_ab_imm::OpAdd_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_ab_dir::OpAdd_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_ab_ext::OpAdd_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_ab_idx::OpAdd_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAdd_ab_idx::~OpAdd_ab_idx()
{
	delete xb;
}

OpAded_imm::OpAded_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "aded_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAded_dir::OpAded_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "aded_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAded_ext::OpAded_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "aded_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAded_idx::OpAded_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "aded_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAded_idx::~OpAded_idx()
{
	delete xb;
}

OpAde_xy_imm::OpAde_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "ade_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAde_xy_dir::OpAde_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "ade_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAde_xy_ext::OpAde_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ade_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAde_xy_idx::OpAde_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ade_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAde_xy_idx::~OpAde_xy_idx()
{
	delete xb;
}

OpAdd_xy_imm::OpAdd_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAdd_xy_dir::OpAdd_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_xy_ext::OpAdd_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_xy_idx::OpAdd_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAdd_xy_idx::~OpAdd_xy_idx()
{
	delete xb;
}

OpAdd_sub_d_imm::OpAdd_sub_d_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_sub_d_imm")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_sub_d_dir::OpAdd_sub_d_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_sub_d_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_sub_d_ext::OpAdd_sub_d_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_sub_d_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAdd_sub_d_idx::OpAdd_sub_d_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "add_sub_d_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAdd_sub_d_idx::~OpAdd_sub_d_idx()
{
	delete xb;
}

OpSba::OpSba(CodeType const& code, uint16_t addr) : Operation(code, addr, "sba")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_imm::OpSbc_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbc_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_dir::OpSbc_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbc_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_ext::OpSbc_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbc_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_idx::OpSbc_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbc_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSbc_ab_idx::~OpSbc_ab_idx()
{
	delete xb;
}

OpSbed_imm::OpSbed_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbed_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpSbed_dir::OpSbed_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbed_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbed_ext::OpSbed_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbed_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbed_idx::OpSbed_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbed_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSbed_idx::~OpSbed_idx()
{
	delete xb;
}

OpSbe_xy_imm::OpSbe_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbe_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpSbe_xy_dir::OpSbe_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbe_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbe_xy_ext::OpSbe_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbe_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSbe_xy_idx::OpSbe_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbe_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSbe_xy_idx::~OpSbe_xy_idx()
{
	delete xb;
}

OpSub_ab_imm::OpSub_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_ab_dir::OpSub_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_ab_ext::OpSub_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_ab_idx::OpSub_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSub_ab_idx::~OpSub_ab_idx()
{
	delete xb;
}

OpSub_xy_imm::OpSub_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpSub_xy_dir::OpSub_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_xy_ext::OpSub_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpSub_xy_idx::OpSub_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "sub_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpSub_xy_idx::~OpSub_xy_idx()
{
	delete xb;
}

OpDaa::OpDaa(CodeType const& code, uint16_t addr) : Operation(code, addr, "daa")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpDec_ext::OpDec_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "dec_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpDec_idx::OpDec_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "dec_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpDec_idx::~OpDec_idx()
{
	delete xb;
}

OpDec_ab::OpDec_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "dec_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpDecw_ext::OpDecw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "decw_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpDecw_idx::OpDecw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "decw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpDecw_idx::~OpDecw_idx()
{
	delete xb;
}

OpDec_xy::OpDec_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "dec_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpDes::OpDes(CodeType const& code, uint16_t addr) : Operation(code, addr, "des")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpDex::OpDex(CodeType const& code, uint16_t addr) : Operation(code, addr, "dex")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpDey::OpDey(CodeType const& code, uint16_t addr) : Operation(code, addr, "dey")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpInc_ext::OpInc_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "inc_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpInc_idx::OpInc_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "inc_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpInc_idx::~OpInc_idx()
{
	delete xb;
}

OpInc_ab::OpInc_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "inc_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpIncw_ext::OpIncw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "incw_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpIncw_idx::OpIncw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "incw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpIncw_idx::~OpIncw_idx()
{
	delete xb;
}

OpInc_xy::OpInc_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "inc_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpIns::OpIns(CodeType const& code, uint16_t addr) : Operation(code, addr, "ins")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpInx::OpInx(CodeType const& code, uint16_t addr) : Operation(code, addr, "inx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpIny::OpIny(CodeType const& code, uint16_t addr) : Operation(code, addr, "iny")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpCba::OpCba(CodeType const& code, uint16_t addr) : Operation(code, addr, "cba")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_imm::OpCmp_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "cmp_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_dir::OpCmp_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "cmp_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_ext::OpCmp_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "cmp_ab_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr16a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_idx::OpCmp_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "cmp_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpCmp_ab_idx::~OpCmp_ab_idx()
{
	delete xb;
}

OpCp_dyxs_imm::OpCp_dyxs_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "cp_dyxs_imm")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCp_dyxs_dir::OpCp_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "cp_dyxs_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCp_dyxs_ext::OpCp_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "cp_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCp_dyxs_idx::OpCp_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "cp_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpCp_dyxs_idx::~OpCp_dyxs_idx()
{
	delete xb;
}

OpCpe_dyxs_imm::OpCpe_dyxs_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "cpe_dyxs_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCpe_dyxs_dir::OpCpe_dyxs_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "cpe_dyxs_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 8) & 0x3ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCpe_dyxs_ext::OpCpe_dyxs_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "cpe_dyxs_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCpe_dyxs_idx::OpCpe_dyxs_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "cpe_dyxs_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dyxs = ((_subword_ >> 0) & 0x3ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpCpe_dyxs_idx::~OpCpe_dyxs_idx()
{
	delete xb;
}

OpTst_ext::OpTst_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "tst_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpTst_idx::OpTst_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "tst_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpTst_idx::~OpTst_idx()
{
	delete xb;
}

OpTst_ab::OpTst_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "tst_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpTstw_ext::OpTstw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "tstw_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpTstw_idx::OpTstw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "tstw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpTstw_idx::~OpTstw_idx()
{
	delete xb;
}

OpTst_xy::OpTst_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "tst_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEmin_dm::OpEmin_dm(CodeType const& code, uint16_t addr) : Operation(code, addr, "emin_dm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 2) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEmin_dm::~OpEmin_dm()
{
	delete xb;
}

OpMin_am::OpMin_am(CodeType const& code, uint16_t addr) : Operation(code, addr, "min_am")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 2) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMin_am::~OpMin_am()
{
	delete xb;
}

OpEmax_dm::OpEmax_dm(CodeType const& code, uint16_t addr) : Operation(code, addr, "emax_dm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 2) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEmax_dm::~OpEmax_dm()
{
	delete xb;
}

OpMax_am::OpMax_am(CodeType const& code, uint16_t addr) : Operation(code, addr, "max_am")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 2) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpMax_am::~OpMax_am()
{
	delete xb;
}

OpAnd_ab_imm::OpAnd_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAnd_ab_dir::OpAnd_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAnd_ab_ext::OpAnd_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAnd_ab_idx::OpAnd_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAnd_ab_idx::~OpAnd_ab_idx()
{
	delete xb;
}

OpAndcc_imm::OpAndcc_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "andcc_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_imm::OpAnd_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_dir::OpAnd_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_xy_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_ext::OpAnd_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_xy_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_idx::OpAnd_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "and_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAnd_xy_idx::~OpAnd_xy_idx()
{
	delete xb;
}

OpOra_ab_imm::OpOra_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "ora_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpOra_ab_dir::OpOra_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "ora_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpOra_ab_ext::OpOra_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ora_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpOra_ab_idx::OpOra_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ora_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpOra_ab_idx::~OpOra_ab_idx()
{
	delete xb;
}

OpOrcc_imm::OpOrcc_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "orcc_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpOr_xy_imm::OpOr_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "or_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpOr_xy_dir::OpOr_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "or_xy_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpOr_xy_ext::OpOr_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "or_xy_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpOr_xy_idx::OpOr_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "or_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpOr_xy_idx::~OpOr_xy_idx()
{
	delete xb;
}

OpEor_ab_imm::OpEor_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8i = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEor_ab_dir::OpEor_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEor_ab_ext::OpEor_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEor_ab_idx::OpEor_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEor_ab_idx::~OpEor_ab_idx()
{
	delete xb;
}

OpEor_xy_imm::OpEor_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpEor_xy_dir::OpEor_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_xy_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpEor_xy_ext::OpEor_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_xy_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpEor_xy_idx::OpEor_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "eor_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEor_xy_idx::~OpEor_xy_idx()
{
	delete xb;
}

OpClc::OpClc(CodeType const& code, uint16_t addr) : Operation(code, addr, "clc")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCli::OpCli(CodeType const& code, uint16_t addr) : Operation(code, addr, "cli")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpClv::OpClv(CodeType const& code, uint16_t addr) : Operation(code, addr, "clv")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpClr_ext::OpClr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "clr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpClr_idx::OpClr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "clr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpClr_idx::~OpClr_idx()
{
	delete xb;
}

OpClrw_ext::OpClrw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "clrw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpClrw_idx::OpClrw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "clrw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpClrw_idx::~OpClrw_idx()
{
	delete xb;
}

OpClr_ab::OpClr_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "clr_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpClr_xy::OpClr_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "clr_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCom_ext::OpCom_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "com_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCom_idx::OpCom_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "com_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpCom_idx::~OpCom_idx()
{
	delete xb;
}

OpCom_ab::OpCom_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "com_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpComw_ext::OpComw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "comw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpComw_idx::OpComw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "comw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpComw_idx::~OpComw_idx()
{
	delete xb;
}

OpCom_xy::OpCom_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "com_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpNeg_ext::OpNeg_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "neg_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpNeg_idx::OpNeg_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "neg_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpNeg_idx::~OpNeg_idx()
{
	delete xb;
}

OpNeg_ab::OpNeg_ab(CodeType const& code, uint16_t addr) : Operation(code, addr, "neg_ab")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpNegw_ext::OpNegw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "negw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpNegw_idx::OpNegw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "negw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpNegw_idx::~OpNegw_idx()
{
	delete xb;
}

OpNeg_xy::OpNeg_xy(CodeType const& code, uint16_t addr) : Operation(code, addr, "neg_xy")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 4) & 0x1ULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBclr_dir::OpBclr_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "bclr_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dd = ((_subword_ >> 8) & 0xffULL);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBclr_ext::OpBclr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "bclr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBclr_idx::OpBclr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "bclr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBclr_idx::~OpBclr_idx()
{
	delete xb;
}

OpBit_ab_imm::OpBit_ab_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_ab_imm")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		ii = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_ab_dir::OpBit_ab_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_ab_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_ab_ext::OpBit_ab_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_ab_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_ab_idx::OpBit_ab_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_ab_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpBit_ab_idx::~OpBit_ab_idx()
{
	delete xb;
}

OpBit_xy_imm::OpBit_xy_imm(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_xy_imm")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 22) & 0x1ULL);
		opr16i = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBit_xy_dir::OpBit_xy_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_xy_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 14) & 0x1ULL);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_xy_ext::OpBit_xy_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_xy_ext")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBit_xy_idx::OpBit_xy_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "bit_xy_idx")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b = ((_subword_ >> 6) & 0x1ULL);
	}
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpBit_xy_idx::~OpBit_xy_idx()
{
	delete xb;
}

OpBset_dir::OpBset_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "bset_dir")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		dd = ((_subword_ >> 8) & 0xffULL);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBset_ext::OpBset_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "bset_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBset_idx::OpBset_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "bset_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		mm = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBset_idx::~OpBset_idx()
{
	delete xb;
}

OpLsl_ext::OpLsl_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsl_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsl_idx::OpLsl_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsl_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLsl_idx::~OpLsl_idx()
{
	delete xb;
}

OpLsla::OpLsla(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsla")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLslb::OpLslb(CodeType const& code, uint16_t addr) : Operation(code, addr, "lslb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLsld::OpLsld(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsld")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLslw_ext::OpLslw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "lslw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLslw_idx::OpLslw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lslw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLslw_idx::~OpLslw_idx()
{
	delete xb;
}

OpLslx::OpLslx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lslx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsly::OpLsly(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsly")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRol_ext::OpRol_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "rol_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRol_idx::OpRol_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rol_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpRol_idx::~OpRol_idx()
{
	delete xb;
}

OpRola::OpRola(CodeType const& code, uint16_t addr) : Operation(code, addr, "rola")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRolb::OpRolb(CodeType const& code, uint16_t addr) : Operation(code, addr, "rolb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRolw_ext::OpRolw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "rolw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRolw_idx::OpRolw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rolw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpRolw_idx::~OpRolw_idx()
{
	delete xb;
}

OpRolx::OpRolx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rolx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRoly::OpRoly(CodeType const& code, uint16_t addr) : Operation(code, addr, "roly")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsr_ext::OpLsr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsr_idx::OpLsr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLsr_idx::~OpLsr_idx()
{
	delete xb;
}

OpLsra::OpLsra(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsra")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLsrb::OpLsrb(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLsrd::OpLsrd(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrd")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLsrw_ext::OpLsrw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsrw_idx::OpLsrw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpLsrw_idx::~OpLsrw_idx()
{
	delete xb;
}

OpLsrx::OpLsrx(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsrx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLsry::OpLsry(CodeType const& code, uint16_t addr) : Operation(code, addr, "lsry")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRor_ext::OpRor_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "ror_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRor_idx::OpRor_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "ror_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpRor_idx::~OpRor_idx()
{
	delete xb;
}

OpRora::OpRora(CodeType const& code, uint16_t addr) : Operation(code, addr, "rora")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRorb::OpRorb(CodeType const& code, uint16_t addr) : Operation(code, addr, "rorb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRorw_ext::OpRorw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "rorw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRorw_idx::OpRorw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rorw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpRorw_idx::~OpRorw_idx()
{
	delete xb;
}

OpRorx::OpRorx(CodeType const& code, uint16_t addr) : Operation(code, addr, "rorx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRory::OpRory(CodeType const& code, uint16_t addr) : Operation(code, addr, "rory")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAsr_ext::OpAsr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "asr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAsr_idx::OpAsr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "asr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAsr_idx::~OpAsr_idx()
{
	delete xb;
}

OpAsra::OpAsra(CodeType const& code, uint16_t addr) : Operation(code, addr, "asra")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpAsrb::OpAsrb(CodeType const& code, uint16_t addr) : Operation(code, addr, "asrb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpAsrw_ext::OpAsrw_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "asrw_ext")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAsrw_idx::OpAsrw_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "asrw_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpAsrw_idx::~OpAsrw_idx()
{
	delete xb;
}

OpAsrx::OpAsrx(CodeType const& code, uint16_t addr) : Operation(code, addr, "asrx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpAsry::OpAsry(CodeType const& code, uint16_t addr) : Operation(code, addr, "asry")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBtas_dir::OpBtas_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "btas_dir")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr8a = ((_subword_ >> 8) & 0xffULL);
		msk8 = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBtas_ext::OpBtas_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "btas_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 8) & 0xffffULL);
		msk8 = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBtas_idx::OpBtas_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "btas_idx")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		msk8 = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBtas_idx::~OpBtas_idx()
{
	delete xb;
}

OpEmul::OpEmul(CodeType const& code, uint16_t addr) : Operation(code, addr, "emul")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpEmuls::OpEmuls(CodeType const& code, uint16_t addr) : Operation(code, addr, "emuls")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpMul::OpMul(CodeType const& code, uint16_t addr) : Operation(code, addr, "mul")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpEdiv::OpEdiv(CodeType const& code, uint16_t addr) : Operation(code, addr, "ediv")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpEdivs::OpEdivs(CodeType const& code, uint16_t addr) : Operation(code, addr, "edivs")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpFdiv::OpFdiv(CodeType const& code, uint16_t addr) : Operation(code, addr, "fdiv")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpIdiv::OpIdiv(CodeType const& code, uint16_t addr) : Operation(code, addr, "idiv")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpIdivs::OpIdivs(CodeType const& code, uint16_t addr) : Operation(code, addr, "idivs")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpEmacs::OpEmacs(CodeType const& code, uint16_t addr) : Operation(code, addr, "emacs")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpSbr::OpSbr(CodeType const& code, uint16_t addr) : Operation(code, addr, "sbr")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		sel = ((_subword_ >> 8) & 0xfULL);
		rel8 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpLbr::OpLbr(CodeType const& code, uint16_t addr) : Operation(code, addr, "lbr")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		sel = ((_subword_ >> 16) & 0xfULL);
		rel16 = (((int32_t((_subword_ >> 0) & 0xffffLL)) << 16) >> 16);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBr_clr_set_dir::OpBr_clr_set_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "br_clr_set_dir")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		b = ((_subword_ >> 24) & 0x1ULL);
		opr8a = ((_subword_ >> 16) & 0xffULL);
		msk8 = ((_subword_ >> 8) & 0xffULL);
		rel8 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBr_clr_set_ext::OpBr_clr_set_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "br_clr_set_ext")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 1 );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 16) & 0xffffULL);
		msk8 = ((_subword_ >> 8) & 0xffULL);
		rel8 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpBr_clr_set_idx::OpBr_clr_set_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "br_clr_set_idx")
{
	CodeType _code_( code );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		b = ((_subword_ >> 0) & 0x1ULL);
	}
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		msk8 = ((_subword_ >> 8) & 0xffULL);
		rel8 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpBr_clr_set_idx::~OpBr_clr_set_idx()
{
	delete xb;
}

OpBsr::OpBsr(CodeType const& code, uint16_t addr) : Operation(code, addr, "bsr")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		rel8 = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCall_ext::OpCall_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "call_ext")
{
	CodeType _code_( code );
	{
		uint32_t _subword_ = (uint32_t( _code_.str[0] ) << 24) | (uint32_t( _code_.str[1] ) << 16) | (uint32_t( _code_.str[2] ) << 8) | (uint32_t( _code_.str[3] ) << 0);
		opr16a = ((_subword_ >> 8) & 0xffffULL);
		page = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 4 );
	this->encoding.size -= _code_.size;
}

OpCall_16offset_idx_ind::OpCall_16offset_idx_ind(CodeType const& code, uint16_t addr) : Operation(code, addr, "call_16offset_idx_ind")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		rr = ((_subword_ >> 3) & 0x3ULL);
	}
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		n16 = (((int32_t((_subword_ >> 0) & 0xffffLL)) << 16) >> 16);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpCall_accD_offset_idx_ind::OpCall_accD_offset_idx_ind(CodeType const& code, uint16_t addr) : Operation(code, addr, "call_accD_offset_idx_ind")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		rr = ((_subword_ >> 3) & 0x3ULL);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpJmp_ext::OpJmp_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "jmp_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpJmp_idx::OpJmp_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "jmp_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpJmp_idx::~OpJmp_idx()
{
	delete xb;
}

OpJsr_dir::OpJsr_dir(CodeType const& code, uint16_t addr) : Operation(code, addr, "jsr_dir")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr8a = ((_subword_ >> 0) & 0xffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpJsr_ext::OpJsr_ext(CodeType const& code, uint16_t addr) : Operation(code, addr, "jsr_ext")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		opr16a = ((_subword_ >> 0) & 0xffffULL);
	}
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpJsr_idx::OpJsr_idx(CodeType const& code, uint16_t addr) : Operation(code, addr, "jsr_idx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpJsr_idx::~OpJsr_idx()
{
	delete xb;
}

OpRtc::OpRtc(CodeType const& code, uint16_t addr) : Operation(code, addr, "rtc")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRts::OpRts(CodeType const& code, uint16_t addr) : Operation(code, addr, "rts")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpLoop::OpLoop(CodeType const& code, uint16_t addr) : Operation(code, addr, "loop")
{
	CodeType _code_( code );
	{
		uint16_t _subword_ = (uint16_t( _code_.str[0] ) << 8) | (uint16_t( _code_.str[1] ) << 0);
		b765 = ((_subword_ >> 5) & 0x7ULL);
		b4 = ((_subword_ >> 4) & 0x1ULL);
		b3 = ((_subword_ >> 3) & 0x1ULL);
		b210 = ((_subword_ >> 0) & 0x7ULL);
	}
	_code_.pop( 2 );
	{
		uint8_t _subword_ = (uint8_t( _code_.str[0] ) << 0);
		rel9 = (((int32_t((_subword_ >> 0) & 0xffLL)) << 24) >> 24);
	}
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPsha::OpPsha(CodeType const& code, uint16_t addr) : Operation(code, addr, "psha")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshb::OpPshb(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshc::OpPshc(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshc")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshcw::OpPshcw(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshcw")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpPshd::OpPshd(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshd")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshx::OpPshx(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPshy::OpPshy(CodeType const& code, uint16_t addr) : Operation(code, addr, "pshy")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPula::OpPula(CodeType const& code, uint16_t addr) : Operation(code, addr, "pula")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPulb::OpPulb(CodeType const& code, uint16_t addr) : Operation(code, addr, "pulb")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPulc::OpPulc(CodeType const& code, uint16_t addr) : Operation(code, addr, "pulc")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPulcw::OpPulcw(CodeType const& code, uint16_t addr) : Operation(code, addr, "pulcw")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpPuld::OpPuld(CodeType const& code, uint16_t addr) : Operation(code, addr, "puld")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPulx::OpPulx(CodeType const& code, uint16_t addr) : Operation(code, addr, "pulx")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpPuly::OpPuly(CodeType const& code, uint16_t addr) : Operation(code, addr, "puly")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpMem::OpMem(CodeType const& code, uint16_t addr) : Operation(code, addr, "mem")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRev::OpRev(CodeType const& code, uint16_t addr) : Operation(code, addr, "rev")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpRevw::OpRevw(CodeType const& code, uint16_t addr) : Operation(code, addr, "revw")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpWav::OpWav(CodeType const& code, uint16_t addr) : Operation(code, addr, "wav")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpWavr::OpWavr(CodeType const& code, uint16_t addr) : Operation(code, addr, "wavr")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpTbl::OpTbl(CodeType const& code, uint16_t addr) : Operation(code, addr, "tbl")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpTbl::~OpTbl()
{
	delete xb;
}

OpEtlb::OpEtlb(CodeType const& code, uint16_t addr) : Operation(code, addr, "etlb")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	xb = unisim::component::cxx::processor::hcs12x::XB::sub_decode( addr, unisim::component::cxx::processor::hcs12x::XB::CodeType( _code_.str, _code_.size ) );
	_code_.pop( xb->GetEncoding().size );
	this->encoding.size -= _code_.size;
}

OpEtlb::~OpEtlb()
{
	delete xb;
}

OpNop::OpNop(CodeType const& code, uint16_t addr) : Operation(code, addr, "nop")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpStop::OpStop(CodeType const& code, uint16_t addr) : Operation(code, addr, "stop")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

OpWait::OpWait(CodeType const& code, uint16_t addr) : Operation(code, addr, "wait")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpBgnd::OpBgnd(CodeType const& code, uint16_t addr) : Operation(code, addr, "bgnd")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpRti::OpRti(CodeType const& code, uint16_t addr) : Operation(code, addr, "rti")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpSwi::OpSwi(CodeType const& code, uint16_t addr) : Operation(code, addr, "swi")
{
	CodeType _code_( code );
	_code_.pop( 1 );
	this->encoding.size -= _code_.size;
}

OpSys::OpSys(CodeType const& code, uint16_t addr) : Operation(code, addr, "sys")
{
	CodeType _code_( code );
	_code_.pop( 2 );
	this->encoding.size -= _code_.size;
}

DecodeMapPage::DecodeMapPage(uint16_t key)
{
	this->key = key;
	memset(operation, 0, sizeof(operation));
	next = 0;
}

DecodeMapPage::~DecodeMapPage()
{
	unsigned int idx;
	for(idx = 0; idx < NUM_OPERATIONS_PER_PAGE; idx++)
	delete operation[idx];
}

DecodeTableEntry::DecodeTableEntry(CodeType const& opcode, CodeType const& opcode_mask, Operation *(*decode)(CodeType const&, uint16_t))
{
	this->opcode = opcode;
	this->opcode_mask = opcode_mask;
	this->decode = decode;
}

Decoder::Decoder()
{
	little_endian = false;
	mru_page = 0;
	memset(decode_hash_table, 0, sizeof(decode_hash_table));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa7" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSys));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3f" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpSwi));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x0b" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRti));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x00" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBgnd));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3e" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpWait));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3e" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpStop));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa7" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpNop));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3f" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEtlb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3d" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpTbl));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3c" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpWavr));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3c" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpWav));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3b" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRevw));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x3a" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRev));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x01" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpMem));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x31" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPuly));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x30" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPulx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3a" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPuld));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x38" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpPulcw));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x38" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPulc));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x33" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPulb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x32" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPula));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x35" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x34" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3b" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshd));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x39" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpPshcw));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x39" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshc));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x37" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPshb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x36" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpPsha));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x04" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLoop));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x3d" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRts));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x0a" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRtc));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x15" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJsr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x16" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJsr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x17" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJsr_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x05" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJmp_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x06" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpJmp_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4b\xe7" ), 2 ), CodeType( (uint8_t*)( "\xff\xe7" ), 2 ), DecodeOpCall_accD_offset_idx_ind));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4b\xe3" ), 2 ), CodeType( (uint8_t*)( "\xff\xe7" ), 2 ), DecodeOpCall_16offset_idx_ind));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4a" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpCall_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x07" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBsr));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x06" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpBr_clr_set_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1e" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpBr_clr_set_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4e" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpBr_clr_set_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x20" ), 2 ), CodeType( (uint8_t*)( "\xff\xf0" ), 2 ), DecodeOpLbr));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x20" ), 1 ), CodeType( (uint8_t*)( "\xf0" ), 1 ), DecodeOpSbr));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x12" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEmacs));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x15" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIdivs));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x10" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIdiv));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x11" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpFdiv));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x14" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEdivs));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x11" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpEdiv));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x12" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpMul));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x13" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpEmuls));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x13" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpEmul));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x37" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpBtas_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x36" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpBtas_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x35" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpBtas_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x57" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAsry));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x47" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAsrx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x67" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAsrw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x77" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAsrw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x57" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAsrb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x47" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAsra));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x67" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAsr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x77" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAsr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x56" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRory));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x46" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRorx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x66" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRorw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x76" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRorw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x56" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRorb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x46" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRora));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x66" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRor_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x76" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRor_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x54" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsry));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x44" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsrx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x64" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsrw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x74" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsrw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x49" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsrd));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x54" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsrb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x44" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsra));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x64" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x74" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x55" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRoly));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x45" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRolx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x65" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRolw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x75" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpRolw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x55" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRolb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x45" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRola));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x65" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRol_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x75" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpRol_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x58" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLsly));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x48" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLslx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x68" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLslw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x78" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpLslw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x59" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsld));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x58" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLslb));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x48" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsla));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x68" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsl_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x78" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLsl_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x0c" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBset_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1c" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBset_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4c" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBset_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa5" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpBit_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb5" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpBit_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x95" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpBit_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x85" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpBit_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa5" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpBit_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb5" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpBit_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x95" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpBit_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x85" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpBit_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x0d" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBclr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1d" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBclr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4d" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpBclr_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x40" ), 2 ), CodeType( (uint8_t*)( "\xff\xef" ), 2 ), DecodeOpNeg_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x60" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpNegw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x70" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpNegw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x40" ), 1 ), CodeType( (uint8_t*)( "\xef" ), 1 ), DecodeOpNeg_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x60" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpNeg_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x70" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpNeg_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x41" ), 2 ), CodeType( (uint8_t*)( "\xff\xef" ), 2 ), DecodeOpCom_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x61" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpComw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x71" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpComw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x41" ), 1 ), CodeType( (uint8_t*)( "\xef" ), 1 ), DecodeOpCom_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x61" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpCom_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x71" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpCom_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x87" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpClr_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x87" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpClr_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x69" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpClrw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x79" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpClrw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x69" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpClr_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x79" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpClr_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x10\xfd" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpClv));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x10\xef" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpCli));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x10\xfe" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpClc));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa8" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpEor_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb8" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpEor_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x98" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpEor_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x88" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpEor_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa8" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpEor_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb8" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpEor_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x98" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpEor_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x88" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpEor_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xaa" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpOr_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xba" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpOr_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x9a" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpOr_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x8a" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpOr_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x14" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpOrcc_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xaa" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpOra_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xba" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpOra_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x9a" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpOra_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x8a" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpOra_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa4" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAnd_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb4" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAnd_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x94" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAnd_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x84" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAnd_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x10" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpAndcc_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa4" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAnd_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb4" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAnd_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x94" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAnd_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x84" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAnd_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x18" ), 2 ), CodeType( (uint8_t*)( "\xff\xfb" ), 2 ), DecodeOpMax_am));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x1a" ), 2 ), CodeType( (uint8_t*)( "\xff\xfb" ), 2 ), DecodeOpEmax_dm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x19" ), 2 ), CodeType( (uint8_t*)( "\xff\xfb" ), 2 ), DecodeOpMin_am));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x1b" ), 2 ), CodeType( (uint8_t*)( "\xff\xfb" ), 2 ), DecodeOpEmin_dm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x97" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpTst_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xe7" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpTstw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xf7" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpTstw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x97" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpTst_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xe7" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpTst_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xf7" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpTst_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xac" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpCpe_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xbc" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpCpe_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x9c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpCpe_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x8c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpCpe_dyxs_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xac" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpCp_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xbc" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpCp_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x9c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpCp_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x8c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpCp_dyxs_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa1" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpCmp_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb1" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpCmp_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x91" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpCmp_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x81" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpCmp_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x17" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpCba));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x02" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpIny));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x08" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpInx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1b\x81" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIns));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x42" ), 2 ), CodeType( (uint8_t*)( "\xff\xef" ), 2 ), DecodeOpInc_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x62" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIncw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x72" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpIncw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x42" ), 1 ), CodeType( (uint8_t*)( "\xef" ), 1 ), DecodeOpInc_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x62" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpInc_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x72" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpInc_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x03" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpDey));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x09" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpDex));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1b\x9f" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpDes));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x43" ), 2 ), CodeType( (uint8_t*)( "\xff\xef" ), 2 ), DecodeOpDec_xy));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x63" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpDecw_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x73" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpDecw_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x43" ), 1 ), CodeType( (uint8_t*)( "\xef" ), 1 ), DecodeOpDec_ab));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x63" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpDec_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x73" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpDec_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x07" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpDaa));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa0" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSub_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb0" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSub_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x90" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSub_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x80" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSub_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa0" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSub_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb0" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSub_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x90" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSub_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x80" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSub_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa2" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSbe_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb2" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSbe_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x92" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSbe_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x82" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpSbe_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSbed_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSbed_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x93" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSbed_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x83" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSbed_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa2" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSbc_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb2" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSbc_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x92" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSbc_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x82" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpSbc_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x16" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpSba));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa3" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_sub_d_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb3" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_sub_d_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x93" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_sub_d_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x83" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_sub_d_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xab" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAdd_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xbb" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAdd_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x9b" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAdd_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x8b" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAdd_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa9" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAde_xy_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb9" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAde_xy_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x99" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAde_xy_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x89" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpAde_xy_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xe3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAded_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xf3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAded_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xd3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAded_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xc3" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAded_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xab" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xbb" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x9b" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x8b" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdd_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa9" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdc_ab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb9" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdc_ab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x99" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdc_ab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x89" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpAdc_ab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x19\xed" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAby));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1a\xe5" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAbx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x06" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpAba));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x02" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_02));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x05" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_05));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x01" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_01));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x04" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_04));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x00" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_00));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x03" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovw_03));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0a" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_0A));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0d" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_0D));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x09" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_09));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0c" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_0C));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x08" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_08));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0b" ), 2 ), CodeType( (uint8_t*)( "\xff\xff" ), 2 ), DecodeOpMovb_0B));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb7\x08" ), 2 ), CodeType( (uint8_t*)( "\xff\x88" ), 2 ), DecodeOpTfr_hcs12x));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb7\x88" ), 2 ), CodeType( (uint8_t*)( "\xff\x88" ), 2 ), DecodeOpExg_hcs12x));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb7\x00" ), 2 ), CodeType( (uint8_t*)( "\xff\x80" ), 2 ), DecodeOpTfr_hcs12));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb7\x80" ), 2 ), CodeType( (uint8_t*)( "\xff\x88" ), 2 ), DecodeOpExg_hcs12));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x0e" ), 2 ), CodeType( (uint8_t*)( "\xff\xfe" ), 2 ), DecodeOpT_ab_ba));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x6c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGst_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x7c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGst_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x5c" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGst_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x6a" ), 2 ), CodeType( (uint8_t*)( "\xff\xfe" ), 2 ), DecodeOpGstaab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x7a" ), 2 ), CodeType( (uint8_t*)( "\xff\xfe" ), 2 ), DecodeOpGstaab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x5a" ), 2 ), CodeType( (uint8_t*)( "\xff\xfe" ), 2 ), DecodeOpGstaab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xec" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGld_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xfc" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGld_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xdc" ), 2 ), CodeType( (uint8_t*)( "\xff\xfc" ), 2 ), DecodeOpGld_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xa6" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpGldaab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\xb6" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpGldaab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18\x96" ), 2 ), CodeType( (uint8_t*)( "\xff\xbf" ), 2 ), DecodeOpGldaab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x6c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpSt_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x7c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpSt_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x5c" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpSt_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x6a" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpStaab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x7a" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpStaab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x5a" ), 1 ), CodeType( (uint8_t*)( "\xfe" ), 1 ), DecodeOpStaab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1b" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLeas));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x1a" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLeax));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x19" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpLeay));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xec" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpLd_dyxs_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xfc" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpLd_dyxs_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xdc" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpLd_dyxs_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xcc" ), 1 ), CodeType( (uint8_t*)( "\xfc" ), 1 ), DecodeOpLd_dyxs_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xa6" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpLdaab_idx));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\xb6" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpLdaab_ext));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x96" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpLdaab_dir));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x86" ), 1 ), CodeType( (uint8_t*)( "\xbf" ), 1 ), DecodeOpLdaab_imm));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x18" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpTrap));
	decode_table.push_back(DecodeTableEntry(CodeType( (uint8_t*)( "\x4b" ), 1 ), CodeType( (uint8_t*)( "\xff" ), 1 ), DecodeOpCall_idx));
}

Decoder::~Decoder()
{
	InvalidateDecodingCache();
}

void Decoder::Fetch( CodeType&, uint16_t )
{
	assert( ! "Calling unimplemented virtual method Fetch" );
}

Operation *Decoder::NCDecode(uint16_t addr)
{
	Operation *operation;
	CodeType code;
	Fetch( code, addr );
	unsigned int count = decode_table.size();
	unsigned int idx;
	for(idx = 0; idx < count; idx++)
	{
		if( code.match( decode_table[idx].opcode, decode_table[idx].opcode_mask) )
		{
			operation = decode_table[idx].decode(code, addr);
			return operation;
		}
	}
	operation = new Operation(code, addr, "???");
	return operation;
}

Operation *Decoder::NCDecode(uint16_t addr, CodeType const& code)
{
	Operation *operation;
	unsigned int count = decode_table.size();
	unsigned int idx;
	for(idx = 0; idx < count; idx++)
	{
		if( code.match( decode_table[idx].opcode, decode_table[idx].opcode_mask) )
		{
			operation = decode_table[idx].decode(code, addr);
			return operation;
		}
	}
	operation = new Operation(code, addr, "???");
	return operation;
}

void Decoder::InvalidateDecodingCache()
{
	uint32_t index;
	mru_page = 0;
	for(index = 0; index < NUM_DECODE_HASH_TABLE_ENTRIES; index++)
	{
		DecodeMapPage *page, *next_page;
		page = decode_hash_table[index];
		if(page)
		{
			do
			{
				next_page = page->next;
				delete page;
				page = next_page;
			} while(page);
			decode_hash_table[index] = 0;
		}
	}
}

void Decoder::InvalidateDecodingCacheEntry(uint16_t addr)
{
	uint16_t page_key = addr / NUM_OPERATIONS_PER_PAGE;
	if(mru_page && mru_page->key == page_key) mru_page = 0;
	uint32_t index = page_key % NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key
	DecodeMapPage *prev, *cur;
	cur = decode_hash_table[index];
	if(cur)
	{
		if(cur->key == page_key)
		{
			decode_hash_table[index] = cur->next;
			delete cur;
			return;
		}
		prev = cur;
		cur = cur->next;
		if(cur)
		{
			do
			{
				if(cur->key == page_key)
				{
					prev->next = cur->next;
					cur->next = 0;
					delete cur;
					return;
				}
				prev = cur;
			} while((cur = cur->next) != 0);
		}
	}
}

inline DecodeMapPage *Decoder::FindPage(uint16_t page_key)
{
	if(mru_page && mru_page->key == page_key) return mru_page;
	uint32_t index = page_key % NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key
	DecodeMapPage *prev, *cur;
	cur = decode_hash_table[index];
	if(cur)
	{
		if(cur->key == page_key)
		{
			mru_page = cur;
			return cur;
		}
		prev = cur;
		cur = cur->next;
		if(cur)
		{
			do
			{
				if(cur->key == page_key)
				{
					prev->next = cur->next;
					cur->next= decode_hash_table[index];
					decode_hash_table[index] = cur;
					mru_page = cur;
					return cur;
				}
				prev = cur;
			} while((cur = cur->next) != 0);
		}
	}
	return 0;
}

Operation *Decoder::Decode(uint16_t addr)
{
	Operation *operation;
	uint16_t page_key = addr / NUM_OPERATIONS_PER_PAGE;
	DecodeMapPage *page;
	page = FindPage(page_key);
	if(!page)
	{
		page = new DecodeMapPage(page_key);
		uint32_t index = page_key % NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key
		page->next = decode_hash_table[index];
		decode_hash_table[index] = page;
		mru_page = page;
	}
	operation = page->operation[(addr) & (NUM_OPERATIONS_PER_PAGE - 1)];
	if(operation)
	{
		return operation;
	}
	operation = NCDecode(addr);
	page->operation[(addr) & (NUM_OPERATIONS_PER_PAGE - 1)] = operation;
	return operation;
}

Operation *Decoder::Decode(uint16_t addr, CodeType const& insn)
{
	Operation *operation;
	uint16_t page_key = addr / NUM_OPERATIONS_PER_PAGE;
	DecodeMapPage *page;
	page = FindPage(page_key);
	if(!page)
	{
		page = new DecodeMapPage (page_key);
		uint32_t index = page_key % NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key
		page->next = decode_hash_table[index];
		decode_hash_table[index] = page;
		mru_page = page;
	}
	operation = page->operation[(addr) & (NUM_OPERATIONS_PER_PAGE - 1)];
	if(operation)
	{
		if(insn.match( operation->GetEncoding() ) && operation->GetAddr() == addr)
		return operation;
		delete operation;
	}
	operation = NCDecode(addr, insn);
	page->operation[(addr) & (NUM_OPERATIONS_PER_PAGE - 1)] = operation;
	return operation;
}

void Decoder::SetLittleEndian()
{
	little_endian = true;
}

void Decoder::SetBigEndian()
{
	little_endian = false;
}

} } } } }
