// -*- C++ -*-

// EMUL: 16 by 16 Bit Multiply (unsigned) (D) x (Y) => Y:D
op emul(0x13[8])

emul.disasm = {
	sink << "EMUL";
}

emul.execute = {
	uint32_t result = cpu->getRegD() * cpu->getRegY();

	cpu->setRegY(result >> 16);
	cpu->setRegD((uint16_t) result);

	if (result > 0xFFFF) { cpu->ccr->setC(1); } else { cpu->ccr->setC(0); }	
	if (result == 0) { cpu->ccr->setZ(1); } else { cpu->ccr->setZ(0); }
	if ((result & 0x80000000) == 0x80000000) { cpu->ccr->setN(1); } else { cpu->ccr->setN(0); }
}

// EMULS: 16 by 16 Bit Multiply (signed) (D) x (Y) => Y:D
op emuls(0x18[8]:0x13[8])

emuls.disasm = {
	sink << "EMULS";
}

emuls.execute = {
	uint32_t result = cpu->getRegD() * cpu->getRegY();

	cpu->setRegY((uint16_t) (result >> 16));
	cpu->setRegD((uint16_t) result);

/*
 * C: Set if bit 15 of the result is set; cleared otherwise
 */
	if ((result & 0x8000) > 0x8000) { cpu->ccr->setC(1); } else { cpu->ccr->setC(0); }	

/*
 * Z: Set if result is $00000000; cleared otherwise
 */	
	if (result == 0) { cpu->ccr->setZ(1); } else { cpu->ccr->setZ(0); }

/*
 * N: Set if the MSB of the result is set; cleared otherwise
 */
	if ((result & 0x80000000) == 0x80000000) { cpu->ccr->setN(1); } else { cpu->ccr->setN(0); }

	
}

// MUL: 8 by 8 Bit Multiply (unsigned) (A) x (B) => A:B
op mul(0x12[8])

mul.disasm = {
	sink << "MUL";
}

mul.execute = {
	uint16_t result = cpu->getRegA() * cpu->getRegB();

	cpu->setRegD(result);

	if (result > 0xFF) { cpu->ccr->setC(1); } else { cpu->ccr->setC(0); }	
}

// EDIV: 32 by 16 bit to 16 bit divide (unsigned) (Y:D) div (X) => Y remainder => D
op ediv(0x11[8])

ediv.disasm = {
	sink << "EDIV";
}

ediv.execute = {
	// TODO
	/*
	 * source_url: http://www.embeddedrelated.com/groups/68hc12/show/3775.php
	 * 
	 * U16 X, Y, Z;
	 * X = (U16)(((U32)Y * 1000) / (U16)Z);
	 * 
	 * with an EMUL and an EDIV is that if the 32/16 bit EDIV division overflows, then the
	 * HC12 does not generate a result at all (it just sets the V flag). 
	 * Therefore using a simple EDIV does not generate the same result
	 * for all possible Y and Z's as calculating it with longs.
	 */
	uint32_t dividend = ((uint32_t) cpu->getRegY() << 16) | (0x00FF & cpu->getRegD());
	uint16_t divisor = cpu->getRegX();
	uint32_t quotion = cpu->getRegY();
	uint16_t remind = cpu->getRegD();
	 
	if (divisor == 0) {
		// TODO: throw an exception "division by 0"
		cpu->ccr->setC(1);
	} else {
		cpu->ccr->setC(0);
		quotion = dividend / divisor;
		remind = dividend % divisor;
		
		if (quotion > 0xFFFF) {
			cpu->ccr->setV(1);
		} else {
			cpu->ccr->setV(0);
	
			cpu->setRegY((uint16_t) quotion);
			cpu->setRegD(remind);
			
			if (quotion == 0) { cpu->ccr->setZ(1); } else { cpu->ccr->setZ(0); }
			if (cpu->getRegY() & 0x8000 == 0x8000 ) { cpu->ccr->setN(1); } else { cpu->ccr->setN(0); }
		}  
	}

}

// EDIVS: 32 by 16 bit to 16 bit divide (signed)  (Y:D) div (X) => Y remainder => D
op edivs(0x18[8]:0x14[8])

edivs.disasm = {
	sink << "EDIVS";
}

edivs.execute = {
	
	uint32_t dividend = ((uint32_t) cpu->getRegY() << 16) | (0x00FF & cpu->getRegD());
	uint16_t divisor = cpu->getRegX();
	uint32_t quotion = cpu->getRegY();
	uint16_t remind = cpu->getRegD();
	 
	if (divisor == 0) {
		// TODO: throw an exception "division by 0"
		cpu->ccr->setC(1);
	} else {
		cpu->ccr->setC(0);
		
		quotion = dividend / divisor;
		remind = dividend % divisor;

		if ((uint16_t) quotion > 0x7FFF) {
			cpu->ccr->setV(1);
		} else {
			cpu->ccr->setV(0);
			
			cpu->setRegY((uint16_t) quotion); // cpu->setRegY((uint16_t) quotion | ((quotion >> 16) & 0x8000));
			cpu->setRegD(remind);
			
			if (quotion == 0) { cpu->ccr->setZ(1); } else { cpu->ccr->setZ(0); }

			if (cpu->getRegY() & 0x8000 == 0x8000 ) { cpu->ccr->setN(1); } else { cpu->ccr->setN(0); }
		}  
	}
}

// FDIV: 16 by 16 fractional divide
op fdiv(0x18[8]:0x11[8])

fdiv.disasm = {
	sink << "FDIV";
}

fdiv.execute = {
	/* FDIV is equivalent to multiplying the numerator by 2^16 and then performing 32 by 16-bit integer division. */
	
	uint32_t dividend = (uint32_t) cpu->getRegD() << 16;
	uint16_t divisor = cpu->getRegX();
	uint16_t quotion = 0xFFFF;
	uint16_t remind = dividend;
	
	if (divisor == 0) { 
		cpu->ccr->setC(1); 
	} else { 
		cpu->ccr->setC(0); 
		if (dividend >= divisor) {
			cpu->ccr->setV(1);
		} else {
			cpu->ccr->setV(0);
			quotion = dividend / divisor;
			remind = dividend % divisor;
		} 
	}
	
	cpu->setRegX(quotion);
	cpu->setRegD(remind);
	if (quotion == 0) { cpu->ccr->setZ(1); }  else { cpu->ccr->setZ(0); }
}

// IDIV: 16 by 16 integer divide (unsigned)
op idiv(0x18[8]:0x10[8])

idiv.disasm = {
	sink << "IDIV";
}

idiv.execute = {
/* In the case of division by zero, C is set, the quotient is set to $FFFF,
and the remainder is indeterminate. */

	uint16_t dividend = cpu->getRegD();
	uint16_t divisor = cpu->getRegX();
	uint16_t quotion = 0xFFFF;
	uint16_t remind = dividend;

	cpu->ccr->setV(0);	
	if (divisor == 0) { 
		cpu->ccr->setC(1); 
	} else { 
		cpu->ccr->setC(0); 
		quotion = dividend / divisor;
		remind = dividend % divisor;
	}
	
	cpu->setRegX(quotion);
	cpu->setRegD(remind);
	if (quotion == 0) { cpu->ccr->setZ(1); }  else { cpu->ccr->setZ(0); }
}

// IDIVS: 16 by 16 integer divide (signed)
op idivs(0x18[8]:0x15[8])

idivs.disasm = {
	sink << "IDIVS";
}

idivs.execute = {
	/* In the case of division by zero, C is set, the quotient is set to $FFFF,
and the remainder is indeterminate. */

	uint16_t dividend = cpu->getRegD();
	uint16_t divisor = cpu->getRegX();
	uint16_t quotion = 0xFFFF;
	uint16_t remind = dividend;

	cpu->ccr->setV(0);	
	if (divisor == 0) { 
		cpu->ccr->setC(1); 
	} else { 
		cpu->ccr->setC(0); 
		quotion = dividend / divisor;
		remind = dividend % divisor;
	}
	
	cpu->setRegX(quotion);
	cpu->setRegD(remind);
/*
 * V: Set if the result was > $7FFF or < $8000; cleared otherwise
 * Undefined after division by zero
 */
	if ((dividend == 0x8000) && (divisor == 0xFFFF)) { cpu->ccr->setV(1); } else { cpu->ccr->setV(0);}
	if (quotion == 0) { cpu->ccr->setZ(1); }  else { cpu->ccr->setZ(0); }
	if ((quotion & 0x8000) == 0x8000) { cpu->ccr->setN(1); } else { cpu->ccr->setN(0); } 
}


/* ********* Multiply and Accumulate instruction ********* */

// EMACS: Multiply an Accumulate Instruction
op emacs(0x18[8]:0x12[8]:opr16a[16])

emacs.disasm = {
	sink << "EMACS $" << std::hex << opr16a;
}

emacs.execute = {
	/* operation: (M(X) : M(X+1)) × (M(Y) : M(Y+1)) + (M ~ M+3) ⇒ M ~ M+3 */

	uint16_t xOpr, yOpr;
	uint32_t accOpr, result, inter;
	
	xOpr = cpu->memRead16(cpu->getRegX());
	yOpr = cpu->memRead16(cpu->getRegY());
	accOpr = cpu->memRead16(opr16a);
	accOpr = (accOpr << 16) | cpu->memRead16(opr16a+2); 
	
	inter = (uint32_t) xOpr * yOpr;
	result =  inter + accOpr;
	
	cpu->memWrite16(opr16a, (uint16_t) (accOpr >> 16));
	cpu->memWrite16(opr16a+2, (uint16_t) accOpr);
	
	// N: Set if MSB of result is set; cleared otherwise
	if (result & 0x80000000 == 0x80000000) { cpu->ccr->setN(1); } else { cpu->ccr->setN(0); }
	
	// Z: Set if result is $00000000; cleared otherwise
	if (result == 0) { cpu->ccr->setZ(1); } else { cpu->ccr->setZ(0); }
	 /*
	  * I: Intermediate result
	  * R: Result
	  * M: 32 bit accumulator in memory (second operand in the addition)
	  * */
	  
	/* V: M31 • I31 • !R31 + !M31 • !I31 • R31
	 * Set if result > $7FFFFFFF (+ overflow) or < $80000000 (– underflow)
	 * Indicates two’s complement overflow
	 */
	// if (result > 0x7FFFFFFF) { cpu->ccr->setV(1); } else { cpu->ccr->setV(0); }
	cpu->ccr->setV(((accOpr & 0x80000000) & (inter & 0x80000000) & ~(result & 0x80000000) | ~(accOpr & 0x80000000) & ~(inter & 0x80000000) & (result & 0x80000000)) >> 31);

	/* C: M15 • I15 + I15 • !R15 + !R15 • M15
	 * Set if there was a carry from bit 15 of the result; cleared otherwise
	 * Indicates a carry from low word to high word of the result occurred
	 */
	cpu->ccr->setC(((accOpr & 0x00008000) & (inter & 0x00008000) | (inter & 0x00008000) & ~(result & 0x00008000) | ~(result & 0x00008000) & (accOpr & 0x00008000)) >> 15);
	 
}

