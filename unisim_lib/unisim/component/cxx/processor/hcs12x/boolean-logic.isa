/*
 *  Copyright (c) 2008,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
 */


// ANDA/ANDB  IMM  (regAB & ii => regAB)
op and_ab_imm(0b1[1]:b[1]:0x04[6]:opr8i[8])

and_ab_imm.getCycles = { return 1; }

and_ab_imm.disasm = {
	if (b==0) {
		sink << "ANDA #$";
	} else {
		sink << "ANDB #$";
	}
	sink << std::hex << opr8i;
}

and_ab_imm.execute = {
	uint8_t result;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	result = regVal & opr8i;
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// ANDA/ANDB  DIR  (regAB & mem[regDirect:opr8a] => regAB)s
op and_ab_dir(0b1[1]:b[1]:0x14[6]:opr8a[8])

and_ab_dir.getCycles = { return 3; }

and_ab_dir.disasm = {
	if (b==0) {
		sink << "ANDA $";
	} else {
		sink << "ANDB $"; 
	}
	sink << std::hex << opr8a;
}

and_ab_dir.execute = {
	uint8_t result;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint8_t opr8aVal = cpu->memRead8(addr);

	result = regVal & opr8aVal;
		
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ANDA/ANDB EXT (regAB & mem[opr16a] => regAB)
op and_ab_ext(0b1[1]:b[1]:0x34[6]:> <:opr16a[16])

and_ab_ext.getCycles = { return 3; }

and_ab_ext.disasm = {
	if (b==0) {
		sink << "ANDA $";
	} else {
		sink << "ANDB $";		
	}
	sink << std::hex << opr16a;
}

and_ab_ext.execute = {
	uint8_t result;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t opr16aVal = cpu->memRead8(addr);

	result = regVal & opr16aVal;	

	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ANDA/ANDB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regAB & mem[xb->addrE] => regAB)
op and_ab_idx(0b1[1]:b[1]:0x24[6]:> <:*xb[XB])

and_ab_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }

and_ab_idx.disasm = {
	if (b==0){
		sink << "ANDA ";
	} else {
		sink << "ANDB ";
	}

	xb->disasm(sink);
}

and_ab_idx.execute = {
	uint8_t result;
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t xbVal = cpu->memRead8(addr);

	result = regVal & xbVal;
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ANDCC  IMM  (ccr & ii => ccr)
op andcc_imm(0x10[8]:opr8i[8])

andcc_imm.getCycles = { return 1; }

andcc_imm.disasm = {
	
	sink << "ANDCC #$" << std::hex << opr8i;
}

andcc_imm.execute = {
	uint8_t result;
	
	uint8_t regVal = cpu->ccr->getCCRLow();

	result = regVal & opr8i;
	
	cpu->ccr->setCCRLow(result);
	
}

// ANDX/ANDY IMM (regXY & opr16i => regXY)
op and_xy_imm(0x18[8]:0b1[1]:b[1]:0x04[6]:opr16i[16])

and_xy_imm.getCycles = { return 3; }

and_xy_imm.disasm = {
	if (b==0) {
		sink << "ANDX #$";
	} else {
		sink << "ANDY #$";
	}

	sink << std::hex << opr16i;
}

and_xy_imm.execute = {

	uint16_t result, regVal;
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal & opr16i;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ANDX/ANDY DIR (regXY & mem[regDirect:opr8a]:mem[regDirect:opr8a+1] => regXY)
op and_xy_dir(0x18[8]:0b1[1]:b[1]:0x14[6]:> <:opr8a[8])

and_xy_dir.getCycles = { return 4; }

and_xy_dir.disasm = {
	if (b==0) {
		sink << "ANDX $";
	} else {
		sink << "ANDY $";
	}

	sink << std::hex << opr8a;
}

and_xy_dir.execute = {

	uint16_t result, regVal;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint16_t opr8aVal = cpu->memRead16(addr);
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal & opr8aVal;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ANDX/ANDY EXT (regXY & mem[opr16a]:mem[opr16a+1] => regXY)
op and_xy_ext(0x18[8]:0b1[1]:b[1]:0x34[6]:opr16a[16])

and_xy_ext.getCycles = { return 4; }

and_xy_ext.disasm = {
	if (b==0) {
		sink << "ANDX $";
	} else {
		sink << "ANDY $";
	}

	sink << std::hex << opr16a;
}

and_xy_ext.execute = {

	uint16_t result, regVal;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t opr16aVal = cpu->memRead16(addr);
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal & opr16aVal;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ANDX/ANDY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regXY & mem[xb->addrE]:mem[xb->addrE+1] => regXY)
op and_xy_idx(0x18[8]:0b1[1]:b[1]:0x24[6]:> <:*xb[XB])

and_xy_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }

and_xy_idx.disasm = {
	if (b==0) {
		sink << "ANDX ";
	} else {
		sink << "ANDY ";
	}

	xb->disasm(sink);
}

and_xy_idx.execute = {

	uint16_t result, regVal;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t xbVal = cpu->memRead16(addr);
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal & xbVal;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ORAA/ORAB IMM (regAB or opr8i => regAB)

op ora_ab_imm(0b1[1]:b[1]:0x0A[6]:opr8i[8])

ora_ab_imm.getCycles = { return 1; }

ora_ab_imm.disasm = {
	if (b==0) {
		sink << "ORA #$";
	} else {
		sink << "ORB #$";
	}
	sink << std::hex << opr8i;
}

ora_ab_imm.execute = {
	uint8_t result;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	result = regVal | opr8i;
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
	
}

// ORAA/ORAB  DIR  (regAB | mem[regDirect:opr8a] => regAB)s
op ora_ab_dir(0b1[1]:b[1]:0x1A[6]:opr8a[8])

ora_ab_dir.getCycles = { return 3; }

ora_ab_dir.disasm = {
	if (b==0) {
		sink << "ORAA $";
	} else {
		sink << "ORAB $"; 
	}
	sink << std::hex << opr8a;
}

ora_ab_dir.execute = {
	uint8_t result;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint8_t opr8aVal = cpu->memRead8(addr);

	result = regVal | opr8aVal;
		
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ORAA/ORAB EXT (regAB | mem[opr16a] => regAB)
op ora_ab_ext(0b1[1]:b[1]:0x3A[6]:> <:opr16a[16])  

ora_ab_ext.getCycles = { return 3; }

ora_ab_ext.disasm = {
	if (b==0) {
		sink << "ORAA $";
	} else {
		sink << "ORAB $";		
	}
	sink << std::hex << opr16a;
}

ora_ab_ext.execute = {
	uint8_t result;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t opr16aVal = cpu->memRead8(addr);

	result = regVal | opr16aVal;	

	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ORAA/ORAB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regAB | mem[xb->addrE] => regAB)
op ora_ab_idx(0b1[1]:b[1]:0x2A[6]:> <:*xb[XB])

ora_ab_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }

ora_ab_idx.disasm = {
	if (b==0){
		sink << "ORAA ";
	} else {
		sink << "ORAB ";
	}

	xb->disasm(sink);
}

ora_ab_idx.execute = {
	uint8_t result;
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t xbVal = cpu->memRead8(addr);

	result = regVal | xbVal;
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ORCC  IMM  (ccr & ii => ccr)
op orcc_imm(0x14[8]:opr8i[8])

orcc_imm.getCycles = { return 1; }

orcc_imm.disasm = {
	
	sink << "ORCC #$" << std::hex << opr8i;
}

orcc_imm.execute = {
	uint8_t result, xFlag;
	
	uint8_t regVal = cpu->ccr->getCCRLow();

	// get ccr.X which may not be affected by ORCC instruction
	// if (ccr.X==1) then xFlag=0xFF else xFlag=0xBF;  0xBF = 0b10111111
	xFlag = regVal | 0xBF;  
	
	result = (regVal | opr8i) & xFlag;  
	
	cpu->ccr->setCCRLow(result);
	
}

// TODO: implement specialization ++++++++++++++

// SEC: set carry 
// use specialize orcc_imm with opr8i=0x01

// SEI: set I (inhibit I interrupts)
// use specialize orcc_imm with opr8i=0x10

// SEV: set overflow
// use specialize orcc_imm with opr8i=0x02 

// end todo specialization ++++++++++++++++++++++


// ORX/ORY IMM (regXY | opr16i => regXY)
op or_xy_imm(0x18[8]:0b1[1]:b[1]:0x0A[6]:opr16i[16])

or_xy_imm.getCycles = { return 3; }

or_xy_imm.disasm = {
	if (b==0) {
		sink << "ORX #$";
	} else {
		sink << "ORY #$";
	}

	sink << std::hex << opr16i;
}

or_xy_imm.execute = {

	uint16_t result, regVal;
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal | opr16i;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ORX/ORY DIR (regXY | mem[regDirect:opr8a]:mem[regDirect:opr8a+1] => regXY)
op or_xy_dir(0x18[8]:0b1[1]:b[1]:0x1A[6]:> <:opr8a[8])

or_xy_dir.getCycles = { return 4; }

or_xy_dir.disasm = {
	if (b==0) {
		sink << "ORX $";
	} else {
		sink << "ORY $";
	}

	sink << std::hex << opr8a;
}

or_xy_dir.execute = {

	uint16_t result, regVal;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint16_t opr8aVal = cpu->memRead16(addr);
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal | opr8aVal;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ORX/ORY EXT (regXY | mem[opr16a]:mem[opr16a+1] => regXY)
op or_xy_ext(0x18[8]:0b1[1]:b[1]:0x3A[6]:opr16a[16])

or_xy_ext.getCycles = { return 4; }

or_xy_ext.disasm = {
	if (b==0) {
		sink << "ORX $";
	} else {
		sink << "ORY $";
	}

	sink << std::hex << opr16a;
}

or_xy_ext.execute = {

	uint16_t result, regVal;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t opr16aVal = cpu->memRead16(addr);
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal | opr16aVal;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// ORX/ORY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regXY | mem[xb->addrE]:mem[xb->addrE+1] => regXY)
op or_xy_idx(0x18[8]:0b1[1]:b[1]:0x2A[6]:> <:*xb[XB])

or_xy_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }

or_xy_idx.disasm = {
	if (b==0) {
		sink << "ORX ";
	} else {
		sink << "ORY ";
	}

	xb->disasm(sink);
}

or_xy_idx.execute = {

	uint16_t result, regVal;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t xbVal = cpu->memRead16(addr);
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal | xbVal;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// EORA/EORB IMM (regAB ^ opr8i => regAB)

op eor_ab_imm(0b1[1]:b[1]:0x08[6]:opr8i[8])

eor_ab_imm.getCycles = { return 1; }

eor_ab_imm.disasm = {
	if (b==0) {
		sink << "EOR #$";
	} else {
		sink << "EOR #$";
	}
	sink << std::hex << opr8i;
}

eor_ab_imm.execute = {
	uint8_t result;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}

	result = regVal ^ opr8i;  
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// EORA/EORB  DIR  (regAB ^ mem[regDirect:opr8a] => regAB)s
op eor_ab_dir(0b1[1]:b[1]:0x18[6]:opr8a[8])

eor_ab_dir.getCycles = { return 3; }

eor_ab_dir.disasm = {
	if (b==0) {
		sink << "ORAA $";
	} else {
		sink << "ORAB $"; 
	}
	sink << std::hex << opr8a;
}

eor_ab_dir.execute = {
	uint8_t result;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint8_t opr8aVal = cpu->memRead8(addr);

	result = regVal ^ opr8aVal;
		
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// EORA/EORB EXT (regAB ^ mem[opr16a] => regAB)
op eor_ab_ext(0b1[1]:b[1]:0x38[6]:> <:opr16a[16])  

eor_ab_ext.getCycles = { return 3; }

eor_ab_ext.disasm = {
	if (b==0) {
		sink << "EORA $";
	} else {
		sink << "EORB $";		
	}
	sink << std::hex << opr16a;
}

eor_ab_ext.execute = {
	uint8_t result;
	
	uint8_t regVal;
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t opr16aVal = cpu->memRead8(addr);

	result = regVal ^ opr16aVal;	

	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// EORA/EORB  IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regAB ^ mem[xb->addrE] => regAB)
op eor_ab_idx(0b1[1]:b[1]:0x28[6]:> <:*xb[XB])

eor_ab_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 3, 3, 4, 6, 6); }

eor_ab_idx.disasm = {
	if (b==0){
		sink << "EORA ";
	} else {
		sink << "EORB ";
	}

	xb->disasm(sink);
}

eor_ab_idx.execute = {
	uint8_t result;
	
	uint8_t regVal;
	
	if (b==0) {
		regVal = cpu->getRegA();
	} else {
		regVal = cpu->getRegB();
	}
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t xbVal = cpu->memRead8(addr);

	result = regVal ^ xbVal;
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x80) == 0x80) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// EORX/EORY IMM (regXY ^ opr16i => regXY)
op eor_xy_imm(0x18[8]:0b1[1]:b[1]:0x08[6]:opr16i[16])

eor_xy_imm.getCycles = { return 3; }

eor_xy_imm.disasm = {
	if (b==0) {
		sink << "EORX #$";
	} else {
		sink << "EORY #$";
	}

	sink << std::hex << opr16i;
}

eor_xy_imm.execute = {

	uint16_t result, regVal;
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal ^ opr16i;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// EORX/EORY DIR (regXY ^ mem[regDirect:opr8a]:mem[regDirect:opr8a+1] => regXY)
op eor_xy_dir(0x18[8]:0b1[1]:b[1]:0x18[6]:> <:opr8a[8])

eor_xy_dir.getCycles = { return 4; }

eor_xy_dir.disasm = {
	if (b==0) {
		sink << "EORX $";
	} else {
		sink << "eORY $";
	}

	sink << std::hex << opr8a;
}

eor_xy_dir.execute = {

	uint16_t result, regVal;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint16_t opr8aVal = cpu->memRead16(addr);
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal ^ opr8aVal;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// EORX/EORY EXT (regXY ^ mem[opr16a]:mem[opr16a+1] => regXY)
op eor_xy_ext(0x18[8]:0b1[1]:b[1]:0x38[6]:opr16a[16])

eor_xy_ext.getCycles = { return 4; }

eor_xy_ext.disasm = {
	if (b==0) {
		sink << "EORX $";
	} else {
		sink << "EORY $";
	}

	sink << std::hex << opr16a;
}

eor_xy_ext.execute = {

	uint16_t result, regVal;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t opr16aVal = cpu->memRead16(addr);
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal ^ opr16aVal;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}

// EORX/EORY IDX or IDX1 or IDX2 or [D,IDX] or [IDX2] (regXY ^ mem[xb->addrE]:mem[xb->addrE+1] => regXY)
op eor_xy_idx(0x18[8]:0b1[1]:b[1]:0x28[6]:> <:*xb[XB])

eor_xy_idx.getCycles = { return XbModes::GetIDXCycles(xb->getXbMode(), 4, 4, 5, 7, 7); }

eor_xy_idx.disasm = {
	if (b==0) {
		sink << "EORX ";
	} else {
		sink << "EORY ";
	}

	xb->disasm(sink);
}

eor_xy_idx.execute = {

	uint16_t result, regVal;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t xbVal = cpu->memRead16(addr);
	
	if (b==0) {
		regVal = cpu->getRegX();
	} else {
		regVal = cpu->getRegY();
	}
	
	result = regVal ^ xbVal;

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}

	cpu->ccr->clrV();
	
	if (result == 0) cpu->ccr->setZ(); else cpu->ccr->clrZ();
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(); else cpu->ccr->clrN();
}
