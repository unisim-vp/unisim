// -*- C++ -*-

op dec_ext(0x73[8]:opr16a[8])

dec_ext.disasm = {
	sink << "DEC $" << std::hex << opr16a;
}

dec_ext.execute = {
	uint8_t opr16aVal = cpu->mmc->memRead8(opr16a);
	uint8_t result, carry_out, overflow, carry_in;
	
	carry_in = 0;
	Sub8(result, carry_out, overflow, opr16aVal, 1, carry_in);

	cpu->mmc->memWrite8(opr16a, result);
		
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op dec_idx(0x63[8]:> <:*xb[XB])

dec_idx.disasm = {
	sink << "DEC ";
	xb->disasm(sink);
}

dec_idx.execute = {
	uint16_t addr = xb->getEAddr(cpu);
	uint8_t val = cpu->mmc->memRead8(addr);

	uint8_t result, carry_out, overflow, carry_in;
	
	carry_in = 0;
	Sub8(result, carry_out, overflow, val, 1, carry_in);

	cpu->mmc->memWrite8(addr, result);
	
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op dec_ab(0b010[3]:b[1]:0x3[4])

dec_ab.disasm = {
	if (b == 0) {
		sink << "DECA";
	} else {
		sink << "DECB";
	}
}

dec_ab.execute = {
	
	uint8_t result, carry_out, overflow, carry_in;

	uint8_t val;
	if (b==0) {
		val = cpu->getRegA();
	} else {
		val = cpu->getRegB();
	}

	carry_in = 0;
	Sub8(result, carry_out, overflow, val, 1, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);		
	}
	
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	
}

op decw_ext(0x18[8]:0x73[8]:opr16a[16])

decw_ext.disasm = {
	sink << "DECW $" << std::hex << opr16a;
}

decw_ext.execute = {
	uint16_t opr16aVal = cpu->mmc->memRead16(opr16a);
	uint16_t result;
	uint8_t carry_out, overflow, carry_in;
	
	carry_in = 0;
	Sub16(result, carry_out, overflow, opr16aVal, 1, carry_in);

	cpu->mmc->memWrite16(opr16a, result);
		
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op decw_idx(0x18[8]:0x63[8]:> <:*xb[XB])

decw_idx.disasm = {
	sink << "DECW ";
	xb->disasm(sink);
}

decw_idx.execute = {
	uint16_t addr = xb->getEAddr(cpu);
	uint16_t val = cpu->mmc->memRead16(addr);

	uint16_t result;
	uint8_t carry_out, overflow, carry_in;
	
	carry_in = 0;
	Sub16(result, carry_out, overflow, val, 1, carry_in);

	cpu->mmc->memWrite16(addr, result);
	
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op dec_xy(0x18[8]:0b010[3]:b[1]:0x3[4])

dec_xy.disasm = {
	if (b==0) {
		sink << "DECX";
	} else {
		sink << "DECY";
	}
}

dec_xy.execute = {

	uint16_t val;
	if (b==0) {
		val = cpu->getRegX();
	} else {
		val = cpu->getRegY();
	}

	uint16_t result;
	uint8_t carry_out, overflow, carry_in;
	
	carry_in = 0;
	Sub16(result, carry_out, overflow, val, 1, carry_in);

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	
}

op des(0x1B[8]:0x9F[8])

des.disasm = {
	sink << "DES";
}

des.execute = {
	cpu->setSP(cpu->getSP() - 1);
}

op dex(0x09[8])

dex.disasm = {
	sink << "DEX";
}

dex.execute = {
	uint16_t val = cpu->getRegX();
	val--;
	cpu->setRegX(val);
	if (val == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);  
}

op dey(0x03[8])

dey.disasm = {
	sink << "DEY";
}

dey.execute = {
	uint16_t val = cpu->getRegY();
	val--;
	cpu->setRegY(val);
	if (val == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);  
}

/* ********* Increment Instructions ****** */

op inc_ext(0x72[8]:opr16a[8])

inc_ext.disasm = {
	sink << "INC $" << std::hex << opr16a;
}

inc_ext.execute = {
	uint8_t opr16aVal = cpu->mmc->memRead8(opr16a);
	uint8_t result, carry_out, overflow, carry_in;
	
	carry_in = 0;
	Add8(result, carry_out, overflow, opr16aVal, 1, carry_in);

	cpu->mmc->memWrite8(opr16a, result);
		
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op inc_idx(0x62[8]:> <:*xb[XB])

inc_idx.disasm = {
	sink << "INC ";
	xb->disasm(sink);
}

inc_idx.execute = {
	uint16_t addr = xb->getEAddr(cpu);
	uint8_t val = cpu->mmc->memRead8(addr);

	uint8_t result, carry_out, overflow, carry_in;
	
	carry_in = 0;
	Add8(result, carry_out, overflow, val, 1, carry_in);

	cpu->mmc->memWrite8(addr, result);
	
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op inc_ab(0b010[3]:b[1]:0x2[4])

inc_ab.disasm = {
	if (b == 0) {
		sink << "INCA";
	} else {
		sink << "INCB";
	}
}

inc_ab.execute = {
	
	uint8_t result, carry_out, overflow, carry_in;

	uint8_t val;
	if (b==0) {
		val = cpu->getRegA();
	} else {
		val = cpu->getRegB();
	}

	carry_in = 0;
	Add8(result, carry_out, overflow, val, 1, carry_in);
	
	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);		
	}
	
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x80) == 0x80) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	
}

op incw_ext(0x18[8]:0x72[8]:opr16a[16])

incw_ext.disasm = {
	sink << "INCW $" << std::hex << opr16a;
}

incw_ext.execute = {
	uint16_t opr16aVal = cpu->mmc->memRead16(opr16a);
	uint16_t result;
	uint8_t carry_out, overflow, carry_in;
	
	carry_in = 0;
	Add16(result, carry_out, overflow, opr16aVal, 1, carry_in);

	cpu->mmc->memWrite16(opr16a, result);
		
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op incw_idx(0x18[8]:0x62[8]:> <:*xb[XB])

incw_idx.disasm = {
	sink << "INCW ";
	xb->disasm(sink);
}

incw_idx.execute = {
	uint16_t addr = xb->getEAddr(cpu);
	uint16_t val = cpu->mmc->memRead16(addr);

	uint16_t result;
	uint8_t carry_out, overflow, carry_in;
	
	carry_in = 0;
	Add16(result, carry_out, overflow, val, 1, carry_in);

	cpu->mmc->memWrite16(addr, result);
	
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
}

op inc_xy(0x18[8]:0b010[3]:b[1]:0x2[4])

inc_xy.disasm = {
	if (b==0) {
		sink << "INCX";
	} else {
		sink << "INCY";
	}
}

inc_xy.execute = {

	uint16_t val;
	if (b==0) {
		val = cpu->getRegX();
	} else {
		val = cpu->getRegY();
	}

	uint16_t result;
	uint8_t carry_out, overflow, carry_in;
	
	carry_in = 0;
	Add16(result, carry_out, overflow, val, 1, carry_in);

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	cpu->ccr->setV(overflow);
	
	if (result == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);
	if ((result & 0x8000) == 0x8000) cpu->ccr->setN(1); else cpu->ccr->setN(0);
	
}

op ins(0x1B[8]:0x81[8])

ins.disasm = {
	sink << "INS";
}

ins.execute = {
	cpu->setSP(cpu->getSP() + 1);
}

op inx(0x08[8])

inx.disasm = {
	sink << "INX";
}

inx.execute = {
	uint16_t val = cpu->getRegX();
	val++;
	cpu->setRegX(val);
	if (val == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);  
}

op iny(0x02[8])

iny.disasm = {
	sink << "INY";
}

iny.execute = {
	uint16_t val = cpu->getRegY();
	val++;
	cpu->setRegY(val);
	if (val == 0) cpu->ccr->setZ(1); else cpu->ccr->setZ(0);  
}

