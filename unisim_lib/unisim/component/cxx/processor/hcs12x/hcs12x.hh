/*** File generated by GenISSLib version 2.1: DO NOT MODIFY ***/
#ifndef ___local_home_gracia_svn_unisim_devel_unisim_lib_unisim_component_cxx_processor_hcs12x_hcs12x_unisim__component__cxx__processor__hcs12x_HH__
#define ___local_home_gracia_svn_unisim_devel_unisim_lib_unisim_component_cxx_processor_hcs12x_hcs12x_unisim__component__cxx__processor__hcs12x_HH__
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

#include <vector>
#include <inttypes.h>
#include <iosfwd>
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x {
struct CodeType {
	static const unsigned int maxsize = 8;
	unsigned int              size;
	uint8_t                   str[maxsize];
	enum Exception_t { NotEnoughBytes };
	CodeType() : size( 0 ) {};
	CodeType( uint8_t* _src, unsigned int _size )
	: size( std::min( _size, maxsize ) ) { memcpy( str, _src, size ); }
	CodeType( CodeType const& _ct )
	: size( _ct.size ) { memcpy( str, _ct.str, _ct.size ); }
	bool match( CodeType const& _bits, CodeType const& _mask ) const {
		for( unsigned int idx = 0; idx < _mask.size; ++idx ) {
			if( idx >= size ) throw NotEnoughBytes;
			if( (str[idx] & _mask.str[idx]) != _bits.str[idx] ) return false;
		};
		return true;
	};
	bool match( CodeType const& _bits ) const {
		if( size < _bits.size ) throw NotEnoughBytes;
		return memcmp( str, _bits.str, _bits.size ) == 0;
	}
	void pop( unsigned int _bytes ) {
		if( size < _bytes ) throw NotEnoughBytes;
		size -= _bytes;
		memmove( str, str + _bytes, size );
	}
	friend std::ostream& operator << ( std::ostream& _sink, CodeType const& _ct );
};
class Operation;
const unsigned int NUM_OPERATIONS_PER_PAGE = 4096;
class DecodeMapPage
{
public:
	DecodeMapPage(uint16_t key);
	~DecodeMapPage();
	uint16_t key;
	DecodeMapPage *next;
	Operation *operation[NUM_OPERATIONS_PER_PAGE];
};

class DecodeTableEntry
{
public:
	DecodeTableEntry(CodeType const& opcode, CodeType const& opcode_mask, Operation *(*decode)(CodeType const&, uint16_t));
	CodeType opcode;
	CodeType opcode_mask;
	Operation *(*decode)(CodeType const& code, uint16_t addr);
};
const unsigned int NUM_DECODE_HASH_TABLE_ENTRIES = 4096;
class Decoder
{
public:
	Decoder();
	virtual ~Decoder();

	Operation*NCDecode(uint16_t addr);
	Operation *NCDecode(uint16_t addr, CodeType const& code);
	Operation *Decode(uint16_t addr);
	Operation *Decode(uint16_t addr, CodeType const& insn);
	std::vector<DecodeTableEntry > const& GetDecodeTable() const { return decode_table; };
	virtual void Fetch( CodeType&, uint16_t ) ;
	void InvalidateDecodingCacheEntry(uint16_t addr);
	void InvalidateDecodingCache();

	void SetLittleEndian();
	void SetBigEndian();
private:
	bool little_endian;
	std::vector<DecodeTableEntry > decode_table;
	DecodeMapPage *mru_page;
	DecodeMapPage *decode_hash_table[NUM_DECODE_HASH_TABLE_ENTRIES];
	DecodeMapPage *FindPage(uint16_t page_key)
#if defined(__GNUC__) && (__GNUC__ >= 3 && (__GNUC__ != 3 || __GNUC_MINOR__ != 4 || __GNUC_PATCHLEVEL__ != 6))
	__attribute__((always_inline))
#endif
	;
};

} } } } }
#line 49 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.isa"

#include <unisim/component/cxx/processor/hcs12x/cpu.hh>
#include <unisim/component/cxx/processor/hcs12x/concatenated_register.hh>
#include <iostream>
#include <iosfwd>
#line 98 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.hh"
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x {
class Operation
{
public:
	Operation(CodeType const& code, uint16_t addr, const char *name);
	virtual ~Operation();
	inline uint16_t GetAddr() const { return addr; }
	inline CodeType const& GetEncoding() const { return encoding; }
	inline const char *GetName() const { return name; }
	virtual
#line 65 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.isa"
	void
#line 111 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.hh"
	disasm(
#line 65 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.isa"
	ostream&
#line 115 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.hh"
#line 65 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.isa"
	sink
#line 118 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.hh"
	);
	virtual
#line 60 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.isa"
	void
#line 123 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.hh"
	execute(
#line 60 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.isa"
	CPU *
#line 127 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.hh"
#line 60 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.isa"
	cpu
#line 130 "/local/home/gracia/svn/unisim/devel/unisim_lib/unisim/component/cxx/processor/hcs12x/hcs12x.hh"
	);
protected:
	CodeType encoding;
	uint16_t addr;
	const char *name;
};

} } } } }
#endif
