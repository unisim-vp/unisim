/*
 *  Copyright (c) 2008,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
 */


/* ********** Clear, Complement, and Negate instructions ********* */

// CLC: clear bit C
op clc(0x10[8]:0xFE[8])

clc.disasm = {
	sink << "CLC";
}

clc.execute = {
	cpu->ccr->clrC();
}

// CLI: clear bit I
op cli(0x10[8]:0xEF[8])

cli.disasm = {
	sink << "CLI";
}

cli.execute = {
	cpu->ccr->clrI();
}

// CLV: clear bit V
op clv(0x10[8]:0xFD[8])

clv.disasm = {
	sink << "CLV";
}

clv.execute = {
	cpu->ccr->clrV();
}

// clear Memory
op clr_ext(0x79[8]:> <:opr16a[16])

clr_ext.disasm = {
	sink << "CLR $" << std::hex << opr16a;
}

clr_ext.execute = {

	cpu->memWrite8(opr16a, 0);
	
	cpu->ccr->clrN();
	cpu->ccr->setZ();
	cpu->ccr->clrV();
	cpu->ccr->clrC();
}

op clr_idx(0x69[8]:> <:*xb[XB])

clr_idx.disasm = {
	sink << "CLR ";
	xb->disasm(sink);
}

clr_idx.execute = {

	cpu->memWrite8(xb->getEAddr(cpu), 0);

	cpu->ccr->clrN();
	cpu->ccr->setZ();
	cpu->ccr->clrV();
	cpu->ccr->clrC();
}

op clr_ab(0b1[1]:b[1]:0x07[6])

clr_ab.disasm = {
	if (b==0) {
		sink << "CLRA";
	} else {
		sink << "CLRB";
	}
}

clr_ab.execute = {

	if (b==0) {
		cpu->setRegA(0);
	} else {
		cpu->setRegB(0);
	}
	
	cpu->ccr->clrN();
	cpu->ccr->setZ();
	cpu->ccr->clrV();
	cpu->ccr->clrC();
}

// COM: One's complement memory Location
op com_ext(0x71[8]:> <:opr16a[16])

com_ext.disasm = {
	sink << "COM $" << std::hex << opr16a;
}

com_ext.execute = {

	uint8_t val = ~cpu->memRead8(opr16a);
	cpu->memWrite8(opr16a, val);
	
	cpu->ccr->setC();
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
}

op com_idx(0x61[8]:> <:*xb[XB])

com_idx.disasm = {
	sink << "COM ";
	xb->disasm(sink);
}

com_idx.execute = {

	address_t addr = xb->getEAddr(cpu);

	uint8_t val = ~cpu->memRead8(addr);
	cpu->memWrite8(addr, val);
	
	cpu->ccr->setC();
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
}

op com_ab(0b010[3]:b[1]:0x1[4])

com_ab.disasm = {
	if (b==0) {
		sink << "COMA";
	} else {
		sink << "COMB";
	}
}

com_ab.execute = {
	
	uint8_t val;
	if (b==0) {
		val = cpu->getRegA();
	} else {
		val = cpu->getRegB();
	}
	
	val = ~val;
	
	if (b==0) {
		cpu->setRegA(val);
	} else {
		cpu->setRegB(val);
	}

	cpu->ccr->setC();
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
}

// NEG: Two's Complement Negate
op neg_ext(0x70[8]:> <:opr16a[16])

neg_ext.disasm = {
	sink << "NEG $" << std::hex << opr16a;
}

neg_ext.execute = {
	uint8_t result, carry_out, overflow;
	
	Sub8(result, carry_out, overflow, 0, cpu->memRead8(opr16a), 0);
	cpu->memWrite8(opr16a, result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();} 
}

op neg_idx(0x60[8]:> <:*xb[XB])

neg_idx.disasm = {
	sink << "NEG $";
	xb->disasm(sink);
}

neg_idx.execute = {
	address_t addr = xb->getEAddr(cpu);
	uint8_t result, carry_out, overflow;
	
	Sub8(result, carry_out, overflow, 0, cpu->memRead8(addr), 0);
	cpu->memWrite8(addr, result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();} 
	
}

op neg_ab(0b010[3]:b[1]:0x0[4])

neg_ab.disasm = {
	if (b==0) {
		sink << "NEGA";
	} else {
		sink << "NEGB";
	}
}

neg_ab.execute = {
	uint8_t val, result, carry_out, overflow;
	
	if (b==0) {
		val = cpu->getRegA();
	} else {
		val = cpu->getRegB();
	}

	Sub8(result, carry_out, overflow, 0, val, 0);

	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();} 
}


/* ********** Bit Test and Manipulation Instructions ************* */

// BCLR: Clear bit(s) in memory
op bclr_dir(0x4D[8]:> <:dd[8]:mm[8])

bclr_dir.disasm = {
	sink << "BCLR $" << std::hex << dd << ", $" << std::hex << mm;
}

bclr_dir.execute = {
	uint8_t ddVal = cpu->memRead8(dd,MEMORY::DIRECT);
	uint8_t mmCom = ~mm;
	
	uint8_t val = ddVal & mmCom;
	
	cpu->memWrite8(dd, val, MEMORY::DIRECT);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

op bclr_ext(0x1D[8]:> <:opr16a[16]:> <:mm[8])

bclr_ext.disasm = {
	sink << "BCLR $" << std::hex << opr16a << ", $" << std::hex << mm;
}

bclr_ext.execute = {
	uint8_t opr16aVal = cpu->memRead8(opr16a);
	uint8_t mmCom = ~mm;
	
	uint8_t val = opr16aVal & mmCom;
	
	cpu->memWrite8(opr16a, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

op bclr_idx(0x0D[8]:> <:*xb[XB]:> <:mm[8])

bclr_idx.disasm = {
	sink << "BCLR ";
	xb->disasm(sink);
	sink << ", $" << std::hex << mm;
}

bclr_idx.execute = {
	address_t addr = xb->getEAddr(cpu);
	uint8_t xbVal = cpu->memRead8(addr);
	uint8_t mmCom = ~mm;
	
	uint8_t val = xbVal & mmCom;
	
	cpu->memWrite8(addr, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

// BITA or BITB: bit test A/B (Logical 'AND' A/B with Memory
op bit_ab_imm(0b1[1]:b[1]:0x05[6]:ii[8])

bit_ab_imm.disasm = {
	if (b==0) {
		sink << "BITA #$";
	} else {
		sink << "BITB #$";
	} 
	sink << std::hex << ii;
}

bit_ab_imm.execute = {
	uint8_t val = cpu->getRegA() & ii;
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

op bit_ab_dir(0b1[1]:b[1]:0x15[6]:opr8a[8])

bit_ab_dir.disasm = {
	if (b==0) {
		sink << "BITA $";
	} else {
		sink << "BITB $";
	} 
	sink << std::hex << opr8a;
}

bit_ab_dir.execute = {
	uint8_t val = cpu->getRegA() & cpu->memRead8(opr8a, MEMORY::DIRECT);
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

op bit_ab_ext(0b1[1]:b[1]:0x35[6]:> <:opr16a[16])

bit_ab_ext.disasm = {
	if (b==0) {
		sink << "BITA $";
	} else {
		sink << "BITB $";
	} 
	sink << std::hex << opr16a;
}

bit_ab_ext.execute = {
	uint8_t val = cpu->getRegA() & cpu->memRead8(opr16a);
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

op bit_ab_idx(0b1[1]:b[1]:0x25[6]:> <:*xb[XB])

bit_ab_idx.disasm = {
	if (b==0) {
		sink << "BITA ";
	} else {
		sink << "BITB ";
	} 
	xb->disasm(sink);
}

bit_ab_idx.execute = {
	uint8_t val = cpu->getRegA() & cpu->memRead8(xb->getEAddr(cpu));
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

// BSET: Set bits in memory
op bset_dir(0x4C[8]:> <:dd[8]:mm[8])

bset_dir.disasm = {
	sink << "BSET $" << std::hex << dd << ", $" << std::hex << mm;
}

bset_dir.execute = {
	uint8_t ddVal = cpu->memRead8(dd,MEMORY::DIRECT);
	
	uint8_t val = ddVal | mm;
	
	cpu->memWrite8(dd, val, MEMORY::DIRECT);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

op bset_ext(0x1C[8]:> <:opr16a[16]:> <:mm[8])

bset_ext.disasm = {
	sink << "BSET $" << std::hex << opr16a << ", $" << std::hex << mm;
}

bset_ext.execute = {
	uint8_t opr16aVal = cpu->memRead8(opr16a);
	
	uint8_t val = opr16aVal | mm;
	
	cpu->memWrite8(opr16a, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

op bset_idx(0x0C[8]:> <:*xb[XB]:> <:mm[8])

bset_idx.disasm = {
	sink << "BSET ";
	xb->disasm(sink);
	sink << ", $" << std::hex << mm;
}

bset_idx.execute = {
	address_t addr = xb->getEAddr(cpu);
	uint8_t xbVal = cpu->memRead8(addr);
	
	uint8_t val = xbVal | mm;
	
	cpu->memWrite8(addr, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

/* ********** Shift and Rotate instructions ********************** */

// LSL: Logical Shift Left
// ASL: Arithmetic Shift Left
op lsl_ext(0x78[8]:> <:opr16a[16])

lsl_ext.disasm = {
	sink << "LSL $" << std::hex << opr16a;
}

lsl_ext.execute = {
	uint8_t val = cpu->memRead8(opr16a);
	uint8_t c2val = ~val + 1;
	
	val = val << 1;
	cpu->memWrite8(opr16a, val);
	
	if ((val & 0x80) == 0x80) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lsl_idx(0x68[8]:> <:*xb[XB])

lsl_idx.disasm = {
	sink << "LSL ";
	xb->disasm(sink);
}

lsl_idx.execute = {
	address_t addr = xb->getEAddr(cpu);
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;

	val = val << 1;
	cpu->memWrite8(addr, val);
	
	if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lsla(0x48[8])

lsla.disasm = {
	sink << "LSLA";
}

lsla.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;

	val = val << 1;
	cpu->setRegA(val);

	if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lslb(0x58[8])

lslb.disasm = {
	sink << "LSLB";
}

lslb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;

	val = val << 1;
	cpu->setRegB(val);

	if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lsld(0x59[8])

lsld.disasm = {
	sink << "LSLD";
}

lsld.execute = {
	uint16_t val = cpu->getRegD();
	uint16_t c2val = ~val + 1;

	val = val << 1;
	cpu->setRegD(val);

	if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

// ROL: Rotate Memory/Accumulator Left through carry
op rol_ext(0x75[8]:> <:opr16a[16])

rol_ext.disasm = {
	sink << "ROL $" << std::hex << opr16a;
}

rol_ext.execute = {
	uint8_t val = cpu->memRead8(opr16a);
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x80) == 0x80) { carry = 1; }	
	val = (val << 1) | carry;
	cpu->memWrite8(opr16a, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op rol_idx(0x65[8]:> <:*xb[XB])

rol_idx.disasm = {
	sink << "ROL ";
	xb->disasm(sink);
}

rol_idx.execute = {
	address_t addr = xb->getEAddr(cpu);
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x80) == 0x80) { carry = 1; }	
	val = (val << 1) | carry;
	cpu->memWrite8(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op rola(0x45[8])

rola.disasm = {
	sink << "ROLA";
}

rola.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x80) == 0x80) { carry = 1; }	
	val = (val << 1) | carry;
	cpu->setRegA(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op rolb(0x55[8])

rolb.disasm = {
	sink << "ROLB";
}

rolb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x80) == 0x80) { carry = 1; }
	val = (val << 1) | carry;
	cpu->setRegB(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}


// LSR: Logical Shift Right
op lsr_ext(0x74[8]:> <:opr16a[16])

lsr_ext.disasm = {
	sink << "LSR $" << std::hex << opr16a;
}

lsr_ext.execute = {
	uint8_t val = cpu->memRead8(opr16a);
	uint8_t c2val = ~val + 1;
	
	val = val >> 1;
	cpu->memWrite8(opr16a, val);

	if ((val & 0x01) == 0x01) { cpu->ccr->setC();}	else  { cpu->ccr->clrC();}	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsr_idx(0x64[8]:> <:*xb[XB])

lsr_idx.disasm = {
	sink << "LSR ";
	xb->disasm(sink);
}

lsr_idx.execute = {
	address_t addr = xb->getEAddr(cpu);
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;

	val = val >> 1;
	cpu->memWrite8(addr, val);

	if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsra(0x44[8])

lsra.disasm = {
	sink << "LSRA";
}

lsra.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;

	val = val >> 1;
	cpu->setRegA(val);

	if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsrb(0x54[8])

lsrb.disasm = {
	sink << "LSRB";
}

lsrb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;

	val = val >> 1;
	cpu->setRegB(val);

	if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsrd(0x49[8])

lsrd.disasm = {
	sink << "LSRD";
}

lsrd.execute = {
	uint16_t val = cpu->getRegD();
	uint16_t c2val = ~val + 1;
	
	val = val >> 1;
	cpu->setRegD(val);

	if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();}	else { cpu->ccr->clrC();}	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

// ROR: Rotate Memory/Accumulator Right through Carry
op ror_ext(0x76[8]:> <:opr16a[16])

ror_ext.disasm = {
	sink << "ROR $" << std::hex << opr16a;
}

ror_ext.execute = {
	uint8_t val = cpu->memRead8(opr16a);
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	
	val = (carry << 7) | (val >> 1);
	cpu->memWrite8(opr16a, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op ror_idx(0x66[8]:> <:*xb[XB])

ror_idx.disasm = {
	sink << "ROR ";
	xb->disasm(sink);
}

ror_idx.execute = {
	address_t addr = xb->getEAddr(cpu);
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	
	val = (carry << 7) | (val >> 1);
	cpu->memWrite8(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op rora(0x46[8])

rora.disasm = {
	sink << "RORA";
}

rora.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	
	val = (carry << 7) | (val >> 1);
	cpu->setRegA(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op rorb(0x56[8])

rorb.disasm = {
	sink << "RORB";
}

rorb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }
	val = (carry << 7) | (val >> 1);
	cpu->setRegB(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

// ASR: Arithmetic Shift Right
op asr_ext(0x77[8]:> <:opr16a[16])

asr_ext.disasm = {
	sink << "ASR $" << std::hex << opr16a;
}

asr_ext.execute = {
	uint8_t val = cpu->memRead8(opr16a);
	uint8_t c2val = ~val + 1;

	uint8_t msb = val & 0x80;
		
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }
	
	val = (val >> 1) | msb;
	cpu->memWrite8(opr16a, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 

}

op asr_idx(0x67[8]:> <:*xb[XB])

asr_idx.disasm = {
	sink << "ASR ";
	xb->disasm(sink);
}

asr_idx.execute = {
	address_t addr = xb->getEAddr(cpu);
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;

	uint8_t msb = val & 0x80;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	

	val = (val >> 1) | msb;
	cpu->memWrite8(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op asra(0x47[8])

asra.disasm = {
	sink << "ASRA";
}

asra.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;

	uint8_t msb = val & 0x80;
	
	val = (val >> 1) | msb;
	cpu->setRegA(val);

	if ((val & 0x01) == 0x01) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op asrb(0x57[8])

asrb.disasm = {
	sink << "ASRB";
}

asrb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;

	uint8_t msb = val & 0x80;
	
	val = (val >> 1) | msb;
	cpu->setRegB(val);

	if ((val & 0x01) == 0x01) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}
