/*
 *  Copyright (c) 2008,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Reda   Nouacer  (reda.nouacer@cea.fr)
 */


/* ********** Clear, Complement, and Negate instructions ********* */

// CLC: clear bit C
op clc(0x10[8]:0xFE[8])

clc.disasm = {
	sink << "CLC";
}

clc.execute = {
	cpu->ccr->clrC();
}

// CLI: clear bit I
op cli(0x10[8]:0xEF[8])

cli.disasm = {
	sink << "CLI";
}

cli.execute = {
	cpu->ccr->clrI();
}

// CLV: clear bit V
op clv(0x10[8]:0xFD[8])

clv.disasm = {
	sink << "CLV";
}

clv.execute = {
	cpu->ccr->clrV();
}

// clear Memory
op clr_ext(0x79[8]:> <:opr16a[16])

clr_ext.disasm = {
	sink << "CLR $" << std::hex << opr16a;
}

clr_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	cpu->memWrite8(addr, 0);
	
	cpu->ccr->clrN();
	cpu->ccr->setZ();
	cpu->ccr->clrV();
	cpu->ccr->clrC();
}

op clr_idx(0x69[8]:> <:*xb[XB])

clr_idx.disasm = {
	sink << "CLR ";
	xb->disasm(sink);
}

clr_idx.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	cpu->memWrite8(addr, 0);

	cpu->ccr->clrN();
	cpu->ccr->setZ();
	cpu->ccr->clrV();
	cpu->ccr->clrC();
}

op clrw_ext(0x18[8]:0x79[8]:> <:opr16a[16])

clrw_ext.disasm = {
	sink << "CLRW $" << std::hex << opr16a;
}

clrw_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	cpu->memWrite16(addr, 0);
	
	cpu->ccr->clrN();
	cpu->ccr->setZ();
	cpu->ccr->clrV();
	cpu->ccr->clrC();
}

op clrw_idx(0x18[8]:0x69[8]:> <:*xb[XB])

clrw_idx.disasm = {
	sink << "CLRW ";
	xb->disasm(sink);
}

clrw_idx.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	cpu->memWrite16(addr, 0);

	cpu->ccr->clrN();
	cpu->ccr->setZ();
	cpu->ccr->clrV();
	cpu->ccr->clrC();
}

op clr_ab(0b1[1]:b[1]:0x07[6])

clr_ab.disasm = {
	if (b==0) {
		sink << "CLRA";
	} else {
		sink << "CLRB";
	}
}

clr_ab.execute = {

	if (b==0) {
		cpu->setRegA(0);
	} else {
		cpu->setRegB(0);
	}
	
	cpu->ccr->clrN();
	cpu->ccr->setZ();
	cpu->ccr->clrV();
	cpu->ccr->clrC();
}

op clr_xy(0x18[8]:0b1[1]:b[1]:0x07[6])

clr_xy.disasm = {
	if (b==0) {
		sink << "CLRX";
	} else {
		sink << "CLRY";
	}
}

clr_xy.execute = {

	if (b==0) {
		cpu->setRegX(0);
	} else {
		cpu->setRegY(0);
	}
	
	cpu->ccr->clrN();
	cpu->ccr->setZ();
	cpu->ccr->clrV();
	cpu->ccr->clrC();
}

// COM: One's complement memory Location
op com_ext(0x71[8]:> <:opr16a[16])

com_ext.disasm = {
	sink << "COM $" << std::hex << opr16a;
}

com_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t val = ~cpu->memRead8(addr);
	cpu->memWrite8(addr, val);
	
	cpu->ccr->setC();
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
}

op com_idx(0x61[8]:> <:*xb[XB])

com_idx.disasm = {
	sink << "COM ";
	xb->disasm(sink);
}

com_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t val = ~cpu->memRead8(addr);
	cpu->memWrite8(addr, val);
	
	cpu->ccr->setC();
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
}

op com_ab(0b010[3]:b[1]:0x1[4])

com_ab.disasm = {
	if (b==0) {
		sink << "COMA";
	} else {
		sink << "COMB";
	}
}

com_ab.execute = {
	
	uint8_t val;
	if (b==0) {
		val = cpu->getRegA();
	} else {
		val = cpu->getRegB();
	}
	
	val = ~val;
	
	if (b==0) {
		cpu->setRegA(val);
	} else {
		cpu->setRegB(val);
	}

	cpu->ccr->setC();
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
}

op comw_ext(0x18[8]:0x71[8]:> <:opr16a[16])

comw_ext.disasm = {
	sink << "COMW $" << std::hex << opr16a;
}

comw_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t val = ~cpu->memRead16(addr);
	cpu->memWrite16(addr, val);
	
	cpu->ccr->setC();
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
}

op comw_idx(0x18[8]:0x61[8]:> <:*xb[XB])

comw_idx.disasm = {
	sink << "COMW ";
	xb->disasm(sink);
}

comw_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t val = ~cpu->memRead16(addr);
	cpu->memWrite16(addr, val);
	
	cpu->ccr->setC();
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
}

op com_xy(0x18[8]:0b010[3]:b[1]:0x1[4])

com_xy.disasm = {
	if (b==0) {
		sink << "COMX";
	} else {
		sink << "COMY";
	}
}

com_xy.execute = {
	
	uint16_t val;
	if (b==0) {
		val = cpu->getRegX();
	} else {
		val = cpu->getRegY();
	}
	
	val = ~val;
	
	if (b==0) {
		cpu->setRegX(val);
	} else {
		cpu->setRegY(val);
	}

	cpu->ccr->setC();
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else {cpu->ccr->clrN();}
}

// NEG: Two's Complement Negate
op neg_ext(0x70[8]:> <:opr16a[16])

neg_ext.disasm = {
	sink << "NEG $" << std::hex << opr16a;
}

neg_ext.execute = {
	uint8_t result, carry_out, overflow;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	Sub8(result, carry_out, overflow, 0, cpu->memRead8(addr), 0);
	cpu->memWrite8(addr, result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();} 
}

op neg_idx(0x60[8]:> <:*xb[XB])

neg_idx.disasm = {
	sink << "NEG $";
	xb->disasm(sink);
}

neg_idx.execute = {

	uint8_t result, carry_out, overflow;
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
		
	Sub8(result, carry_out, overflow, 0, cpu->memRead8(addr), 0);
	cpu->memWrite8(addr, result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();} 
	
}

op neg_ab(0b010[3]:b[1]:0x0[4])

neg_ab.disasm = {
	if (b==0) {
		sink << "NEGA";
	} else {
		sink << "NEGB";
	}
}

neg_ab.execute = {
	uint8_t val, result, carry_out, overflow;
	
	if (b==0) {
		val = cpu->getRegA();
	} else {
		val = cpu->getRegB();
	}

	Sub8(result, carry_out, overflow, 0, val, 0);

	if (b==0) {
		cpu->setRegA(result);
	} else {
		cpu->setRegB(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x80) == 0x80) {cpu->ccr->setN();} else { cpu->ccr->clrN();} 
}

op negw_ext(0x18[8]:0x70[8]:> <:opr16a[16])

negw_ext.disasm = {
	sink << "NEGW $" << std::hex << opr16a;
}

negw_ext.execute = {
	uint8_t carry_out, overflow;
	uint16_t result;
	
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	
	Sub16(result, carry_out, overflow, 0, cpu->memRead16(addr), 0);
	cpu->memWrite16(addr, result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x8000) == 0x8000) {cpu->ccr->setN();} else { cpu->ccr->clrN();} 
}

op negw_idx(0x18[8]:0x60[8]:> <:*xb[XB])

negw_idx.disasm = {
	sink << "NEGW $";
	xb->disasm(sink);
}

negw_idx.execute = {

	uint8_t carry_out, overflow;
	uint16_t result;
	
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
		
	Sub16(result, carry_out, overflow, 0, cpu->memRead16(addr), 0);
	cpu->memWrite16(addr, result);
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x8000) == 0x8000) {cpu->ccr->setN();} else { cpu->ccr->clrN();} 
	
}

op neg_xy(0x18[8]:0b010[3]:b[1]:0x0[4])

neg_xy.disasm = {
	if (b==0) {
		sink << "NEGX";
	} else {
		sink << "NEGY";
	}
}

neg_xy.execute = {
	uint8_t carry_out, overflow;
	uint16_t val, result;
	
	if (b==0) {
		val = cpu->getRegX();
	} else {
		val = cpu->getRegY();
	}

	Sub16(result, carry_out, overflow, 0, val, 0);

	if (b==0) {
		cpu->setRegX(result);
	} else {
		cpu->setRegY(result);
	}
	
	if (carry_out) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (overflow) { cpu->ccr->setV();} else { cpu->ccr->clrV();}
	if (result == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((result & 0x8000) == 0x8000) {cpu->ccr->setN();} else { cpu->ccr->clrN();} 
}


/* ********** Bit Test and Manipulation Instructions ************* */

// BCLR: Clear bit(s) in memory
op bclr_dir(0x4D[8]:> <:dd[8]:mm[8])

bclr_dir.disasm = {
	sink << "BCLR $" << std::hex << dd << ", $" << std::hex << mm;
}

bclr_dir.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(dd, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	uint8_t ddVal = cpu->memRead8(addr);
	uint8_t mmCom = ~mm;
	
	uint8_t val = ddVal & mmCom;
	
	cpu->memWrite8(addr, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

op bclr_ext(0x1D[8]:> <:opr16a[16]:> <:mm[8])

bclr_ext.disasm = {
	sink << "BCLR $" << std::hex << opr16a << ", $" << std::hex << mm;
}

bclr_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t opr16aVal = cpu->memRead8(addr);
	uint8_t mmCom = ~mm;
	
	uint8_t val = opr16aVal & mmCom;
	
	cpu->memWrite8(addr, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

op bclr_idx(0x0D[8]:> <:*xb[XB]:> <:mm[8])

bclr_idx.disasm = {
	sink << "BCLR ";
	xb->disasm(sink);
	sink << ", $" << std::hex << mm;
}

bclr_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t xbVal = cpu->memRead8(addr);
	uint8_t mmCom = ~mm;
	
	uint8_t val = xbVal & mmCom;
	
	cpu->memWrite8(addr, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

// BITA or BITB: bit test A/B (Logical 'AND' A/B with Memory
op bit_ab_imm(0b1[1]:b[1]:0x05[6]:ii[8])

bit_ab_imm.disasm = {
	if (b==0) {
		sink << "BITA #$";
	} else {
		sink << "BITB #$";
	} 
	sink << std::hex << ii;
}

bit_ab_imm.execute = {
	uint8_t val;
	
	if (b==0) {
		val = cpu->getRegA() & ii;
	} else {
		val = cpu->getRegB() & ii;
	}
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

op bit_ab_dir(0b1[1]:b[1]:0x15[6]:opr8a[8])

bit_ab_dir.disasm = {
	if (b==0) {
		sink << "BITA $";
	} else {
		sink << "BITB $";
	} 
	sink << std::hex << opr8a;
}

bit_ab_dir.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	uint8_t val;
	
	if (b==0) {
		val = cpu->getRegA() & cpu->memRead8(addr);
	} else {
		val = cpu->getRegB() & cpu->memRead8(addr);
	}
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

op bit_ab_ext(0b1[1]:b[1]:0x35[6]:> <:opr16a[16])

bit_ab_ext.disasm = {
	if (b==0) {
		sink << "BITA $";
	} else {
		sink << "BITB $";
	} 
	sink << std::hex << opr16a;
}

bit_ab_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t val;
	
	if (b==0) {
		val = cpu->getRegA() & cpu->memRead8(addr);
	} else {
		val = cpu->getRegB() & cpu->memRead8(addr);
	}
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

op bit_ab_idx(0b1[1]:b[1]:0x25[6]:> <:*xb[XB])

bit_ab_idx.disasm = {
	if (b==0) {
		sink << "BITA ";
	} else {
		sink << "BITB ";
	} 
	xb->disasm(sink);
}

bit_ab_idx.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t val;
	
	if (b==0) {
		val = cpu->getRegA() & cpu->memRead8(addr);
	} else {
		val = cpu->getRegB() & cpu->memRead8(addr);
	}
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

// BITX or BITY: bit test X/Y (Logical 'AND' X/Y with Memory
op bit_xy_imm(0x18[8]:0b1[1]:b[1]:0x05[6]:opr16i[16])

bit_xy_imm.disasm = {
	if (b==0) {
		sink << "BITX #$";
	} else {
		sink << "BITY #$";
	} 
	sink << std::hex << opr16i;
}

bit_xy_imm.execute = {
	uint16_t val;
	
	if (b==0) {
		val = cpu->getRegX() & opr16i;
	} else {
		val = cpu->getRegY() & opr16i;
	}
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

op bit_xy_dir(0x18[8]:> <:0b1[1]:b[1]:0x15[6]:opr8a[8])

bit_xy_dir.disasm = {
	if (b==0) {
		sink << "BITA $";
	} else {
		sink << "BITB $";
	} 
	sink << std::hex << opr8a;
}

bit_xy_dir.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	uint16_t val;
	
	if (b==0) {
		val = cpu->getRegX() & cpu->memRead16(addr);
	} else {
		val = cpu->getRegY() & cpu->memRead16(addr);
	}
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

op bit_xy_ext(0x18[8]:0b1[1]:b[1]:0x35[6]:> <:opr16a[16])

bit_xy_ext.disasm = {
	if (b==0) {
		sink << "BITX $";
	} else {
		sink << "BITY $";
	} 
	sink << std::hex << opr16a;
}

bit_xy_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t val;
	
	if (b==0) {
		val = cpu->getRegX() & cpu->memRead16(addr);
	} else {
		val = cpu->getRegY() & cpu->memRead16(addr);
	}	
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

op bit_xy_idx(0x18[8]:0b1[1]:b[1]:0x25[6]:> <:*xb[XB])

bit_xy_idx.disasm = {
	if (b==0) {
		sink << "BITX ";
	} else {
		sink << "BITY ";
	} 
	xb->disasm(sink);
}

bit_xy_idx.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t val;
	
	if (b==0) {
		val = cpu->getRegX() & cpu->memRead16(addr);
	} else {
		val = cpu->getRegY() & cpu->memRead16(addr);
	}	
	
	cpu->ccr->clrV();
	
	if (val == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();};
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN();};
}

// BSET: Set bits in memory
op bset_dir(0x4C[8]:> <:dd[8]:mm[8])

bset_dir.disasm = {
	sink << "BSET $" << std::hex << dd << ", $" << std::hex << mm;
}

bset_dir.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(dd, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);
	uint8_t ddVal = cpu->memRead8(addr);
	
	uint8_t val = ddVal | mm;
	
	cpu->memWrite8(addr, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

op bset_ext(0x1C[8]:> <:opr16a[16]:> <:mm[8])

bset_ext.disasm = {
	sink << "BSET $" << std::hex << opr16a << ", $" << std::hex << mm;
}

bset_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t opr16aVal = cpu->memRead8(addr);
	
	uint8_t val = opr16aVal | mm;
	
	cpu->memWrite8(addr, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

op bset_idx(0x0C[8]:> <:*xb[XB]:> <:mm[8])

bset_idx.disasm = {
	sink << "BSET ";
	xb->disasm(sink);
	sink << ", $" << std::hex << mm;
}

bset_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t xbVal = cpu->memRead8(addr);
	
	uint8_t val = xbVal | mm;
	
	cpu->memWrite8(addr, val);
	
	cpu->ccr->clrV();
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); }
}

/* ********** Shift and Rotate instructions ********************** */

// LSL: Logical Shift Left
// ASL: Arithmetic Shift Left
op lsl_ext(0x78[8]:> <:opr16a[16])

lsl_ext.disasm = {
	sink << "LSL $" << std::hex << opr16a;
}

lsl_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;

	if ((val & 0x80) == 0x80) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	
	val = val << 1;
	cpu->memWrite8(addr, val);
	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lsl_idx(0x68[8]:> <:*xb[XB])

lsl_idx.disasm = {
	sink << "LSL ";
	xb->disasm(sink);
}

lsl_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;

	if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

	val = val << 1;
	cpu->memWrite8(addr, val);
	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lsla(0x48[8])

lsla.disasm = {
	sink << "LSLA";
}

lsla.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;

	if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

	val = val << 1;
	cpu->setRegA(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lslb(0x58[8])

lslb.disasm = {
	sink << "LSLB";
}

lslb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;

	if ((val & 0x80) == 0x80) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

	val = val << 1;
	cpu->setRegB(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lsld(0x59[8])

lsld.disasm = {
	sink << "LSLD";
}

lsld.execute = {
	uint16_t val = cpu->getRegD();
	uint16_t c2val = ~val + 1;

	if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

	val = val << 1;
	cpu->setRegD(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}


// LSLW: Logical Shift Left
// ASLW: Arithmetic Shift Left
op lslw_ext(0x18[8]:0x78[8]:> <:opr16a[16])

lslw_ext.disasm = {
	sink << "LSLW $" << std::hex << opr16a;
}

lslw_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;

	if ((val & 0x8000) == 0x8000) { cpu->ccr->setC(); } else { cpu->ccr->clrC(); }
	
	val = val << 1;
	cpu->memWrite16(addr, val);
	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lslw_idx(0x18[8]:0x68[8]:> <:*xb[XB])

lslw_idx.disasm = {
	sink << "LSLW ";
	xb->disasm(sink);
}

lslw_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;

	if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

	val = val << 1;
	cpu->memWrite16(addr, val);
	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lslx(0x18[8]:0x48[8])

lslx.disasm = {
	sink << "LSLX";
}

lslx.execute = {
	uint16_t val = cpu->getRegX();
	uint16_t c2val = ~val + 1;

	if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

	val = val << 1;
	cpu->setRegX(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op lsly(0x18[8]:0x58[8])

lsly.disasm = {
	sink << "LSLY";
}

lsly.execute = {
	uint16_t val = cpu->getRegY();
	uint16_t c2val = ~val + 1;

	if ((val & 0x8000) == 0x8000) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

	val = val << 1;
	cpu->setRegY(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

// ROL: Rotate Memory/Accumulator Left through carry
op rol_ext(0x75[8]:> <:opr16a[16])

rol_ext.disasm = {
	sink << "ROL $" << std::hex << opr16a;
}

rol_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x80) == 0x80) { carry = 1; }	
	val = (val << 1) | carry;
	cpu->memWrite8(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op rol_idx(0x65[8]:> <:*xb[XB])

rol_idx.disasm = {
	sink << "ROL ";
	xb->disasm(sink);
}

rol_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x80) == 0x80) { carry = 1; }	
	val = (val << 1) | carry;
	cpu->memWrite8(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op rola(0x45[8])

rola.disasm = {
	sink << "ROLA";
}

rola.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x80) == 0x80) { carry = 1; }	
	val = (val << 1) | carry;
	cpu->setRegA(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op rolb(0x55[8])

rolb.disasm = {
	sink << "ROLB";
}

rolb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x80) == 0x80) { carry = 1; }
	val = (val << 1) | carry;
	cpu->setRegB(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}


// ROLW: Rotate word Memory/Accumulator Left through carry
op rolw_ext(0x18[8]:0x75[8]:> <:opr16a[16])

rolw_ext.disasm = {
	sink << "ROLw $" << std::hex << opr16a;
}

rolw_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;
	
	uint16_t carry = 0;
	if ((val & 0x8000) == 0x8000) { carry = 1; }	
	val = (val << 1) | carry;
	cpu->memWrite16(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op rolw_idx(0x18[8]:0x65[8]:> <:*xb[XB])

rolw_idx.disasm = {
	sink << "ROLW ";
	xb->disasm(sink);
}

rolw_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;
	
	uint16_t carry = 0;
	if ((val & 0x8000) == 0x8000) { carry = 1; }	
	val = (val << 1) | carry;
	cpu->memWrite16(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op rolx(0x18[8]:0x45[8])

rolx.disasm = {
	sink << "ROLX";
}

rolx.execute = {
	uint16_t val = cpu->getRegX();
	uint16_t c2val = ~val + 1;
	
	uint16_t carry = 0;
	if ((val & 0x8000) == 0x8000) { carry = 1; }	
	val = (val << 1) | carry;
	cpu->setRegX(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op roly(0x18[8]:0x55[8])

roly.disasm = {
	sink << "ROLY";
}

roly.execute = {
	uint16_t val = cpu->getRegY();
	uint16_t c2val = ~val + 1;
	
	uint16_t carry = 0;
	if ((val & 0x8000) == 0x8000) { carry = 1; }
	val = (val << 1) | carry;
	cpu->setRegY(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();} 	
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

// LSR: Logical Shift Right
op lsr_ext(0x74[8]:> <:opr16a[16])

lsr_ext.disasm = {
	sink << "LSR $" << std::hex << opr16a;
}

lsr_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;

	if ((val & 0x01) == 0x01) { cpu->ccr->setC();}	else  { cpu->ccr->clrC();}	
	
	val = val >> 1;
	cpu->memWrite8(addr, val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsr_idx(0x64[8]:> <:*xb[XB])

lsr_idx.disasm = {
	sink << "LSR ";
	xb->disasm(sink);
}

lsr_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;

	if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

	val = val >> 1;
	cpu->memWrite8(addr, val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsra(0x44[8])

lsra.disasm = {
	sink << "LSRA";
}

lsra.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;

	if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

	val = val >> 1;
	cpu->setRegA(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsrb(0x54[8])

lsrb.disasm = {
	sink << "LSRB";
}

lsrb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;

	if ((val & 0x01) == 0x01) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

	val = val >> 1;
	cpu->setRegB(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsrd(0x49[8])

lsrd.disasm = {
	sink << "LSRD";
}

lsrd.execute = {
	uint16_t val = cpu->getRegD();
	uint16_t c2val = ~val + 1;

	if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();}	else { cpu->ccr->clrC();}	
	
	val = val >> 1;
	cpu->setRegD(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

// LSRW: Logical Shift Right word
op lsrw_ext(0x18[8]:0x74[8]:> <:opr16a[16])

lsrw_ext.disasm = {
	sink << "LSRW $" << std::hex << opr16a;
}

lsrw_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;

	if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();}	else  { cpu->ccr->clrC();}	
	
	val = val >> 1;
	cpu->memWrite16(addr, val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsrw_idx(0x18[8]:0x64[8]:> <:*xb[XB])

lsrw_idx.disasm = {
	sink << "LSRW ";
	xb->disasm(sink);
}

lsrw_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;

	if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();} else  { cpu->ccr->clrC();}

	val = val >> 1;
	cpu->memWrite16(addr, val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsrx(0x18[8]:0x44[8])

lsrx.disasm = {
	sink << "LSRX";
}

lsrx.execute = {
	uint16_t val = cpu->getRegX();
	uint16_t c2val = ~val + 1;

	if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

	val = val >> 1;
	cpu->setRegX(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op lsry(0x18[8]:0x54[8])

lsry.disasm = {
	sink << "LSRY";
}

lsry.execute = {
	uint16_t val = cpu->getRegY();
	uint16_t c2val = ~val + 1;

	if ((val & 0x0001) == 0x0001) { cpu->ccr->setC();} else { cpu->ccr->clrC();}

	val = val >> 1;
	cpu->setRegY(val);

	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}
 
// ROR: Rotate Memory/Accumulator Right through Carry
op ror_ext(0x76[8]:> <:opr16a[16])

ror_ext.disasm = {
	sink << "ROR $" << std::hex << opr16a;
}

ror_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	
	val = (carry << 7) | (val >> 1);
	cpu->memWrite8(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op ror_idx(0x66[8]:> <:*xb[XB])

ror_idx.disasm = {
	sink << "ROR ";
	xb->disasm(sink);
}

ror_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	
	val = (carry << 7) | (val >> 1);
	cpu->memWrite8(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op rora(0x46[8])

rora.disasm = {
	sink << "RORA";
}

rora.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	
	val = (carry << 7) | (val >> 1);
	cpu->setRegA(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op rorb(0x56[8])

rorb.disasm = {
	sink << "RORB";
}

rorb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }
	val = (carry << 7) | (val >> 1);
	cpu->setRegB(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}


// RORW: Rotate word Memory/Accumulator Right through Carry
op rorw_ext(0x18[8]:0x76[8]:> <:opr16a[16])

rorw_ext.disasm = {
	sink << "RORW $" << std::hex << opr16a;
}

rorw_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;
	
	uint16_t carry = 0;
	if ((val & 0x0001) == 0x0001) { carry = 1; }	
	val = (carry << 15) | (val >> 1);
	cpu->memWrite16(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op rorw_idx(0x18[8]:0x66[8]:> <:*xb[XB])

rorw_idx.disasm = {
	sink << "RORW ";
	xb->disasm(sink);
}

rorw_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;
	
	uint16_t carry = 0;
	if ((val & 0x0001) == 0x0001) { carry = 1; }	
	val = (carry << 15) | (val >> 1);
	cpu->memWrite16(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op rorx(0x18[8]:0x46[8])

rorx.disasm = {
	sink << "RORX";
}

rorx.execute = {
	uint16_t val = cpu->getRegX();
	uint16_t c2val = ~val + 1;
	
	uint16_t carry = 0;
	if ((val & 0x0001) == 0x0001) { carry = 1; }	
	val = (carry << 15) | (val >> 1);
	cpu->setRegX(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

op rory(0x18[8]:0x56[8])

rory.disasm = {
	sink << "RORY";
}

rory.execute = {
	uint16_t val = cpu->getRegY();
	uint16_t c2val = ~val + 1;
	
	uint16_t carry = 0;
	if ((val & 0x0001) == 0x0001) { carry = 1; }
	val = (carry << 15) | (val >> 1);
	cpu->setRegY(val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	cpu->ccr->clrN(); 
}

// ASR: Arithmetic Shift Right
op asr_ext(0x77[8]:> <:opr16a[16])

asr_ext.disasm = {
	sink << "ASR $" << std::hex << opr16a;
}

asr_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;

	uint8_t msb = val & 0x80;
		
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }
	
	val = (val >> 1) | msb;
	cpu->memWrite8(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 

}

op asr_idx(0x67[8]:> <:*xb[XB])

asr_idx.disasm = {
	sink << "ASR ";
	xb->disasm(sink);
}

asr_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint8_t val = cpu->memRead8(addr);
	uint8_t c2val = ~val + 1;

	uint8_t msb = val & 0x80;
	
	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	

	val = (val >> 1) | msb;
	cpu->memWrite8(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op asra(0x47[8])

asra.disasm = {
	sink << "ASRA";
}

asra.execute = {
	uint8_t val = cpu->getRegA();
	uint8_t c2val = ~val + 1;

	uint8_t msb = val & 0x80;

	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	
	
	val = (val >> 1) | msb;
	cpu->setRegA(val);

	if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op asrb(0x57[8])

asrb.disasm = {
	sink << "ASRB";
}

asrb.execute = {
	uint8_t val = cpu->getRegB();
	uint8_t c2val = ~val + 1;

	uint8_t msb = val & 0x80;

	uint8_t carry = 0;
	if ((val & 0x01) == 0x01) { carry = 1; }	
	
	val = (val >> 1) | msb;
	cpu->setRegB(val);

	if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x80) == 0x80) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

// ASRW: Arithmetic Shift Right word
op asrw_ext(0x18[8]:0x77[8]:> <:opr16a[16])

asrw_ext.disasm = {
	sink << "ASRW $" << std::hex << opr16a;
}

asrw_ext.execute = {
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;

	uint16_t msb = val & 0x8000;
		
	uint16_t carry = 0;
	if ((val & 0x0001) == 0x0001) { carry = 1; }
	
	val = (val >> 1) | msb;
	cpu->memWrite16(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 

}

op asrw_idx(0x18[8]:0x67[8]:> <:*xb[XB])

asrw_idx.disasm = {
	sink << "ASRW ";
	xb->disasm(sink);
}

asrw_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);		
	uint16_t val = cpu->memRead16(addr);
	uint16_t c2val = ~val + 1;

	uint16_t msb = val & 0x8000;
	
	uint16_t carry = 0;
	if ((val & 0x0001) == 0x0001) { carry = 1; }	

	val = (val >> 1) | msb;
	cpu->memWrite16(addr, val);

	if (carry) { cpu->ccr->setC();} else { cpu->ccr->clrC();}
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op asrx(0x18[8]:0x47[8])

asrx.disasm = {
	sink << "ASRX";
}

asrx.execute = {
	uint16_t val = cpu->getRegX();
	uint16_t c2val = ~val + 1;

	uint16_t msb = val & 0x8000;

	uint16_t carry = 0;
	if ((val & 0x0001) == 0x0001) { carry = 1; }	
	
	val = (val >> 1) | msb;
	cpu->setRegX(val);

	if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

op asry(0x18[8]:0x57[8])

asry.disasm = {
	sink << "ASRY";
}

asry.execute = {
	uint16_t val = cpu->getRegY();
	uint16_t c2val = ~val + 1;

	uint16_t msb = val & 0x8000;

	uint16_t carry = 0;
	if ((val & 0x0001) == 0x0001) { carry = 1; }	
	
	val = (val >> 1) | msb;
	cpu->setRegY(val);

	if (carry) { cpu->ccr->setC(); }	else { cpu->ccr->clrC(); }
	if (val == c2val) { cpu->ccr->setV(); } else { cpu->ccr->clrV(); }
	if (val == 0) { cpu->ccr->setZ(); } else { cpu->ccr->clrZ(); }
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN(); } else { cpu->ccr->clrN(); } 
}

// BTAS: Bit(s) Test and Set in Memory

op btas_dir(0x18[8]:0x35[8]:opr8a[8]:msk8[8])

btas_dir.disasm = {
	sink << "BTAS $" << std::hex << opr8a << ", $" << std::hex << msk8;
}

btas_dir.execute = {
/*
If (M) & (Mask) = 0, then set Z, else clear Z
(M) | (Mask) => M

N: Set if MSB of test is set; cleared otherwise
Z: Set if test is $00; cleared otherwise
V: 0; cleared
*/
	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr8a, MEMORY::DIRECT, WO_GLOBAL_ADDRESS);	
	uint8_t opr8aVal = cpu->memRead8(addr);
	
	uint8_t test = opr8aVal & msk8;
	if (test == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((test & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
	cpu->ccr->clrV();
	
	cpu->memWrite8(addr, opr8aVal | msk8);
}

op btas_ext(0x18[8]:> <:0x36[8]:opr16a[16]:msk8[8])

btas_ext.disasm = {
	sink << "BTAS $" << std::hex << opr16a << ", $" << std::hex << msk8;
}

btas_ext.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(opr16a, MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t opr16aVal = cpu->memRead8(addr);
	
	uint8_t test = opr16aVal & msk8;
	if (test == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((test & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
	cpu->ccr->clrV();
	
	cpu->memWrite8(addr, opr16aVal | msk8);
}

op btas_idx(0x18[8]:0x37[8]:> <:*xb[XB]:> <:msk8[8])

btas_idx.disasm = {
	sink << "BTAS ";
	xb->disasm(sink);
	sink << ", $" << std::hex << msk8;
}

btas_idx.execute = {

	physical_address_t addr = cpu->mmc->getPhysicalAddress(xb->getEAddr(cpu), MEMORY::EXTENDED, WO_GLOBAL_ADDRESS);	
	uint8_t xbVal = cpu->memRead8(addr);
	
	uint8_t test = xbVal & msk8;
	if (test == 0) { cpu->ccr->setZ();} else { cpu->ccr->clrZ();}
	if ((test & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN();}
	cpu->ccr->clrV();
	
	cpu->memWrite8(addr, xbVal | msk8);
}

