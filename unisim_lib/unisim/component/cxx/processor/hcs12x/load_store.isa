// -*- C++ -*-


// LDAA or LDAB #opr8i
op ldaab_imm(0b1[1]:b[1]:0x6[6]:opr8i[8])

ldaab_imm.disasm = {
    if (b==0) {
	    sink << "LDAA #$";
    } else {
	    sink << "LDAB #$";
    }
    sink  << std::hex << opr8i;    
}

ldaab_imm.execute = {
	if (b==0) {
	    cpu->setRegA(opr8i); // ldaa #<opr8i>
	} else {
	    cpu->setRegB(opr8i); // ldab #<opr8i>	
	}
// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (opr8i == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if (opr8i < 0) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
}

// LDAA or LDAB opr8a
op ldaab_dir( 0b1[1]:b[1]:0x16[6]:opr8a[8] )

ldaab_dir.disasm = {
	if (b==0) {
	    sink << "LDAA $";
	} else {
	    sink << "LDAB $";
	}
	sink << std::hex << opr8a;
}

ldaab_dir.execute = {
	uint8_t val = cpu->memRead8((uint16_t) opr8a, MEMORY::DIRECT);
	if (b==0) {
	    cpu->setRegA(val);
	} else {
	    cpu->setRegB(val);	
	}
// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
}

// LDAA or LDAB opr16a
op ldaab_ext(0b1[1]:b[1]:0x36[6]:> <:opr16a[16] )

ldaab_ext.disasm = {
	if (b==0) {
	    sink << "LDAA $";
	} else {
	    sink << "LDAB $";	
	}
	sink << std::hex << opr16a; 
}

ldaab_ext.execute = {
	uint8_t val = cpu->memRead8(opr16a); 
	if (b==0) {
	    cpu->setRegA(val);
	} else {
	    cpu->setRegB(val);
	}
// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }
	
}

// LDAA or LDAB oprx0_xysp
// LDAA or LDAB oprx9,xysp
// LDAA or LDAB oprx16,xysp
// LDAA or LDAB [D,xysp]
// LDAA or LDAB [oprx16,xysp]
op ldaab_idx(0b1[1]:b[1]:0x26[6]:> <:*xb[XB]) 

ldaab_idx.disasm = {
	if (b==0) {
	    sink << "LDAA ";
	} else {
	    sink << "LDAB ";	
	}
    xb->disasm(sink);
}

ldaab_idx.execute = {
    
    address_t	addr = xb->getEAddr(cpu);
	uint8_t		val = cpu->memRead8(addr);     
	
	if (b==0) {
	    cpu->setRegA(val);
	} else {
	    cpu->setRegB(val);	
	}
// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

// LDD or LDY or LDX or LDS #opr16i
op ld_dyxs_imm(0x33[6]:dyxs[2]:> <:opr16i[16])

ld_dyxs_imm.disasm = {

	switch (dyxs) {
	case 0: sink << "LDD #$"; break;
	case 1: sink << "LDY #$"; break;
	case 2: sink << "LDX #$"; break;
	case 3: sink << "LDS #$"; break;
	}
	sink << std::hex << opr16i;
}

ld_dyxs_imm.execute = {

	switch (dyxs) {
	case 0: cpu->setRegD(opr16i); break;
	case 1: cpu->setRegY(opr16i); break;
	case 2: cpu->setRegX(opr16i); break;
	case 3: cpu->setRegSP(opr16i); break;
	}
// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (opr16i == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((opr16i & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

// LDD or LDY or LDX or LDS opr8a
op ld_dyxs_dir(0x37[6]:dyxs[2]:dd[8])

ld_dyxs_dir.disasm = {

	switch (dyxs) {
	case 0: sink << "LDD $"; break;
	case 1: sink << "LDY $"; break;
	case 2: sink << "LDX $"; break;
	case 3: sink << "LDS $"; break;
	}
	sink << std::hex << dd;
}

ld_dyxs_dir.execute = {

	uint16_t val = cpu->memRead16((uint16_t) dd, MEMORY::DIRECT);
	switch (dyxs) {
	case 0: cpu->setRegD(val); break;
	case 1: cpu->setRegY(val); break;
	case 2: cpu->setRegX(val); break;
	case 3: cpu->setRegSP(val); break;
	}
// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

// LDD or LDY or LDX or LDS opr16a
op ld_dyxs_ext(0x3F[6]:dyxs[2]:> <:opr16a[16])

ld_dyxs_ext.disasm = {

	switch (dyxs) {
	case 0: sink << "LDD $"; break;
	case 1: sink << "LDY $"; break;
	case 2: sink << "LDX $"; break;
	case 3: sink << "LDS $"; break;
	}

	sink << std::hex << opr16a;
}

ld_dyxs_ext.execute = {
	
	uint16_t val = cpu->memRead16(opr16a);
	
	switch (dyxs) {
	case 0: cpu->setRegD(val); break;
	case 1: cpu->setRegY(val); break;
	case 2: cpu->setRegX(val); break;
	case 3: cpu->setRegSP(val); break;
	}
// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

// LDD or LDY or LDX or LDS oprx0_xysp
// LDD or LDY or LDX or LDS oprx9,xysp
// LDD or LDY or LDX or LDS oprx16,xysp
// LDD or LDY or LDX or LDS [D,xysp]
// LDD or LDY or LDX or LDS [oprx16,xysp]
op ld_dyxs_idx(0x3B[6]:dyxs[2]:> <:*xb[XB]) 

ld_dyxs_idx.disasm = {

	switch (dyxs) {
	case 0: sink << "LDD "; break;
	case 1: sink << "LDY "; break;
	case 2: sink << "LDX "; break;
	case 3: sink << "LDS "; break;
	}

    xb->disasm(sink);
}

ld_dyxs_idx.execute = {
    
    address_t	addr = xb->getEAddr(cpu);
	uint16_t	val = cpu->memRead16(addr);     

	switch (dyxs) {
	case 0: cpu->setRegD(val); break;
	case 1: cpu->setRegY(val); break;
	case 2: cpu->setRegX(val); break;
	case 3: cpu->setRegSP(val); break;
	}
// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

  
// LEAY oprx0_xysp
// LEAY oprx9,xysp
// LEAY oprx16,xysp
op leay(0x19[8]:> <:*xb[XB])

leay.disasm = {

	sink << "LEAY ";
	xb->disasm(sink);
}

leay.execute = {

    address_t	addr = xb->getEAddr(cpu);
    
	cpu->setRegY(addr);
	
}

// LEAX oprx0_xysp
// LEAX oprx9,xysp
// LEAX oprx16,xysp
op leax(0x1A[8]:> <:*xb[XB])

leax.disasm = {

	sink << "LEAX ";
	
	xb->disasm(sink);
}

leax.execute = {

    address_t	addr = xb->getEAddr(cpu);
    
	cpu->setRegX(addr);
	
}

// LEAS  oprx0_xysp
// LEAS  oprx9,xysp
// LEAS  oprx16,xysp
op leas(0x1B[8]:> <:*xb[XB])

leas.disasm = {

	sink << "LEAS ";
	
	xb->disasm(sink);
}

leas.execute = {

    address_t	addr = xb->getEAddr(cpu);
    
	cpu->setRegSP(addr);
	
}

// STAA or STAB opr8a
op staab_dir(0x2D[7]:b[1]:opr8a[8])

staab_dir.disasm = {

	if (b==0) {
	    sink << "STAA $";
	} else {
	    sink << "STAB $";
	}
	sink << std::hex << opr8a;

}

staab_dir.execute = {

	uint8_t val;

	if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }
    cpu->memWrite8((uint16_t) opr8a, val, MEMORY::DIRECT);	

// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

// STAA or STAB opr16a
op staab_ext(0x3D[7]:b[1]:> <:opr16a[16])

staab_ext.disasm = {

	if (b==0) {
	    sink << "STAA $";
	} else {
	    sink << "STAB $";
	}
	sink << std::hex << opr16a;

}

staab_ext.execute = {

	uint8_t	val;
	if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }
    cpu->memWrite8((uint16_t) opr16a, val, MEMORY::DIRECT);

// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

// STAA or STAB oprx0_xysp
// STAA or STAB oprx9,xysp
// STAA or STAB oprx16,xysp
// STAA or STAB [D,xysp]
// STAA or STAB [oprx16,xysp]

op staab_idx(0x35[7]:b[1]:> <:*xb[XB])

staab_idx.disasm = {

	if (b==0) {
	    sink << "STAA ";
	} else {
	    sink << "STAB ";	
	}
    xb->disasm(sink);

}

staab_idx.execute = {

    address_t	addr = xb->getEAddr(cpu);
	uint8_t val;
	if (b == 0) { val = cpu->getRegA(); } else { val = cpu->getRegB(); }
    cpu->memWrite8(addr,val);	

// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x80) == 0x80) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

// STD or STY or STX or STS opr8a
op st_dyxs_dir(0x17[6]:dyxs[2]:opr8a[8])

st_dyxs_dir.disasm = {

	switch (dyxs) {
	case 0: sink << "STD $"; break;
	case 1: sink << "STY $"; break;
	case 2: sink << "STX $"; break;
	case 3: sink << "STS $"; break;
	}
	
	sink << std::hex << opr8a;
}

st_dyxs_dir.execute = {

	uint16_t val;
	
	switch (dyxs) {
	case 0: val = cpu->getRegD(); break;
	case 1: val = cpu->getRegY(); break;
	case 2: val = cpu->getRegX(); break;
	case 3: val = cpu->getRegSP(); break;
	}
	
	cpu->memWrite16((uint16_t) opr8a, val, MEMORY::DIRECT);

// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

// STD or STY or STX or STS opr16a
op st_dyxs_ext(0x1F[6]:dyxs[2]:> <:opr16a[16])

st_dyxs_ext.disasm = {

	switch (dyxs) {
	case 0: sink << "STD $"; break;
	case 1: sink << "STY $"; break;
	case 2: sink << "STX $"; break;
	case 3: sink << "STS $"; break;
	}
	
	sink << std::hex << opr16a;

}

st_dyxs_ext.execute = {

	uint16_t val = 0;
		
	switch (dyxs) {
	case 0: val = cpu->getRegD(); break;
	case 1: val = cpu->getRegY(); break;
	case 2: val = cpu->getRegX(); break;
	case 3: val = cpu->getRegSP(); break;
	}
	
	cpu->memWrite16(opr16a, val);

// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}

// STD or STY or STX or STS oprx0_xysp
// STD or STY or STX or STS oprx9,xysp
// STD or STY or STX or STS oprx16,xysp
// STD or STY or STX or STS [D,xysp]
// STD or STY or STX or STS [oprx16,xysp]

op st_dyxs_idx(0x1B[6]:dyxs[2]:> <:*xb[XB])

st_dyxs_idx.disasm = {

	switch (dyxs) {
	case 0: sink << "STD "; break;
	case 1: sink << "STY "; break;
	case 2: sink << "STX "; break;
	case 3: sink << "STS "; break;
	}

    xb->disasm(sink);

}

st_dyxs_idx.execute = {

    address_t	addr = xb->getEAddr(cpu);
	uint16_t val = 0;
	
	switch (dyxs) {
	case 0: val = cpu->getRegD(); break;
	case 1: val = cpu->getRegY(); break;
	case 2: val = cpu->getRegX(); break;
	case 3: val = cpu->getRegSP(); break;
	}
	cpu->memWrite16(addr,val);

// CRC flags 0->V; setZ; setN
	cpu->ccr->clrV();
	if (val == 0) {cpu->ccr->setZ();} else {cpu->ccr->clrZ();}
	if ((val & 0x8000) == 0x8000) { cpu->ccr->setN();} else { cpu->ccr->clrN(); }

}
