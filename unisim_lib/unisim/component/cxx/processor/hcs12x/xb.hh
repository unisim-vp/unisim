/*** File generated by GenISSLib version 2.1: DO NOT MODIFY ***/
#ifndef __xb_unisim__component__cxx__processor__hcs12x__XB_HH__
#define __xb_unisim__component__cxx__processor__hcs12x__XB_HH__
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

#include <vector>
#include <inttypes.h>
#include <cstring>
#include <iosfwd>
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x { namespace XB {
struct CodeType {
	static const unsigned int capacity = 3;
	unsigned int              size;
	uint8_t                   str[capacity];
	enum Exception_t { NotEnoughBytes };
	CodeType() : size( 0 ) {};
	CodeType( uint8_t* src, unsigned int sz )
	: size( std::min( sz, capacity*8 ) )
	{
		for (int idx = (size+7)/8; (--idx) >= 0;) str[idx] = src[idx];
	}
	CodeType( CodeType const& ct )
	: size( ct.size )
	{
		str[0] = ct.str[0]; str[1] = ct.str[1]; str[2] = ct.str[2];
	}
	bool match( CodeType const& bits, CodeType const& mask ) const {
		unsigned int maskbound = (mask.size+7)/8, codebound = (size+7)/8;
		for (unsigned int idx = 0; idx < maskbound; ++idx) {
			if (idx >= codebound) throw NotEnoughBytes;
			if ((str[idx] & mask.str[idx]) != bits.str[idx]) return false;
		};
		return true;
	}
	bool match( CodeType const& bits ) const {
		if (size < bits.size) throw NotEnoughBytes;
		unsigned int end = bits.size/8;
		for (unsigned int idx = 0; idx < end; idx += 1)
		if (str[idx] != bits.str[idx]) return false;
		unsigned int tail = (bits.size        );
		if (tail == 0); return true;  uint8_t tailmask = 0xff << (8-tail);
		return ((str[end] ^ bits.str[end]) & tailmask) == 0;
	}
	CodeType& stretch_front( unsigned int shift ) {
		int hish = shift / 8, losh = shift % 8;
		for (int dst = 2, src = dst - hish; dst >= 0; dst-=1, src-=1) {
			if (src > 0) str[dst] = (str[src] >> losh) | (str[src-1] << (8-losh));
			else if (src == 0) str[dst] = (str[src] >> losh);
			else str[dst] = 0;
		}
		return *this;
	}
	CodeType& shrink_front( unsigned int shift ) {
		int hish = shift / 8, losh = shift % 8;
		for (unsigned int dst = 0, src = dst + hish; dst < 3; dst+=1, src+=1) {
			if (src < 2) str[dst] = (str[src] << losh) | (str[src-1] >> (8-losh));
			else if (src == 2) str[dst] = (str[src] << losh);
			else str[dst] = 0;
		}
		return *this;
	}
	CodeType& extend( uint8_t* src, unsigned int sz ) {
		CodeType tail( src, sz );
		unsigned int mod = this->size % 8;
		if (mod) {
			tail.size = std::min( tail.size + mod, capacity*8 );
			tail.stretch_front( mod );
			tail.str[0] = (tail.str[0] & (0xff >> mod)) | (this->str[this->size/8] & (0xff << (8-mod)));
			this->size -= mod;
		}
		for (unsigned int src = 0, dst = this->size/8; (src < this->capacity) and (dst < this->capacity); src+=1, dst+=1) {
			this->str[dst] = tail.str[src];
		}
		this->size = std::min( this->size + tail.size, capacity*8 );
		return *this;
	}
	friend std::ostream& operator << ( std::ostream& _sink, CodeType const& _ct );
};
class Operation;
class DecodeTableEntry
{
public:
	DecodeTableEntry(CodeType const& opcode, CodeType const& opcode_mask, Operation *(*decode)(CodeType const&, uint16_t));
	CodeType opcode;
	CodeType opcode_mask;
	Operation *(*decode)(CodeType const& code, uint16_t addr);
};
const unsigned int NUM_DECODE_HASH_TABLE_ENTRIES = 4096;
class Decoder
{
public:
	Decoder();
	virtual ~Decoder();

	Operation *NCDecode(uint16_t addr, CodeType const& code);
	void SetLittleEndian();
	void SetBigEndian();
private:
	bool is_little_endian;
	std::vector<DecodeTableEntry > decode_table;
};

inline
Operation *sub_decode(uint16_t addr, CodeType const& code) {
	static Decoder decoder;
	return decoder.NCDecode( addr, code );
}
} } } } } }
#line 48 "xb.isa"


#include <iosfwd>
#include <iostream>
#include <vector>

#include <unisim/component/cxx/processor/hcs12x/hcs12x.hh>

namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x { namespace XB {

	class XbModes {
	public:
		enum MODE {IDX=0, IDX1=1, IDX2=2, IDXD_Ind=3, IDX2_Ind=4, Unknown=0xFF};

		static inline uint8_t GetIDXCycles(uint8_t xbMode, uint8_t idx, uint8_t idx1, uint8_t idx2, uint8_t idxd_ind, uint8_t idx2_ind)
		{
			switch (xbMode)
			{
				case XbModes::IDX: return idx;
				case XbModes::IDX1: return idx1;
				case XbModes::IDX2: return idx2;
				case XbModes::IDXD_Ind: return idxd_ind;
				case XbModes::IDX2_Ind: return idx2_ind;
				default: return 0xff;
			}
		}

	};

} } } } } }  // end namespaces

#line 144 "xb.hh"
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x { namespace XB {
class Operation
{
public:
	Operation(CodeType const& code, uint16_t addr, const char *name);
	virtual ~Operation();
	inline uint16_t GetAddr() const { return addr; }
	inline CodeType const& GetEncoding() const { return encoding; }
	inline unsigned int GetLength() const { return this->encoding.size; }
	inline const char *GetName() const { return name; }
	static unsigned int const minsize = 8;
	static unsigned int const maxsize = 24;
	virtual
#line 136 "xb.isa"
	void
#line 160 "xb.hh"
	post_execute(
#line 136 "xb.isa"
	ostream&
#line 164 "xb.hh"
#line 136 "xb.isa"
	sink
#line 167 "xb.hh"
	);
	virtual
#line 100 "xb.isa"
	void
#line 172 "xb.hh"
	pre_execute(
#line 100 "xb.isa"
	ostream&
#line 176 "xb.hh"
#line 100 "xb.isa"
	sink
#line 179 "xb.hh"
	);
	virtual
#line 97 "xb.isa"
	void
#line 184 "xb.hh"
	getRegsLabel(
#line 97 "xb.isa"
	vector<string>
#line 188 "xb.hh"
#line 97 "xb.isa"
	&vect
#line 191 "xb.hh"
	);
	virtual
#line 95 "xb.isa"
	uint16_t
#line 196 "xb.hh"
	getEAddr(
#line 95 "xb.isa"
	CPU *
#line 200 "xb.hh"
#line 95 "xb.isa"
	cpu
#line 203 "xb.hh"
	);
	virtual
#line 91 "xb.isa"
	void
#line 208 "xb.hh"
	disasm(
#line 91 "xb.isa"
	ostream&
#line 212 "xb.hh"
#line 91 "xb.isa"
	sink
#line 215 "xb.hh"
	);
	virtual
#line 86 "xb.isa"
	uint8_t
#line 220 "xb.hh"
	getXbMode( );
protected:
	CodeType encoding;
	uint16_t addr;
	const char *name;
};

} } } } } }
#endif
