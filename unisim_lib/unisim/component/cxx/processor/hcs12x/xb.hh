/*** File generated by GenISSLib version 2.1: DO NOT MODIFY ***/
#ifndef __xb_unisim__component__cxx__processor__hcs12x__XB_HH__
#define __xb_unisim__component__cxx__processor__hcs12x__XB_HH__
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

#include <vector>
#include <inttypes.h>
#include <iosfwd>
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x { namespace XB {
struct CodeType {
	static const unsigned int maxsize = 3;
	unsigned int              size;
	uint8_t                   str[maxsize];
	enum Exception_t { NotEnoughBytes };
	CodeType() : size( 0 ) {};
	CodeType( uint8_t* _src, unsigned int _size )
	: size( std::min( _size, maxsize ) ) { memcpy( str, _src, size ); }
	CodeType( CodeType const& _ct )
	: size( _ct.size ) { memcpy( str, _ct.str, _ct.size ); }
	bool match( CodeType const& _bits, CodeType const& _mask ) const {
		for( unsigned int idx = 0; idx < _mask.size; ++idx ) {
			if( idx >= size ) throw NotEnoughBytes;
			if( (str[idx] & _mask.str[idx]) != _bits.str[idx] ) return false;
		};
		return true;
	};
	bool match( CodeType const& _bits ) const {
		if( size < _bits.size ) throw NotEnoughBytes;
		return memcmp( str, _bits.str, _bits.size ) == 0;
	}
	void pop( unsigned int _bytes ) {
		if( size < _bytes ) throw NotEnoughBytes;
		size -= _bytes;
		memmove( str, str + _bytes, size );
	}
	friend std::ostream& operator << ( std::ostream& _sink, CodeType const& _ct );
};
class Operation;
class DecodeTableEntry
{
public:
	DecodeTableEntry(CodeType const& opcode, CodeType const& opcode_mask, Operation *(*decode)(CodeType const&, uint16_t));
	CodeType opcode;
	CodeType opcode_mask;
	Operation *(*decode)(CodeType const& code, uint16_t addr);
};
const unsigned int NUM_DECODE_HASH_TABLE_ENTRIES = 4096;
class Decoder
{
public:
	Decoder();
	virtual ~Decoder();

	Operation *NCDecode(uint16_t addr, CodeType const& code);
	void SetLittleEndian();
	void SetBigEndian();
private:
	bool little_endian;
	std::vector<DecodeTableEntry > decode_table;
};

inline
Operation *sub_decode(uint16_t addr, CodeType const& code) {
	static Decoder decoder;
	return decoder.NCDecode( addr, code );
}
} } } } } }
#line 43 "xb.isa"


#include <iosfwd>
#include <iostream>

#include <unisim/component/cxx/processor/hcs12x/hcs12x.hh>

#line 79 "xb.hh"
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x { namespace XB {
class Operation
{
public:
	Operation(CodeType const& code, uint16_t addr, const char *name);
	virtual ~Operation();
	inline uint16_t GetAddr() const { return addr; }
	inline CodeType const& GetEncoding() const { return encoding; }
	inline const char *GetName() const { return name; }
	virtual
#line 62 "xb.isa"
	uint16_t
#line 92 "xb.hh"
	getEAddr(
#line 62 "xb.isa"
	CPU *
#line 96 "xb.hh"
#line 62 "xb.isa"
	cpu
#line 99 "xb.hh"
	);
	virtual
#line 58 "xb.isa"
	void
#line 104 "xb.hh"
	disasm(
#line 58 "xb.isa"
	ostream&
#line 108 "xb.hh"
#line 58 "xb.isa"
	sink
#line 111 "xb.hh"
	);
	virtual
#line 56 "xb.isa"
	uint8_t
#line 116 "xb.hh"
	getCycles( );
protected:
	CodeType encoding;
	uint16_t addr;
	const char *name;
};

} } } } } }
#endif
