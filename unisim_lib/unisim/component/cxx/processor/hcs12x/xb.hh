/*** File generated by GenISSLib version 2.1: DO NOT MODIFY ***/
#ifndef __xb_unisim__component__cxx__processor__hcs12x__XB_HH__
#define __xb_unisim__component__cxx__processor__hcs12x__XB_HH__
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

#include <vector>
#include <inttypes.h>
#include <cstring>
#include <iosfwd>
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x { namespace XB {
struct CodeType {
	static const unsigned int maxsize = 3;
	unsigned int              size;
	uint8_t                   str[maxsize];
	enum Exception_t { NotEnoughBytes };
	CodeType() : size( 0 ) {};
	CodeType( uint8_t* _src, unsigned int _size )
	: size( std::min( _size, maxsize ) ) { memcpy( str, _src, size ); }
	CodeType( CodeType const& _ct )
	: size( _ct.size ) { memcpy( str, _ct.str, _ct.size ); }
	bool match( CodeType const& _bits, CodeType const& _mask ) const {
		for( unsigned int idx = 0; idx < _mask.size; ++idx ) {
			if( idx >= size ) throw NotEnoughBytes;
			if( (str[idx] & _mask.str[idx]) != _bits.str[idx] ) return false;
		};
		return true;
	};
	bool match( CodeType const& _bits ) const {
		if( size < _bits.size ) throw NotEnoughBytes;
		return memcmp( str, _bits.str, _bits.size ) == 0;
	}
	void pop( unsigned int _bytes ) {
		if( size < _bytes ) throw NotEnoughBytes;
		size -= _bytes;
		memmove( str, str + _bytes, size );
	}
	friend std::ostream& operator << ( std::ostream& _sink, CodeType const& _ct );
};
class Operation;
class DecodeTableEntry
{
public:
	DecodeTableEntry(CodeType const& opcode, CodeType const& opcode_mask, Operation *(*decode)(CodeType const&, uint16_t));
	CodeType opcode;
	CodeType opcode_mask;
	Operation *(*decode)(CodeType const& code, uint16_t addr);
};
const unsigned int NUM_DECODE_HASH_TABLE_ENTRIES = 4096;
class Decoder
{
public:
	Decoder();
	virtual ~Decoder();

	Operation *NCDecode(uint16_t addr, CodeType const& code);
	void SetLittleEndian();
	void SetBigEndian();
private:
	bool is_little_endian;
	std::vector<DecodeTableEntry > decode_table;
};

inline
Operation *sub_decode(uint16_t addr, CodeType const& code) {
	static Decoder decoder;
	return decoder.NCDecode( addr, code );
}
} } } } } }
#line 48 "xb.isa"


#include <iosfwd>
#include <iostream>
#include <vector>

#include <unisim/component/cxx/processor/hcs12x/hcs12x.hh>

namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x { namespace XB {

	class XbModes {
	public:
		enum MODE {IDX=0, IDX1=1, IDX2=2, IDXD_Ind=3, IDX2_Ind=4, Unknown=0xFF};

		static inline uint8_t GetIDXCycles(uint8_t xbMode, uint8_t idx, uint8_t idx1, uint8_t idx2, uint8_t idxd_ind, uint8_t idx2_ind)
		{
			switch (xbMode)
			{
				case XbModes::IDX: return idx;
				case XbModes::IDX1: return idx1;
				case XbModes::IDX2: return idx2;
				case XbModes::IDXD_Ind: return idxd_ind;
				case XbModes::IDX2_Ind: return idx2_ind;
				default: return 0xff;
			}
		}

	};

} } } } } }  // end namespaces

#line 104 "xb.hh"
namespace unisim { namespace component { namespace cxx { namespace processor { namespace hcs12x { namespace XB {
class Operation
{
public:
	Operation(CodeType const& code, uint16_t addr, const char *name);
	virtual ~Operation();
	inline uint16_t GetAddr() const { return addr; }
	inline CodeType const& GetEncoding() const { return encoding; }
	inline unsigned int GetLength() const { return this->encoding.size; }
	inline const char *GetName() const { return name; }
	static unsigned int const minsize = 8;
	static unsigned int const maxsize = 24;
	virtual
#line 136 "xb.isa"
	void
#line 120 "xb.hh"
	post_execute(
#line 136 "xb.isa"
	ostream&
#line 124 "xb.hh"
#line 136 "xb.isa"
	sink
#line 127 "xb.hh"
	);
	virtual
#line 100 "xb.isa"
	void
#line 132 "xb.hh"
	pre_execute(
#line 100 "xb.isa"
	ostream&
#line 136 "xb.hh"
#line 100 "xb.isa"
	sink
#line 139 "xb.hh"
	);
	virtual
#line 97 "xb.isa"
	void
#line 144 "xb.hh"
	getRegsLabel(
#line 97 "xb.isa"
	vector<string>
#line 148 "xb.hh"
#line 97 "xb.isa"
	&vect
#line 151 "xb.hh"
	);
	virtual
#line 95 "xb.isa"
	uint16_t
#line 156 "xb.hh"
	getEAddr(
#line 95 "xb.isa"
	CPU *
#line 160 "xb.hh"
#line 95 "xb.isa"
	cpu
#line 163 "xb.hh"
	);
	virtual
#line 91 "xb.isa"
	void
#line 168 "xb.hh"
	disasm(
#line 91 "xb.isa"
	ostream&
#line 172 "xb.hh"
#line 91 "xb.isa"
	sink
#line 175 "xb.hh"
	);
	virtual
#line 86 "xb.isa"
	uint8_t
#line 180 "xb.hh"
	getXbMode( );
protected:
	CodeType encoding;
	uint16_t addr;
	const char *name;
};

} } } } } }
#endif
