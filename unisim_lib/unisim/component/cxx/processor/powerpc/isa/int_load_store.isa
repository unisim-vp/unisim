/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Gilles Mouchard (gilles.mouchard@cea.fr)
 */

/***************************

INTEGER LOAD INSTRUCTIONS

***************************/
op lbz(34[6]:rd[5]:ra[5]:sext<32>d[16])
lbz.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
	// do the memory access
	return cpu->Int8Load(rd, ea);
}
lbz.disasm = {
	os << "lbz r" << (unsigned int) rd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lbzu(35[6]:rd[5]:ra[5]:sext<32>d[16])
lbzu.execute = {
	if(unlikely(ra == 0 || ra == rd))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
	// do the memory access
	if(unlikely(!cpu->Int8Load(rd, ea))) return false;
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
lbzu.disasm = {
	os << "lbzu r" << (unsigned int) rd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lbzux(31[6]:rd[5]:ra[5]:rb[5]:119[10]:?[1])
lbzux.execute = {
	if(unlikely(ra == 0 || ra == rd))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// do the memory access
	if(unlikely(!cpu->Int8Load(rd, ea))) return false;
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
lbzux.disasm = {
	os << "lbzux r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lbzx(31[6]:rd[5]:ra[5]:rb[5]:87[10]:?[1])
lbzx.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
	// do the memory access
	return cpu->Int8Load(rd, ea);
}
lbzx.disasm = {
	os << "lbzx r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lha(42[6]:rd[5]:ra[5]:sext<32>d[16])
lha.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
	// do the memory access
	return cpu->SInt16Load(rd, ea); // 16-bit load/no byte reverse/sign extend
}
lha.disasm = {
	os << "lha r" << (unsigned int) rd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lhau(43[6]:rd[5]:ra[5]:sext<32>d[16])
lhau.execute = {
	if(unlikely(ra == 0 || ra == rd))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
	// do the memory access
	if(unlikely(!cpu->SInt16Load(rd, ea))) return false; // 16-bit load/no byte reverse/sign extend
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
lhau.disasm = {
	os << "lhau r" << (unsigned int) rd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lhaux(31[6]:rd[5]:ra[5]:rb[5]:375[10]:?[1])
lhaux.execute = {
	if(unlikely(ra == 0 || ra == rd))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// do the memory access
	if(unlikely(!cpu->SInt16Load(rd, ea))) return false; // 16-bit load/no byte reverse/sign extend
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
lhaux.disasm = {
	os << "lhaux r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lhax(31[6]:rd[5]:ra[5]:rb[5]:343[10]:?[1])
lhax.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
	// do the memory access
	return cpu->SInt16Load(rd, ea); // 16-bit load/no byte reverse/sign extend
}
lhax.disasm = {
	os << "lhax r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lhz(40[6]:rd[5]:ra[5]:sext<32>d[16])
lhz.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
	// do the memory access
	return cpu->Int16Load(rd, ea); // 16-bit load/no byte reverse/no sign extend
}
lhz.disasm = {
	os << "lhz r" << (unsigned int) rd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lhzu(41[6]:rd[5]:ra[5]:sext<32>d[16])
lhzu.execute = {
	if(unlikely(ra == 0 || ra == rd))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
	// do the memory access
	if(unlikely(!cpu->Int16Load(rd, ea))) return false; // 16-bit load/no byte reverse/no sign extend
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
lhzu.disasm = {
	os << "lhzu r" << (unsigned int) rd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lhzux(31[6]:rd[5]:ra[5]:rb[5]:311[10]:?[1])
lhzux.execute = {
	if(unlikely(ra == 0 || ra == rd))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// do the memory access
	if(unlikely(!cpu->Int16Load(rd, ea))) return false; // 16-bit load/no byte reverse/no sign extend
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
lhzux.disasm = {
	os << "lhzux r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lhzx(31[6]:rd[5]:ra[5]:rb[5]:279[10]:?[1])
lhzx.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
	// do the memory access
	return cpu->Int16Load(rd, ea); // 16-bit load/no byte reverse/no sign extend
}
lhzx.disasm = {
	os << "lhzx r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lwz(32[6]:rd[5]:ra[5]:sext<32>d[16])
lwz.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
	// do the memory access
	return cpu->Int32Load(rd, ea); // 32-bit load/no byte reverse/no sign extend
}
lwz.disasm = {
	os << "lwz r" << (unsigned int) rd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lwzu(33[6]:rd[5]:ra[5]:sext<32>d[16])
lwzu.execute = {
	if(unlikely(ra == 0 || ra == rd))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
	// do the memory access
	if(unlikely(!cpu->Int32Load(rd, ea))) return false; // 32-bit load/no byte reverse/no sign extend
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
lwzu.disasm = {
	os << "lwzu r" << (unsigned int) rd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lwzux(31[6]:rd[5]:ra[5]:rb[5]:55[10]:?[1])
lwzux.execute = {
	if(unlikely(ra == 0 || ra == rd))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// do the memory access
	if(unlikely(!cpu->Int32Load(rd, ea))) return false; // 32-bit load/no byte reverse/no sign extend
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
lwzux.disasm = {
	os << "lwzux r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lwzx(31[6]:rd[5]:ra[5]:rb[5]:23[10]:?[1])
lwzx.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
	// do the memory access
	return cpu->Int32Load(rd, ea); // 32-bit load/no byte reverse/no sign extend
}
lwzx.disasm = {
	os << "lwzx r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

/****************************

INTEGER STORE INSTRUCTIONS

****************************/
op stb(38[6]:rs[5]:ra[5]:sext<32>d[16])
stb.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
	// do the memory access
	return cpu->Int8Store(rs, ea);
}
stb.disasm = {
	os << "stb r" << (unsigned int) rs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stbu(39[6]:rs[5]:ra[5]:sext<32>d[16])
stbu.execute = {
	if(unlikely(ra == 0))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
	// do the memory access
	if(unlikely(!cpu->Int8Store(rs, ea))) return false;
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
stbu.disasm = {
	os << "stbu r" << (unsigned int) rs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stbux(31[6]:rs[5]:ra[5]:rb[5]:247[10]:?[1])
stbux.execute = {
	if(unlikely(ra == 0))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// do the memory access
	if(unlikely(!cpu->Int8Store(rs, ea))) return false;
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
stbux.disasm = {
	os << "stbux r" << (unsigned int) rs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stbx(31[6]:rs[5]:ra[5]:rb[5]:215[10]:?[1])
stbx.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
	// do the memory access
	return cpu->Int8Store(rs, ea);
}
stbx.disasm = {
	os << "stbx r" << (unsigned int) rs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op sth(44[6]:rs[5]:ra[5]:sext<32>d[16])
sth.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
	// do the memory access
	return cpu->Int16Store(rs, ea);
}
sth.disasm = {
	os << "sth r" << (unsigned int) rs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op sthu(45[6]:rs[5]:ra[5]:sext<32>d[16])
sthu.execute = {
	if(unlikely(ra == 0))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
	// do the memory access
	if(unlikely(!cpu->Int16Store(rs, ea))) return false;
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
sthu.disasm = {
	os << "sthu r" << (unsigned int) rs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op sthux(31[6]:rs[5]:ra[5]:rb[5]:439[10]:?[1])
sthux.execute = {
	if(unlikely(ra == 0))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// do the memory access
	if(unlikely(!cpu->Int16Store(rs, ea))) return false;
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
sthux.disasm = {
	os << "sthux r" << (unsigned int) rs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op sthx(31[6]:rs[5]:ra[5]:rb[5]:407[10]:?[1])
sthx.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
	// do the memory access
	return cpu->Int16Store(rs, ea);
}
sthx.disasm = {
	os << "sthx r" << (unsigned int) rs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stw(36[6]:rs[5]:ra[5]:sext<32>d[16])
stw.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
	// do the memory access
	return cpu->Int32Store(rs, ea);
}
stw.disasm = {
	os << "stw r" << (unsigned int) rs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stwu(37[6]:rs[5]:ra[5]:sext<32>d[16])
stwu.execute = {
	if(unlikely(ra == 0))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
	// do the memory access
	if(unlikely(!cpu->Int32Store(rs, ea))) return false;
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
stwu.disasm = {
	os << "stwu r" << (unsigned int) rs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stwux(31[6]:rs[5]:ra[5]:rb[5]:183[10]:?[1])
stwux.execute = {
	if(unlikely(ra == 0))
	{
		cpu->SetException(CONFIG::EXC_PROGRAM_ILLEGAL_INSTRUCTION);
		return false;
	}
	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// do the memory access
	if(unlikely(!cpu->Int32Store(rs, ea))) return false;
	// update the address register
	cpu->SetGPR(ra, ea);
	
	return true;
}
stwux.disasm = {
	os << "stwux r" << (unsigned int) rs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stwx(31[6]:rs[5]:ra[5]:rb[5]:151[10]:?[1])
stwx.execute = {
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
	// do the memory access
	return cpu->Int32Store(rs, ea);
}
stwx.disasm = {
	os << "stwx r" << (unsigned int) rs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}
