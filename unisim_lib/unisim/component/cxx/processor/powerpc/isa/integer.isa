/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Gilles Mouchard (gilles.mouchard@cea.fr)
 */

impl {

#include <unisim/util/arithmetic/arithmetic.hh>

namespace unisim {
namespace component {
namespace cxx {
namespace processor {
namespace powerpc {

using unisim::util::arithmetic::Add32;
using unisim::util::arithmetic::RotateLeft;
using unisim::util::arithmetic::CountLeadingZeros;
using unisim::util::arithmetic::SignExtend;
using unisim::util::arithmetic::SignedSatAdd32;
using unisim::util::arithmetic::UnsignedSatAdd32;

inline uint32_t Mask(uint32_t mb, uint32_t me)
{
	return (mb > me) ? ~(((uint32_t) -1 >> mb) ^ ((me >= 31) ? 0 : (uint32_t) -1 >> (me + 1))) : (((uint32_t)-1 >> mb) ^ ((me >= 31) ? 0 : (uint32_t) -1 >> (me + 1)));
}

} // end of namespace powerpc
} // end of namespace processor
} // end of namespace cxx
} // end of namespace component
} // end of namespace unisim

}

op add(31[6]:rd[5]:ra[5]:rb[5]:oe[1]:266[9]:rc[1])
add.execute = {
	uint8_t ca; // carry out
	uint8_t ov; // overflow
	uint8_t sign; // sign
	uint32_t result;

	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);

	// Compute the result
	Add32(result, ca, ov, sign, a, b, 0);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	if(unlikely(oe || rc))
	{
		// Read XER
		uint32_t xer = cpu->GetXER();
		if(unlikely(oe))
		{
			// Generate XER[OV] and XER[SO]
			xer = ov ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
			// Update XER
			cpu->SetXER(xer);
		}
		if(unlikely(rc))
		{
			// Read CR
			uint32_t cr = cpu->GetCR();
			
			// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
			cr = (cr & ~CONFIG::CR0_MASK) |
				((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
				(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
					
			// Update CR
			cpu->SetCR(cr);
		}
	}
}
add.disasm = {
	os << "add" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op addc(31[6]:rd[5]:ra[5]:rb[5]:oe[1]:10[9]:rc[1])
addc.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;

	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);
	uint32_t xer = cpu->GetXER();
	
	// Compute the result
	Add32(result, carry, overflow, sign, a, b, 0);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	
	if(unlikely(oe))
	{
		// Generate XER[OV] and XER[SO]
		xer = overflow ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
	}

	// Update XER
	cpu->SetXER(xer);
	
	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
addc.disasm = {
	os << "addc" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op adde(31[6]:rd[5]:ra[5]:rb[5]:oe[1]:138[9]:rc[1])
adde.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;

	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);
	uint32_t xer = cpu->GetXER();
	uint32_t carry_in = (xer >> CONFIG::XER_CA_OFFSET) & 1;
	
	// Compute the result
	Add32(result, carry, overflow, sign, a, b, carry_in);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;

	if(unlikely(oe))
	{
		// Generate XER[OV] and XER[SO]
		xer = overflow ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
	}
	
	// Update XER
	cpu->SetXER(xer);
	
	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
adde.disasm = {
	os << "adde" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op addi(14[6]:rd[5]:ra[5]:sext<32> simm[16])
addi.execute = {
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	
	// Compute the result
	uint32_t result = (ra != 0 ? a + simm : simm);
	
	// Write back the result
	cpu->SetGPR(rd, result);
}
addi.disasm = {
	if(ra == 0)
		os << "li r" << (unsigned int) rd << ", " << simm;
	else
		os << "addi r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", " << simm;
}

op addic(12[6]:rd[5]:ra[5]:sext<32> simm[16])
addic.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;
	
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t xer = cpu->GetXER();

	// Compute the result
	Add32(result, carry, overflow, sign, a, simm, 0);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	
	// Update XER
	cpu->SetXER(xer);
}
addic.disasm = {
	os << "addic r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", " << simm;
}

op addic_(13[6]:rd[5]:ra[5]:sext<32> simm[16])
addic_.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;

	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t xer = cpu->GetXER();
	
	// Compute the result
	Add32(result, carry, overflow, sign, a, simm, 0) ;
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	
	// Update XER
	cpu->SetXER(xer);

	// Read CR
	uint32_t cr = cpu->GetCR();
	
	// Generate CR0
	cr = (cr & ~CONFIG::CR0_MASK) |
		((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
		(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
			
	// Update CR
	cpu->SetCR(cr);
}
addic_.disasm = {
	os << "addic. r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", " << simm;
}

op addis(15[6]:rd[5]:ra[5]:shl<16> sext<32> simm[16])
addis.execute = {
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	
	// Compute the result
	uint32_t result = ra != 0 ? a + simm : simm;
	
	// Write back the result
	cpu->SetGPR(rd, result);
}
addis.disasm = {
	if(ra == 0)
		os << "lis r" << (unsigned int) rd << ", " << (simm >> 16);
	else
		os << "addis r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", " << (simm >> 16);
}

op addme(31[6]:rd[5]:ra[5]:?[5]:oe[1]:234[9]:rc[1])
addme.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;
	
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t xer = cpu->GetXER();
	uint8_t carry_in = (xer >> CONFIG::XER_CA_OFFSET) & 1;
	
	// Compute the result
	Add32(result, carry, overflow, sign, 0xFFFFFFFF, a, carry_in);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
 	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	
	if(unlikely(oe))
	{
		// Generate XER[OV] and XER[SO]
		xer = overflow ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
	}
	
	// Update XER
	cpu->SetXER(xer);
	
	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
addme.disasm = {
	os << "addme" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra;
}

op addze(31[6]:rd[5]:ra[5]:?[5]:oe[1]:202[9]:rc[1])
addze.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;
	
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t xer = cpu->GetXER();
	uint8_t carry_in = (xer >> CONFIG::XER_CA_OFFSET) & 1;
	
	// Compute the result
	Add32(result, carry, overflow, sign, a, carry_in, 0);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	
	if(unlikely(oe))
	{
		// Generate XER[OV] and XER[SO]
		xer = overflow ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
	}
	
	// Update XER
	cpu->SetXER(xer);
	
	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
addze.disasm = {
	os << "addze" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra;
}


op divw(31[6]:rd[5]:ra[5]:rb[5]:oe[1]:491[9]:rc[1])
divw.execute = {
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);
	
	if(unlikely((a == 0x80000000UL && b == 0xffffffffUL) || b == 0))
	{
		// Write back the result (zero)
		cpu->SetGPR(rd, 0);
		
		if(unlikely(oe || rc))
		{
			// Read XER
			uint32_t xer = cpu->GetXER();
			if(unlikely(oe))
			{
				// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
				xer = xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK;

				// Update XER
				cpu->SetXER(xer);
			}
			if(unlikely(rc))
			{
				// Read CR
				uint32_t cr = cpu->GetCR();
				
				// Generate CR0: LT=0 GT=0 EQ=0 SO=XER[SO]
				cr = (cr & ~CONFIG::CR0_MASK) |
					((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0);

				// Update CR
				cpu->SetCR(cr);
			}
		}
	}
	else
	{
		// Read the input operands
		int32_t a = cpu->GetGPR(ra);
		int32_t b = cpu->GetGPR(rb);
		
		// Compute the result
		int32_t result = a / b;
		
		// Write back the result
		cpu->SetGPR(rd, result);
		
		if(unlikely(oe || rc))
		{
			// Read XER
			uint32_t xer = cpu->GetXER();
			
			if(unlikely(oe))
			{
				// Generate XER[OV]: XER[OV]=0
				xer = xer & ~CONFIG::XER_OV_MASK;
				
				// Update XER
				cpu->SetXER(xer);
			}
			if(unlikely(rc))
			{
				// Read CR
				uint32_t cr = cpu->GetCR();
				
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr = (cr & ~CONFIG::CR0_MASK) |
					((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
					(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
						
				// Update CR
				cpu->SetCR(cr);
			}
		}
	}
}
divw.disasm = {
	os << "divw" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op divwu(31[6]:rd[5]:ra[5]:rb[5]:oe[1]:459[9]:rc[1])
divwu.execute = {
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);
	
	if(unlikely(b == 0))
	{
		// Write back the result (zero)
		cpu->SetGPR(rd, 0);
		
		if(unlikely(oe || rc))
		{
			// Read XER
			uint32_t xer = cpu->GetXER();
			
			if(unlikely(oe))
			{
				// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
				xer = xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK;
				
				// Update XER
				cpu->SetXER(xer);
			}
			if(unlikely(rc))
			{
				// Read CR
				uint32_t cr = cpu->GetCR();
				
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=0 CR0[GT]=0 CR0[EQ]=1
				cr = (cr & ~CONFIG::CR0_MASK) |
					((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
					CONFIG::CR0_EQ_MASK;
						
				// Update CR
				cpu->SetCR(cr);
			}
		}
	}
	else
	{
		// Compute the result
		uint32_t result = a / b ;
		
		// Write back the result
		cpu->SetGPR(rd, result);
		
		if(unlikely(oe || rc))
		{
			// Read XER
			uint32_t xer = cpu->GetXER();
			
			if(unlikely(oe))
			{
				// Generate XER[OV]: XER[OV]=0
				xer = xer & ~CONFIG::XER_OV_MASK;
				
				// Update XER
				cpu->SetXER(xer);
			}
			if(unlikely(rc))
			{
				// Read CR
				uint32_t cr = cpu->GetCR();
				
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr = (cr & ~CONFIG::CR0_MASK) |
					((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
					(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
						
				// Update CR
				cpu->SetCR(cr);
			}
		}
	}
}
divwu.disasm = {
	os << "divwu" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}


op mulhw(31[6]:rd[5]:ra[5]:rb[5]:?[1]:75[9]:rc[1])
mulhw.execute = {
	// Read the input operands
	int32_t a = cpu->GetGPR(ra);
	int32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	int64_t result64 = (int64_t) a * (int64_t) b;
	uint32_t result = (int32_t) (result64 >> 32);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	if(unlikely(rc))
	{
		// Read XER
		uint32_t xer = cpu->GetXER();

		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
mulhw.disasm = {
	os << "mulhw" << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op mulhwu(31[6]:rd[5]:ra[5]:rb[5]:?[1]:11[9]:rc[1])
mulhwu.execute = {
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint64_t result64 = (uint64_t) a * (uint64_t) b;
	uint32_t result = (uint32_t) (result64 >> 32);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	if(unlikely(rc))
	{
		// Read XER
		uint32_t xer = cpu->GetXER();

		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
mulhwu.disasm = {
	os << "mulhwu" << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op mulli(07[6]:rd[5]:ra[5]: sext<32> simm[16])
mulli.execute = {
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	
	// Compute the result
	int64_t result64 = (int64_t) a * (int64_t) simm;
	uint32_t result = (uint32_t) result64;
	
	// Write back the result
	cpu->SetGPR(rd, result);
}
mulli.disasm = {
	os << "mulli r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", " << simm;
}

op mullw(31[6]:rd[5]:ra[5]:rb[5]:oe[1]:235[9]:rc[1])
mullw.execute = {
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	int64_t result64 = (int64_t) a * (int64_t) b;
	uint32_t result = (uint32_t) result64;
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	if(unlikely(oe || rc))
	{
		// Read XER
		uint32_t xer = cpu->GetXER();
		
		if(oe && (0xFFFFFFFF00000000ULL & result64) != 0)
		{
			// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
			xer = xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK;
			
			// Update XER
			cpu->SetXER(xer);
		}
		if(unlikely(rc))
		{
			// Read CR
			uint32_t cr = cpu->GetCR();
			
			// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
			cr = (cr & ~CONFIG::CR0_MASK) |
				((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
				(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
					
			// Update CR
			cpu->SetCR(cr);
		}
	}
}
mullw.disasm = {
	os << "mullw r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op neg(31[6]:rd[5]:ra[5]:?[5]:oe[1]:104[9]:rc[1])
neg.execute = {
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	
	if(a == 0x80000000UL)
	{
		// Write back the result
		cpu->SetGPR(rd, 0x80000000UL);
		
		if(unlikely(oe || rc))
		{
			// Read XER
			uint32_t xer = cpu->GetXER();
			
			if(unlikely(oe))
			{
				// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
				xer = xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK;
				// Update XER
				cpu->SetXER(xer);
			}
			if(unlikely(rc))
			{
				// Read CR
				uint32_t cr = cpu->GetCR();
				
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=1 CR0[GT]=0 CR0[EQ]=0
				cr = (cr & ~CONFIG::CR0_MASK) |
					((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
					CONFIG::CR0_LT_MASK;
						
				// Update CR
				cpu->SetCR(cr);
			}
		}
	}
	else
	{
		// Compute the result
		uint32_t result = -a; // 2's complement of a: (~a) + 1;
		
		// Write back the result
		cpu->SetGPR(rd, result);

		if(unlikely(oe || rc))
		{
			// Read XER
			uint32_t xer = cpu->GetXER();
			
			if(unlikely(oe))
			{
				// Generate XER[OV]: XER[OV]=0
				xer = xer & ~CONFIG::XER_OV_MASK;
				// Update XER
				cpu->SetXER(xer);
			}
			if(unlikely(rc))
			{
				// Read CR
				uint32_t cr = cpu->GetCR();
				
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr = (cr & ~CONFIG::CR0_MASK) |
					((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
					(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
						
				// Update CR
				cpu->SetCR(cr);
			}
		}
	}
}
neg.disasm = {
	os << "neg" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra;
}

op subf(31[6]:rd[5]:ra[5]:rb[5]:oe[1]:40[9]:rc[1])
subf.execute = {
	uint8_t carry; // carry out
	uint8_t sign; // sign
	uint8_t overflow; // overflow
	
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result;
	Add32(result, carry, overflow, sign, ~a, b, 1);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	if(unlikely(oe || rc))
	{
		// Read XER
		uint32_t xer = cpu->GetXER();
		if(unlikely(oe))
		{
			// Generate XER[OV] and XER[SO]
			xer = overflow ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
			// Update XER
			cpu->SetXER(xer);
		}
		if(unlikely(rc))
		{
			// Read CR
			uint32_t cr = cpu->GetCR();
			
			// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
			cr = (cr & ~CONFIG::CR0_MASK) |
				((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
				(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
					
			// Update CR
			cpu->SetCR(cr);
		}
	}
}
subf.disasm = {
	os << "subf" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op subfc(31[6]:rd[5]:ra[5]:rb[5]:oe[1]:8[9]:rc[1])
subfc.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;

	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);
	uint32_t xer = cpu->GetXER();
	
	// Compute the result
	Add32(result, carry, overflow, sign, ~a, b, 1);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	if(unlikely(oe))
	{
		// Generate XER[OV] and XER[SO]
		xer = overflow ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
	}

	// Update XER
	cpu->SetXER(xer);

	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
subfc.disasm = {
	os << "subfc" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op subfe(31[6]:rd[5]:ra[5]:rb[5]:oe[1]:136[9]:rc[1])
subfe.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;

	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb);
	uint32_t xer = cpu->GetXER();
	uint8_t carry_in = (xer >> CONFIG::XER_CA_OFFSET) & 1;
	
	// Compute the result
	Add32(result, carry, overflow, sign, ~a, b, carry_in);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	
	if(unlikely(oe))
	{
		// Generate XER[OV] and XER[SO]
		xer = overflow ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
	}

	// Update XER
	cpu->SetXER(xer);

	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
subfe.disasm = {
	os << "subfe" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op subfic(08[6]:rd[5]:ra[5]:sext<32> simm[16])
subfic.execute = {
	uint8_t carry; // carry out
	uint8_t overflow = 0; // overflow
	uint8_t sign; // sign
	uint32_t result;

	// Read the input operands
	int32_t a = cpu->GetGPR(ra);
	int32_t b = simm;
	uint32_t xer = cpu->GetXER();
	
	// Compute the result
	Add32(result, carry, overflow, sign, -a, b, 0);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = (carry || a == 0) ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	
	// Update XER
	cpu->SetXER(xer);
}
subfic.disasm = {
	os << "subfic r" << (unsigned int) rd << ", r" << (unsigned int) ra << ", " << simm;
}

op subfme(31[6]:rd[5]:ra[5]:?[5]:oe[1]:232[9]:rc[1])
subfme.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;
	
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t xer = cpu->GetXER();
	uint8_t carry_in = (xer >> CONFIG::XER_CA_OFFSET) & 1;
	
	// Compute the result
	Add32(result, carry, overflow, sign, ~a, 0xFFFFFFFF, carry_in);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	
	if(unlikely(oe))
	{
		// Generate XER[OV] and XER[SO]
		xer = overflow ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
	}
	
	// Update XER
	cpu->SetXER(xer);
	
	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
subfme.disasm = {
	os << "subfme" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra;
}

op subfze(31[6]:rd[5]:ra[5]:?[5]:oe[1]:200[9]:rc[1])
subfze.execute = {
	uint8_t carry; // carry out
	uint8_t overflow; // overflow
	uint8_t sign; // sign
	uint32_t result;
	
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t xer = cpu->GetXER();
	uint8_t carry_in = (xer >> CONFIG::XER_CA_OFFSET) & 1;
	
	// Compute the result
	Add32(result, carry, overflow, sign, ~a, carry_in, 0);
	
	// Write back the result
	cpu->SetGPR(rd, result);
	
	// Generate XER[CA]
	xer = carry ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	
	if(unlikely(oe))
	{
		// Generate XER[OV] and XER[SO]
		xer = overflow ? xer | CONFIG::XER_OV_MASK | CONFIG::XER_SO_MASK : xer & ~CONFIG::XER_OV_MASK;
	}
	
	// Update XER
	cpu->SetXER(xer);
	
	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
subfze.disasm = {
	os << "subfze" << (oe ? "o" : "") << (rc ? "." : "") << " r" << (unsigned int) rd << ", r" << (unsigned int) ra;
}

/****************************************************

	INTEGER COMPARE INSTRUCTIONS

****************************************************/

op cmp(31[6]:crfD[3]:?[1]:l[1]:ra[5]:rb[5]:0[10]:?[1])
cmp.execute = {
	// Read the input operands
	int32_t a = cpu->GetGPR(ra);
	int32_t b = cpu->GetGPR(rb) ;
	uint32_t cr = cpu->GetCR();
	uint32_t xer = cpu->GetXER();
	
	// Generate CR[crfD] bit field
	uint32_t c = ((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) | ((a < b) ? CONFIG::CR0_LT_MASK : (a > b) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK);
	cr = (cr & ~(CONFIG::CR0_MASK >> (4 * crfD))) | (c >> (4 * crfD));
	
	// Update CR
	cpu->SetCR(cr);
}
cmp.disasm = {
	os << "cmp cr" << (unsigned int) crfD << ", " << (unsigned int) l << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op cmpi(11[6]:crfD[3]:?[1]:l[1]:ra[5]:sext<32> simm[16])
cmpi.execute = {
	// Raise an illegal instruction exception if l=1
	if(unlikely(l)) throw IllegalInstructionException<CONFIG>();
	
	// Read the input operands
	int32_t a = cpu->GetGPR(ra);
	uint32_t cr = cpu->GetCR();
	uint32_t xer = cpu->GetXER();
	
	// Generate CR[crfD] bit field
	uint32_t c = ((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) | ((a < simm) ? CONFIG::CR0_LT_MASK : (a > simm) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK);
	cr = (cr & ~(CONFIG::CR0_MASK >> (4 * crfD))) | (c >> (4 * crfD));
	
	// Update CR
	cpu->SetCR(cr);
}
cmpi.disasm = {
	os << "cmpi cr" << (unsigned int) crfD << ", " << (unsigned int) l << ", r" << (unsigned int) ra << ", " << simm;
}

op cmpl(31[6]:crfD[3]:?[1]:l[1]:ra[5]:rb[5]:32[10]:?[1])
cmpl.execute = {
	// Raise an illegal instruction exception if l=1
	if(unlikely(l)) throw IllegalInstructionException<CONFIG>();
	
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t b = cpu->GetGPR(rb) ;
	uint32_t cr = cpu->GetCR();
	uint32_t xer = cpu->GetXER();
	
	// Generate CR[crfD] bit field
	uint32_t c = ((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) | ((a < b) ? CONFIG::CR0_LT_MASK : (a > b) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK);
	cr = (cr & ~(CONFIG::CR0_MASK >> (4 * crfD))) | (c >> (4 * crfD));
	
	// Update CR
	cpu->SetCR(cr);
}
cmpl.disasm = {
	os << "cmpl cr" << (unsigned int) crfD << ", " << (unsigned int) l << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
}

op cmpli(10[6]:crfD[3]:?[1]:l[1]:ra[5]:uimm[16])
cmpli.execute = {
	// Raise an illegal instruction exception if l=1
	if(unlikely(l)) throw IllegalInstructionException<CONFIG>();
	
	// Read the input operands
	uint32_t a = cpu->GetGPR(ra);
	uint32_t cr = cpu->GetCR();
	uint32_t xer = cpu->GetXER();
	
	// Generate CR[crfD] bit field
	uint32_t c = ((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) | ((a < uimm) ? CONFIG::CR0_LT_MASK : (a > uimm) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK);
	cr = (cr & ~(CONFIG::CR0_MASK >> (4 * crfD))) | (c >> (4 * crfD));
	
	// Update CR
	cpu->SetCR(cr);
}
cmpli.disasm = {
	os << "cmpli cr" << (unsigned int) crfD << ", " << (unsigned int) l << ", r" << (unsigned int) ra << ", " << uimm;
}

/****************************************************

	INTEGER LOGICAL INSTRUCTIONS

****************************************************/

op and(31[6]: rs[5]: ra[5]: rb[5]: 28[10]: rc[1])
and.execute = {
	// read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result = s & b;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
and.disasm = {
	os << "and" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op andc(31[6]: rs[5]: ra[5]: rb[5]: 60[10]: rc[1])
andc.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result = s & ~b;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
andc.disasm = {
	os << "andc" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op andi_(28[6]:rs[5]:ra[5]:uimm[16])
andi_.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t xer = cpu->GetXER();
	
	// Compute the result
	uint32_t result = s & uimm;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	// Read CR
	uint32_t cr = cpu->GetCR();
	
	// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
	cr = (cr & ~CONFIG::CR0_MASK) |
		((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
		(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));

	// Update CR
	cpu->SetCR(cr);
}
andi_.disasm = {
	os << "andi. r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", " << uimm;
}

op andis_(29[6]:rs[5]:ra[5]: shl<16> <32> uimm[16])
andis_.execute = {
	// read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t xer = cpu->GetXER();

	// Compute the result
	uint32_t result = s & uimm;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	// Read CR
	uint32_t cr = cpu->GetCR();
	
	// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
	cr = (cr & ~CONFIG::CR0_MASK) |
		((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
		(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
			
	// Update CR
	cpu->SetCR(cr);
}
andis_.disasm = {
	os << "andis. r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", " << (uimm >> 16);
}

op cntlzw(31[6]:rs[5]:ra[5]:?[5]:26[10]:rc[1])
cntlzw.execute = {
	// read the input operands
	uint32_t s = cpu->GetGPR(rs);
	
	// Compute the result
// 	uint32_t result = 0;
// 	uint32_t m = 1 << 31;
// 	while(result < 32)
// 	{
// 		if(s & m) break;
// 		m >>= 1;
// 		result++;
// 	}

	uint32_t result = CountLeadingZeros(s);
	
	// Write back the result
	cpu->SetGPR(ra, result);

	if(unlikely(rc))
	{
		// Read XER
		uint32_t xer = cpu->GetXER();
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
cntlzw.disasm = {
	os << "cntlzw" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs;
}

op eqv(31[6]:rs[5]:ra[5]:rb[5]:284[10]:rc[1])
eqv.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result = ~(s ^ b);
	
	// Write back the result
	cpu->SetGPR(ra, result);

	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
eqv.disasm = {
	os << "eqv" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op extsb(31[6]:rs[5]:ra[5]:?[5]:954[10]:rc[1])
extsb.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	
	// Compute the result
	uint32_t result = (uint32_t)(int32_t)(int8_t)(uint8_t) s;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
extsb.disasm = {
	os << "extsb" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs;
}

op extsh(31[6]:rs[5]:ra[5]:?[5]:922[10]:rc[1])
extsh.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	
	// Compute the result
	uint32_t result = (uint32_t)(int32_t)(int16_t)(uint16_t) s;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
extsh.disasm = {
	os << "extsh" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs;
}

op nand(31[6]:rs[5]:ra[5]:rb[5]:476[10]:rc[1])
nand.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result = ~(s & b);
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
nand.disasm = {
	os << "nand" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op nor(31[6]:rs[5]:ra[5]:rb[5]:124[10]:rc[1])
nor.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result = ~(s | b);
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
nor.disasm = {
	if(rs == rb)
		os << "not" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs;
	else
		os << "nor" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op or(31[6]:rs[5]:ra[5]:rb[5]:444[10]:rc[1])
or.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result = s | b;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
or.disasm = {
	if(rs == rb)
		os << "mr" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs;
	else
		os << "or" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op orc(31[6]:rs[5]:ra[5]:rb[5]:412[10]:rc[1])
orc.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result = s | ~b;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
orc.disasm = {
	os << "orc" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op ori(24[6]:rs[5]:ra[5]:uimm[16])
ori.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	
	// Compute the result
	uint32_t result = s | uimm;
	
	// Write back the result
	cpu->SetGPR(ra, result);
}
ori.disasm = {
	if(rs == 0 && ra == 0 && uimm == 0)
		os << "nop";
	else
		os << "ori r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", " << uimm;	
}

op oris(25[6]:rs[5]:ra[5]:shl<16> <32> uimm[16])
oris.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	
	// Compute the result
	uint32_t result = s | uimm;
	
	// Write back the result
	cpu->SetGPR(ra, result);
}
oris.disasm = {
	os << "oris r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", " << (uimm >> 16);
}

op xor(31[6]:rs[5]:ra[5]:rb[5]:316[10]:rc[1])
xor.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result = s ^ b;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
xor.disasm = {
	os << "xor" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op xori(26[6]:rs[5]:ra[5]:uimm[16])
xori.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	
	// Compute the result
	uint32_t result = s ^ uimm;
	
	// Write back the result
	cpu->SetGPR(ra, result);
}
xori.disasm = {
	os << "xori r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", " << uimm;
}

op xoris(27[6]:rs[5]:ra[5]:shl<16> <32> uimm[16])
xoris.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	
	// Compute the result
	uint32_t result = s ^ uimm;
	
	// Write back the result
	cpu->SetGPR(ra, result);
}
xoris.disasm = {
	os << "xoris r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", " << (uimm >> 16);
}

/****************************************************

	INTEGER LOGICAL INSTRUCTIONS

****************************************************/

op rlwimi(20[6]:rs[5]:ra[5]:sh[5]:mb[5]:me[5]:rc[1])
rlwimi.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t a = cpu->GetGPR(ra);
	
	// Compute the result
  	uint32_t r = RotateLeft(s, sh);
	uint32_t mask = Mask(mb, me);
	uint32_t result = (r & mask) | (a & ~mask);
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
rlwimi.disasm = {
	os << "rlwimi" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", " << (unsigned int) sh << ", " << (unsigned int) mb << ", " << (unsigned int) me;
}

op rlwinm(21[6]:rs[5]:ra[5]:sh[5]:mb[5]:me[5]:rc[1])
rlwinm.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	
	// Compute the result
	uint32_t r = RotateLeft(s, sh);
	uint32_t mask = Mask(mb, me);
	uint32_t result = r & mask;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
rlwinm.disasm = {
	os << "rlwinm" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", " << (unsigned int) sh << ", " << (unsigned int) mb << ", " << (unsigned int) me;
}

op rlwnm(23[6]:rs[5]:ra[5]:rb[5]:mb[5]:me[5]:rc[1])
rlwnm.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t r = RotateLeft(s, b);
	uint32_t mask = Mask(mb, me);
	uint32_t result = r & mask;
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
rlwnm.disasm = {
	os << "rlwnm" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb << ", " << (unsigned int) mb << ", " << (unsigned int) me;
}

/****************************************************

	INTEGER SHIFT INSTRUCTIONS

****************************************************/

op slw(31[6]:rs[5]:ra[5]:rb[5]:24[10]:rc[1])
slw.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	uint32_t result = (b & 0x20) ? 0 : s << (b & 0x1f);
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
slw.disasm = {
	os << "slw" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op sraw(31[6]:rs[5]:ra[5]:rb[5]:792[10]:rc[1])
sraw.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	uint32_t xer = cpu->GetXER();
	
	// Compute the result
	int32_t result;

	if(b == 0)
	{
		result = s;
		// Generate XER[CA]: XER[CA]=1
		xer = xer & ~CONFIG::XER_CA_MASK;
	}
	else if(b & 0x20)
	{
		if(s < 0)
		{
			result = 0xffffffff;
			// Generate XER[CA]
			xer = (s & 0x7fffffff) ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
		}
		else
		{
			result = 0;
			// Generate XER[CA]: XER[CA]=0
			xer = xer & ~CONFIG::XER_CA_MASK;
		}
	}
	else
	{
		b = b & 0x1f;
		result = (int32_t) s >> b;
		// Generate XER[CA]
		xer = (s < 0 && (s << (32 - b)) != 0) ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	}
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	// Update XER
	cpu->SetXER(xer);
	
	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
sraw.disasm = {
	os << "sraw" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

op srawi(31[6]:rs[5]:ra[5]:sh[5]:824[10]:rc[1])
srawi.execute = {
	// Read the input operands
	int32_t s = cpu->GetGPR(rs);
	uint32_t xer = cpu->GetXER();
	
	// Compute the result
	int32_t result;

	if(sh == 0)
	{
		result = s;
		// Generate XER[CA]: XER[CA]=0
		xer = xer & ~CONFIG::XER_CA_MASK;
	}
	else
	{
		result = s >> sh;
		// Generate XER[CA]
		xer = (s < 0 && (s << (32 - sh)) != 0) ? xer | CONFIG::XER_CA_MASK : xer & ~CONFIG::XER_CA_MASK;
	}
	
	// Update XER
	cpu->SetXER(xer);
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
srawi.disasm = {
	os << "srawi" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", " << (unsigned int) sh;
}

op srw(31[6]:rs[5]:ra[5]:rb[5]:536[10]:rc[1])
srw.execute = {
	// Read the input operands
	uint32_t s = cpu->GetGPR(rs);
	uint32_t b = cpu->GetGPR(rb);
	
	// Compute the result
	unsigned int sh = b & 0x3f;
	uint32_t result = (sh & 0x20) ? 0 : s >> (sh & 0x1f);
	
	// Write back the result
	cpu->SetGPR(ra, result);
	
	if(unlikely(rc))
	{
		// read XER
		uint32_t xer = cpu->GetXER();
		
		// Read CR
		uint32_t cr = cpu->GetCR();
		
		// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
		cr = (cr & ~CONFIG::CR0_MASK) |
			((xer & CONFIG::XER_SO_MASK) ? CONFIG::CR0_SO_MASK : 0) |
			(((int32_t)(result) < 0) ? CONFIG::CR0_LT_MASK : (((int32_t)(result) > 0) ? CONFIG::CR0_GT_MASK : CONFIG::CR0_EQ_MASK));
				
		// Update CR
		cpu->SetCR(cr);
	}
}
srw.disasm = {
	os << "srw" << (rc ? "." : "") << " r" << (unsigned int) ra << ", r" << (unsigned int) rs << ", r" << (unsigned int) rb;
}

