/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Gilles Mouchard (gilles.mouchard@cea.fr)
 */

/**********************************

FLOATING POINT LOAD INSTRUCTIONS

**********************************/

op lfd(50[6]:fd[5]:ra[5]:sext<32>d[16])
lfd.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	// check if FPU is available
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	// do the memory access
	cpu->Fp64Load(fd, ea);
}
lfd.disasm = {
	os << "lfd f" << (unsigned int) fd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lfdu(51[6]:fd[5]:ra[5]:sext<32>d[16])
lfdu.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(ra == 0)) throw IllegalInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	// do the memory access
	cpu->Fp64Load(fd, ea);
	// update the address register
	cpu->SetGPR(ra, ea);
}
lfdu.disasm = {
	os << "lfdu f" << (unsigned int) fd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lfdux(31[6]:fd[5]:ra[5]:rb[5]:631[10]:?[1])
lfdux.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(ra == 0)) throw IllegalInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}	

	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->Fp64Load(fd, ea);
	// update the address register
	cpu->SetGPR(ra, ea);
}
lfdux.disasm = {
	os << "lfdux f" << (unsigned int) fd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lfdx(31[6]:fd[5]:ra[5]:rb[5]:599[10]:?[1])
lfdx.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));

	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	// do the memory access
	cpu->Fp64Load(fd, ea);
}
lfdx.disasm = {
	os << "lfdx f" << (unsigned int) fd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lfs(48[6]:fd[5]:ra[5]:sext<32>d[16])
lfs.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);

	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	// do the memory access
	cpu->Fp32Load(fd, ea);
}
lfs.disasm = {
	os << "lfs f" << (unsigned int) fd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lfsu(49[6]:fd[5]:ra[5]:sext<32>d[16])
lfsu.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(ra == 0)) throw IllegalInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);

	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}
	// do the memory access
	cpu->Fp32Load(fd, ea);
	// update the address register
	cpu->SetGPR(ra, ea);
}
lfsu.disasm = {
	os << "lfsu f" << (unsigned int) fd << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lfsux(31[6]:fd[5]:ra[5]:rb[5]:567[10]:?[1])
lfsux.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(ra == 0)) throw IllegalInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	// do the memory access
	cpu->Fp32Load(fd, ea);
	// update the address register
	cpu->SetGPR(ra, ea);
}
lfsux.disasm = {
	os << "lfsux f" << (unsigned int) fd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op lfsx(31[6]:fd[5]:ra[5]:rb[5]:535[10]:?[1])
lfsx.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));

	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	// do the memory access
	cpu->Fp32Load(fd, ea);
}
lfsx.disasm = {
	os << "lfsx f" << (unsigned int) fd << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

/***********************************

FLOATING POINT STORE INSTRUCTIONS

***********************************/

op stfd(54[6]:fs[5]:ra[5]:sext<32>d[16])
stfd.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);

	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->Fp64Store(fs, ea);
}
stfd.disasm = {
	os << "stfd f" << (unsigned int) fs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stfdu(55[6]:fs[5]:ra[5]:sext<32>d[16])
stfdu.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(ra == 0)) throw IllegalInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);

	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->Fp64Store(fs, ea);
	// update the address register
	cpu->SetGPR(ra, ea);
}
stfdu.disasm = {
	os << "stfdu f" << (unsigned int) fs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stfdux(31[6]:fs[5]:ra[5]:rb[5]:759[10]:?[1])
stfdux.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(ra == 0)) throw IllegalInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));

	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->Fp64Store(fs, ea);
	// update the address register
	cpu->SetGPR(ra, ea);
}
stfdux.disasm = {
	os << "stfdux f" << (unsigned int) fs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stfdx(31[6]:fs[5]:ra[5]:rb[5]:727[10]:?[1])
stfdx.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->Fp64Store(fs, ea);
}
stfdx.disasm = {
	os << "stfdx f" << (unsigned int) fs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stfiwx(31[6]:fs[5]:ra[5]:rb[5]:983[10]:?[1])
stfiwx.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));

	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->FpStoreLSW(fs, ea);
}
stfiwx.disasm = {
	os << "stfiwx f" << (unsigned int) fs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stfs(52[6]:fs[5]:ra[5]:sext<32>d[16])
stfs.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}
	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->Fp32Store(fs, ea);
}
stfs.disasm = {
	os << "stfs f" << (unsigned int) fs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + d : d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stfsu(53[6]:fs[5]:ra[5]:sext<32>d[16])
stfsu.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(ra == 0)) throw IllegalInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->Fp32Store(fs, ea);
	// update the address register
	cpu->SetGPR(ra, ea);
}
stfsu.disasm = {
	os << "stfsu f" << (unsigned int) fs << ", " << d << "(r" << (unsigned int) ra << ")";
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + d);
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stfsux(31[6]:fs[5]:ra[5]:rb[5]:695[10]:?[1])
stfsux.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(ra == 0)) throw IllegalInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->Fp32Store(fs, ea);
	// update the address register
	cpu->SetGPR(ra, ea);
}
stfsux.disasm = {
	os << "stfsux f" << (unsigned int) fs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}

op stfsx(31[6]:fs[5]:ra[5]:rb[5]:663[10]:?[1])
stfsx.execute = {
	if(!CONFIG::HAS_FPU) throw UnimplementedInstructionException<CONFIG>();
	if(unlikely(!cpu->GetMSR_FP()))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// compute the effective address
	typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
	// check alignment
	if(unlikely(ea & 3))
	{
		if(!cpu->linux_os_import) throw AlignmentException<CONFIG>(ea);
	}

	cpu->Fp32Store(fs, ea);
}
stfsx.disasm = {
	os << "stfsx f" << (unsigned int) fs << ", r" << (unsigned int) ra << ", r" << (unsigned int) rb;
	if(cpu && cpu->GetCIA() == Operation<CONFIG>::GetAddr())
	{
		typename CONFIG::address_t ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
		os << " <" << cpu->GetObjectFriendlyName(ea) << ">";
	}
}
