/*
 *  Copyright (c) 2007,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Gilles Mouchard (gilles.mouchard@cea.fr)
 */
 
/***************************************************

	FLOATING-POINT ARITHMETIC INSTRUCTIONS

****************************************************/

impl {

#include <unisim/component/cxx/processor/powerpc/floating.hh>

namespace unisim {
namespace component {
namespace cxx {
namespace processor {
namespace powerpc {

template <class CONFIG, class FLOAT>
inline void GenFPSCR_FPRF(uint32_t& fpscr, const FLOAT& result)
{
	fpscr = fpscr & ~CONFIG::FPSCR_FPRF_MASK;
	
	if(unlikely(result.isQNaN()))
	{
		fpscr = fpscr | (CONFIG::FPRF_FOR_QNAN << CONFIG::FPSCR_FPRF_OFFSET);
	}
	else if(unlikely(result.isInfty()))
	{
		if(result.isNegative())
			fpscr = fpscr | (CONFIG::FPRF_FOR_NEGATIVE_INFINITY << CONFIG::FPSCR_FPRF_OFFSET);
		else
			fpscr = fpscr | (CONFIG::FPRF_FOR_POSITIVE_INFINITY << CONFIG::FPSCR_FPRF_OFFSET);
	}
	else if(unlikely(result.isDenormalized()))
	{
		if(result.isNegative())
			fpscr = fpscr | (CONFIG::FPRF_FOR_NEGATIVE_DENORMAL << CONFIG::FPSCR_FPRF_OFFSET);
		else
			fpscr = fpscr | (CONFIG::FPRF_FOR_POSITIVE_DENORMAL << CONFIG::FPSCR_FPRF_OFFSET);
	}
	else if(unlikely(result.isZero()))
	{
		if(result.isNegative())
			fpscr = fpscr | (CONFIG::FPRF_FOR_NEGATIVE_ZERO << CONFIG::FPSCR_FPRF_OFFSET);
		else
			fpscr = fpscr | (CONFIG::FPRF_FOR_POSITIVE_ZERO << CONFIG::FPSCR_FPRF_OFFSET);
	}
	else
	{
		if(result.isNegative())
			fpscr = fpscr | (CONFIG::FPRF_FOR_NEGATIVE_NORMAL << CONFIG::FPSCR_FPRF_OFFSET);
		else
			fpscr = fpscr | (CONFIG::FPRF_FOR_POSITIVE_NORMAL << CONFIG::FPSCR_FPRF_OFFSET);
	}
}

template <class CONFIG, class FLOAT>
inline void GenFPSCR_FR(uint32_t& fpscr, const FLOAT& result, const Flags& flags)
{
	if(flags.hasIncrementFraction(result.isNegative()))
		fpscr = fpscr | CONFIG::FPSCR_FR_MASK;
	else
		fpscr = fpscr & ~CONFIG::FPSCR_FR_MASK;
}

template <class CONFIG>
inline void GenFPSCR_FI(uint32_t& fpscr, const Flags& flags)
{
	if(flags.isApproximate())
		fpscr = fpscr | CONFIG::FPSCR_FI_MASK;
	else
		fpscr = fpscr & ~CONFIG::FPSCR_FI_MASK;
}

template <class CONFIG>
inline void GenFPSCR_OX(uint32_t& fpscr, const Flags& flags)
{
	if(unlikely(flags.hasFlowException() && flags.isApproximate()))
	{
		if(flags.isOverflow())
		{
			fpscr = fpscr | CONFIG::FPSCR_OX_MASK;
		}
	}
}

template <class CONFIG>
inline void GenFPSCR_UX(uint32_t& fpscr, const Flags& flags)
{
	if(unlikely(flags.hasFlowException() && flags.isApproximate()))
	{
		if(flags.isUnderflow())
		{
			fpscr = fpscr | CONFIG::FPSCR_UX_MASK;
		}
	}
}

template <class CONFIG>
inline void GenFPSCR_ZX(uint32_t& fpscr, const Flags& flags)
{
	if(unlikely(flags.isDivisionByZero()))
	{
		fpscr = fpscr | CONFIG::FPSCR_ZX_MASK;
	}
}

template <class CONFIG>
inline void GenFPSCR_VXSNAN(uint32_t& fpscr, const Flags& flags)
{
	if(unlikely(flags.hasSNaNOperand()))
	{
		fpscr = fpscr | CONFIG::FPSCR_VXSNAN_MASK;
	}
}

template <class CONFIG>
inline void GenFPSCR_VXISI(uint32_t& fpscr, const Flags& flags)
{
	if(unlikely(flags.isInftyMinusInfty()))
	{
		fpscr = fpscr | CONFIG::FPSCR_VXISI_MASK;
	}
}

template <class CONFIG>
inline void GenFPSCR_VXIDI(uint32_t& fpscr, const Flags& flags)
{
	if(unlikely(flags.isInftyOnInfty()))
	{
		fpscr = fpscr | CONFIG::FPSCR_VXIDI_MASK;
	}
}

template <class CONFIG>
inline void GenFPSCR_VXZDZ(uint32_t& fpscr, const Flags& flags)
{
	if(unlikely(flags.isZeroOnZero()))
	{
		fpscr = fpscr | CONFIG::FPSCR_VXZDZ_MASK;
	}
}

template <class CONFIG>
inline void GenFPSCR_VXIMZ(uint32_t& fpscr, const Flags& flags)
{
	if(unlikely(flags.isInftyMultZero()))
	{
		fpscr = fpscr | CONFIG::FPSCR_VXIMZ_MASK;
	}
}

template <class CONFIG>
inline void GenFPSCR_VXCVI(uint32_t& fpscr, const Flags& flags)
{
	if(unlikely(flags.isOverflow()))
	{
		fpscr = fpscr | CONFIG::FPSCR_VXCVI_MASK;
	}
}

template <class CONFIG>
inline void GenFPSCR_XX(uint32_t& fpscr)
{
	fpscr = fpscr | ((fpscr & CONFIG::FPSCR_FI_MASK) ? CONFIG::FPSCR_XX_MASK : 0);
}

template <class CONFIG>
inline void GenFPSCR_FX(uint32_t& fpscr, uint32_t old_fpscr)
{
	fpscr = fpscr |
	       (((~old_fpscr & fpscr & CONFIG::FPSCR_OX_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_UX_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_ZX_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_XX_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_VXSNAN_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_VXISI_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_VXIDI_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_VXZDZ_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_VXIMZ_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_VXVC_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_VXSOFT_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_VXSQRT_MASK) |
	         (~old_fpscr & fpscr & CONFIG::FPSCR_VXCVI_MASK)) ? CONFIG::FPSCR_FX_MASK : 0);
}

template <class CONFIG>
inline void GenFPSCR_VX(uint32_t& fpscr)
{
	fpscr = (fpscr & ~CONFIG::FPSCR_VX_MASK) |
	         (((fpscr & CONFIG::FPSCR_VXSNAN_MASK) |
	           (fpscr & CONFIG::FPSCR_VXISI_MASK) |
	           (fpscr & CONFIG::FPSCR_VXIDI_MASK) |
	           (fpscr & CONFIG::FPSCR_VXZDZ_MASK) |
	           (fpscr & CONFIG::FPSCR_VXIMZ_MASK) |
	           (fpscr & CONFIG::FPSCR_VXVC_MASK) |
	           (fpscr & CONFIG::FPSCR_VXSOFT_MASK) |
	           (fpscr & CONFIG::FPSCR_VXSQRT_MASK) |
	           (fpscr & CONFIG::FPSCR_VXCVI_MASK)) ? CONFIG::FPSCR_VX_MASK : 0);
}

template <class CONFIG>
inline void GenFPSCR_FEX(uint32_t& fpscr)
{
	fpscr = (fpscr & ~CONFIG::FPSCR_FEX_MASK) |
	         ((((fpscr & CONFIG::FPSCR_VX_MASK) && (fpscr & CONFIG::FPSCR_VE_MASK)) ||
	           ((fpscr & CONFIG::FPSCR_OX_MASK) && (fpscr & CONFIG::FPSCR_OE_MASK)) ||
	           ((fpscr & CONFIG::FPSCR_UX_MASK) && (fpscr & CONFIG::FPSCR_UE_MASK)) ||
	           ((fpscr & CONFIG::FPSCR_ZX_MASK) && (fpscr & CONFIG::FPSCR_ZE_MASK)) ||
	           ((fpscr & CONFIG::FPSCR_XX_MASK) && (fpscr & CONFIG::FPSCR_XE_MASK))) ? CONFIG::FPSCR_FEX_MASK : 0);
}

} // end of namespace powerpc
} // end of namespace processor
} // end of namespace cxx
} // end of namespace component
} // end of namespace unisim

}

op fadd(63[6]:fd[5]:fa[5]:fb[5]:?[5]:21[5]:rc[1])
fadd.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftDouble result = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);
	
	// Compute the result
	result.plusAssign(b, flags);
	
	// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftDouble>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fadd.disasm = {
	os << "fadd" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fb;
}

op fadds(59[6]:fd[5]:fa[5]:fb[5]:?[5]:21[5]:rc[1])
fadds.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}
	
	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftFloat result(cpu->GetFPR(fa), flags);
	flags.clear();
	SoftFloat b(cpu->GetFPR(fb), flags);
	flags.clear();
	
	// Compute the result
	result.plusAssign(b, flags);

	// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftFloat>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);
	
	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, SoftDouble(result, flags));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fadds.disasm = {
	os << "fadds" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fb;
}

op fdiv(63[6]:fd[5]:fa[5]:fb[5]:?[5]:18[5]:rc[1])
fdiv.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftDouble result = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);

	// Compute the result
	result.divAssign(b, flags);

	// Generate OX, UX, ZX, VXSNAN, VXIDI, VXZDZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_ZX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXIDI<CONFIG>(fpscr, flags);
	GenFPSCR_VXZDZ<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftDouble>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fdiv.disasm = {
	os << "fdiv" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fb;
}

op fdivs(59[6]:fd[5]:fa[5]:fb[5]:?[5]:18[5]:rc[1])
fdivs.execute = {
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftFloat result(cpu->GetFPR(fa), flags);
	flags.clear();
	SoftFloat b(cpu->GetFPR(fb), flags);
	flags.clear();

	// Compute the result	
	result.divAssign(b, flags);

	// Generate OX, UX, ZX, VXSNAN, VXIDI, VXZDZ, FR, FI, FPRF, XX, FX, VX, FEX
	uint32_t old_fpscr = fpscr;
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_ZX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXIDI<CONFIG>(fpscr, flags);
	GenFPSCR_VXZDZ<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftFloat>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, SoftDouble(result, flags));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fdivs.disasm = {
	os << "fdivs" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fb;
}

op fmul(63[6]:fd[5]:fa[5]:?[5]:fc[5]:25[5]:rc[1])
fmul.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftDouble result = cpu->GetFPR(fa);
	const SoftDouble& c = cpu->GetFPR(fc);

	// Compute the result
	result.multAssign(c, flags);

	// Generate OX, UX, VXSNAN, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftDouble>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fmul.disasm = {
	os << "fmul" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc;
}

op fmuls(59[6]:fd[5]:fa[5]:?[5]:fc[5]:25[5]:rc[1])
fmuls.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftFloat result(cpu->GetFPR(fa), flags);
	flags.clear();
	SoftFloat c(cpu->GetFPR(fc), flags);
	flags.clear();

	// Compute the result
	result.multAssign(c, flags);

	// Generate OX, UX, VXSNAN, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftFloat>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, SoftDouble(result, flags));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fmuls.disasm = {
	os << "fmuls" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc;
}

op fres(59[6]:fd[5]:?[5]:fb[5]:?[5]:24[5]:rc[1])
fres.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode(RN_NEAREST);
	SoftFloat b(cpu->GetFPR(fb), flags);
	flags.clear();

	if(unlikely(b.isSNaN()))
	{
		// b = SNaN
		if(!(fpscr & CONFIG::FPSCR_VE_MASK))
		{
			// Write back result
			SoftFloat result(b.queryValue() | 0x400000UL);// QNaN (b with high order bit of mantissa set)
			cpu->SetFPR(fd, SoftDouble(result, flags)); 
			// Generate FPRF
			fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_QNAN << CONFIG::FPSCR_FPRF_OFFSET);
		}
		// Generate VXSNAN
		fpscr = fpscr | CONFIG::FPSCR_VXSNAN_MASK;
	}
	else if(unlikely(b.isQNaN()))
	{
		// b = QNaN
		// Write back result
		cpu->SetFPR(fd, SoftDouble(b, flags)); // QNaN (b)
		// Generate FPRF
		fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_QNAN << CONFIG::FPSCR_FPRF_OFFSET);
	}
	else if(unlikely(b.isZero()))
	{
		// Generate ZX
		fpscr = fpscr | CONFIG::FPSCR_ZX_MASK;

		if(!(fpscr & CONFIG::FPSCR_ZE_MASK))
		{
			if(b.isNegative())
			{
				// b = -0
				// Write back result
				cpu->SetFPR(fd, SoftDouble(0xfff0000000000000ULL)); // -infinity
				// Generate FPRF
				fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_NEGATIVE_INFINITY << CONFIG::FPSCR_FPRF_OFFSET);
			}
			else
			{
				// b = +0
				// Write back result
				cpu->SetFPR(fd, SoftDouble(0x7ff0000000000000ULL)); // +infinity
				// Generate FPRF
				fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_POSITIVE_INFINITY << CONFIG::FPSCR_FPRF_OFFSET);
			}
		}
	}
	else if(unlikely(b.isInfty()))
	{
		if(b.isNegative())
		{
			// b = -infinity
			cpu->SetFPR(fd, SoftDouble(0x8000000000000000ULL)); // -0
			// Generate FPRF
			fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_NEGATIVE_ZERO << CONFIG::FPSCR_FPRF_OFFSET);
		}
		else
		{
			// b = +infinity
			cpu->SetFPR(fd, SoftDouble(0x0000000000000000ULL)); // +0
			// Generate FPRF
			fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_POSITIVE_ZERO << CONFIG::FPSCR_FPRF_OFFSET);
		}
	}
	else
	{
		SoftFloat result(0x3f800000ULL); // 1.0

		// Compute the result
		result.divAssign(b, flags);

		// Generate OX, UX, ZX, VXSNAN, FR, FI, FPRF
		GenFPSCR_OX<CONFIG>(fpscr, flags);
		GenFPSCR_UX<CONFIG>(fpscr, flags);
		GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);

		// Write back the result
		cpu->SetFPR(fd, SoftDouble(result, flags));
	}

	// Generate XX, FX, VX, FEX
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fres.disasm = {
	os << "fres" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

op frsqrte(63[6]:fd[5]:?[5]:fb[5]:?[5]:26[5]:rc[1])
frsqrte.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode(RN_NEAREST);
	const SoftDouble& b = cpu->GetFPR(fb);

	if(unlikely(b.isSNaN()))
	{
		// b = SNaN
		if(!(fpscr & CONFIG::FPSCR_VE_MASK))
		{
			// Generate FPRF
			fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_QNAN << CONFIG::FPSCR_FPRF_OFFSET);
			// Write back result
			cpu->SetFPR(fd, SoftDouble(b.queryValue() | 0x0008000000000000ULL)); // QNaN (b with high order bit of mantissa set)
		}
		// Generate VXSNAN
		fpscr = fpscr | CONFIG::FPSCR_VXSNAN_MASK;
	}
	else if(unlikely(b.isQNaN()))
	{
		// b = QNaN
		// Generate FPRF
		fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_QNAN << CONFIG::FPSCR_FPRF_OFFSET);
		// Write back result
		cpu->SetFPR(fd, b); // QNaN (b)
	}
	else if(unlikely(b.isZero()))
	{
		// Generate ZX
		fpscr = fpscr | CONFIG::FPSCR_ZX_MASK;

		if(!(fpscr & CONFIG::FPSCR_ZE_MASK))
		{
			if(b.isNegative())
			{
				// b = -0
				// Write back result
				cpu->SetFPR(fd, SoftDouble(0xfff0000000000000ULL)); // -infinity
				// Generate FPRF
				fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_NEGATIVE_INFINITY << CONFIG::FPSCR_FPRF_OFFSET);
			}
			else
			{
				// b = +0
				// Write back result
				cpu->SetFPR(fd, SoftDouble(0x7ff0000000000000ULL)); // +infinity
				// Generate FPRF
				fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_POSITIVE_INFINITY << CONFIG::FPSCR_FPRF_OFFSET);
			}
		}
	}
	else if(unlikely(b.isNegative()))
	{
		// -infinity <= b < 0
		if(!(fpscr & CONFIG::FPSCR_VE_MASK))
		{
			// Write back result
			cpu->SetFPR(fd, SoftDouble(0x7ff8000000000000ULL)); // Positive QNaN
			// Generate FPRF
			fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_QNAN << CONFIG::FPSCR_FPRF_OFFSET);
		}
		// Generate VXSQRT
		fpscr = fpscr | CONFIG::FPSCR_VXSQRT_MASK;
	}
	else if(unlikely(b.isInfty()))
	{
		// b = +infinity
		cpu->SetFPR(fd, SoftDouble(0x0000000000000000ULL)); // +0
		// Generate FPRF
		fpscr = (fpscr & ~CONFIG::FPSCR_FPRF_MASK) | (CONFIG::FPRF_FOR_POSITIVE_ZERO << CONFIG::FPSCR_FPRF_OFFSET);
	}
	else
	{
		// 0 < b < infinity

		// First estimation of 1/sqrt(b), seed of Newton-Raphson algorithm 
		// see http://www.mceniry.net/papers/Fast%20Inverse%20Square%20Root.pdf
		SoftDouble u((0xbfcdd6a18f6a6f55ULL - b.queryValue()) >> 1);

		// Newton-Raphson method
		SoftDouble half(0x3fe0000000000000ULL); // 0.5
		SoftDouble three(0x4008000000000000ULL); // 3.0

		unsigned int i;
		for(i = 0; i < 5; i++)
		{
			// Newton-Raphson iteration
			// w = b * u * u
			SoftDouble w(b);
			w.multAssign(u, flags);
			w.multAssign(u, flags);
			// v = 3.0 - w
			SoftDouble v(three);
			v.minusAssign(w, flags);
			// u = 0.5 * u * v
			u.multAssign(half, flags);
			u.multAssign(v, flags);
		}

		// Write back result
		cpu->SetFPR(fd, u);

		// Generate ZX, VXSNAN, FR, FI, FPRF
		GenFPSCR_ZX<CONFIG>(fpscr, flags);
		GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
		GenFPSCR_FPRF<CONFIG, SoftDouble>(fpscr, u);
	}

	// Generate XX, FX, VX, FEX
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
frsqrte.disasm = {
	os << "frsqrte" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

op fsub(63[6]:fd[5]:fa[5]:fb[5]:?[5]:20[5]:rc[1])
fsub.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftDouble result = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);
	
	// Compute the result
	result.minusAssign(b, flags);
	
	// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftDouble>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fsub.disasm = {
	os << "fsub" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fb;
}

op fsubs(59[6]:fd[5]:fa[5]:fb[5]:?[5]:20[5]:rc[1])
fsubs.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftFloat result(cpu->GetFPR(fa), flags);
	flags.clear();
	SoftFloat b(cpu->GetFPR(fb), flags);
	flags.clear();

	// Compute the result	
	result.minusAssign(b, flags);

	// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftFloat>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, SoftDouble(result, flags));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));

}
fsubs.disasm = {
	os << "fsubs" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fb;
}

op fsel(63[6]:fd[5]:fa[5]:fb[5]:fc[5]:23[5]:rc[1])
fsel.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	const SoftDouble& a = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);
	const SoftDouble& c = cpu->GetFPR(fc);

	// Compute and write the result
	cpu->SetFPR(fd, ((!a.isZero() && a.isNegative()) || a.isNaN()) ? b : c);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fsel.disasm = {
	os << "fsel" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc << ", f" << (unsigned int) fb;
}

op fsqrt(63[6]:fd[5]:?[5]:fb[5]:?[5]:22[5]:rc[1])
fsqrt.execute = {
	/* this optional instruction is not implemented */
	throw IllegalInstructionException<CONFIG>();
}
fsqrt.disasm = {
	os << "fsqrt" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

op fsqrts(59[6]:fd[5]:?[5]:fb[5]:?[5]:22[5]:rc[1])
fsqrts.execute = {
	/* this optional instruction is not implemented */
	throw IllegalInstructionException<CONFIG>();
}
fsqrts.disasm = {
	os << "fsqrts" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

/******************************************************

	FLOATING POINT MULTIPLY-ADD INSTRUCTIONS

******************************************************/

op fmadd(63[6]:fd[5]:fa[5]:fb[5]:fc[5]:29[5]:rc[1])
fmadd.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftDouble result = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);
	const SoftDouble& c = cpu->GetFPR(fc);

	// Compute the result
	result.multAndAddAssign(c, b, flags);

	// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftDouble>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fmadd.disasm = {
	os << "fmadd" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc << ", f" << (unsigned int) fb;
}

op fmadds(59[6]:fd[5]:fa[5]:fb[5]:fc[5]:29[5]:rc[1])
fmadds.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftFloat result(cpu->GetFPR(fa), flags);
	flags.clear();
	SoftFloat b(cpu->GetFPR(fb), flags);
	flags.clear();
	SoftFloat c(cpu->GetFPR(fc), flags);
	flags.clear();
	
	// Compute the result
	result.multAndAddAssign(c, b, flags);
	
	// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftFloat>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, SoftDouble(result, flags));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fmadds.disasm = {
	os << "fmadds" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc << ", f" << (unsigned int) fb;
}

op fmsub(63[6]:fd[5]:fa[5]:fb[5]:fc[5]:28[5]:rc[1])
fmsub.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftDouble result = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);
	const SoftDouble& c = cpu->GetFPR(fc);

	// Compute the result
	result.multAndSubAssign(c, b, flags);

	// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftDouble>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fmsub.disasm = {
	os << "fmsub" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc << ", f" << (unsigned int) fb;
}

op fmsubs(59[6]:fd[5]:fa[5]:fb[5]:fc[5]:28[5]:rc[1])
fmsubs.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftFloat result(cpu->GetFPR(fa), flags);
	flags.clear();
	SoftFloat b(cpu->GetFPR(fb), flags);
	flags.clear();
	SoftFloat c(cpu->GetFPR(fc), flags);
	flags.clear();

	// Compute the result
	result.multAndSubAssign(c, b, flags);

	// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftFloat>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, SoftDouble(result, flags));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fmsubs.disasm = {
	os << "fmsubs" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc << ", f" << (unsigned int) fb;
}

op fnmadd(63[6]:fd[5]:fa[5]:fb[5]:fc[5]:31[5]:rc[1])
fnmadd.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftDouble result = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);
	const SoftDouble& c = cpu->GetFPR(fc);

	// Compute the result
	result.multAndAddAssign(c, b, flags);

	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, result, flags);

	if(likely(!result.isQNaN())) result.opposite();

	// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftDouble>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fnmadd.disasm = {
	os << "fnmadd" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc << ", f" << (unsigned int) fb;
}

op fnmadds(59[6]:fd[5]:fa[5]:fb[5]:fc[5]:31[5]:rc[1])
fnmadds.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftFloat result(cpu->GetFPR(fa), flags);
	flags.clear();
	SoftFloat b(cpu->GetFPR(fb), flags);
	flags.clear();
	SoftFloat c(cpu->GetFPR(fc), flags);
	flags.clear();

	// Compute the result
	result.multAndAddAssign(c, b, flags);

	GenFPSCR_FR<CONFIG, SoftFloat>(fpscr, result, flags);

	if(likely(!result.isQNaN())) result.opposite();

	// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, SoftDouble(result, flags));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fnmadds.disasm = {
	os << "fnmadds" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc << ", f" << (unsigned int) fb;
}

op fnmsub(63[6]:fd[5]:fa[5]:fb[5]:fc[5]:30[5]:rc[1])
fnmsub.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftDouble result = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);
	const SoftDouble& c = cpu->GetFPR(fc);

	// Compute the result
	result.multAndSubAssign(c, b, flags);

	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, result, flags);

	if(likely(!result.isQNaN())) result.opposite();

	// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftDouble>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fnmsub.disasm = {
	os << "fnmsub" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc << ", f" << (unsigned int) fb;
}

op fnmsubs(59[6]:fd[5]:fa[5]:fb[5]:fc[5]:30[5]:rc[1])
fnmsubs.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftFloat result(cpu->GetFPR(fa), flags);
	flags.clear();
	SoftFloat b(cpu->GetFPR(fb), flags);
	SoftFloat c(cpu->GetFPR(fc), flags);
	flags.clear();

	// Compute the result
	result.multAndSubAssign(c, b, flags);

	GenFPSCR_FR<CONFIG, SoftFloat>(fpscr, result, flags);

	if(likely(!result.isQNaN())) result.opposite();

	// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXISI<CONFIG>(fpscr, flags);
	GenFPSCR_VXIMZ<CONFIG>(fpscr, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, SoftDouble(result, flags));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fnmsubs.disasm = {
	os << "fnmsubs" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fa << ", f" << (unsigned int) fc << ", f" << (unsigned int) fb;
}

/**************************************************

	FLOATING POINT COMPARE INSTRUCTIONS

**************************************************/

op fcmpo(63[6]:crfD[3]:?[2]:fa[5]:fb[5]:32[10]:?[1])
fcmpo.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	const SoftDouble& a = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);
	
	// Do the floating point comparison
	uint32_t c;
	switch(a.compare(b))
	{
		case SoftDouble::CRNaN: c = 1; break;
		case SoftDouble::CRLess: c = 8; break;
		case SoftDouble::CREqual: c = 2; break;
		case SoftDouble::CRGreater: c = 4; break;
		default:
			throw "Internal error";
	}

	// Generate FPCC
	fpscr = (fpscr & ~CONFIG::FPSCR_FPCC_MASK) | ((c << CONFIG::FPSCR_FPCC_OFFSET) & CONFIG::FPSCR_FPCC_MASK);
	
	// Generate VXSNAN and VXVC
	if(unlikely(a.isSNaN() || b.isSNaN()))
	{
		fpscr = fpscr | CONFIG::FPSCR_VXSNAN_MASK;
		if(!(fpscr & CONFIG::FPSCR_VE_MASK))
		{
			fpscr = fpscr | CONFIG::FPSCR_VXVC_MASK;
		}
	}
	if(unlikely(a.isQNaN() || b.isQNaN()))
	{
		fpscr = fpscr | CONFIG::FPSCR_VXVC_MASK;
	}

	// Generate FX, VX, FEX
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// CR[crfD] <- c
	cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> (4 * crfD))) | (c << ((7 - crfD) * 4)));
}
fcmpo.disasm = {
	os << "fcmpo cr" << (unsigned int) crfD << ", f" << (unsigned int) fa << ", f" << (unsigned int) fb;
}

op fcmpu(63[6]:crfD[3]:?[2]:fa[5]:fb[5]:0[10]:?[1])
fcmpu.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	const SoftDouble& a = cpu->GetFPR(fa);
	const SoftDouble& b = cpu->GetFPR(fb);
	
	// Do the floating point comparison
	uint32_t c;
	switch(a.compare(b))
	{
		case SoftDouble::CRNaN: c = 1; break;
		case SoftDouble::CRLess: c = 8; break;
		case SoftDouble::CREqual: c = 2; break;
		case SoftDouble::CRGreater: c = 4; break;
		default:
			throw "Internal error";
	}

	// Generate FPCC
	fpscr = (fpscr & ~CONFIG::FPSCR_FPCC_MASK) | ((c << CONFIG::FPSCR_FPCC_OFFSET) & CONFIG::FPSCR_FPCC_MASK);

	// Generate VXSNAN
	if(unlikely(a.isSNaN() || b.isSNaN()))
	{
		fpscr = fpscr | CONFIG::FPSCR_VXSNAN_MASK;
	}

	// Generate FX, VX, FEX
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}
	
	// CR[crfD] <- c
	cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> (4 * crfD))) | (c << ((7 - crfD) * 4)));
}
fcmpu.disasm = {
	os << "fcmpu cr" << (unsigned int) crfD << ", f" << (unsigned int) fa << ", f" << (unsigned int) fb;
}

/**************************************************

  FLOATING POINT ROUNDING-CONVERTING INSTRUCTIONS

**************************************************/

op fctiw(63[6]:fd[5]:?[5]:fb[5]:14[10]:rc[1])
fctiw.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	SoftDouble b = cpu->GetFPR(fb);

	// Compute the result
	SoftDouble::IntConversion icResult;
	uint32_t result32;
	uint64_t result64;
    flags.clearKeepSignalingConversion();
	b.retrieveInteger(icResult.setSigned(), flags);
    flags.setKeepSignalingConversion();
	result32 = (uint32_t) icResult.queryInt();
	result64 = 0xfff8000000000000ULL | result32;
	if(result32 == 0 && b.isNegative())
		result64 |= 0x0000000100000000ULL;
	
	SoftDouble result(result64);
	
	// Generate VXSNAN, VXCVI, FR, FI, XX, FX, VX, FEX
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXCVI<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, b, flags);
	if(!flags.isOverflow()) GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception if FPSCR[FEX] is set
		throw FloatingPointException<CONFIG>();
	}

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fctiw.disasm = {
	os << "fctiw" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}


op fctiwz(63[6]:fd[5]:?[5]:fb[5]:15[10]:rc[1])
fctiwz.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	SoftDouble b = cpu->GetFPR(fb);
	
	// Compute the result
	SoftDouble::IntConversion icResult;
	uint32_t result32;
	uint64_t result64;
	flags.setRoundingMode(RN_ZERO);	
    flags.clearKeepSignalingConversion();
	b.retrieveInteger(icResult.setSigned(), flags);
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
    flags.setKeepSignalingConversion();
	result32 = (uint32_t) icResult.queryInt();
	result64 = 0xfff8000000000000ULL | result32;
	if(result32 == 0 && b.isNegative())
		result64 |= 0x0000000100000000ULL;
	
	SoftDouble result(result64);
	
	// Generate VXSNAN, VXCVI, FR, FI, XX, FX, VX, FEX
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_VXCVI<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftDouble>(fpscr, b, flags);
	if(!flags.isOverflow()) GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception if FPSCR[FEX] is set
		throw FloatingPointException<CONFIG>();
	}

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fctiwz.disasm = {
	os << "fctiwz" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

op frsp(63[6]:fd[5]:?[5]:fb[5]:12[10]:rc[1])
frsp.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	uint32_t old_fpscr = fpscr;
	Flags flags;
	flags.setRoundingMode((fpscr & CONFIG::FPSCR_RN_MASK) >> CONFIG::FPSCR_RN_OFFSET);
	const SoftDouble& b = cpu->GetFPR(fb);

	// Compute the result
    flags.clearKeepSignalingConversion();
	flags.setUpApproximateInfty();
	SoftFloat result(b, flags);
	flags.clearUpApproximateInfty();
    flags.setKeepSignalingConversion();

	// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
	GenFPSCR_OX<CONFIG>(fpscr, flags);
	GenFPSCR_UX<CONFIG>(fpscr, flags);
	GenFPSCR_VXSNAN<CONFIG>(fpscr, flags);
	GenFPSCR_FR<CONFIG, SoftFloat>(fpscr, result, flags);
	GenFPSCR_FI<CONFIG>(fpscr, flags);
	GenFPSCR_FPRF<CONFIG, SoftFloat>(fpscr, result);
	GenFPSCR_XX<CONFIG>(fpscr);
	GenFPSCR_FX<CONFIG>(fpscr, old_fpscr);
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	// Update FPSCR
	cpu->SetFPSCR(fpscr);

	// Check for floating point exception condition: (MSR[FE0] ^ MSR[FE1]) & FPSCR[FEX]
	if(unlikely(((msr & CONFIG::MSR_FE0_MASK) |
	            (msr & CONFIG::MSR_FE1_MASK)) &&
	            (fpscr & CONFIG::FPSCR_FEX_MASK)))
	{
		// Raise a floating point exception
		throw FloatingPointException<CONFIG>();
	}

	// Write back the result
	cpu->SetFPR(fd, SoftDouble(result, flags));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
frsp.disasm = {
	os << "frsp" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

/**************************************************

	FLOATING POINT MOVE INSTRUCTIONS

**************************************************/

op fabs(63[6]:fd[5]:?[5]:fb[5]:264[10]:rc[1])
fabs.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	SoftDouble result = cpu->GetFPR(fd);
	const SoftDouble& b = cpu->GetFPR(fb);

	// Compute the result
	result = b;
	if(result.isNegative())
	{
		result.opposite();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fabs.disasm = {
	os << "fabs" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

op fmr(63[6]:fd[5]:?[5]:fb[5]:72[10]:rc[1])
fmr.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	uint32_t fpscr = cpu->GetFPSCR();

	cpu->SetFPR(fd, cpu->GetFPR(fb));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fmr.disasm = {
	os << "fmr" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

op fnabs(63[6]:fd[5]:?[5]:fb[5]:136[10]:rc[1])
fnabs.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	SoftDouble result = cpu->GetFPR(fd);
	const SoftDouble& b = cpu->GetFPR(fb);

	// Compute the result
	result = b;
	if(result.isPositive())
	{
		result.opposite();
	}

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fnabs.disasm = {
	os << "fnabs" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

op fneg(63[6]:fd[5]:?[5]:fb[5]:40[10]:rc[1])
fneg.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();
	SoftDouble result = cpu->GetFPR(fb);

	// Compute the result
	result.opposite();

	// Write back the result
	cpu->SetFPR(fd, result);

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
fneg.disasm = {
	os << "fneg" << (rc ? "." : "") << " f" << (unsigned int) fd << ", f" << (unsigned int) fb;
}

/*****************************************************************

	FLOATING-POINT STATUS & CONTROL REGISTER INSTRUCTIONS

*****************************************************************/

op mcrfs(63[6]:crfD[3]:?[2]:crfS[3]:?[7]:64[10]:?[1])
mcrfs.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Read the input operands
	uint32_t fpscr = cpu->GetFPSCR();

	// Extract FPSCR source 4-bit field
	uint32_t c = (fpscr >> (4 * (7 - crfS))) & 0xf;
	// Copy it into CR 4-bit destination field
	cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> (4 * crfD))) | (c << (4 * (7 - crfS))));
	if(unlikely(crfS == 0))
		cpu->SetFPSCR(fpscr & 0x9fffffffUL); // Don't clear FEX and VX bits
	else
		cpu->SetFPSCR(fpscr & ~(0xffUL << (4 * (7 - crfS)))); // clear bit field
}
mcrfs.disasm = {
	os << "mcrfs cr" << (unsigned int) crfD << ", cr" << (unsigned int) crfS;
}

op mffs(63[6]:fd[5]:?[10]:583[10]:rc[1])
mffs.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	// Move FPSCR into destination FPR
	uint32_t fpscr = cpu->GetFPSCR();
	uint64_t _f;
	_f = (uint64_t) fpscr | 0xfff8000000000000ULL;
	cpu->SetFPR(fd, SoftDouble(_f));

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
mffs.disasm = {
	os << "mffs" << (rc ? "." : "") << " f" << (unsigned int) fd;
}

op mtfsb0(63[6]:crbD[5]:?[10]:70[10]:rc[1])
mtfsb0.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	uint32_t fpscr = cpu->GetFPSCR();

	if(likely(crbD != 1 && crbD != 2))
	{
		fpscr = fpscr & (~(1 << (31 - crbD)));
	}

	// Generate VX, FEX
	GenFPSCR_VX<CONFIG>(fpscr);
	GenFPSCR_FEX<CONFIG>(fpscr);

	cpu->SetFPSCR(fpscr);
	

	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
mtfsb0.disasm = {
	os << "mtfsb0" << (rc ? "." : "") << " crb" << crbD;
}

op mtfsb1(63[6]:crbD[5]:?[10]:38[10]:rc[1])
mtfsb1.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	uint32_t fpscr = cpu->GetFPSCR();

	if(likely(crbD != 1 && crbD != 2))
	{
		fpscr = fpscr | (1 << (31 - crbD));
		cpu->SetFPSCR(fpscr);
	}
	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
mtfsb1.disasm = {
	os << "mtfsb1" << (rc ? "." : "") << " cr" << crbD;
}

op mtfsf(63[6]:?[1]:fm[8]:?[1]:fb[5]:711[10]:rc[1])
mtfsf.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	uint32_t _m, fpscr, _fm, _rb,_c;
	int _i;
	_rb = cpu->GetFPR(fb).queryValue();
	fpscr = cpu->GetFPSCR();
	_fm = fm;

	if(_fm & 0x80)
	{
		_m = 0x60000000;
	}
	else
	{
		_m=0x0;
	}
	_c=0x1;
	for(_i=0;_i< 8;_i++)
	{
		if(_c & _fm)
		{
			_m= _m | (0xf<<(_i*4));
		}
		_c=_c<<1;
	}
	fpscr = _rb & _m;
	cpu->SetFPSCR(fpscr);
	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
mtfsf.disasm = {
	os << "mtfsf" << (rc ? "." : "") << " " << (unsigned int) fm << ", f" << (unsigned int) fb;
}

op mtfsfi(63[6]:crfD[3]:?[7]:imm[4]:?[1]:134[10]:rc[1])
mtfsfi.execute = {
	// Check if FPU is enabled
	uint32_t msr = cpu->GetMSR();
	if(unlikely(!(msr & CONFIG::MSR_FP_MASK)))
	{
		throw FloatingPointUnavailableException<CONFIG>();
	}

	uint32_t mask = crfD ? 0xf : 0x9;
	uint32_t fpscr = cpu->GetFPSCR();
	fpscr = (fpscr & (~(0xf << (4 * (7 - crfD))))) | ((imm & mask) << (4 * (7 - crfD)));
	cpu->SetFPSCR(fpscr);
	// Copy FX, FEX, VX, OX to CR1
	if(unlikely(rc)) cpu->SetCR((cpu->GetCR() & ~(CONFIG::CR0_MASK >> 4)) | ((fpscr >> 4) & (CONFIG::CR0_MASK >> 4)));
}
mtfsfi.disasm = {
	os << "mtfsfi" << (rc ? "." : "") << " cr" << (unsigned int) crfD << ", " << (unsigned int) imm;
}
