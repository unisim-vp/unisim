/*
 *  Copyright (c) 2007,
 *  INRIA Futurs
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Sylvain Girbal (sylvain.girbal@inria.fr)
 *          David Parello (david.parello@univ-perp.fr)
 */

/* --------------------------------------------------------------------------

Ces instructions updatant ra, ra ne devrait pas ï¿½tre a la fois input et output.
Mais sinon elle respecte bien le format rd = premier registre

> lbzu lhau lhzu lwzu
> lbzux, lhaux, lhzux, lwzux
> stbu, sthu, stwu
> stbux, sthux, stwux

> lfdu, lfsu
> lfdux
> stfdu, stfsu
> stfdux, stfsux

manque les loafd flottant a update comme lfdu)
-------------------------------------------------------------------------- */

/* ----
 lswi: load string should output to (rd .. rd+ ceil(nb/4))
 lswx: should output to (rd.. XER[25..31] /4)
 stswi: should input (rs .. rs+ceil(nb/4))
 stswx: should input (rs .. rs+ceil(XER[25..31]/4))
----- */
/*
 * NOTES :
 *     -- For store fisrt operand is to oprand to write into memory.
 *     -- For other instructions (to defined)
 */

decl {

#include <stdarg.h>
#include <sstream>
#include <string>

namespace unisim {
namespace component {
namespace cxx {
namespace processor {
namespace powerpc {

using std::stringstream;
using std::string;

// DD New depencies are arriving ...
/*
  typedef enum operand_type_t { GPR_T, FPR_T, CRF_T, CRB_T, FPSCRF_T,
  SR_T, CR_T , BO_T, BD_T, IMM_T, NONE_REGISTER} operand_type_t;
*/
  /* New operand types for superscalar simulator... */
  typedef enum operand_type_t { GPR_T, FPR_T, CRF_T, CRB_T, FPSCRF_T, SR_T, BO_T, BD_T, IMM_T,
			        CR_T, FPSCR_T, LR_T, CTR_T, XER_T, NONE_REGISTER} operand_type_t;


  typedef enum operand_direction_t { INPUT_T, OUTPUT_T } operand_direction_t;

  typedef struct operand_t
  {
    operand_type_t type;
    operand_direction_t dir;
    int value;
    struct operand_t *next;
  } operand_t;


#define INPUT(_type, _value) \
{\
	Operation<CONFIG>::operands[Operation<CONFIG>::noperands].type = _type;\
	Operation<CONFIG>::operands[Operation<CONFIG>::noperands].dir = INPUT_T;\
	Operation<CONFIG>::operands[Operation<CONFIG>::noperands++].value = _value;\
}

#define OUTPUT(_type, _value) \
{\
	Operation<CONFIG>::operands[Operation<CONFIG>::noperands].type = _type;\
	Operation<CONFIG>::operands[Operation<CONFIG>::noperands].dir = OUTPUT_T;\
	Operation<CONFIG>::operands[Operation<CONFIG>::noperands++].value = _value;\
}

  typedef operand_t operands_t[64];


} // end of namespace powerpc
} // end of namespace processor
} // end of namespace cxx
} // end of namespace component
} // end of namespace unisim

}

var noperands : {int} = {0}
var operands : {operands_t}

constructor action initialize_operands() {
  stringstream ss;
  Operation<CONFIG>::disasm(0,ss);
  string s;
  ss >> s;
  if(s!="???")
  { cerr << "Error: missing initialize_operands for instruction \"" << s << "\" !" << endl;
  }
}

group instr_nope(sc, sync, tlbia, tlbsync, eieio, rfi, isync)
instr_nope.initialize_operands = { 
/*
  for(int i=0; i<32; i++)
  { INPUT(GPR_T, i);
    OUTPUT(GPR_T, i);
  }
*/
}

/* Dependancies for Branch Instruction */
group instr_b(b)
instr_b.initialize_operands = { 
  if(lk)
  {
    OUTPUT(LR_T,0);
  }
}

group instr_bc(bc)
instr_bc.initialize_operands = { 
  if( (bo & 16) == 0 )
  {
    INPUT(CR_T, bi/4);
  }
  if ( (bo & 4) == 0 )
  {
    INPUT(CTR_T,0);
    OUTPUT(CTR_T,0);
  }
  if(lk)
  {
    OUTPUT(LR_T,0);
  }
}

group instr_bcctr(bcctr)
instr_bcctr.initialize_operands = { 
  INPUT(CTR_T,0);
  if( (bo & 16) == 0)
  {
    INPUT(CR_T, bi/4);
  }
  if(lk)
  {
    OUTPUT(LR_T,0);
  }
}

group instr_bclr(bclr)
instr_bclr.initialize_operands = { 
  INPUT(LR_T,0);
  if( (bo & 16) == 0)
  {
    INPUT(CR_T, bi/4);
  }
  if ( (bo & 4) == 0 )
  {
    INPUT(CTR_T,0);
    OUTPUT(CTR_T,0);
  }
  if(lk)
  {
    OUTPUT(LR_T,0);
  }
}

group instr_lmw(lmw)
instr_lmw.initialize_operands = {
  INPUT(GPR_T, ra);
  for(int i=rd; i<32; i++)
  { OUTPUT(GPR_T, i);
  }
}

group instr_stmw(stmw)
instr_stmw.initialize_operands = {
  INPUT(GPR_T, ra);
  for(int i=rs; i<32; i++)
  { INPUT(GPR_T, i);
  }
}


group instr_rd_ra_may(addi, addis, lbz, lha, lhz, lwz)
instr_rd_ra_may.initialize_operands = {
  OUTPUT(GPR_T, rd);
  if (ra != 0)
  {
    INPUT(GPR_T, ra);
  }
  //  INPUT(GPR_T, ra);
}
group instr_rd_ra(mulli, neg)
instr_rd_ra.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
}

/*
group instr_rd_addis(addis)
instr_rd_ra_addis.initialize_operands = {
  OUTPUT(GPR_T, rd);
  if (ra != 0)
  {
    INPUT(GPR_T, ra);
  }
}
*/

//group instr_rd_ra_xerca(addic, addic_, subfic, addme, addze, subfme, subfze)
//group instr_rd_ra_xerca(addic, subfic, addme, addze, subfme, subfze)
group instr_rd_ra_xerca(addic, subfic, addme, subfme)
instr_rd_ra_xerca.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  INPUT(XER_T,2);
  OUTPUT(XER_T,2);
}
group instr_addze(addze, subfze)
instr_addze.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(XER_T, 2);
  INPUT(GPR_T, ra);
  OUTPUT(XER_T,2);
  if (rc)
  {
    OUTPUT(CR_T,0);
  }
}

group instr_rd_ra_xerca_cr0(addic_)
instr_rd_ra_xerca_cr0.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  OUTPUT(CR_T,0);
  OUTPUT(XER_T,2);

}



group instr_rd_ra_update(lbzu, lhau, lhzu, lwzu)
instr_rd_ra_update.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  OUTPUT(GPR_T, ra); /*DD*/
}

group instr_fd_ra(lfd, lfs)
instr_fd_ra.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(GPR_T, ra);
}

group instr_fd_ra_update(lfdu, lfsu)
instr_fd_ra_update.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(GPR_T, ra);
}

// TODO rlwixx (if RC=1)...
group instr_rs_ra(ori, oris, xori, xoris)
instr_rs_ra.initialize_operands = {
  INPUT(GPR_T, rs);
  OUTPUT(GPR_T, ra);
}

group instr_rs_ra_rccr0(rlwinm, cntlzw, extsb, extsh)
instr_rs_ra_rccr0.initialize_operands = {
  INPUT(GPR_T, rs);
  OUTPUT(GPR_T, ra);
  if (rc)
  {
    OUTPUT(CR_T,0);
  }
}

group instr_rlwimi(rlwimi)
instr_rlwimi.initialize_operands = {
  INPUT(GPR_T, rs);
  INPUT(GPR_T, ra);
  OUTPUT(GPR_T, ra);
  if (rc)
  {
    OUTPUT(CR_T,0);
  }
}

group instr_rs_ra_rccr0xer2(srawi)
instr_rs_ra_rccr0xer2.initialize_operands = {
  INPUT(GPR_T, rs);
  OUTPUT(GPR_T, ra);
  OUTPUT(XER_T,2);
  if (rc)
  {
    OUTPUT(CR_T,0);
  }
}

group instr_rs_ra_cr0(andi_, andis_)
instr_rs_ra_cr0.initialize_operands = {
  INPUT(GPR_T, rs);
  OUTPUT(GPR_T, ra);
  OUTPUT(CR_T,0);
}

group instr_store_rs_ra(stb, sth, stw)
instr_store_rs_ra.initialize_operands = {
  INPUT(GPR_T, rs);
  INPUT(GPR_T, ra);
}

group instr_store_rs_ra_update(stbu, sthu, stwu)
instr_store_rs_ra_update.initialize_operands = {
  INPUT(GPR_T, rs);
  INPUT(GPR_T, ra);
  OUTPUT(GPR_T, ra); /*DD*/
}

group instr_fs_ra(stfd, stfs)
instr_fs_ra.initialize_operands = {
  INPUT(FPR_T, fs);
  INPUT(GPR_T, ra);
}

group instr_fs_ra_update(stfdu, stfsu)
instr_fs_ra_update.initialize_operands = {
  INPUT(FPR_T, fs);
  INPUT(GPR_T, ra);
}

group instr_to_ra(twi)
instr_to_ra.initialize_operands = {
  INPUT(GPR_T, ra);
}

group instr_to_ra_rb(tw)
instr_to_ra_rb.initialize_operands = {
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

group instr_crfd_ra(cmpi, cmpli)
instr_crfd_ra.initialize_operands = {
  INPUT(GPR_T, ra);
  INPUT(XER_T,0);
//  OUTPUT(CRF_T, crfD);
  OUTPUT(CR_T, crfD);
}

group instr_rs_ra_rb(and, andc, eqv, nand, nor, or, orc, slw, srw, xor, rlwnm)
instr_rs_ra_rb.initialize_operands = {
  OUTPUT(GPR_T, ra);
  INPUT(GPR_T, rs);
  INPUT(GPR_T, rb);
  if (rc)
  {
    OUTPUT(CR_T, 0);
  }
}

group instr_rs_ra_rb_xer2(sraw)
instr_rs_ra_rb_xer2.initialize_operands = {
  OUTPUT(GPR_T, ra);
  INPUT(GPR_T, rs);
  INPUT(GPR_T, rb);
  OUTPUT(XER_T,2);
  if (rc)
  {
    OUTPUT(CR_T, 0);
  }
}

group instr_store_rs_ra_rb(stbx, sthbrx, sthx, stwbrx, stwcx_, stwx)
instr_store_rs_ra_rb.initialize_operands = {
  INPUT(GPR_T, rs);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

group instr_store_rs_ra_rb_update(stbux, sthux, stwux)
instr_store_rs_ra_rb_update.initialize_operands = {
  INPUT(GPR_T, rs);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

group instr_fs_ra_rb(stfdx, stfiwx, stfsx)
instr_fs_ra_rb.initialize_operands = {
  INPUT(FPR_T, fs);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

group instr_fs_ra_rb_update(stfdux, stfsux)
instr_fs_ra_rb_update.initialize_operands = {
  INPUT(FPR_T, fs);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

//group instr_rd_ra_rb(eciwx, lbzx, lhax, lhbrx, lhzx, lwarx, lwbrx, lwzx, add, addc, adde, divw, divwu, mulhw, mulhwu, mullw, subf, subfc, subfe)
//group instr_rd_ra_rb(eciwx, lbzx, lhax, lhbrx, lhzx, lwarx, lwbrx, lwzx, add, addc, divw, divwu, mulhw, mulhwu, mullw, subf, subfc)
group instr_rd_ra_rb(eciwx, lbzx, lhax, lhbrx, lhzx, lwarx, lwbrx, lwzx)
instr_rd_ra_rb.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

group instr_rd_ra_rb_cr0(divw, divwu, mulhw, mulhwu, mullw)
instr_rd_ra_rb_cr0.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
  if (rc)
  {
    OUTPUT(CR_T,0);
  }
}



group instr_add_sub(add, subf)
instr_add_sub.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
  if (rc)
  {
    OUTPUT(CR_T,0);
  }
}

group instr_addc_subc(addc, subfc)
instr_addc_subc.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
  OUTPUT(XER_T, 2);
  if (rc)
  {
    OUTPUT(CR_T,0);
  }
}

group instr_adde_sube(adde,subfe)
instr_adde_sube.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
  INPUT(XER_T,2);
  OUTPUT(XER_T,2);
  if (rc)
  {
    OUTPUT(CR_T,0);
  }
}


group instr_rd_ra_rb_update(lbzux, lhaux, lhzux, lwzux)
instr_rd_ra_rb_update.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

group instr_fd_ra_rb(lfdx, lfsx)
instr_fd_ra_rb.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

group instr_fd_ra_rb_update(lfdux)
instr_fd_ra_rb_update.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

group instr_fd_fa_fb(fadd, fadds, fdiv, fdivs, fsub, fsubs)
instr_fd_fa_fb.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(FPR_T, fa);
  INPUT(FPR_T, fb);
  INPUT(FPSCR_T, 0);
  if (rc)
  {
    OUTPUT(CR_T, 0);
  }
  OUTPUT(FPSCR_T, 0);
}

group instr_fd_fa_fc(fmul, fmuls)
instr_fd_fa_fc.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(FPR_T, fa);
  INPUT(FPR_T, fc);
  INPUT(FPSCR_T, 0);
  if (rc)
  {
    OUTPUT(CR_T, 0);
  }
  OUTPUT(FPSCR_T, 0);
}

group instr_fd_fb(fres, frsqrte, fsqrts, fsqrt)
instr_fd_fb.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(FPR_T, fb);
  INPUT(FPSCR_T, 0);
  if (rc)
  {
    OUTPUT(CR_T, 0);
  }
  OUTPUT(FPSCR_T, 0);
}

group instr_fd_fa_fb_fc_fpscr(fmadd, fmadds, fmsub, fmsubs, fnmadd, fnmadds, fnmsub, fnmsubs)
instr_fd_fa_fb_fc_fpscr.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(FPSCR_T, 0);
  INPUT(FPR_T, fa);
  INPUT(FPR_T, fb);
  INPUT(FPR_T, fc);
  if (rc)
  {
    OUTPUT(CR_T, 0);
  }
  OUTPUT(FPSCR_T, 0);
}

group instr_fd_fa_fb_fc(fsel)
instr_fd_fa_fb_fc.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(FPR_T, fa);
  INPUT(FPR_T, fb);
  INPUT(FPR_T, fc);
  if (rc)
  {
    OUTPUT(CR_T, 0);
  }
}

group instr_rd_rb(mfsrin)
instr_rd_rb.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, rb);
}

group instr_rd_rb_flt_fpscr(fctiw, fctiwz, frsp)
instr_rd_rb_flt_fpscr.initialize_operands = {
  OUTPUT(FPR_T, fd);
  OUTPUT(FPSCR_T, 0);
  INPUT(FPR_T, fb);
  INPUT(FPSCR_T, 0);
  if (rc)
  {
    OUTPUT(CR_T, 0);
  }
}

group instr_rd_rb_flt(fabs, fmr, fnabs, fneg)
instr_rd_rb_flt.initialize_operands = {
  OUTPUT(FPR_T, fd);
  INPUT(FPR_T, fb);
  if (rc)
  {
    OUTPUT(CR_T, 0);
  }
}

group instr_rd(mfmsr, mftb)
instr_rd.initialize_operands = {
  OUTPUT(GPR_T, rd);
}

group instr_mfcr(mfcr)
instr_mfcr.initialize_operands = {
		   INPUT(CR_T,0);		
		   INPUT(CR_T,1);		
		   INPUT(CR_T,2);		
		   INPUT(CR_T,3);		
		   INPUT(CR_T,4);		
		   INPUT(CR_T,5);		
		   INPUT(CR_T,6);		
		   INPUT(CR_T,7);		
  OUTPUT(GPR_T, rd);
}

group instr_mfspr(mfspr)
instr_mfspr.initialize_operands = {
   uint32_t d = ((spr & 0x1f) << 5) | ((spr >> 5) & 0x1f);
   switch(d)
   {
      case 1:
        INPUT(XER_T,0);
        INPUT(XER_T,1);
	INPUT(XER_T,2);
	INPUT(XER_T,3);
        break;
      case 8:
        INPUT(LR_T,0);		   
        break;
      case 9:
        INPUT(CTR_T,0);		
/*
	INPUT(CR_T,1);		
	INPUT(CR_T,2);		
	INPUT(CR_T,3);		
	INPUT(CR_T,4);		
	INPUT(CR_T,5);		
	INPUT(CR_T,6);		
	INPUT(CR_T,7);		
*/
	break;
      default:
        break;
   }
  OUTPUT(GPR_T, rd);
}

group instr_fd(mffs)
instr_fd.initialize_operands = {
  INPUT(FPSCR_T,0);
  OUTPUT(FPR_T, fd);
  if (rc)
  {
    OUTPUT(CR_T,1);
  }
}

group instr_rs(mtmsr)
instr_rs.initialize_operands = {
  INPUT(GPR_T, rs);
}

group instr_mtcrf(mtcrf)
instr_mtcrf.initialize_operands = {
  INPUT(GPR_T, rs);
        INPUT(CR_T,0);		
	INPUT(CR_T,1);		
	INPUT(CR_T,2);		
	INPUT(CR_T,3);		
	INPUT(CR_T,4);		
	INPUT(CR_T,5);		
	INPUT(CR_T,6);		
	INPUT(CR_T,7);  

        OUTPUT(CR_T,0);		
	OUTPUT(CR_T,1);		
	OUTPUT(CR_T,2);		
	OUTPUT(CR_T,3);		
	OUTPUT(CR_T,4);		
	OUTPUT(CR_T,5);		
	OUTPUT(CR_T,6);		
	OUTPUT(CR_T,7);  
}

group instr_mtspr(mtspr)
instr_mtspr.initialize_operands = {
  INPUT(GPR_T, rs);
   uint32_t d = ((spr & 0x1f) << 5) | ((spr >> 5) & 0x1f);
   switch(d)
   {
      case 1:
        OUTPUT(XER_T,0);
        OUTPUT(XER_T,1);
	OUTPUT(XER_T,2);
	OUTPUT(XER_T,3);
        break;
      case 8:
        OUTPUT(LR_T,0);		   
        break;
      case 9:
        OUTPUT(CTR_T,0);		
/*
	OUTPUT(CR_T,1);		
	OUTPUT(CR_T,2);		
	OUTPUT(CR_T,3);		
	OUTPUT(CR_T,4);		
	OUTPUT(CR_T,5);		
	OUTPUT(CR_T,6);		
	OUTPUT(CR_T,7);		
*/
	break;
      default:
        break;
   }
}

group instr_rs_sr(mtsr)
instr_rs_sr.initialize_operands = {
  INPUT(GPR_T, rs);
  OUTPUT(SR_T, sr);
}

group instr_rd_sr(mfsr)
instr_rd_sr.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(SR_T, sr);
}

group instr_rs_rb(mtsrin)
instr_rs_rb.initialize_operands = {
  INPUT(GPR_T, rs);
  INPUT(GPR_T, rb);
}

group instr_crfd_ra_rb(cmp, cmpl)
instr_crfd_ra_rb.initialize_operands = {
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
  INPUT(XER_T,0);
//  OUTPUT(CRF_T, crfD);
  OUTPUT(CR_T, crfD);
}

group instr_fpscrfd_ra_rb(fcmpo, fcmpu)
instr_fpscrfd_ra_rb.initialize_operands = {
  INPUT(FPR_T, fa);
  INPUT(FPR_T, fb);
  INPUT(FPSCR_T, 0);
//  OUTPUT(FPSCRF_T, crfD);
//  OUTPUT(FPSCR_T, crfD);
  OUTPUT(FPSCR_T, 0);
  OUTPUT(CR_T, crfD);
}

group instr_rb_flt(mtfsf)
instr_rb_flt.initialize_operands = {
  INPUT(FPSCR_T, 0);
  INPUT(FPR_T, fb);
  OUTPUT(FPSCR_T, 0);
  if (rc)
  {
    OUTPUT(CR_T, 1);
  }
}

group instr_ra_rb(dcba, dcbf, dcbi, dcbst, dcbt, dcbtst, dcbz, icbi)
instr_ra_rb.initialize_operands = {
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

group instr_crfd_mcrxr(mcrxr)
instr_crfd_mcrxr.initialize_operands = {
//  OUTPUT(CRF_T, crfD);
  INPUT(XER_T, 0);
  OUTPUT(CR_T, crfD);
}

group instr_crfd_mtfsfi(mtfsfi)
instr_crfd_mtfsfi.initialize_operands = {
//  OUTPUT(CRF_T, crfD);
  INPUT(FPSCR_T, 0);
  if (rc)
  {
    OUTPUT(CR_T, 1);
  }
  //  OUTPUT(CR_T, crfD);
  OUTPUT(FPSCR_T, 0);
}

group instr_crfd_fpscrfs(mcrfs)
instr_crfd_fpscrfs.initialize_operands = {
//  OUTPUT(CRF_T, crfD);
//  INPUT(FPSCRF_T, crfS);
  OUTPUT(CR_T, crfD);
  //  INPUT(FPSCR_T, crfS);
  INPUT(FPSCR_T, 0);
}

group instr_crfd_crfs(mcrf)
instr_crfd_crfs.initialize_operands = {
//  OUTPUT(CRF_T, crfD);
//  INPUT(CRF_T, crfS);
  OUTPUT(CR_T, crfD);
  INPUT(CR_T, crfS);
}

group instr_crbd_crba_crbb(crand, crandc, creqv, crnand, crnor, cror, crorc, crxor)
instr_crbd_crba_crbb.initialize_operands = {
//  OUTPUT(CRF_T, crbD);
//  INPUT(CRF_T, crbA);
//  INPUT(CRF_T, crbB);
/*
  OUTPUT(CR_T, crbD);
  INPUT(CR_T, crbA);
  INPUT(CR_T, crbB);
*/
        INPUT(CR_T,0);		
	INPUT(CR_T,1);		
	INPUT(CR_T,2);		
	INPUT(CR_T,3);		
	INPUT(CR_T,4);		
	INPUT(CR_T,5);		
	INPUT(CR_T,6);		
	INPUT(CR_T,7);  

        OUTPUT(CR_T,0);		
	OUTPUT(CR_T,1);		
	OUTPUT(CR_T,2);		
	OUTPUT(CR_T,3);		
	OUTPUT(CR_T,4);		
	OUTPUT(CR_T,5);		
	OUTPUT(CR_T,6);		
	OUTPUT(CR_T,7);  
}

group instr_crbd(mtfsb0, mtfsb1)
instr_crbd.initialize_operands = {
  //  INPUT(CRB_T, crbD);
  INPUT(FPSCR_T, 0);
  if (rc)
  {
    OUTPUT(CR_T, 1);
  }
  OUTPUT(FPSCR_T, 0);
}

group instr_rb(tlbie)
instr_rb.initialize_operands = {
  INPUT(GPR_T, rb);
}

// --- Load & Store string ----------------------------------------------------




/*

lswi.initialize_operands = {
  uint8_t n = nb ? nb : 32;
  uint8_t r = rd;
  INPUT(GPR_T, ra);
  while(n>0)
  { OUTPUT(GPR_T,r);
    n-=4;
    r = (r + 1) & 31;
  }
}

stswi.initialize_operands = {
  uint8_t n = nb ? nb : 32;
  uint8_t r = rs;
  INPUT(GPR_T, ra);
  while(n>0)
  { OUTPUT(GPR_T,r);
    n-=4;
    r = (r + 1) & 31;
  }
}

lswx.initialize_operands = {
  uint8_t n = cpu->GetXER_BYTE_COUNT();
  uint8_t r = rd;
  INPUT(GPR_T, ra);
  while(n>0)
  { OUTPUT(GPR_T,r);
    n-=4;
    r = (r + 1) & 31;
  }
}

stswx.initialize_operands = {
  uint8_t n = cpu->GetXER_BYTE_COUNT();
  uint8_t r = rs;
  INPUT(GPR_T, ra);
  while(n>0)
  { OUTPUT(GPR_T,r);
    n-=4;
    r = (r + 1) & 31;
  }
}

*/



lswi.initialize_operands = {
  INPUT(GPR_T, ra); // target address
  INPUT(GPR_T, rd); 
  INPUT(IMM_T, nb);
}

stswi.initialize_operands = {
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rs);
  INPUT(IMM_T, nb);
}

lswx.initialize_operands = {
  OUTPUT(GPR_T, rd);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}

stswx.initialize_operands = {
  INPUT(GPR_T, rs);
  INPUT(GPR_T, ra);
  INPUT(GPR_T, rb);
}
