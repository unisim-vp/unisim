//----------------------------------------------------------------------

//                  BIT INSTRUCTIONS

//----------------------------------------------------------------------

//BFEXTS - bitfield extract and sign-extend

op bfexts(0b111[3]:rd[4]:0b11101[5]:rs[4]:><:0b1011[4]:0b00[2]:bp5[5]:w5[5])

bfexts.execute={
	
	uint32_t s= cpu->GetGPR(rs);

	s= s >> bp5;
	s=s & ((1UL<< w5)-1);     
	uint32_t result=SignExtend(s,(unsigned int)w5);
	uint8_t neg=(int32_t)result<0;
	uint8_t zero=result==0;
	uint8_t carry=result & (1 <<31);

	cpu->SetGPR(rd,result);
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry);

	return true;  
}

bfexts.disasm={
	os << "bfexts\tr" << (unsigned int) rd << ",r" <<  (unsigned int) rs << ",0x" << std::hex <<(int) bp5 << ",0x" << std::hex << ( int) w5 << endl;
}

//BFEXTU - bitfield extract and zero-extend

op bfextu(0b111[3]:rd[4]:0b11101[5]:rs[4]:><:0b1100[4]:0b00[2]:bp5[5]:w5[5])

bfextu.execute={
	
	uint32_t s= cpu->GetGPR(rs);

	s= s >> bp5;
	uint32_t result=s & ((1UL<< w5)-1);     
	
	uint8_t neg=(int32_t)result<0;
	uint8_t zero=result==0;
	uint8_t carry=result & (1 <<31);

	cpu->SetGPR(rd,result);
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry); 

	return true; 
}


bfextu.disasm={
	os << "bfextu\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << ",0x" << std::hex <<(int) bp5 << ",0x" <<std::hex<< ( int)w5 << endl;
}

//BFINS - bitfield insert

op bfins(0b111[3]:rd[4]:0b11101[5]:rs[4]:><:0b1101[4]:0b00[2]:bp5[5]:w5[5])

bfins.execute={

   	if (w5 == 0 || bp5 + w5 > 32) return false; // the result 

	uint32_t s=cpu->GetGPR(rs);
	uint32_t d=cpu->GetGPR(rd);
	
	s=s << bp5;
	uint32_t mask=((1<< w5)-1)<< bp5;                  // initialize mask size w5 offset bp5
	uint32_t result= (d & ~mask) | (s & mask);         // insert bietfield in 
	uint8_t neg=(int32_t)result<0;
	uint8_t zero=result==0;
	uint8_t carry=result & (1 <<31);
	

	cpu->SetGPR(rd,result); 
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry);

	return true;  
}

bfins.disasm={
	os << "bfins\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << ",0x" << std::hex << ( int) bp5 << "," <<std::hex << (unsigned int) w5 << endl;
}


//BLD - bit load from register to c and z

op bld(0b111[3]:0b0110[4]:0b11011[5]:rd[4]:><:0b00000000000[11]:bp5[5])

bld.execute={

	uint32_t d=cpu->GetGPR(rd);

	uint8_t result= d & (1 << bp5);
	uint8_t zero= result;
	uint8_t carry=result;

	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry);

	return true;

}

bld.disasm={
	os << "bld\tr" << (unsigned int) rd << ",0x" << std::hex << (int) bp5 << endl; 
}

//BREV - bit reverse  // verifier s'il existe une fonction en c

op brev(0b010[3]:0b1110[4]:0b01001[5]:rd[4])

brev.execute={

	uint32_t d=cpu->GetGPR(rd);

	uint32_t result=0;
	uint8_t bit=0;
	for(int i=0;i<32;i++)
	{
		bit=(d >> i) & 1;  // copy bit
		result=(result & ~(1<<(31-i))) | (bit & 1<<(31-i)) ;//insert in result
	}	
	uint32_t zero= result==0;

	cpu->SetGPR(rd,result);
	cpu->SetSR_Z(zero);

	return true;
	
}

brev.disasm={
	os << "brev\tr" << (unsigned int) rd << endl;
}

//BST - copy c to register

op bst(0b111[3]:0b0111[4]:0b11011[5]:rd[4]:><:0b00000000000[11]:bp5[5])

bst.execute={

	uint32_t d=cpu->GetGPR(rd);
	uint32_t c=cpu->GetSR_C();

	uint32_t result= (d & ~(1<<bp5)) | c << bp5;

	cpu->SetGPR(rd,result);

	return true;
}

bst.disasm={
	os << "bst\tr" << (unsigned int) rd << ",0x" << std::hex << ( int) bp5 << endl;
}

//CASTS - type cast to signed word

op casts_h(0b010[3]:0b1110[4]:0b01000[5]:rd[4])

casts_h.execute={

	uint32_t d= cpu->GetGPR(rd);
	
	d= d & ((1<<16) -1);
	uint32_t result = SignExtend(d,16);
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result ==0;
	uint32_t carry= result & (1<<31);
	
	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry);

	return true;
}

casts_h.disasm={
	os << "casts_h\tr" << (unsigned int) rd << endl;
}

op casts_b(0b010[3]:0b1110[4]:0b00110[5]:rd[4])

casts_b.execute={

	uint32_t d= cpu->GetGPR(rd);
	
	d= d & ((1<<8) -1);
	uint32_t result = SignExtend(d,8);
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result ==0;
	uint32_t carry= result & (1<<31);
	
	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry);

	return true;
}


casts_b.disasm={
	os << "casts_b\tr" << (unsigned int) rd << endl;
}

//CASTU - type cast to unsigned word

op castu_h(0b010[3]:0b1110[4]:0b00111[5]:rd[4])

castu_h.execute={

	uint32_t d= cpu->GetGPR(rd);
	
	uint32_t result= d & 0x0000FFFF;
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result ==0;
	uint32_t carry= result & (1<<31);
	
	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry);

	return true;
}

castu_h.disasm={
	os << "castu_h\tr" << (unsigned int) rd << endl;
}

op castu_b(0b010[3]:0b1110[4]:0b00101[5]:rd[4])

castu_b.execute={

	uint32_t d= cpu->GetGPR(rd);
	
	uint32_t result = d & 0x000000FF;
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result ==0;
	uint32_t carry= result & (1<<31);
	
	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry);

	return true;
}

castu_b.disasm={
	os << "castu_b\tr" << (unsigned int) rd << endl;
}

// CBR - clear bit in register

op cbr(0b101[3]:bp_4_1[4]:0b1110[4]:bp_0[1]:rd[4])

cbr.var bp : {uint8_t} = {(bp_4_1 << 1)| bp_0 }

cbr.execute={

	uint32_t d=cpu->GetGPR(rd);

	uint32_t result= d & ~(1<<bp);
	uint8_t zero= result ==0;

	cpu->SetGPR(rd,result);
	cpu->SetSR_Z(zero);

	return true;
}

cbr.disasm={
	os << "cbr\tr" << (unsigned int) rd << ",0x" <<std::hex << ( int) bp << endl;
}

//CLZ - count leading zeros

op clz(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0010[4]:0b00000000[8])

clz.execute={
	
	uint32_t s=cpu->GetGPR(rs);
	
	uint32_t result=CountLeadingZeros(s);
	uint8_t zero=result==0;
	uint8_t carry= result=32;

	cpu->SetGPR(rd,result);

	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry);

	return true;
}

clz.disasm={
	os << "clz\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << endl;
}

//SBR - set bit in register

op sbr(0b101[3]:bp_4_1[4]:0b1101[4]:bp_0[1]:rd[4])

sbr.var bp : {uint8_t} = {(bp_4_1 << 1)| bp_0 } 

sbr.execute={

	uint32_t d=cpu->GetGPR(rd);

	uint32_t result= d | (1<<bp);
	uint8_t zero= result ==0;             //documentation pas claire

	cpu->SetGPR(rd,result);
	cpu->SetSR_Z(zero);

	return true;
}

sbr.disasm={
	os << "sbr\tr" << (unsigned int) rd << ",0x"<< std::hex << (int) bp << endl;
}


//SWAP_B -  swap bytes

op swap_b(0b010[3]:0b1110[4]:0b01011[5]:rd[4])

swap_b.execute={

	uint32_t temp=cpu->GetGPR(rd);
	

	uint32_t result= ((temp & 0x000000FF) << 24) | ((temp & 0x0000FF00)<<8) | ((temp & 0x00FF0000)>>8) | ((temp & 0xFF000000)>>24); 

	cpu->SetGPR(rd,result);

	return true;
}

swap_b.disasm={

	os << "swap_b\tr" << (unsigned int) rd << endl;
}

// SWAP_BH - swap bytes in halfword

op swap_bh(0b010[3]:0b1110[4]:0b01100[5]:rd[4])

swap_bh.execute={

	uint32_t temp=cpu->GetGPR(rd);

	uint32_t result= ((temp & 0x00FF0000)<<8) | ((temp & 0xFF000000)>>8) |((temp & 0x000000FF)<<8) | ((temp & 0x0000FF00)>>8);

	cpu->SetGPR(rd,result);

	return 0;
}

swap_bh.disasm={

	os << "swap_bh\tr" << (unsigned int) rd << endl;
}


//SWAP_H - swap halfwords

op swap_h(0b010[3]:0b1110[4]:0b01010[5]:rd[4])

swap_h.execute={

	uint32_t temp=cpu->GetGPR(rd);

	uint32_t result= ((temp & 0x0000FFFF)<<16) | ((temp & 0xFFFF0000)>>16);

	cpu->SetGPR(rd,result);	

	return 0;
}

swap_h.disasm={

	os << "swap_h\tr" << (unsigned int) rd << endl;
}


//---------------------------------------------------------------------------

//                SHIFT INSTRUCTIONS

//---------------------------------------------------------------------------


//ASR - arithmetic shift right

op asr_a(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b10000100[8]:rd[4])

asr_a.execute={

	uint32_t x= cpu->GetGPR(rx);
	uint32_t y= cpu->GetGPR(ry);
	uint32_t sa = y & 0x0000001F;
	uint32_t result;
	uint8_t bit_out;

	result=ShiftArithmeticRight(x, (unsigned int)sa,bit_out);
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(bit_out);

	return true;
}

asr_a.disasm={
	os << "asr_a\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << endl;
}

op asr_b(0b101[3]:sa_4_1[4]:0b1010[4]:sa_0[1]:rd[4])

asr_b.var sa : {uint8_t} = {(sa_4_1 << 1)| sa_0 }

asr_b.execute={

	uint32_t d= cpu->GetGPR(rd);
	uint32_t result;
	uint8_t bit_out;

	result=ShiftArithmeticRight(d, (unsigned int)sa,bit_out);
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(bit_out);

	return true;
}


asr_b.disasm={
	os << "asr_b\tr" << (unsigned int) rd << ",0x" << std::hex<<(unsigned int) sa << endl;
}


op asr_c(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0100[4]:0b000[3]:sa5[5])

asr_c.execute={

	uint32_t s= cpu->GetGPR(rs);
	uint32_t result;
	uint8_t bit_out;

	result=ShiftArithmeticRight(s,(unsigned int)sa5,bit_out);
	uint8_t neg= (int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(bit_out);

	return true;
}

asr_c.disasm={
	os << "asr_c\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << ",0x" <<std::hex << (int) sa5 << endl;
}




//LSL - logical shift left

op lsl_a(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b10010100[8]:rd[4])

lsl_a.execute={
	
	uint32_t x= cpu->GetGPR(rx);
	uint32_t y= cpu->GetGPR(ry);
	uint32_t sa = y & 0x0000001F;
	uint32_t result;
	uint8_t bit_out;

	result=ShiftLeft(x, (unsigned int)sa,bit_out);
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(bit_out);
	
	return true;
}

lsl_a.disasm={
	os << "lsl_a\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << endl;
}

op lsl_b(0b101[3]:sa_4_1[4]:0b1011[4]:sa_0[1]:rd[4])

lsl_b.var sa : {uint8_t} = {(sa_4_1 << 1)| sa_0 }

lsl_b.execute={
	
	uint32_t d= cpu->GetGPR(rd);
	uint32_t result;
	uint8_t bit_out;

	result=ShiftLeft(d, (unsigned int)sa,bit_out);
	uint8_t neg= (int32_t) result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(bit_out);	
	
	return true;
}

lsl_b.disasm={
	os << "lsl_b\r" << (unsigned int) rd << ",0x" << std::hex << (int) sa << endl;
}


op lsl_c(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0101[4]:0b000[3]:sa5[5])

lsl_c.execute={
	
	uint32_t s= cpu->GetGPR(rs);
	uint32_t result;
	uint8_t bit_out;

	result=ShiftLeft(s,(unsigned int)sa5,bit_out);
	uint8_t neg= result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(bit_out);
	
	return true;
}

lsl_c.disasm={
	os << "lsl_c\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << ",0x"<< std::hex << (int) sa5 << endl;
}

//LSR - logical shift right

op lsr_a(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b10100100[8]:rd[4])

lsr_a.execute={

	uint32_t x= cpu->GetGPR(rx);
	uint32_t y= cpu->GetGPR(ry);
	uint32_t sa = y & 0x0000001F;
	uint32_t result;
	uint8_t bit_out;

	result=ShiftRight(x, (unsigned int)sa,bit_out);
	uint8_t neg= (int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(bit_out);
	
	return true;
}

lsr_a.disasm={
	os << "lsr_a\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << endl;
}


op lsr_b(0b101[3]:sa_4_1[4]:0b1100[4]:sa_0[1]:rd[4])

lsr_b.var sa : {uint8_t} = {(sa_4_1 << 1)| sa_0 }

lsr_b.execute={
	
	uint32_t d= cpu->GetGPR(rd);
	uint32_t result;
	uint8_t bit_out;

	result=ShiftRight(d,(unsigned int)sa,bit_out);
	uint8_t neg= (int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(bit_out);	
	
	return true;
}

lsr_b.disasm={
	os << "lsr_b\tr" << (unsigned int) rd << ",0x" << std::hex << (int) sa << endl;
}

op lsr_c(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0110[4]:0b000[3]:sa5[5])

lsr_c.execute={
	
	uint32_t s= cpu->GetGPR(rs);
	uint32_t result;
	uint8_t bit_out;

	result=ShiftRight(s,(unsigned int)sa5,bit_out);
	uint8_t neg=(int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(bit_out);
	
	return true;
}

lsr_c.disasm={
	os << "lsr_c\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << ",0x" << std::hex << (int) sa5 << endl;
}




//ROL - rotate left through carry

op rol(0b010[3]:0b1110[4]:0b01111[5]:rd[4])

rol.execute={
	
	uint32_t d = cpu->GetGPR(rd);

	uint8_t neg;
	uint8_t zero;
	uint8_t carry_in=cpu->GetSR_C();
	uint8_t carry_out;

	uint32_t result=RotateLeft(d, 1, carry_in , carry_out);
	neg=(int32_t)result < 0;
	zero= result==0;
	
	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry_out);
	
	return true;

}

rol.disasm={

	os << "rol\tr" << (unsigned int) rd << endl;
}

//ROR - rotate right through carry

op ror(0b010[3]:0b1110[4]:0b10000[5]:rd[4])

ror.execute={
	
	uint32_t d = cpu->GetGPR(rd);

	uint8_t neg;
	uint8_t zero;
	uint8_t carry_in=cpu->GetSR_C();
	uint8_t carry_out;

	uint32_t result=RotateRight(d, 1, carry_in , carry_out);
	neg=(int32_t)result < 0;
	zero= result==0;
	
	cpu->SetGPR(rd,result);
	
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	cpu->SetSR_C(carry_out);
	
	return true;

}

ror.disasm={

	os << "ror\tr" << (unsigned int) rd << endl;
}



