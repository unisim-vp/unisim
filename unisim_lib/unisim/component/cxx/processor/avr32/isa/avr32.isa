/*
 *  Copyright (c) 2014,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Julien Lisita (julien.lisita@cea.fr)
 *          Gilles Mouchard (gilles.mouchard@cea.fr)
 */

decl {

#include <iosfwd>
#include <cmath>

extern uint32_t grp[15];
extern uint32_t pc;
extern uint32_t psr;
}

set endianness big
set codetype buffer
set addressclass {typename CONFIG::address_t}
template <{class} {CONFIG}>

action {bool} execute({typename CONFIG::STATE *} {cpu}) {
	return false;
}

action {void} disasm({typename CONFIG::STATE *} {cpu}, {std::ostream&} {os}) {
	os << "???";
}

//-------------------------------------------------------------------------

//                                ALU INSTRUCTIONS

//-------------------------------------------------------------------------

// ABS - absolute value

op abs(0b010[3]:0b1110[4]:0b00100[5]:rd[4])


abs.execute={

	if(gpr[rd]!=0x80000000) gpr[rd]= abs(gpr[rd]);
	
}
abs.disasm={

	os<< "abs " << rd << endl ;
}


// ACR - add carry to register

op acr(0b010[3]:0b1110[4]:0b00000[5]:rd[4])

acr.disasm={

	os<< "acr " << rd << endl ;
}

// ADC - add with carry

op adc(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00000100[8]:rd[4])

adc.disasm={

	os<< "adc " << rd << "," << rx << "," << ry << endl ;
}

// ADD - add without carry

op add_a(0b000[3]:rs[4]:0b00000[5]:rd[4]) 

add_a.execute={

	gpr[rd]=gpr[rd]+gpr[rs];
}
add_a.disasm={

	os<< "add_a " << rd << "," << rs << endl ;

}

op add_b(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0000[4]:0b00[2]:sa[2]:rd[4])

add_b.execute={

	gpr[rd]=gpr[rx]+(gpr[ry] << sa);
}

add_b.disasm={

	os << "add_b " << rd << "," << rx << "," << ry << "<<" << sa << endl;
}

// ADD_COND4 - conditional add

op add_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0000[4]:rd[4])

add_cond4.execute={

	if(cond4) gpr[rd]=grp[rx]+gpr[ry];
}
add_cond4.disasm={

	os<< "add_cond4 " << rd << "," << rx << "," << ry << endl ;

}

// ADDHH_W - add halfwords into word

op addhh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1110[4]:0b00[2]:x[1]:y[1]:rd[4])

// ADDABS - add absolute value

op addabs(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b11100100[8]:rd[4])

addabs.disasm={

	os<< "addabs " << rd << "," << rx << "," << ry << endl ;

}

// CP_B - compare byte

op cp_b(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b1000[4]:0b00000000[8])

cp_b.disasm={

	os<< "cp_b " << rd << "," << rs << endl ;

}

// CP_H - compare halfword

op cp_h(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b1001[4]:0b00000000[8])

cp_h.disasm={

	os<< "cp_h " << rd << "," << rs << endl ;

}

// CP_W - compare word

op cp_w_a(0b000[3]:rs[4]:0b00011[5]:rd[4])

cp_w_a.disasm={

	os<< "cp_w_a " << rd << "," << rs << endl ;

}

op cp_w_b(0b010[3]:0b110[3]:imm6[6]:rd[4])

cp_w_b.disasm={

	os<< "cp_w_b " << rd << "," << imm6 << endl ;

}

op cp_w_c(0b111[3]:imm_20_17[4]:0b0010[4]:imm_15[1]:rd[4]:><:imm_15_0[16])

cp_w_c.var imm : { uint32_t } = { (imm_20_17 << 17) | (imm_15 << 15) | imm_15_0 }

cp_w_c.disasm={

	os<< "cp_w_c " << rd << "," << imm << endl ;

}



// CPC - compare with carry

op cpc_a(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0011[4]:0b00000000[8])

cpc_a.disasm={

	os<< "cpc_a "<< rd << "," << rs << endl;
}

op cpc_b(0b010[3]:0b1110[4]:0b00010[5]:rd[4])

cpc_b.disasm={

	os<< "cpc_b "<< rd << endl;
}

// MAX - return maximum value

op max(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b11000100[8]:rd[4])

max.disasm={

	os << "max " << rd << "," << rx << "," << ry << endl;
}

//MIN - return minimum value

op min(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b11010100[8]:rd[4])//erreur dans la doc rd au lieu de ry

min.disasm={

	os << "min " << rd << "," << rx << "," << ry << endl;
}

//NEG - two's complement

op neg(0b010[3]:0b1110[4]:0b00011[5]:rd[4])

neg.disasm={

	os << "neg " <<  rd << endl;
}

// RSUB - reverse subtract

op rsub_a(0b000[3]:rs[4]:0b00010[5]:rd[4])

rsub_a.disasm={

	os << "rsub_a " << rd << "," << rs << endl;
}

op rsub_b(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0001[4]:imm8[8])

rsub_b.disasm={

	os << "rsub_b " << rd << "," << rs << "," << imm8 << endl;
}

// conditional reverse subtract

op rsub_cond4(0b111[3]:0b1101[4]:0b11011[5]:rd[4]:><:0b0000[4]:cond4[4]:imm8[8])

rsub_cond4.disasm={

	os << "rsub_cond4 " << rd << "," << imm8 << endl;
}

// subtract with carry

op sbc(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00010100[8]:rd[4])

sbc.disasm={

	
os << "sbc " << rd << "," << rx << "," << ry << endl;
}

//SCR - subtract carry from register

op scr(0b010[3]:0b1110[4]:0b00001[5]:rd[4])

scr.disasm={

	os << "scr " << rd << endl;
}

//SUB - subtract without carry

op sub_a(0b000[3]:rs[4]:0b00001[5]:rd[4])

sub_a.disasm={

	os << "sub_a " << rd << "," << rs << endl;
}

op sub_b(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0001[4]:0b00[2]:sa[2]:rd[4])

sub_b.disasm={

	os << "sub_b " << rd << "," << rx << "," << ry << "<<" << sa << endl;
}

op sub_c(0b001[3]:0b0[1]:imm8[8]:rd[4])

sub_c.disasm={

	os << "sub_c " << rd << "," << imm8 << endl;
}

op sub_d(0b111[3]:imm_20_17[4]:0b0001[4]:imm_16[1]:rd[4]:><:imm_15_0[16])
sub_d.var imm :{uint32_t}= {(imm_20_17 << 17)|(imm_16 <<16 )|imm_15_0}

sub_d.disasm={

	os << "sub_d " << rd << "," << imm << endl;
}

op sub_e(0b111[3]:rs[4]:0b01100[5]:rd[4]:><:imm16[16])

sub_e.disasm={

	os << "sub_e " << rd << "," << rs << "," << imm16 << endl;
}


//SUBHH_W - subtract halfwords into word

op subhh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b111100[6]:x[1]:y[1]:rd[4])



//SUB_CON4 - conditional subtract

op sub_f_cond4(0b111[3]:0b101[3]:f[1]:0b11011[5]:rd[4]:><:0b0000[4]:cond4[4]:imm8[8])

sub_f_cond4.disasm={

	os << "sub_f_cond4 " << rd << "," << imm8 << endl;

}

op sub_cond4(0b111[3]:rx[4]:0b11011[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0001[4]:rd[4])

sub_cond4.disasm={

	os << "sub_cond4 " << rd << "," << rx << "," << ry << endl;
}

//TNBZ - test if no byte equal to zero

op tnbz(0b010[3]:0b1110[4]:0b01110[5]:rd[4])

tnbz.disasm={

	os << "tnbz " << rd << endl;
}

//AND - logical and with optional logical shift

op and_a(0b000[3]:rs[4]:0b00110[5]:rd[4])

and_a.disasm={

	os << "and_a " << rd << "," << rs << endl;
}

op and_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0000000[7]:sa5[5]:rd[4])

and_b.disasm={

	os << "and_b " << rd << "," << rx << "," << ry << " << " << sa5 << endl;
}


op and_c(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0000001[7]:sa5[5]:rd[4])

and_c.disasm={

	os << "and_c " << rd << "," << rx << "," << ry << " >> " << sa5 << endl;
}

// AND_COND4 - conditionnal and

op and_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0010[4]:rd[4])


and_cond4.disasm={

	os << "and_cond4 " << rd << "," << rx << "," << ry << endl;
}

// ANDN - logical and not

op andn(0b000[3]:rs[4]:0b01000[5]:rd[4])

andn.disasm={

	os << "andn " << rd << "," << rs << endl;
}

//AND - logical and into hight or low half to register

op andh(0b111[3]:0b00[2]:0b1[1]:coh[1]:0b00001[5]:rd[4]:><:imm16[16])

andh.disasm={
	os << "andh " << rd << "," << imm16 << "," << coh << endl;
}

op andl(0b111[3]:0b00[2]:0b0[1]:coh[1]:0b00001[5]:rd[4]:><:imm16[16])

andl.disasm={
	os << "andl " << rd << "," << imm16 << "," << coh << endl;
}


// COM - one's compliment

op com(0b010[3]:0b1110[4]:0b01101[5]:rd[4])

com.disasm={

	os << "com " << rd << endl;
}

//EOR - logical exclusive or with optional logical shift

op eor_a(0b000[3]:rs[4]:0b00101[5]:rd[4])

eor_a.disasm={
	os << "eor_a " << rd << "," << rs << endl;
}

op eor_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0010000[7]:sa5[5]:rd[4])

eor_b.disasm={
	os << "eor_b " << rd << "," << rx << "," << ry << " << " << sa5 <<endl;
}


op eor_c(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0010001[7]:sa5[5]:rd[4])

eor_c.disasm={

	os << "eor_c " << rd << "," << rx << "," << ry << " >> " << sa5 <<endl;
}


//EOR_COND4 -  conditional logical EOR

op eor_cond4(0b111[3]:rx[4]:0b11101[5]//AND - logical and into hight or low half to register

op andh(0b111[3]:0b00[2]:0b1[1]:coh[1]:0b00001[5]:rd[4]:><:imm16[16])

andh.disasm={
	os << "andh " << rd << "," << imm16 << "," << coh << endl;
}

op andl(0b111[3]:0b00[2]:0b0[1]:coh[1]:0b00001[5]:rd[4]:><:imm16[16])

andl.disasm={
	os << "andl " << rd << "," << imm16 << "," << coh << endl;
}


// COM - one's compliment

op com(0b010[3]:0b1110[4]:0b01101[5]:rd[4])

com.disasm={

	os << "com " << rd << endl;
}

//EOR - logical exclusive or with optional logical shift

op eor_a(0b000[3]:rs[4]:0b00101[5]:rd[4])
:ry[4]:><:0b1110[4]:cond4[4]:rd[4])

eor_cond4.disasm={
	os << "eor_cond4 " << rd << "," << rx << "," << ry << endl;
}


//EORH - logical EOR into hight half register

op eorh(0b111[3]:0b011100001[9]:rd[4]:><:imm16[16])

eorh.disasm={
	os << "eorh " << rd << "," << imm16 << endl;
}

//EORL - logical EOR into low half register

op eorl(0b111[3]:0b011000001[9]:rd[4]:><:imm16[16])

eorl.disasm={
	os << "eorl " << rd << "," << imm16 << endl;
}

//OR - logical or with optional logical shift

op or_a(0b000[3]:rs[4]:0b00100[5]:rd[4])

or_a.disasm={
	os << "or_a " << rd << "," << rs << endl;
}

op or_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0001000[7]:sa5[5]:rd[4])

or_b.disasm={
	os << "or_b " << rd << "," << rx << "," << ry << " << " << sa5 <<endl;
}

op or_c(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0001001[7]:sa5[5]:rd[4])

or_c.disasm={
	os << "or_c " << rd << "," << rx << "," << ry << " >> " << sa5 <<endl;
}
//OR - logical or with optional logical shift

op or_a(0b000[3]:rs[4]:0b00100[5]:rd[4])

or_a.disasm={
	os << "or_a " << rd << "," << rs << endl;
}

op or_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0001000[7]:sa5[5]:rd[4])

or_b.disasm={
	os << "or_b " << rd << "," << rx << "," << ry << " << " << sa5 <<endl;
}

op or_c(0b111[3]:rx[4]:0b11110[
//OR_COND4 - conditional logical OR

op or_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0011[4]:rd[4])

or_cond4.disasm={
	os << "or_cond4 " << rd << "," << rx << "," << ry <<endl;
}

//ORH - logical OR into hight half register

op orh(0b111[3]:0b010100001[9]:rd[4]:><:imm16[16])

orh.disasm={
	os << "orh " << rd << "," << imm16 << endl;
}

//ORL- logical OR into low half register

op orl(0b111[3]:0b010000001[9]:rd[4]:><:imm16[16])

orl.disasm={
	os << "orl " << rd << "," << imm16 << endl;
}


// TST- test register

op tst(0b000[3]:rs[4]:0b00111[5]:rd[4])

tst.disasm={
	os << "tst " << rd << "," << rs << endl;
}


//BFINS - bitfield insert

op bfins(0b111[3]:rd[4]:0b11101[5]:rs[4]:><:0b1101[4]:0b00[2]:bp5[5]:w5[5])

bfins.disasm={
	os << "bfins " << rd << "," << rs << "," << bp5 << "," << w5 << endl;
}

//BFEXTS - bitfield extract and sign-extend

op bfexts(0b111[3]:rd[4]:0b11101[5]:rs[4]:><:0b1011[4]:0b00[2]:bp5[5]:w5[5])

bfexts.disasm={
	os << "bfexts " << rd << "," << rs << "," << bp5 << "," << w5 << endl;
}

//BFEXTU - bitfield extract and zero-extend

op bfextu(0b111[3]:rd[4]:0b11101[5]:rs[4]:><:0b1100[4]:0b00[2]:bp5[5]:w5[5])

bfextu.disasm={
	os << "bfextu " << rd << "," << rs << "," << bp5 << "," << w5 << endl;
}

//BLD - bit load from register to c and z

op bld(0b111[3]:0b0110[4]:0b11011[5]:rd[4]:><:0b00000000000[11]:bp5[5])

bld.disasm={
	os << "bld " << rd << "," << bp5 << endl; 
}

//BREV - bit reverse

op brev(0b010[3]:0b1110[4]:0b01001[5]:rd[4])

brev.disasm={
	os << "brev " << rd << endl;
}

//BST - copy c to register

op bst(0b111[3]:0b0111[4]:0b11011[5]:rd[4]:><:0b00000000000[11]:bp5[5])

bst.disasm={
	os << "bst " << rd << "," << bp5 << endl;
}

//CASTS - type cast to signed word

op casts_h(0b010[3]:0b1110[4]:0b01000[5]:rd[4])

casts_h.disasm={
	os << "casts_h " << rd << endl;
}

op casts_b(0b010[3]:0b1110[4]:0b00110[5]:rd[4])

casts_b.disasm={
	os << "casts_b " << rd << endl;
}

//CASTU - type cast to unsigned word

op castu_h(0b010[3]:0b1110[4]:0b00111[5]:rd[4])

castu_h.disasm={
	os << "castu_h " << rd << endl;
}

op castu_b(0b010[3]:0b1110[4]:0b00101[5]:rd[4])

castu_b.disasm={
	os << "castu_b " << rd << endl;
}

// CBR - clear bit in register

op cbr(0b101[3]:bp_4_1[4]:0b1110[4]:bp_0[1]:rd[4])

cbr.var bp : {uint8_t} = {(bp_4_1 << 1)| bp_0 }

cbr.disasm={
	os << "cbr " << rd << "," << bp << endl;
}

//CLZ - count leading zeros

op clz(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0010[4]:0b00000000[8])

clz.disasm={
	os << "clz " << rd << "," << rs << endl;
}

//SBR - set bit in register

op sbr(0b101[3]:bp_4_1[4]:0b1101[4]:bp_0[1]:rd[4])

sbr.var bp : {uint8_t} = {(bp_4_1 << 1)| bp_0 } 

sbr.disasm={
	os << "sbr " << rd << "," << bp << endl;
}


//SWAP_B -  swap bytes

op swap_b(0b010[3]:0b1110[4]:0b01011[5]:rd[4])

swap_b.disasm={

	os << "swap_b " << rd << endl;
}

// SWAP_BH - swap bytes in halfword

op swap_bh(0b010[3]:0b1110[4]:0b01100[5]:rd[4])

swap_bh.disasm={

	os << "swap_bh " << rd << endl;
}


//SWAP_H - swap halfwords

op swap_h(0b010[3]:0b1110[4]:0b01010[5]:rd[4])

swap_h.disasm={

	os << "swap_h " << rd << endl;
}


//ASR - arithmetic shift right

op asr_a(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b10000100[8]:rd[4])

asr_a.disasm={
	os << "asr_a " << rd << "," << rx << "," << ry << endl;
}

op asr_b(0b101[3]:sa_4_1[4]:0b1010[4]:sa_0[1]:rd[4])

asr_b.var sa : {uint8_t} = {(sa_4_1 << 1)| sa_0 }

asr_b.disasm={
	os << "asr_b " << rd << "," << sa << endl;
}


op asr_c(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0100[4]:0b000[3]:sa5[5])

asr_c.disasm={
	os << "asr_c " << rd << "," << rs << "," << sa5 << endl;
}


//LSL - logical shift left

op lsl_a(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b10010100[8]:rd[4])

lsl_a.disasm={
	os << "lsl_a " << rd << "," << rx << "," << ry << endl;
}

op lsl_b(0b101[3]:sa_4_1[4]:0b1011[4]:sa_0[1]:rd[4])

lsl_b.var sa : {uint8_t} = {(sa_4_1 << 1)| sa_0 }

lsl_b.disasm={
	os << "lsl_b " << rd << "," << sa << endl;
}


op lsl_c(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0101[4]:0b000[3]:sa5[5])

lsl_c.disasm={
	os << "lsl_c " << rd << "," << rs << "," << sa5 << endl;
}

//LSR - logical shift right

op lsr_a(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b10100100[8]:rd[4])

lsr_a.disasm={
	os << "lsr_a " << rd << "," << rx << "," << ry << endl;
}


op lsr_b(0b101[3]:sa_4_1[4]:0b1100[4]:sa_0[1]:rd[4])

lsr_b.var sa : {uint8_t} = {(sa_4_1 << 1)| sa_0 }

lsr_b.disasm={
	os << "lsr_b " << rd << "," << sa << endl;
}



op lsr_c(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0110[4]:0b000[3]:sa5[5])

lsr_c.disasm={
	os << "lsr_c " << rd << "," << rs << "," << sa5 << endl;
}

//ROL - rotate left through carry

op rol(0b010[3]:0b1110[4]:0b01111[5]:rd[4])

rol.disasm={

	os << "rol " << rd << endl;
}

//ROR - rotate right through carry

op ror(0b010[3]:0b1110[4]:0b10000[5]:rd[4])

ror.disasm={

	os << "ror " << rd << endl;
}

//MOV - move data into register

op mov_a(0b001[3]:0b1[1]:imm8[8]:rd[4])

mov_a.disasm={

	os << "mov_a " << rd << "," << imm8 << endl;
}

op mov_b(0b111[3]:imm_20_17[4]:0b0011[4]:imm_16[1]:rd[4]:><:imm_15_0[16])

mov_b.var imm : {uint32_t}= {(imm_20_17<<17)|(imm_16)<<16| imm_15_0}

mov_b.disasm={

	os << "mov_b " << rd << "," << imm << endl;
}

op mov_c(0b000[3]:rs[4]:0b01001[5]:rd[4])

mov_c.disasm={

	os << "mov_c " << rd << "," << rs << endl;
}

// MOV_COND4 - conditional move register

op mov_cond4_a(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0111[4]:cond4[4]:0b0000[4])

mov_cond4_a.disasm={

	os << "mov_cond4_a " << rd << "," << rs << endl;
}

op mov_cond4_b(0b111[3]:0b1100[4]:0b11011[5]:rd[4]:><:0b0000[4]:cond4[4]:imm8[8])

mov_cond4_b.disasm={

	os << "mov_cond4_b " << rd << "," << imm8 << endl;
}

// MOVH - move data into high halfword of register

op movh(0b111[3]:0b1110[4]:0b00001[5]:rd[4]:><:imm16[16])

movh.disasm={

	os << "movh " << rd << "," << imm16 << endl;
}

// CSRF - Clear status register flag

op csrf(0b11010[5]:0b10[2]:bp5[5]:0b0011[4])

csrf.disasm={

	os << "csrf " << bp5 << endl;
}

//CSRFCZ - copy status register flag to C and Z

op csrfcz(0b11010[5]:0b00[2]:bp5[5]:0b0011[4])

csrfcz.disasm={

	os << "csrfcz " << bp5 << endl;
}


// SSRF - set status condition flag

op ssrf(0b11010[5]:0b01[2]:bp5[5]:0b0011[4])

ssrf.disasm={

	os << "ssrf " << bp5 << endl;
}


// SR_COND4 - set register conditionally

op sr_cond4(0b010[3]:0b1111[4]:0b1[1]:cond4[4]:rd[4])

sr_cond4.disasm={

	os << "sr_cond4 " << rd << endl;
}


//-------------------------------------------------------------------------------

//                 MULTIPLY/DIVIDE INSTRUCTIONS

//-------------------------------------------------------------------------------


//MUL - multiply

op mul_a(0b101[3]:rs[4]:0b10011[5]:rd[4])

mul_a.disasm={

	os << "mul_a " << rd << "," << rs << endl;
}

op mul_b(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00100100[8]:rd[4])

mul_b.disasm={

	os << "mul_b " << rd << "," << rx << "," << ry << endl;
}

op mul_c(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0000[4]:imm8[8])

mul_c.disasm={

	os << "mul_c " << rd << "," << rs << "," << imm8 << endl;
}


//MULHH_W multiply halfword with halfword

op mulhh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b00000111[8]:0b10[2]:x[1]:y[1]:rd[4])


// multiply halword with negative halfword

op mulnhh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b00000001[8]:0b10[2]:x[1]:y[1]:rd[4])

//multiply word with negative halfword

op mulnwh_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0010[4]:0b100[3]:y[1]:rd[4])

//multiply word with halfword

op mulwh_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1101[4]:0b100[3]:y[1]:rd[4])

//multiply halfword with saturation into halfword

op mulsathh_h(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1000[4]:0b10[2]:x[1]:y[1]:rd[4])

//multiply halfword with saturation into word

op mulsathh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1001[4]:0b10[2]:x[1]:y[1]:rd[4])

//multiply word and halfword with saturation into word

op mulsatwh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1110[4]:0b100[3]:y[1]:rd[4])

//multiply halfwords with saturation and rounding into halfword

op mulsatrndhh_h(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1010[4]:0b10[2]:x[1]:y[1]:rd[4])

//multiply word ans halfwords with saturation and rounding into word

op mulsatrndwh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1011[4]:0b100[3]:y[1]:rd[4])

//signed divide

op divs(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b11000000[8]:rd[4])

//unsigned divide

op divu(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b11010000[8]:rd[4])

//----------------------------------------------------------------------------------------

//                            LOAD AND STORE INSTRUCTIONS

//----------------------------------------------------------------------------------------

// LD_UB - load zero extended byte

op ld_ub_a(0b000[3]:rp[4]:0b10011[5]:rd[4])

op ld_ub_b(0b000[3]:rp[4]:0b10111[5]:rd[4])

op ld_ub_c(0b000[3]:rp[4]:0b11[2]:disp3[3]:rd[4])

op ld_ub_d(0b111[3]:rp[4]:0b10011[5]:rd[4]:><:dips16[16])

op ld_ub_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0111[4]:0b00[2]:sa[2]:rd[4])

//conditionally load zero extended byte

op ld_ub_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b100[3]:disp9[9])

//load sign-extended byte
//f1
op ld_sb_a(0b111[3]:rp[4]:0b10010[5]:rd[4]:><:disp16[16])
//f2
op ld_sb_b(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0110[4]:0b00[2]:sa[2]:rd[4])

//conditionally load sign-extended byte

op ld_sb_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b011[3]:disp9[9])

//load zero extended half word

op ld_uh_a(0b000[3]:rp[4]:0b10010[5]:rd[4])

op ld_uh_b(0b000[3]:rp[4]:0b10110[5]:rd[4])

op ld_uh_c(0b100[3]:rp[4]:0b01[2]:disp3[3]:rd[4])

op ld_uh_d(0b111[3]:rp[4]:0b10001[5]:rd[4]:><:disp16[16])

op ld_uh_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0101[4]:0b00[2]:sa[2]:rd[4])


//conditionally load zero extended halfword

op ld_uh_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b010[3]:disp9[9])

//load sign extended halfword

op ld_sh_a(0b000[3]:rp[4]:0b10001[5]:rd[4])

op ld_sh_b(0b000[3]:rp[4]:0b10101[5]:rd[4])

op ld_sh_c(0b100[3]:rp[4]:0b00[2]:disp3[3]:rd[4])

op ld_sh_d(0b111[3]:rp[4]:0b10000[5]:rd[4]:><:disp16[16])

op ld_sh_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0100[4]:0b00[2]:sa[2]:rd[4])

//conditionally load extended halword

op ld_sh_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b001[3]:disp9[9])

//load word

op ld_w_a(0b000[3]:rp[4]:0b10000[5]:rd[4])

op ld_w_b(0b000[3]:rp[4]:0b10100[5]:rd[4])

op ld_w_c(0b011[3]:rp[4]:disp5[5]:rd[4])

op ld_w_d(0b111[3]:rp[4]:0b01111[5]:rd[4]:><:disp16[16])

op ld_w_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0011[4]:0b00[2]:sa[2]:rd[4])

op ld_w_f(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b111110[6]:x[1]:y[1]:rd[4])



//conditionally load word

op ld_w_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b000[3]:disp9[9])

//load doubleword

op ld_d_a(0b101[3]:rp[4]:0b100[3]:0b00[2]:rd[3]:0b1[1])

op ld_d_b(0b101[3]:rp[4]:0b100[3]:0b01[2]:rd[3]:0b0[1])

op ld_d_c(0b101[3]:rp[4]:0b100[3]:0b00[2]:rd[3]:0b0[1])

op ld_d_d(0b111[3]:rp[4]:0b01110[5]:rd[3]:0b0[1]:><:disp16[16])

op ld_d_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0010[4]:0b00[2]:sa[2]:rd[4])

//load and insert byte or halfword into register

op ldins_b(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b01[2]:part[2]:disp12[12])

op ldins_h(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b000[3]:part[1]:disp12[12])

//load and swap

op ldsw_sh(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b0010[4]:disp12[12])

op ldswp_uh(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b0011[4]:disp12[12])

op ldswp_w(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b1000[4]:disp12[12])

//load pc relative with displacement

op lddpc(0b010[3]:0b01[2]:disp7[7]:rd[4])

//load sp relative with displacement

op lddsp(0b010[3]:0b00[2]:disp7[7]:rd[4])

// store byte

op st_b_a(0b000[3]:rp[4]:0b01100[5]:rs[4])

op st_b_b(0b000[3]:rp[4]:0b01111[5]:rs[4])

op st_b_c(0b101[3]:rp[4]:0b01[2]:disp3[3]:rs[4])

op st_b_d(0b111[3]:rp[4]:0b10110[5]:rs[4]:disp16[16])

op st_b_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b1011[4]:0b00[2]:sa[2]:rs[4])


//conditional store byte

op st_b_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b111[3]:disp9[9])

//store doubleword

op st_d_a(0b101[3]:rp[4]:0b100[3]:0b10[2]:rs[3]:0b0[1])

op st_d_b(0b101[3]:rp[4]:0b100[3]:0b10[2]:rs[3]:0b1[1])

op st_d_c(0b101[3]:rp[4]:0b100[3]:0b01[2]:rs[3]:0b1[1])

op st_d_d(0b111[3]:rp[4]:0b01110[5]:rs[3]:0b1[1]:><:disp16[16])

op st_d_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b1000[4]:0b00[2]:sa[2]:rs[4])

//store halfword

op st_h_a(0b000[3]:rp[4]:0b01011[5]:rs[4])

op st_h_b(0b000[3]:rp[4]:0b01110[5]:rs[4])

op st_h_c(0b101[3]:rp[4]:0b00[2]:disp3[3]:rs[4])

op st_h_d(0b111[3]:rp[4]:0b10101[5]:rs[4]:><:disp16[16])

op st_h_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b1010[4]:0b00[2]:sa[2]:rs[4])

// conditionally store halfword

op st_h_cond4(0b111[3]:rp[4]:0b11111[5]:rs[4]:><:cond4[4]:0b110[3]:disp9[9])

//store word conditionally

op stcond(0b111[3]:rp[4]:0b10111[5]:rs[4]:><:disp16[16])

//store stack pointer relative

op stdsp(0b010[3]:0b10[2]:disp7[7]:rs[4])

//store halfword into word

op sthh_w_a(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b11[2]:x[1]:y[1]:disp8[8]:rp[4])

op sthh_w_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b10[2]:x[1]:y[1]:ri[4]:0b00[2]:sa[2]:rb[4])

// swap and store

op stswp_h(0b111[3]:rp[4]:0b11101[5]:rs[4]:><:0b1001[4]:disp12[12])

op stswp_w(0b111[3]:rp[4]:0b11101[5]:rs[4]:><:0b1010[4]:disp12[12])


//---------------------------------------------------------------------------------------

//                                 MAC INSTRUCTIONS

//-----------------------------------------------------------------------------------------

// MAC - multiply accumulate

op mac(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00110100[8]:rd[4])

mac.disasm={

	os << "mac " << rd << "," << rx << "," << ry << endl;
}

// MACHH_D - multiply halfwords and accumulate in doubleword

op machh_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0101[4]:0b10[2]:x[1]:y[1]:rd[4])

machh_d.disasm={

	os << "machh_d " << rd << "," << rx << ":<" << part << ">," << ry <<":<" << part << ">" << endl;
}

// MACHH_W - multiply halfwords and accumulate in word

op machh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0100[4]:0b10[2]:x[1]:y[1]:rd[4])

machh_w.disasm={

	os << "machh_w " << rd << "," << rx << ":<" << part << ">," << ry <<":<" << part << ">" << endl;
}


//MACWH_D - multiply word with halfword and accumulate in doubleword

op macwh_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1100[4]:0b100[3]:y[1]:rd[4])

macwh_d.disasm={

	os << "macwh_d " << rd << "," << rx << "," << ry <<":<" << part << ">" << endl;
}


//multiply accumulate halfwords with saturation into word

op macsathh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0110[4]:0b10[2]:x[1]:y[1]:rd[4])

macsathh_w.disasm={

	os << "macsathh_w " << rd << "," << rx << ":<" << part << ">," << ry <<":<" << part << ">" << endl;
}


//multiply accumulate signed

op macs_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b01010100[8]:rd[4])

macs_d.disasm={

	os << "macs_d " << rd << "," << rx << "," << ry << endl;
}


//multiply accumulate unsigned

op macu_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b01110100[8]:rd[4])

macu_d.disasm={

	os << "macu_d " << rd << "," << rx << "," << ry << endl;
}


//multiply signed

op muls_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b01000100[8]:rd[4])

muls_d.disasm={

	os << "muls_d " << rd << "," << rx << "," << ry << endl;
}


//multiply unsigned

op mulu_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b01100100[8]:rd[4]) // verfier pour rd si pas erreur dans le manuel

mulu_d.disasm={

	os << "mulu_d " << rd << "," << rx << "," << ry << endl;
}


 
//-----------------------------------------------------------------------------------------

//                                 SATURATE INSTRUCTIONS

//--------------------------------------------------------------------------------------------

//SATADD_H - saturated add of halfwords

op satadd_h(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00101100[8]:rd[4])

satadd_h.disasm={

	os << "satadd_h " << rd << "," << rx << "," << ry << endl;
}

//SATADD_W - saturated add of words

op satadd_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00001100[8]:rd[4])

satadd_w.disasm={

	os << "satadd_w " << rd << "," << rx << "," << ry << endl;
}

//SATSUB_H - saturate subtract of halfwords

op satsub_h(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00111100[8]:rd[4])

satsub_h.disasm={

	os << "satsub_h " << rd << "," << rx << "," << ry << endl;
}

//SATSUB_W_A saturate subtract of words

op satsub_w_a(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00011100[8]:rd[4])

satsub_w_a.disasm={

	os << "satsub_w_a " << rd << "," << rx << "," << ry << endl;
}

//SATSUB_W_B

op satsub_w_b(0b111[3]:rs[4]:0b01101[5]:rd[4]:><:imm16[16])

satsub_w_b.disasm={

	os << "satsub_w_b " << rd << "," << rs << "," << imm16 << endl;
}

//SATRNDS - saturate with rounding signed

op satrnds(0b111[3]:0b1001[4]:0b11011[5]:rd[4]:><:0b0000[4]:0b00[2]:bp5[5]:sa5[5])

satrnds.disasm={
	os << "satrnds " << rd  << ">>" << sa5 << "," << bp5 << endl; 
}

//SATRNDU - saturate with rounding unsigned

op satrndu(0b111[3]:0b1001[4]:0b11011[5]:rd[4]:><:0b0000[4]:0b01[2]:bp5[5]:sa5[5])

satrndu.disasm={
	os << "satrndu " << rd << ">>" << sa5 << "," << bp5 << endl; 
}


//SATS - saturate signed

op sats(0b111[3]:0b1000[4]:0b11011[5]:rd[4]:><:0b0000[4]:0b00[2]:bp5[5]:sa5[5])

sats.disasm={
	os << "sats " << rd << ">>" << sa5 << "," << bp5 << endl; 
}


//SATU - saturate unsigned

op satu(0b111[3]:0b1000[4]:0b11011[5]:rd[4]:><:0b0000[4]:0b01[2]:bp5[5]:sa5[5])

satu.disasm={

	os << "satu " << rd << ">>" << sa5 << "," << bp5 << endl; 
}


//---------------------------------------------------------------------------------------

//                 Multiple data memory  access instructions

//---------------------------------------------------------------------------------------

//LDM - load multiple register

//op ldm(0b111[3]:0b000[3]:++[1]:0b11100[5]:rp[4]:><:reglist16[16])


//LDMTS load multiple registers for atsk switch

//op ldmts(0b111[3]:0b001[3]:++[1]:0b11100[5]:rp[4]:><:reglist16[16]) 

//----------------------------------------------------------------------------------------

//                 SYSTEM REGISTER INSTRUCTIONS

//----------------------------------------------------------------------------------------


// MFDR - move from debug register

op mfdr(0b111001011011[12]:rd[4]:><:0b00000000[8]: debugRegisterAdress[8])

mfdr.disasm={

	os << "mfdr " << rd << "," << debugRegisterNo << endl; 
}

// MFSR - move from system register

op mfsr(0b111000011011[12]:rd[4]:><:0b00000000[8]: systemRegisterAdress[8])

mfsr.disasm={

	os << "mfsr " << rd << "," << systemRegisterAdress << endl; 
}

// MTDR - move to debug register

op mtdr(0b111001111011[12]:rs[4]:><:0b00000000[8]: debugRegisterAdress[8])

mtdr.disasm={

	os << "mtdr " << debugRegisterAdress << "," << rs << endl;
}

// MTSR - move to system register

op mtsr(0b111000111011[12]:rs[4]:><:0b00000000[8]: systemRegisterAdress[8])

mtsr.disasm={

	os << "mtsr " << systemRegisterAdress << "," << rs << endl;
}
   
// MUSFR - copy register to status register

op musfr(0b010[3]:0b1110[4]:0b10011[5]:rs[4])

musfr.disasm={

	os << "musfr " << rs << endl;
}

//MUSTR - copy status register to register

op mustr(0b010[3]:0b1110[4]:0b10010[5]:rd[4])

mustr.disasm={

	os << "mustr " << rd << endl;
}

//----------------------------------------------------------------------------------------

//                            SYSTEM CONTROL INSTRUCTIONS

//----------------------------------------------------------------------------------------

// FRS - flush return stack

op frs(0b1101011[7]:0b10100[5]:0b0011[4])

frs.disasm={

	os << "frs " << endl;
}

// PREF - cache prefetch

op pref(0b111[3]:0b100100001[9]:rp[4]:><:disp16[16])

pref.disasm={

	os << "pref " << rp << "[" << disp16 << "]" << endl;
}
 
// SLEEP - set CPU activity mode

op sleep(0b111[3]: 0b0100[4]: 0b11011[5]:0b0000[4]:><:0b00000000[8]:op8[8])

sleep.disasm={

	os << "sleep " << op8 << endl;
}

// SYNC - synchronize memory

op sync(0b111[3]:0b0101[4]:0b11011[5]:0b0000[4]:><:0b00000000[8]:op8[8])

sync.disasm={

	os << "sync " << op8 << endl;
}

//------------------------------------------------------------------------------------------

//   read, modify, write instructions
 
//----------------------------------------------------------------------------------------

// MEMC - clear bit in memory

op memc(0b111101100001[12]:bp_4_1[4]:><: bp_0[1]:imm15[15])

memc.var bp: {uint8_t} ={(bp_4_1 << 1)| bp_0 } 

memc.disasm={

	os << "memc " << imm15 << "," << bp << endl;
}

// MEMS - set bit in memory

op mems(0b111110000001[12]:bp_4_1[4]:><: bp_0[1]:imm15[15])

mems.var bp: {uint8_t} ={(bp_4_1 << 1)| bp_0 } 

mems.disasm={

	os << "mems " << imm15 << "," << bp << endl;
}

// MEMT - toggle bit in memory

op memt(0b111110100001[12]:bp_4_1[4]:><: bp_0[1]:imm15[15])

memt.var bp: {uint8_t} ={(bp_4_1 << 1)| bp_0 } 

memt.disasm={

	os << "memt " << imm15 << "," << bp << endl;
}
     
//----------------------------------------------------------------------------------------

//                             BRANCH INSTRUCTIONS

//----------------------------------------------------------------------------------------


// BR_COND3 - branch if condition satisfied

op br_cond3(0b110[3]:0b0[1]:disp[8]:0b0[1]:cond3[3])

br_cond3.disasm={

	os << "br_cond3 " << disp << endl;
}

// BR_COND4

op br_cond4(0b111[3]:disp_20_17[4]:0b0100[4]:disp_16[1]:cond4[4]:><:disp_15_0[16])

br_cond4.var disp : {uint32_t}={(disp_20_17<<17)|(disp_16<<16)|disp_15_0}

br_cond4.disasm={

	os << "br_cond4 " << disp << endl;
}


// RJMP - relative jump

op rjmp(0b110[3]:0b0[1]:disp_7_0[8]:0b1[1]:0b0[1]:disp_9_8[2])

rjmp.var disp :{uint16_t}={(disp_9_8<<8)|disp_7_0}

rjmp.disasm={

	os << "rjmp " << pc << "[" << disp << "]" << endl;
}


// RET_COND4 - conditional return from subroutine

op ret_cond4(0b010[3]:0b1111[4]:0b0[1]:cond4[4]:rs[4])

ret_cond4.disasm={

	os << "ret_cond4 " << rs << endl;
}

//------------------------------------------------------------------------------------------

//                             CALL INSTRUCTIONS

//------------------------------------------------------------------------------------------

//ACALL - application call

op acall(0b1101[4]:disp8[8]:0b000[3]:0b0[1])

acall.disasm={

	os << "acall " << disp8 << endl;
}

// ICALL - indirect call from subroutine

op icall(0b010[3]:0b1110[4]:0b10001[5]:rd[4])

icall.disasm={

	os << "icall " << rd << endl;
}

//MCALL - subroutine call

op mcall(0b111[3]:0b100000001[9]:rp[4]:><:disp16[16])

mcall.disasm={

	os << "mcall " << rp << "[" << disp16 << "]" << endl;
}

//SCALL - supervisor call

op scall(0b1101011[7]:0b10011[5]:0b0011[4])

scall.disasm={

	os << "scall "<< endl;
}

//SSCALL - secure state call

op sscall(0b1101011[7]:0b10101[5]:0b0011[4])

sscall.disasm={

	os << "sscall "<< endl;
}

//BREAKPOINT - software debug breakpoint

op breakpoint(0b1101011[7]:0b00111[5]:0b0011[4])

breakpoint.disasm={

	os << "breakpoint "<< endl;
}



//---------------------------------------------------------------------------------------------

//               return from execution mode instructions

//---------------------------------------------------------------------------------------------

//RETD - return from debug mode

op retd(0b1101011[7]:0b00010[5]:0b0011[4])

retd.disasm={

	os << "retd "<< endl;
}

//RETE - return from event handler

op rete(0b1101011[7]:0b00000[5]:0b0011[4])

rete.disasm={

	os << "rete "<< endl;
}

//RETS - return from supervisor call

op rets(0b1101011[7]:0b00001[5]:0b0011[4])

rets.disasm={

	os << "rets "<< endl;
}

//RETSS - return from secure state

op retss(0b1101011[7]:0b10110[5]:0b0011[4])

retss.disasm={

	os << "retss "<< endl;
}

// XCHG -Exchange register and memory

op xchg(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b10110100[8]:rd[4])

xchg.disasm={

	os << "xchg " << rd << "," << rx << "," << ry << endl;
}
