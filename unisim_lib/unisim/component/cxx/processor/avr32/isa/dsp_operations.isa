//----------------------------------------------------------------------------------------------------

//                                           DSP - OPERATIONS

//----------------------------------------------------------------------------------------------------

// ADDHH_W - add halfwords into word                         

op addhh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1110[4]:0b00[2]:x[1]:y[1]:rd[4])

// X=t=0 high part ; X=b=1 low part
// Y=t=0 high part ; Y=b=1 low part

addhh_w.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);
	uint32_t op1,op2;
	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16):  // select halfword of rx
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):  // select halfword of ry
	SignExtend(y & 0x0000FFFF,16);
	uint32_t result;
 
	uint8_t overflow;
	uint8_t sign;
	uint8_t carry_in=0;                                    
	uint8_t carry_out;
	
	SignedAdd32(result,carry_out, overflow,sign,op1,op2,carry_in); // add in word 

	cpu->SetSR_V(overflow);
	cpu->SetSR_N(sign);
	cpu->SetSR_Z(result==0);
	cpu->SetSR_C(carry_out);

	
	cpu->SetGPR(rd,result);

	return true;
}
addhh_w.disasm={

	os << "addhh.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] << ">," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}


// MACHH_D - multiply halfwords and accumulate in doubleword

op machh_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0101[4]:0b10[2]:x[1]:y[1]:rd[4])

// X=t=0 high part ; X=b=1 low part
// Y=t=0 high part ; Y=b=1 low part

machh_d.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);
	uint32_t d=cpu->GetGPR(rd);
	uint32_t d1=cpu->GetGPR(rd+1);
	uint64_t op1,op2;
	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16):  // select halfword of rx
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):  // select halfword of ry
	SignExtend(y & 0x0000FFFF,16);
	uint64_t result;

	uint64_t acc = ((uint64_t)d1 << 32) | ((uint64_t)(d & 0xFFFF0000));
	result = (((op1 * op2) & 0x00000000FFFFFFFF) + acc)<<16;

	cpu->SetGPR(rd,(uint32_t)(result & 0x00000000FFFFFFFF));          // write back result in 2 registers
	cpu->SetGPR(rd+1,(uint32_t)((result & 0xFFFFFFFF00000000)>>32));
 
	return true;
}

machh_d.disasm={

	os << "machh.d\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] << ">," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}

// MACHH_W - multiply halfwords and accumulate in word

op machh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0100[4]:0b10[2]:x[1]:y[1]:rd[4])

// x=t=0 high part ; x=b=1 low part
// y=t=0 high part ; y=b=1 low part

machh_w.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);
	uint32_t d=cpu->GetGPR(rd);
	uint32_t op1,op2;

	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16):  // select halfword of rx 
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0)? SignExtend((y & 0xFFFF0000)>>16,16):  // select halfword of ry
	SignExtend(y & 0x0000FFFF,16);
	
	uint32_t result = (op1 * op2) + d;

	cpu->SetGPR(rd,result);
 
	return true;
}

machh_w.disasm={

	os << "machh.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] << ">," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}


//MACWH_D - multiply word with halfword and accumulate in doubleword

op macwh_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1100[4]:0b100[3]:y[1]:rd[4])

// y=t=0 high part ; y=b=1 low part

macwh_d.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);
	uint32_t d=cpu->GetGPR(rd);
	uint32_t d1=cpu->GetGPR(rd+1);
	uint64_t op1,op2;
	op1=SignExtend((uint64_t)x,32);                                   // ?? sign extend x ?
	op2= (y==0) ? SignExtend((uint64_t)((y & 0xFFFF0000)>>16),16):   // select halfword of ry
	SignExtend((uint64_t)(y & 0x0000FFFF),16);
	uint64_t result;
	uint64_t acc = ((uint64_t)d1 << 32) | (d & 0xFFFF0000);
	result = (((op1 * op2) & 0x0000000000FFFFFF) + acc)<<16;

	cpu->SetGPR(rd, (uint32_t)(result & 0x00000000FFFFFFFF));
	cpu->SetGPR(rd+1,(uint32_t)((result & 0xFFFFFFFF00000000)>>32));
 
	return true;
}

macwh_d.disasm={
	os << "macwh.d\t" << REG_NAME[rd] << "," << REG_NAME[rx] << "," << REG_NAME[ry] << ":<" << HALF_WORD_PART_NAME[y] << ">";
}

//MULHH_W - multiply halfword with halfword

op mulhh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b00000111[8]:0b10[2]:x[1]:y[1]:rd[4])

mulhh_w.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);
	uint32_t op1,op2;
	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16):  // select halfword of rx 
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):  // select halfword of ry 
	SignExtend(y & 0x0000FFFF,16);
	
	uint32_t result = (op1 * op2);

	cpu->SetGPR(rd,result);
 
	return true;
}

mulhh_w.disasm={

	os << "mulhh.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] <<">," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}

// MULWH_D - multiply word with halfword

//Since the most significant part of the product is stored, no overflow will occur ??

op mulwh_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1101[4]:0b100[3]:y[1]:rd[4])

mulwh_d.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);

	uint64_t op1,op2;
	op1=SignExtend((uint64_t)x,32);                                     // ?? sign extend x ?                     
	op2= (y==0) ? SignExtend((uint64_t)((y & 0xFFFF0000)>>16),16):      // select halfword of ry
	SignExtend((uint64_t)(y & 0x0000FFFF),16);
	
	uint64_t result = (op1 * op2) << 16;

	cpu->SetGPR(rd,(uint32_t)(result & 0x00000000FFFFFFFF));
	cpu->SetGPR( rd+1,(uint32_t)((result & 0xFFFFFFFF00000000)>>32) );
 
	return true;
}
mulwh_d.disasm={

	os << "mulwh.d\t" << REG_NAME[rd] << "," << REG_NAME[rx] << "," << REG_NAME[ry] << ":<" << HALF_WORD_PART_NAME[y] << ">";
}

// MULNHH_W - multiply halword with negative halfword

op mulnhh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b00000001[8]:0b10[2]:x[1]:y[1]:rd[4])

mulnhh_w.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);
	uint32_t op1,op2;
	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16): // select halfword of rx 
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16): // select halfword of ry
	SignExtend(y & 0x0000FFFF,16);
	
	uint32_t result = -(op1 * op2);

	cpu->SetGPR(rd,result);
 
	return true;
}
mulnhh_w.disasm={

	os << "mulnhh.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] <<">," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}

//MULNWH_D - multiply word with negative halfword

//Since the most significant part of the product is stored, no overflow will occur ??

op mulnwh_d(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0010[4]:0b100[3]:y[1]:rd[4])

mulnwh_d.execute={
	
	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);

	uint64_t op1,op2;
	op1=SignExtend((uint64_t)x,32);		   			 // ?? sign extend x ? 
	op2= (y==0) ? SignExtend((uint64_t)((y & 0xFFFF0000)>>16),16):   // select halfword of ry
	SignExtend((uint64_t)(y & 0x0000FFFF),16);
	
	uint64_t result = (-(op1 * op2)) << 16;

	cpu->SetGPR(rd,(uint32_t)(result & 0x00000000FFFFFFFF));
	cpu->SetGPR(rd+1,(uint32_t)((result & 0xFFFFFFFF00000000)>>32));
 
	return true;
}

mulnwh_d.disasm={

	os << "mulnwh.d\t" << REG_NAME[rd] << "," << REG_NAME[rx] << "," << REG_NAME[ry] << ":<" << HALF_WORD_PART_NAME[y] << ">";
}


//SATADD_H - saturated add of halfwords

op satadd_h(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00101100[8]:rd[4])

satadd_h.execute={
	
	uint16_t x = (uint16_t)(cpu->GetGPR(rx) & 0x0000FFFF);
	uint16_t y = (uint16_t)(cpu->GetGPR(ry) & 0x0000FFFF);
	uint32_t d = cpu->GetGPR(rd); 
	uint16_t temp;
	
	uint8_t q ;
	uint8_t carry_in=0;   // without carry
	uint8_t carry_out;
	uint8_t overflow;
	uint8_t sign;

	SignedSatAdd16(temp, carry_out, overflow, sign, x , y , carry_in);
	
	uint8_t x15= (x >> 15) & 1;
	uint8_t y15= (y >> 15) & 1;
	uint8_t t15= (temp >> 15) & 1;
	q  = (x15 && y15 && !t15) || (!x15 && !y15 && t15) || cpu->GetSR_Q();
	uint32_t result;
	/*if( ((x15 && y15 && !t15) || (!x15 && !y15 && t15))==1 )
	{
		if(x15 == 0) result = 0x00007FFF;
		else result = 0xFFFF8000;
	}
	else result = SignExtend((uint32_t)temp,16);*/
	result = SignExtend((uint32_t)temp,16);

	cpu->SetGPR(rd,result);

	cpu->SetSR_Q(q);
	cpu->SetSR_V(overflow);
	cpu->SetSR_N(d < 0);           // rd avant ou après le calcul ??
	cpu->SetSR_Z(d==0);
	cpu->SetSR_C(0);

	return true;
}

satadd_h.disasm={

	os << "satadd.h\t" << REG_NAME[rd] << "," << REG_NAME[rx] << "," << REG_NAME[ry];
}

//SATADD_W - saturated add of words                  ?? sign add without carry

op satadd_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00001100[8]:rd[4])

satadd_w.execute={

	uint32_t x = cpu->GetGPR(rx);
	uint32_t y = cpu->GetGPR(ry);
	uint32_t d = cpu->GetGPR(rd);  
	uint32_t temp;
	uint32_t result;
	uint8_t q ;
	
	uint8_t carry_in=0;
	uint8_t carry_out;
	uint8_t overflow;
	uint8_t sign;

	//SignedAdd32(temp, carry_out, overflow, sign, x,y, carry_in);
	SignedSatAdd32(result, carry_out, overflow, sign, x,y, carry_in);
	temp=result;
	uint8_t x31= (x >> 31) & 1;
	uint8_t y31= (y >> 31) & 1;
	uint8_t t31= (temp >> 31) & 1;
	q  = (x31 && y31 && !t31) || (!x31 && !y31 && t31) || cpu->GetSR_Q();
	
	/*if( ((x31 && y31 && !t31) || (!x31 && !y31 && t31))==1 )
	{
		if( ( x31 == 0 ) result = 0x7FFFFFFF;
		else result = 0x80000000;
	}
	else result = temp;
        */
	result = temp;
	cpu->SetGPR(rd,result);

	cpu->SetSR_Q(q);
	cpu->SetSR_V(overflow);
	cpu->SetSR_N(d < 0);                           // rd avant ou après le calcul ??
	cpu->SetSR_Z(d==0);
	cpu->SetSR_C(0);

	return true;
}

satadd_w.disasm={

	os << "satadd.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << "," << REG_NAME[ry];
}

//SATSUB_H - saturate subtract of halfwords			

op satsub_h(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00111100[8]:rd[4])

satsub_h.execute={

	uint16_t x = (uint16_t)(cpu->GetGPR(rx) & 0x0000FFFF);
	uint16_t y = (uint16_t)(cpu->GetGPR(ry) & 0x0000FFFF); 
	uint32_t d = cpu->GetGPR(rd); 
	uint16_t temp;
	
	uint8_t q ;
	uint8_t borrow_in=0;
	uint8_t borrow_out;
	uint8_t overflow;
	uint8_t sign;

	//SignedSub16(temp, borrow_out, overflow, sign, x , y, borrow_in);
	SignedSatSub16(temp, borrow_out, overflow, sign, x , y, borrow_in);

	uint8_t x15= (x >> 15) & 1;
	uint8_t y15= (y >> 15) & 1;
	uint8_t t15= (temp >> 15) & 1;
	q  = (x15 && y15 && !t15) || (!x15 && !y15 && t15) || cpu->GetSR_Q();
	uint32_t result;
	/*if( ((x15 && y15 && !t15) || (!x15 && !y15 && t15))==1 )
	{
		if( x15 == 0 ) result = 0x7FFF;
		else result = 0x8000;
	}
	else result = SignExtend(((uint32_t)temp & 0x0000FFFF),16);*/
	result = SignExtend(((uint32_t)temp & 0x0000FFFF),16);

	cpu->SetGPR(rd,result);

	cpu->SetSR_Q(q);
	cpu->SetSR_V(overflow);
	cpu->SetSR_N(d < 0);		// rd avant ou après le calcul ??
	cpu->SetSR_Z(d==0);
	cpu->SetSR_C(0);

	return true;


}

satsub_h.disasm={

	os << "satsub.h\t" << REG_NAME[rd] << "," << REG_NAME[rx] << "," << REG_NAME[ry];
}

//SATSUB_W_A saturate subtract of words                      

op satsub_w_a(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00011100[8]:rd[4])

satsub_w_a.execute={

	uint32_t x = cpu->GetGPR(rx);
	uint32_t y = cpu->GetGPR(ry); 
	uint32_t d = cpu->GetGPR(rd); 
	uint32_t temp;
	
	uint8_t q ;
	uint8_t borrow_in=0;                 // without borrow
	uint8_t borrow_out;
	uint8_t overflow;
	uint8_t sign;

	//SignedSub32(temp, borrow_out, overflow, sign, x,y, borrow_in);
	SignedSatSub32(temp, borrow_out, overflow, sign, x,y, borrow_in);
	
	uint8_t x31= (x >> 31) & 1;
	uint8_t y31= (y >> 31) & 1;
	uint8_t t31= (temp >> 31) & 1;
	q  = (x31 && y31 && !t31) || (!x31 && !y31 && t31) || cpu->GetSR_Q();
	uint32_t result;
	/*if( ((x31 && y31 && !t31) || (!x31 && !y31 && t31))==1 )
	{
		if( x31 == 0 ) result = 0x7FFFFFFF;
		else result = 0x80000000;
	}
	else result = temp;
	*/
	result = temp;

	cpu->SetGPR(rd,result);

	cpu->SetSR_Q(q);
	cpu->SetSR_V(overflow);
	cpu->SetSR_N(d < 0);			// rd avant ou après le calcul ??
	cpu->SetSR_Z(d==0);
	cpu->SetSR_C(0);

	return true;
}

satsub_w_a.disasm={

	os << "satsub.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << "," << REG_NAME[ry];
}

//SATSUB_W_B                                  

op satsub_w_b(0b111[3]:rs[4]:0b01101[5]:rd[4]:><:imm16[16])

satsub_w_b.execute={

	uint32_t op1 = cpu->GetGPR(rs);
	uint32_t op2 = SignExtend((uint32_t)imm16,16); 
	uint32_t temp;
	
	uint8_t q;
	uint8_t borrow_in=0;
	uint8_t borrow_out;
	uint8_t overflow;
	uint8_t sign;

	//SignedSub32(temp, borrow_out, overflow, sign, op1,op2, borrow_in);
	SignedSatSub32(temp, borrow_out, overflow, sign, op1,op2, borrow_in);
	uint8_t op1_31= (op1 >> 31) & 1;
	uint8_t op2_31= (op2 >> 31) & 1;
	uint8_t t31= (temp >> 31) & 1;
	q  = (op1_31 && op2_31 && !t31) || (!op1_31 && !op2_31 && t31) || cpu->GetSR_Q();
	uint32_t result;
	/*if( ((op1_31 && op2_31 && !t31) || (!op1_31 && !op2_31 && t31))==1 )
	{
		if( op1_31 == 0 ) result = 0x7FFFFFFF;
		else result = 0x80000000;
	}
	else result = temp;*/
	result=temp;
	cpu->SetGPR(rd,result);

	cpu->SetSR_Q(q);
	cpu->SetSR_V(overflow); 
	cpu->SetSR_N(sign);                       // rd avant ou après le calcul ??
	cpu->SetSR_Z(temp==0);
	cpu->SetSR_C(0);

	return true;
}

satsub_w_b.disasm={

	os << "satsub.w\t" << REG_NAME[rd] << "," << REG_NAME[rs] << ",0x" << std::hex <<(int)imm16;
}

//SATRNDS - saturate with rounding signed

op satrnds(0b111[3]:0b1001[4]:0b11011[5]:rd[4]:><:0b0000[4]:0b00[2]:bp5[5]:sa5[5])

satrnds.execute={
	
	uint32_t d = cpu->GetGPR(rd);
	uint32_t temp = ShiftArithmeticRight(d,(unsigned int)sa5);                // arithmetic shift
	uint32_t result;
	uint8_t q = cpu->GetSR_Q();                                // if Q=1 sat flag is set cleared otherwise
	if(sa5 != 0)
	{
		uint8_t rnd= (rd >> (sa5-1)) & 1;
		temp= temp + rnd;
	}
	uint32_t mask = (1UL << bp5)-1; 
	if( (temp == SignExtend((uint32_t)(temp & mask),(unsigned int)bp5)) || (bp5 == 0))
	{
		result = temp;
	}
	else                                                       // saturation occurs
	{
		q=1;						   // sat flag is set
		if( ((temp >> 31)&1) == 1 ) result = - (uint32_t)pow(2,(int)bp5-1); // min signed value with bp5 bits
		else result = (uint32_t)pow(2,(int)bp5-1)-1;                        // max signed value
	}

	cpu->SetGPR(rd,result);                                    // write back result
	cpu->SetSR_Q(q);						   // set saturation flag

	return true;
}

satrnds.disasm={
	os << "satrnds\t" << REG_NAME[rd]  << ">>0x" << std::hex << (int)sa5 << ",0x" <<  (int) bp5; 
}

//SATRNDU - saturate with rounding unsigned

op satrndu(0b111[3]:0b1001[4]:0b11011[5]:rd[4]:><:0b0000[4]:0b01[2]:bp5[5]:sa5[5])

satrndu.execute={
	
	uint32_t d = cpu->GetGPR(rd);
	uint32_t temp = ShiftArithmeticRight(d,(unsigned int)sa5);           // arithmetic shift
	uint32_t result;
	uint8_t q= cpu->GetSR_Q();                            // if Q=1 sat flag is set cleared otherwise
	if(sa5 != 0)
	{
		uint32_t rnd= (rd >> (sa5-1)) & 1;
		temp= temp + rnd;
	}
	uint32_t mask = (1UL << bp5)-1 ;
	if( (temp == (uint32_t)(temp & mask)) || (bp5 == 0) )
	{
		result = temp;
	}
	else							// saturation occurs
	{
		q=1;						// Q flag is set
		if( ((temp >> 31)&1) == 1 ) result = 0x00000000; 
		else result = (uint32_t)pow(2,(int)bp5)-1;       // max unsigned value with bp5 bits     
	}

	cpu->SetGPR(rd,result);                        //write back result
	cpu->SetSR_Q(q);			      // set saturation flag

	return true;
}

satrndu.disasm={
	os << "satrndu\t" << REG_NAME[rd] << ">>0x" << (int) sa5 << ",0x" << (int) bp5; 
}


//SATS - saturate signed

op sats(0b111[3]:0b1000[4]:0b11011[5]:rd[4]:><:0b0000[4]:0b00[2]:bp5[5]:sa5[5])

sats.execute={

	uint32_t d = cpu->GetGPR(rd);
	uint32_t temp = ShiftArithmeticRight(d,(unsigned int)sa5);                // arithmetic shift
	uint32_t result;
	uint8_t q = cpu->GetSR_Q();                                              // get last saturation flag
	
	uint32_t mask = (1UL << bp5)-1 ;
	if( (temp == SignExtend((uint32_t)(temp & mask),(unsigned int)bp5)) || (bp5 == 0) )
	{
		result = temp;
	}
	else						// saturation occurs
	{
		q=1;					// Q flag is set
		result = ( ((temp >> 31)&1) == 1 ) ? -(uint32_t)pow(2,(int)bp5-1): // max signed value with bp5 bits
			(uint32_t)pow(2,(int)bp5-1)-1;                             // min signed value with bp5 bits
	}

	cpu->SetGPR(rd,result);                            //write back result
	cpu->SetSR_Q(q);                                   // set saturation flag

	return true;
}

sats.disasm={
	os << "sats\t" << REG_NAME[rd] << ">>0x" <<std::hex<< (int)sa5 << ",0x" << (int) bp5; 
}


//SATU - saturate unsigned

op satu(0b111[3]:0b1000[4]:0b11011[5]:rd[4]:><:0b0000[4]:0b01[2]:bp5[5]:sa5[5])

satu.execute={
	
	uint32_t d = cpu->GetGPR(rd);
	int32_t temp = ShiftArithmeticRight(d,(unsigned int)sa5);
	uint32_t result;
	uint8_t q=cpu->GetSR_Q();                // get last saturation flag
	
	uint32_t mask = (1UL << bp5)-1 ;
	if( (temp == (uint32_t)(temp & mask)) || (bp5 == 0) )
	{
		result = temp;
	}
	else					// saturation occurs
	{
		q = 1;
		result = ( ((temp >> 31)&1) == 1 ) ? 0x00000000: (uint32_t)pow(2,(int)bp5)-1;     
	}

	cpu->SetGPR(rd,result);			//write back result in rd
	cpu->SetSR_Q(q);			// set Q flag

	return true;
}

satu.disasm={

	os << "satu\t" << REG_NAME[rd] << ">>0x" << std::hex << (int)sa5 << ",0x"<< (int)bp5; 
}

//SUBHH_W - subtract halfwords into word

op subhh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b111100[6]:x[1]:y[1]:rd[4])

//X=0=t high part X=1=b low part
//Y=0=t high part Y=1=b low part

subhh_w.execute={

	uint32_t x=cpu->GetGPR(rx);			   // get values in registers
	uint32_t y=cpu->GetGPR(ry);
	uint32_t op1,op2;
	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16):  // select halfword of rx
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):  // select halfword of ry
	SignExtend(y & 0x0000FFFF,16);
	uint32_t result;
 
	uint8_t overflow;
	uint8_t sign;
	uint8_t borrow_in=0;                           // case without carry               
	uint8_t borrow_out;
	
	SignedSub32(result,borrow_out, overflow,sign,op1,op2,borrow_in);

	cpu->SetSR_V(overflow);                       // set flags
	cpu->SetSR_N(sign);
	cpu->SetSR_Z(result==0);
	cpu->SetSR_C(borrow_out);

	
	cpu->SetGPR(rd,result);                      // write back result

	return true;
}

subhh_w.disasm={

	os << "msubhh.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] << ">," << REG_NAME[ry] << ":<" << HALF_WORD_PART_NAME[y] << ">";
}


// MULSATHH_H - multiply halfword with saturation into halfword                       

op mulsathh_h(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1000[4]:0b10[2]:x[1]:y[1]:rd[4])

//X=0=t high part X=1=b low part
//Y=0=t high part Y=1=b low part

mulsathh_h.execute={

	uint32_t x=cpu->GetGPR(rx);				 // get values in registers
	uint32_t y=cpu->GetGPR(ry);
	uint32_t op1,op2;                                      // select halfword
	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16):
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):
	SignExtend(y & 0x0000FFFF,16);
	uint32_t result;
	uint8_t q=cpu->GetSR_Q();				// get last saturation flag

	if(((uint16_t)op1 == 0x8000) && ((uint16_t)op2 == 0x8000))   // op1=op2=-1
	{ 
		result = 0x7FFF;				    // saturation occured
		q=1;                                                // set Q flag
	}	
	else result = SignExtend(((op1 * op2) >> 15),16);
	
	cpu->SetGPR(rd,result);                                       
	cpu->SetSR_Q(q);                                             //write Q flag                                
	
	return true;
}

mulsathh_h.disasm={

	os << "mulsathh.h\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] << ">," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}


// MULSATHH_W - multiply halfword with saturation into word                         

op mulsathh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1001[4]:0b10[2]:x[1]:y[1]:rd[4])

//X=0=t high part X=1=b low part
//Y=0=t high part Y=1=b low part

mulsathh_w.execute={

	uint32_t x=cpu->GetGPR(rx);			    // get values in registers
	uint32_t y=cpu->GetGPR(ry);
	uint32_t op1,op2;
	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16):  // select halword into word
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):
	SignExtend(y & 0x0000FFFF,16);
	uint32_t result;
	uint8_t q = cpu->GetSR_Q();			      // get last saturation flag

	if(((uint16_t)op1 == 0x8000) && ((uint16_t)op2 == 0x8000)) // if op1=op2=-1
	{
		result = 0x7FFFFFFF;    // largest positive 32-bit fractional number
		q=1;
	}	
	else result = (op1 * op2) << 1;
	
	cpu->SetGPR(rd,result);          // write back result
	cpu->SetSR_Q(q);                 // write saturation flag
	
	return true;
}

mulsathh_w.disasm={

	os << "mulsathh.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] << ">," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}


// MULSATRNDHH_H - multiply halfwords with saturation and rounding into halfword

op mulsatrndhh_h(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1010[4]:0b10[2]:x[1]:y[1]:rd[4])

//X=0=t high part X=1=b low part
//Y=0=t high part Y=1=b low part

mulsatrndhh_h.execute={

	uint32_t x=cpu->GetGPR(rx);                               // get values in registers
	uint32_t y=cpu->GetGPR(ry);
	uint32_t op1,op2;
	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16):        // select halfword
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):
	SignExtend(y & 0x0000FFFF,16);
	uint32_t result;
	uint8_t q= cpu->GetSR_Q();                                  // get last saturation flag

	if(((uint16_t)op1 == 0x8000) && ((uint16_t)op2 == 0x8000)) // if op1=op2=-1
	{
		result = 0x7FFF;				// saturation occurs
		q=1;
	}	
	else result = SignExtend(((op1 * op2) + 0x4000) >> 15,16);
	
	cpu->SetGPR(rd,result);   
	cpu->SetSR_Q(q);			 //write Q flag

	return true;
}

mulsatrndhh_h.disasm={

	os << "mulsatrndhh.h\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] << ">," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}


// MULSATRNDWH_W - multiply word and halfwords with saturation and rounding into word

op mulsatrndwh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1011[4]:0b100[3]:y[1]:rd[4])

//Y=0=t high part Y=1=b low part

mulsatrndwh_w.execute={

	uint32_t x=cpu->GetGPR(rx);			 // get values in registers
	uint32_t y=cpu->GetGPR(ry);
	uint32_t op1,op2;
	op1=x;                                
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):  // select halfword
	SignExtend(y & 0x0000FFFF,16);
	uint32_t result;
	uint8_t q=cpu->GetSR_Q();                       // get last saturation flag

	if((op1 == 0x80000000) && ((uint16_t)op2 == 0x8000)) // if op1=op2=-1
	{
		result = 0x7FFFFFFF;                          // saturation occurs
		q=1;
	}	
	else result = SignExtend(((op1 * op2) + 0x4000) >> 15,16);
	
	cpu->SetGPR(rd,result);   
	cpu->SetSR_Q(q);                          //write Q flag

	return true;

}

mulsatrndwh_w.disasm={

	os << "mulsatrndwh.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << "," << REG_NAME[ry] << ":<" << HALF_WORD_PART_NAME[y] << ">";
}


// MULSATWH_W - multiply word and halfword with saturation into word

op mulsatwh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b1110[4]:0b100[3]:y[1]:rd[4])

mulsatwh_w.execute={

	//Y=0=t high part Y=1=b low part

	uint32_t x=cpu->GetGPR(rx);                                // get value in registers
	uint32_t y=cpu->GetGPR(ry);
	uint32_t op1,op2;
	op1=x;
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):          // select halfword
	SignExtend(y & 0x0000FFFF,16);
	uint32_t result;
	uint8_t q=cpu->GetSR_Q();                                    // get last Q

	if( (op1 == 0x80000000) && (op2 == 0x80000000) )// if op1=op2=-1
	{
		result = 0x7FFFFFFF;
		q=1;
	}	
	else result = (op1 * op2)  >> 15;                       // arithmetic shift ??
	
	cpu->SetGPR(rd,result);      // write back result in rd
	cpu->SetSR_Q(q);             // write Q flag

	return true;
}

mulsatwh_w.disasm={

	os << "mulsatwh.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << "," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}



// MACSATHH_W - multiply accumulate halfwords with saturation into word    

op macsathh_w(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0110[4]:0b10[2]:x[1]:y[1]:rd[4])

//X=0=t high part X=1=b low part
//Y=0=t high part Y=1=b low part

macsathh_w.execute={

	uint32_t x=cpu->GetGPR(rx);                        //  get value in registers
	uint32_t y=cpu->GetGPR(ry);
	uint32_t d=cpu->GetGPR(rd);
	uint32_t op1,op2;
	op1= (x==0) ? SignExtend((x & 0xFFFF0000)>>16,16):   // select halfword
	SignExtend(x & 0x0000FFFF,16);
	op2= (y==0) ? SignExtend((y & 0xFFFF0000)>>16,16):
	SignExtend(y & 0x0000FFFF,16);
	uint32_t result,product;
	uint8_t q= cpu->GetSR_Q();                   // get last Q flag

	if(((uint16_t)op1 == 0x8000) && ((uint16_t)op2 == 0x8000)) //if op1=op2=-1
	{
		product = 0x7FFFFFFF;                // saturation occurs
		q=1;                                 // set Q
	}	
	else product = (op1 * op2) << 1;             //  arithmetic shift ??
	uint8_t sign,carry_out,overflow;
	uint8_t carry_in=0;
	SignedSatAdd32(result,carry_out,overflow,sign,product,d,carry_in);            
	if(overflow==1) q=1;                        // set if overflow on accumulate          à verifier ??	

	cpu->SetGPR(rd,result);                     // write back result
 	cpu->SetSR_Q(q);			    // write Q flag
	return true;
}

macsathh_w.disasm={

	os << "macsathh.w\t" << REG_NAME[rd] << "," << REG_NAME[rx] << ":<" << HALF_WORD_PART_NAME[x] << ">," << REG_NAME[ry] <<":<" << HALF_WORD_PART_NAME[y] << ">";
}


