// ABS - absolute value

op abs(0b010[3]:0b1110[4]:0b00100[5]:rd[4])


/*abs.execute={

	if(gpr[rd]!=0x80000000) gpr[rd]= abs(gpr[rd]);
	
}*/
abs.disasm={

	os<< "abs\tr" << (unsigned int) rd << endl ;
}


// ACR - add carry to register

op acr(0b010[3]:0b1110[4]:0b00000[5]:rd[4])

acr.disasm={

	os<< "acr\tr" << (unsigned int) rd << endl ;
}

// ADC - add with carry

op adc(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00000100[8]:rd[4])

adc.disasm={

	os<< "adc\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << endl ;
}

// ADD - add without carry

op add_a(0b000[3]:rs[4]:0b00000[5]:rd[4]) 

/*add_a.execute={

	gpr[rd]=gpr[rd]+gpr[rs];
}*/
add_a.disasm={

	os<< "add_a\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << endl ;

}

op add_b(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0000[4]:0b00[2]:sa[2]:rd[4])

/*add_b.execute={

	gpr[rd]=gpr[rx]+(gpr[ry] << sa);
}*/

add_b.disasm={

	os << "add_b\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << "<<0x" << std::hex << (unsigned int) sa << endl;
}

// ADD_COND4 - conditional add

op add_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0000[4]:rd[4])

/*add_cond4.execute={

	if(cond4) gpr[rd]=grp[rx]+gpr[ry];
}*/
add_cond4.disasm={

	os<< "add_cond4\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << endl ;

}

// ADDABS - add absolute value

op addabs(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b11100100[8]:rd[4])

addabs.disasm={

	os<< "addabs\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << endl ;

}

// CP_B - compare byte

op cp_b(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b1000[4]:0b00000000[8])

cp_b.disasm={

	os<< "cp_b\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << endl ;

}

// CP_H - compare halfword

op cp_h(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b1001[4]:0b00000000[8])

cp_h.disasm={

	os<< "cp_h\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << endl ;

}

// CP_W - compare word

op cp_w_a(0b000[3]:rs[4]:0b00011[5]:rd[4])

cp_w_a.disasm={

	os<< "cp_w_a\tr" << (unsigned int) rd << ",r" << (int) rs << endl ;

}

op cp_w_b(0b010[3]:0b110[3]:imm6[6]:rd[4])

cp_w_b.disasm={

	os<< "cp_w_b\tr" << (unsigned int) rd << ","<< (int) imm6 << endl ;

}

op cp_w_c(0b111[3]:imm_20_17[4]:0b0010[4]:imm_15[1]:rd[4]:><:imm_15_0[16])

cp_w_c.var imm : { uint32_t } = { (imm_20_17 << 17) | (imm_15 << 15) | imm_15_0 }

cp_w_c.disasm={

	os<< "cp_w_c\tr" << (unsigned int) rd << "," <<(int) imm << endl ;

}



// CPC - compare with carry

op cpc_a(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0011[4]:0b00000000[8])

cpc_a.disasm={

	os<< "cpc_a\tr"<< (unsigned int) rd << ",r" << (unsigned int) rs << endl;
}

op cpc_b(0b010[3]:0b1110[4]:0b00010[5]:rd[4])

cpc_b.disasm={

	os<< "cpc_b\tr"<< (unsigned int) rd << endl;
}

// MAX - return maximum value

op max(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b11000100[8]:rd[4])

max.disasm={

	os << "max\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << endl;
}

//MIN - return minimum value

op min(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b11010100[8]:rd[4])
//erreur dans la doc rd au lieu de ry

min.disasm={

	os << "min\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << endl;
}

//NEG - two's complement

op neg(0b010[3]:0b1110[4]:0b00011[5]:rd[4])

neg.disasm={

	os << "neg\tr" << (unsigned int) rd << endl;
}

// RSUB - reverse subtract

op rsub_a(0b000[3]:rs[4]:0b00010[5]:rd[4])

rsub_a.disasm={

	os << "rsub_a\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << endl;
}

op rsub_b(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0001[4]:imm8[8])

rsub_b.disasm={

	os << "rsub_b\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << "," << (int) imm8 << endl;
}

// conditional reverse subtract

op rsub_cond4(0b111[3]:0b1101[4]:0b11011[5]:rd[4]:><:0b0000[4]:cond4[4]:imm8[8])

rsub_cond4.disasm={

	os << "rsub_cond4\tr" << (unsigned int) rd << "," << (int) imm8 << endl;
}

// subtract with carry

op sbc(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b00010100[8]:rd[4])

sbc.disasm={

	
os << "sbc\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << endl;
}

//SCR - subtract carry from register

op scr(0b010[3]:0b1110[4]:0b00001[5]:rd[4])

scr.disasm={

	os << "scr\tr" << (unsigned int) rd << endl;
}

//SUB - subtract without carry

op sub_a(0b000[3]:rs[4]:0b00001[5]:rd[4])

sub_a.disasm={

	os << "sub_a\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << endl;
}

op sub_b(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b0001[4]:0b00[2]:sa[2]:rd[4])

sub_b.disasm={

	os << "sub_b\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << "<<0x" << std::hex << (unsigned int) sa << endl;
}

op sub_c(0b001[3]:0b0[1]:imm8[8]:rd[4])

sub_c.disasm={

	os << "sub_c\tr" << (unsigned int) rd << ",0x" << (int) imm8 << endl;
}

op sub_d(0b111[3]:imm_20_17[4]:0b0001[4]:imm_16[1]:rd[4]:><:imm_15_0[16])
sub_d.var imm :{uint32_t}= {(imm_20_17 << 17)|(imm_16 <<16 )|imm_15_0}

sub_d.disasm={

	os << "sub_d\tr" << (unsigned int) rd << ","  << (int) imm << endl;
}

op sub_e(0b111[3]:rs[4]:0b01100[5]:rd[4]:><:imm16[16])

sub_e.disasm={

	os << "sub_e\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << "," << (int) imm16 << endl;
}

//SUB_CON4 - conditional subtract

op sub_f_cond4(0b111[3]:0b101[3]:f[1]:0b11011[5]:rd[4]:><:0b0000[4]:cond4[4]:imm8[8])

sub_f_cond4.disasm={

	os << "sub_f_cond4\tr" << (unsigned int) rd << "," <<(int) imm8 << endl;

}

op sub_cond4(0b111[3]:rx[4]:0b11011[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0001[4]:rd[4])

sub_cond4.disasm={

	os << "sub_cond4\tr" << (unsigned int) rd << ",r" << (unsigned int) rx << ",r" << (unsigned int) ry << endl;
}

//TNBZ - test if no byte equal to zero

op tnbz(0b010[3]:0b1110[4]:0b01110[5]:rd[4])

tnbz.disasm={

	os << "tnbz\tr" << (unsigned int) rd << endl;
}

