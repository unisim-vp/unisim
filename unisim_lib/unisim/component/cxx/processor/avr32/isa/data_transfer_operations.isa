//-----------------------------------------------------------------------------

//                               MOV INSTRUCTIONS

//-----------------------------------------------------------------------------


//MOV - move data into register

op mov_a(0b001[3]:0b1[1]:imm8[8]:rd[4])

mov_a.execute={

	uint32_t result = SignExtend((uint32_t)imm8,8);

	cpu->SetGPR(rd,result); 

	return true; 
}

mov_a.disasm={

	os << "mov_a\tr" << (unsigned int) rd << "," << std::hex << (uint32_t)imm8 << endl;
}

op mov_b(0b111[3]:imm_20_17[4]:0b0011[4]:imm_16[1]:rd[4]:><:imm_15_0[16])

mov_b.var imm : {uint32_t}= {(imm_20_17<<17)|(imm_16)<<16| imm_15_0}

mov_b.execute={

	uint32_t result = SignExtend(imm,21);

	cpu->SetGPR(rd,result); 

	return true; 
	
}

mov_b.disasm={

	os << "mov_b\tr" << (unsigned int) rd << "," << std::hex << (uint32_t)imm << endl;
}

op mov_c(0b000[3]:rs[4]:0b01001[5]:rd[4])

mov_c.execute={
	
	uint32_t result= cpu->GetGPR(rs);

	cpu->SetGPR(rd,result);
	
	return true;
}

mov_c.disasm={

	os << "mov_c\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << endl;
}

// MOV_COND4 - conditional move register

op mov_cond4_a(0b111[3]:rs[4]:0b00000[5]:rd[4]:><:0b0001[4]:0b0111[4]:cond4[4]:0b0000[4])

mov_cond4_a.execute={

	if(cpu->EvaluateCond((uint8_t)cond4))
	{
		uint32_t result = cpu->GetGPR(rs);
		cpu->SetGPR(rd,result);
	}

	return true;
}

mov_cond4_a.disasm={

	os << "mov_cond4_a\tr" << (unsigned int) rd << ",r" << (unsigned int) rs << endl;
}

op mov_cond4_b(0b111[3]:0b1100[4]:0b11011[5]:rd[4]:><:0b0000[4]:cond4[4]:imm8[8])

mov_cond4_b.execute={

	if(cpu->EvaluateCond((uint8_t)cond4))
	{
		uint32_t result= SignExtend((uint32_t)imm8,8);
		cpu->SetGPR(rd,result); 
	}
	return true;
}

mov_cond4_b.disasm={

	os << "mov_cond4_b\tr" << (unsigned int) rd << ",Ox" << std::hex << (uint32_t) imm8 << endl;
}

// MOVH - move data into high halfword of register

op movh(0b111[3]:0b1110[4]:0b00001[5]:rd[4]:><:imm16[16])

movh.execute={

	uint32_t result = (uint32_t)imm16 << 16;

	cpu->SetGPR(rd,result);

	return true; 
}

movh.disasm={

	os << "movh\tr" << (unsigned int) rd << ",0x" << std::hex <<(uint32_t) imm16 << endl;
}

//----------------------------------------------------------------------------

//                          LOAD INSTRUCTIONS

//----------------------------------------------------------------------------

// LD_UB - load zero extended byte

op ld_ub_a(0b000[3]:rp[4]:0b10011[5]:rd[4])

ld_ub_a.execute={

	if (rp==rd) return false;         // the result is undefined

	uint32_t addr= cpu->GetGPR(rp);   //get address in rp
	
	if(!cpu->UintLoadByte(rd,addr++))      // load data in register rd
		return false;
	
        cpu->SetGPR(rp,addr);

	return true;
}

ld_ub_a.disasm={
	os << "ld_ub_a\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << "++" << endl;
}

op ld_ub_b(0b000[3]:rp[4]:0b10111[5]:rd[4])

ld_ub_b.execute={

	if (rp==rd) return false;         // the result is undefined

	uint32_t addr= cpu->GetGPR(rp);   
	
	if(!cpu->UintLoadByte(rd,--addr))       // load in register rd
		return false;
	
	cpu->SetGPR(rp,addr);

	return true;
}

ld_ub_b.disasm={
	os << "ld_ub_b\tr" << (unsigned int) rd << ",--r" << (unsigned int) rp << endl;
}

op ld_ub_c(0b000[3]:rp[4]:0b11[2]:disp[3]:rd[4])

ld_ub_c.execute={

	uint32_t addr= cpu->GetGPR(rp)+ (uint32_t)disp;   
	
	return cpu->UintLoadByte(rd,addr);
}

ld_ub_c.disasm={
	os << "ld_ub_c\tr" << (unsigned int) rd << ",r" << (unsigned int) rp <<"[0x" << std::hex <<(unsigned int) disp << "]" << endl;
}


op ld_ub_d(0b111[3]:rp[4]:0b10011[5]:rd[4]:><:disp16[16])


ld_ub_d.execute={

	uint32_t addr= cpu->GetGPR(rp)+ SignExtend((uint32_t)disp16,16);   
	
	return cpu->UintLoadByte(rd,addr);
}

ld_ub_d.disasm={
	os << "ld_ub_d\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << "[0x" << std::hex<<(uint32_t) disp16 << "]" << endl;
}


op ld_ub_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0111[4]:0b00[2]:sa[2]:rd[4])

ld_ub_e.execute={

	uint32_t addr= cpu->GetGPR(rb)+(cpu->GetGPR(ri)<< sa);   
	
	return cpu->UintLoadByte(rd,addr);

}


ld_ub_e.disasm={
	os << "ld_ub_e\tr" << (unsigned int) rd << ",r"<< (unsigned int) rb << "[r" << (unsigned int) ri << "<<0x" << std::hex << (unsigned int) sa << "]" << endl;
}


//LD_UB_COND4 - conditionally load zero extended byte

op ld_ub_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b100[3]:disp9[9])

ld_ub_cond4.execute={

	if(cpu->EvaluateCond((uint8_t)cond4))
	{
		uint32_t addr = cpu->GetGPR(rp)+ (uint32_t)disp9;

		return cpu->UintLoadByte(rd,addr);
	}

	return true;
}

ld_ub_cond4.disasm={
	os << "ld_ub_cond4\tr" << (unsigned int) rd << ",r"<< (unsigned int) rp <<",[0x" << std::hex <<(unsigned int) disp9 <<"]" << endl;
}

//LD_SB - load sign-extended byte

op ld_sb_a(0b111[3]:rp[4]:0b10010[5]:rd[4]:><:disp16[16])

ld_sb_a.execute={

	uint32_t addr= cpu->GetGPR(rp)+ SignExtend((uint32_t)disp16,16);   
	
	return cpu->SintLoadByte(rd,addr);
}


ld_sb_a.disasm={
	os << "ld_sb_a\tr" << (unsigned int) rd << ",r"<< (unsigned int) rp << "[0x" << std::hex << (uint32_t) disp16 << "]" << endl;
}

op ld_sb_b(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0110[4]:0b00[2]:sa[2]:rd[4])

ld_sb_b.execute={

	uint32_t addr= cpu->GetGPR(rb)+(cpu->GetGPR(ri)<< sa);   
	
	return cpu->SintLoadByte(rd,addr);
}

ld_sb_b.disasm={
	os << "ld_sb_b\t" << (unsigned int) rd << ",r" << (unsigned int) rb << "[r" << (unsigned int) ri << "<<0x" <<std::hex<< (unsigned int) sa << "]" << endl;
}

// LD_SB_COND4 - conditionally load sign-extended byte

op ld_sb_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b011[3]:disp9[9])

ld_sb_cond4.execute={

	if(cpu->EvaluateCond((uint8_t)cond4))
	{
		uint32_t addr = cpu->GetGPR(rp)+ (uint32_t)disp9;

		return cpu->SintLoadByte(rd,addr);
	}

	return true;
}

ld_sb_cond4.disasm={
	os << "ld_sb_cond4\t" << (unsigned int) rd << ",r" << (unsigned int) rp << "[0x"<< std::hex << (unsigned int) disp9 << "]" << endl;
}

// LD_UH - load zero extended half word

op ld_uh_a(0b000[3]:rp[4]:0b10010[5]:rd[4])

ld_uh_a.execute={

	if (rp==rd) return false;         // the result is undefined

	uint32_t addr= cpu->GetGPR(rp);   
	
	if (!cpu->UintLoadHalfWord(rd,addr)) return false;
	
	addr=addr+2;
        cpu->SetGPR(rp,addr);

	return true;
}

ld_uh_a.disasm={
	os << "ld_uh_a\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << "++" << endl;
}


op ld_uh_b(0b000[3]:rp[4]:0b10110[5]:rd[4])

ld_uh_b.execute={

	if (rp==rd) return false;         // the result is undefined

	uint32_t addr= cpu->GetGPR(rp);   
	addr=addr-2;
	
	if(! cpu->UintLoadHalfWord(rd,addr)) return false;        
	
	cpu->SetGPR(rp,addr);

	return true;
}

ld_uh_b.disasm={
	os << "ld_uh_b\tr" << (unsigned int) rd << ",--r" << (unsigned int) rp << endl;
}


op ld_uh_c(0b100[3]:rp[4]:0b01[2]:disp3[3]:rd[4])

ld_uh_c.execute={

	uint32_t addr= cpu->GetGPR(rp)+ ((uint32_t)disp3<<1);   
	
	return cpu->UintLoadHalfWord(rd,addr);

}

ld_uh_c.disasm={
	os << "ld_uh_c\tr" << (unsigned int) rd << ",r"<< (unsigned int) rp << "[0x" << std::hex << (unsigned int) disp3 << "]" << endl;
}

op ld_uh_d(0b111[3]:rp[4]:0b10001[5]:rd[4]:><:disp16[16])

ld_uh_d.execute={

	uint32_t addr= cpu->GetGPR(rp)+ SignExtend((uint32_t)disp16,16);   
	
	return cpu->UintLoadHalfWord(rd,addr);
}

ld_uh_d.disasm={
	os << "ld_uh_d\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << "[0x" << std::hex << (uint32_t) disp16 << "]" << endl;
}

op ld_uh_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0101[4]:0b00[2]:sa[2]:rd[4])

ld_uh_e.execute={

	uint32_t addr= cpu->GetGPR(rb)+(cpu->GetGPR(ri)<< sa);   
	
	return cpu->UintLoadHalfWord(rd,addr);
}

ld_uh_e.disasm={
	os << "ld_uh_e\tr" << rd << ",r" << (unsigned int) rb << "[r" << (unsigned int) ri << "<<0x" << std::hex << (unsigned int) sa << "]" << endl;
}


//LD_UH_COND4 - conditionally load zero extended halfword

op ld_uh_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b010[3]:disp9[9])

ld_uh_cond4.execute={

	if(cpu->EvaluateCond((uint8_t)cond4))
	{
		uint32_t addr = cpu->GetGPR(rp)+ ((uint32_t)disp9 << 1) ;

		return cpu->UintLoadHalfWord(rd,addr);
	}

	return true;
}

ld_uh_cond4.disasm={
	os << "ld_uh_cond4\tr" << (unsigned int)rd << ",r" << (unsigned int)rp << "[0x" << std::hex <<disp9 << "]" << endl;
}

//LD_SH - load sign extended halfword

op ld_sh_a(0b000[3]:rp[4]:0b10001[5]:rd[4])

ld_sh_a.execute={

	if (rp==rd) return false;         // the result is undefined

	uint32_t addr= cpu->GetGPR(rp);   
	
	if(!cpu->SintLoadHalfWord(rd,addr)) return false;
	
	addr=addr+2;
        cpu->SetGPR(rp,addr);

	return true;
}


ld_sh_a.disasm={
	os << "ld_sh_a\tr" << (unsigned int)rd << ",r" << (unsigned int)rp << "++" << endl;
}

op ld_sh_b(0b000[3]:rp[4]:0b10101[5]:rd[4])

ld_sh_b.execute={

	if (rp==rd) return false;         // the result is undefined

	uint32_t addr= cpu->GetGPR(rp);   
	addr=addr-2;
	
	if(!cpu->SintLoadHalfWord(rd,addr)) return false;        
	
	cpu->SetGPR(rp,addr);

	return true;
}

ld_sh_b.disasm={
	os << "ld_sh_b\tr" << (unsigned int)rd << ",--r" << (unsigned int)rp << endl;
}

op ld_sh_c(0b100[3]:rp[4]:0b00[2]:disp3[3]:rd[4])

ld_sh_c.execute={

	uint32_t addr= cpu->GetGPR(rp)+ ((uint32_t)disp3<<1);   
	
	return cpu->SintLoadHalfWord(rd,addr);
}


ld_sh_c.disasm={
	os << "ld_sh_c\tr" << (unsigned int)rd << ",r" << (unsigned int)rp << "[0x" << std::hex << (unsigned int)disp3 << "]" << endl;
}

op ld_sh_d(0b111[3]:rp[4]:0b10000[5]:rd[4]:><:disp16[16])

ld_sh_d.execute={

	uint32_t addr= cpu->GetGPR(rp)+ SignExtend((uint32_t)disp16,16);   
	
	return cpu->SintLoadHalfWord(rd,addr);
}


ld_sh_d.disasm={
	os << "ld_sh_d\tr" << (unsigned int)rd << ",r" << (unsigned int)rp << "[0x" << std::hex << (uint32_t) disp16 << "]" << endl;
}

op ld_sh_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0100[4]:0b00[2]:sa[2]:rd[4])

ld_sh_e.execute={

	uint32_t addr= cpu->GetGPR(rb)+(cpu->GetGPR(ri)<< sa);   
	
	if(!cpu->SintLoadHalfWord(rd,addr)) return false;

	return true;
}


ld_sh_e.disasm={
	os << "ld_sh_e\tr" << (unsigned int)rd << ",r" << (unsigned int)rb << "[r" << (unsigned int)ri << "<<0x" << std::hex<< (unsigned int)sa << "]" << endl;
}


// LD_SH_COND4 - conditionally load extended halword

op ld_sh_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b001[3]:disp9[9])

ld_sh_cond4.execute={

	if(cpu->EvaluateCond((uint8_t)cond4))
	{
		uint32_t addr = cpu->GetGPR(rp)+ ((uint32_t)disp9 << 1);

		return cpu->SintLoadHalfWord(rd,addr);
	}

	return true;
}

ld_sh_cond4.disasm={
	os << "ld_sh_cond4\tr" << (unsigned int)rd << ",r" << (unsigned int)rp << "[0x" << std::hex << (unsigned int)disp9 << "]" << endl;
}


// LD_W - load word

op ld_w_a(0b000[3]:rp[4]:0b10000[5]:rd[4])

ld_w_a.execute={

	if(rp==rd)return false;

	uint32_t addr=cpu->GetGPR(rp);
	
	if(!cpu->IntLoadWord(rd,addr)) return false;
	addr=addr+4;

	cpu->SetGPR(rp,addr);

	return true;
}

ld_w_a.disasm={
	os << "ld_w_a\tr" << (unsigned int)rd << ",r" << (unsigned int)rp << "++" << endl;
}

op ld_w_b(0b000[3]:rp[4]:0b10100[5]:rd[4])

ld_w_b.execute={

	if(rp==rd)return false;

	uint32_t addr=cpu->GetGPR(rp);
	
	addr=addr-4;
	if(!cpu->IntLoadWord(rd,addr)) return false;
	

	cpu->SetGPR(rp,addr);

	return true;
}

ld_w_b.disasm={
	os << "ld_w_b\tr" << (unsigned int)rd << ",--r" << (unsigned int)rp << endl;
}

op ld_w_c(0b011[3]:rp[4]:disp5[5]:rd[4])

ld_w_c.execute={

	uint32_t addr=cpu->GetGPR(rp) +((uint32_t)disp5 << 2);
	
	return cpu->IntLoadWord(rd,addr);
}

ld_w_c.disasm={
	os << "ld_w_c\tr" << (unsigned int)rd << ",r" << (unsigned int)rp << "[0x" << std::hex << (unsigned int) disp5 << "]" << endl;
}


op ld_w_d(0b111[3]:rp[4]:0b01111[5]:rd[4]:><:disp16[16])

ld_w_d.execute={

	uint32_t addr=cpu->GetGPR(rp) +SignExtend((uint32_t)disp16,16);
	
	return cpu->IntLoadWord(rd,addr);
}


ld_w_d.disasm={
	os << "ld_w_d\tr" << (unsigned int)rd << ",r" << (unsigned int)rp << "[0x" <<std::hex<< (uint32_t)disp16 << "]" << endl;
}

op ld_w_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0011[4]:0b00[2]:sa[2]:rd[4])

ld_w_e.execute={

	uint32_t addr=cpu->GetGPR(rb) + (cpu->GetGPR(ri)<<sa);
	
	return cpu->IntLoadWord(rd,addr);
}


ld_w_e.disasm={
	os << "ld_w_e\tr" << (unsigned int) rd << ",r" <<  (unsigned int) rb << "[r" << (unsigned int) ri << "<<0x" << std::hex <<(unsigned int) sa << "]" << endl;
}


op ld_w_f(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b111110[6]:x[1]:y[1]:rd[4])

// x=0, y=0 for bottom
// x=0, y=1 for lower
// x=1, y=0 for upper
// x=1, y=1 for top           à confirmer 

ld_w_f.execute={

	uint32_t b = cpu->GetGPR(rb);
	uint32_t i = cpu->GetGPR(ri); 
	uint32_t addr;

	if(x==0 && y==0)
        {
		addr=b+((i & 0x000000FF )  <<2);
	}
	else if(x==0 && y==1)
	{
		addr=b+(((i & 0x0000FF00)>>8 )<<2);
	}
	else if(x==1 && y==0)
	{
		addr=b+(((i & 0x00FF0000) >> 16) << 2);
	}
	else
	{
		addr=b+(((i & 0xFF000000) >> 24) << 2);
	}
	
	return cpu->IntLoadWord(rd,addr);
}

ld_w_f.disasm={
	os << "ld_w_f\tr" << (unsigned int) rd << ",r" << (unsigned int) rb << "[r" << (unsigned int) ri << ":<" << x << y  << "> << 2]" << endl;
}



// LD_W_COND4 - conditionally load word

op ld_w_cond4(0b111[3]:rp[4]:0b11111[5]:rd[4]:><:cond4[4]:0b000[3]:disp9[9])

ld_w_cond4.execute={

	if(cpu->EvaluateCond((uint8_t) cond4))
	{
		uint32_t addr = cpu->GetGPR(rp) + ((uint32_t)disp9 << 2);

		return cpu->IntLoadWord(rd,addr);
	}
	return true;
}

ld_w_cond4.disasm={
	os << "ld_w_cond4\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << "[0x" << std::hex << (unsigned int)disp9 << "]" << endl;
}


// LD_D - load doubleword

op ld_d_a(0b101[3]:rp[4]:0b100[3]:0b00[2]:rd[3]:0b1[1])

ld_d_a.execute={

	if(rd==rp || rp==(rd+1)) return false;

	uint32_t addr= cpu->GetGPR(rp);
	
	if(!cpu->IntLoadWord(rd +1,addr)) return false;
	if(!cpu->IntLoadWord(rd,addr+4)) return false;

	addr+=8;
	cpu->SetGPR(rp,addr);

	return true;
}

ld_d_a.disasm={
	os << "ld_d_a\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << "++" << endl;
}

op ld_d_b(0b101[3]:rp[4]:0b100[3]:0b01[2]:rd[3]:0b0[1])

ld_d_b.execute={

	if(rd==rp || rp==(rd+1)) return false;

	uint32_t addr= cpu->GetGPR(rp);
	
	addr-=8;
	if(!cpu->IntLoadWord(rd+1,addr))return false;
	if(!cpu->IntLoadWord(rd,addr+4))return false;

	cpu->SetGPR(rp,addr);

	return true;
}

ld_d_b.disasm={
	os << "ld_d_b\tr" << (unsigned int) rd << ",--r" << (unsigned int) rp << endl;
}

op ld_d_c(0b101[3]:rp[4]:0b100[3]:0b00[2]:rd[3]:0b0[1])

ld_d_c.execute={

	uint32_t addr= cpu->GetGPR(rp);

	if(!cpu->IntLoadWord(rd+1,addr)) return false;
	if(!cpu->IntLoadWord(rd,addr+4)) return false;

	return true;
}

ld_d_c.disasm={
	os << "ld_d_c\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << endl;
}


op ld_d_d(0b111[3]:rp[4]:0b01110[5]:rd[3]:0b0[1]:><:disp16[16])

ld_d_d.execute={

	uint32_t addr= cpu->GetGPR(rp)+ SignExtend((uint32_t)disp16,16);

	if (!cpu->IntLoadWord(rd+1,addr)) return false;
	return cpu->IntLoadWord(rd,addr+4);
}

ld_d_d.disasm={
	os << "ld_d_d\tr" << (unsigned int)rd << ",r" << (unsigned int) rp << "[0x" << std::hex << (uint32_t) disp16 << "]" << endl;
}


op ld_d_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b0010[4]:0b00[2]:sa[2]:rd[4])

ld_d_e.execute={

	uint32_t addr= cpu->GetGPR(rb) + (cpu->GetGPR(ri)<< sa);

	if(!cpu->IntLoadWord(rd+1,addr)) return false;
	return cpu->IntLoadWord(rd,addr+4);

	return true;
}

ld_d_e.disasm={
	os << "ld_d_e\tr" << (unsigned int) rd << ",r" <<  (unsigned int) rb << "[r" << (unsigned int) ri << "<<" << std::hex << (uint32_t)sa << "]" << endl;
}


// LDINS_B - load and insert byte  into register
// part=0 for top,1 for upper, 2 for low, 3 for bottom

op ldins_b(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b01[2]:part[2]:disp12[12])

ldins_b.execute={

	uint32_t addr= cpu->GetGPR(rp)+ SignExtend((uint32_t)disp12,12);
	/*uint32_t d = cpu->GetGPR(rd);

	uint32_t val;
	cpu->MemReadByte(addr,val);	

	if(part==3){d= (d & 0xFFFFFF00) | (val & 0x000000FF); }
	else if(part==2){d= (d & 0xFFFF00FF) | ((val<<4) & 0x0000FF00);}
	else if(part==1){d= (d & 0xFF00FFFF) | ((val<<16) & 0x00FF0000);}
	else{d= (d & 0x00FFFFFF) | ((val<<24) & 0xFF000000);}

	cpu->SetGPR(rd,d);	
	*/
	return cpu->LoadAndInsertByte(rd,addr,(uint8_t)part);
}

ldins_b.disasm={
	os << "ldins_b\tr" << (unsigned int) rd << ":<" << part << ">,r" << (unsigned int) rp << "[0x" << std::hex << (uint32_t)disp12 << "]" << endl;
}

// LDINS_H - load and insert halfword into register
// part=0 for top, 1 for bottom

op ldins_h(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b000[3]:part[1]:disp12[12])

ldins_h.execute={

	uint32_t addr = cpu->GetGPR(rp) + (SignExtend((uint32_t)disp12,12) << 1);	
	/*uint32_t d = cpu->GetGPR(rd);
	uint32_t val;
	cpu ->MemReadHalfWord(addr,val);

	if(part==1){d = (d & 0xFFFF0000)|(val & 0x0000FFFF);}
	else{d = (d & 0x0000FFFF)|( (val << 16) & 0xFFFF0000);}	
	
	cpu->SetGPR(rd,d);	
	*/
	return cpu->LoadAndInsertHalfWord(rd,addr,(uint8_t)part);
}

ldins_h.disasm={
	os << "ldins_h\tr" << (unsigned int) rd << ":<" << part << ">,r" << (unsigned int) rp << "[0x" << std::hex << (uint32_t)disp12 << "]" << endl;
}

// LDSWP_SH/UH/W  - load and swap    

op ldswp_sh(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b0010[4]:disp12[12])

ldswp_sh.execute={

	uint32_t addr = cpu->GetGPR(rp)+ (SignExtend((uint32_t)disp12,12) << 1);
	/*uint32_t temp;
	cpu->MemReadHalfWord(addr,temp);
	uint32_t result = SignExtend(((temp & 0x000000FF)<<8 ) | ((temp & 0x0000FF00)>>8),16);// utiliser ByteSwap
	
	cpu->SetGPR(rd,result);
	*/
	return cpu->SintLoadHalfWord(rd,addr,true);
}

ldswp_sh.disasm={
	os << "ldswp_sh\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << "[0x" <<std::hex << (uint32_t)disp12 << "]" << endl;
}


op ldswp_uh(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b0011[4]:disp12[12])

ldswp_uh.execute={

	uint32_t addr = cpu->GetGPR(rp)+ (SignExtend((uint32_t)disp12,12) << 1);
	/*uint32_t temp;
	cpu->MemReadHalfWord(addr,temp);
	uint32_t result =((temp & 0x000000FF)<<8 ) | ((temp & 0x0000FF00)>>8);

	cpu->SetGPR(rd,result);
	*/
	return cpu->UintLoadHalfWord(rd,addr,true);
}

ldswp_uh.disasm={
	os << "ldswp_uh\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << "[0x" << std::hex << (uint32_t)disp12 << "]" << endl;
}


op ldswp_w(0b111[3]:rp[4]:0b11101[5]:rd[4]:><:0b1000[4]:disp12[12])

ldswp_w.execute={

	uint32_t addr = cpu->GetGPR(rp)+ (SignExtend((uint32_t)disp12,12) << 2);
	/*uint32_t temp;
	cpu->MemReadWord(addr,temp);
	uint32_t result = ((temp & 0x000000FF)<<24 ) | ((temp & 0x0000FF00)<<8) | ((temp & 0x00FF0000)>>8) | ((temp & 0xFF000000)>>24);

	cpu->SetGPR(rd,result);
	*/
	return cpu->IntLoadWord(rd,addr,true);
}

ldswp_w.disasm={
	os << "ldswp_w\tr" << (unsigned int) rd << ",r" << (unsigned int) rp << "[0x" << std::hex << (uint32_t)disp12 << "]" << endl;
}


// LDDPC - load pc relative with displacement

op lddpc(0b010[3]:0b01[2]:disp7[7]:rd[4])

lddpc.execute={
	
	uint32_t pc=Operation<CONFIG>::GetAddr();
	uint32_t address= (pc && 0xFFFFFFFC) +( (uint32_t)disp7 << 2);

	return cpu->UintLoadByte(rd,address);
}

lddpc.disasm={

	os << "lddpc\tr" << (unsigned int)rd << ",0x" << std::hex << (unsigned int)Operation<CONFIG>::GetAddr() << "[0x" << std::hex << (uint32_t)disp7 << "]"<< endl; 
}

// LDDSP - load sp relative with displacement

op lddsp(0b010[3]:0b00[2]:disp7[7]:rd[4])

lddsp.execute={
	
	uint32_t sp= cpu->GetSP();
	uint32_t address= (sp && 0xFFFFFFFC) +( (uint32_t)disp7 << 2);

	return cpu->UintLoadByte(rd,address);
}

lddsp.disasm={

	os << "lddsp\tr" << (unsigned int)rd << ",0x" << std::hex<< (unsigned int)cpu->GetSP() << "[0x" << std::hex << (uint32_t)disp7 << "]" << endl; 
}


//-------------------------------------------------------------------------------

//                      STORE INSTRUCTIONS

//-------------------------------------------------------------------------------

// ST_B -  store byte

op st_b_a(0b000[3]:rp[4]:0b01100[5]:rs[4])

st_b_a.execute={

	if(rp==rs) return false;

	uint32_t addr=cpu->GetGPR(rp);       // get address
	cpu->IntStoreByte(rs,addr);          // store byte in memory
	addr++;                              // post increment
	cpu->SetGPR(rp,addr);  
	return true;
}

st_b_a.disasm={

	os << "st_b_a\tr" << (unsigned int) rp << "++,r" << (unsigned int)rs << endl;
}

op st_b_b(0b000[3]:rp[4]:0b01111[5]:rs[4])

st_b_b.execute={

	if(rp==rs) return false;

	uint32_t addr=cpu->GetGPR(rp);        // get address
	addr--;                               // pre increment
	cpu->IntStoreByte(rs,addr);           // store byte in memory
	cpu->SetGPR(rp,addr);  
	return true;
}

st_b_b.disasm={

	os << "st_b_b\t--r" << (unsigned int)rp << ",r" << (unsigned int)rs << endl;
}

op st_b_c(0b101[3]:rp[4]:0b01[2]:disp3[3]:rs[4])

st_b_c.execute={

	uint32_t addr=cpu->GetGPR(rp)+(uint32_t)disp3;
	cpu->IntStoreByte(rs,addr);
  
	return true;
}

st_b_c.disasm={

	os << "st_b_c\tr" << (unsigned int)rp << "[0x" << std::hex<<(unsigned int)disp3 << "],r" << (unsigned int)rs << endl;
}


op st_b_d(0b111[3]:rp[4]:0b10110[5]:rs[4]:disp16[16])

st_b_d.execute={

	uint32_t addr=cpu->GetGPR(rp)+SignExtend((uint32_t)disp16,16);
	cpu->IntStoreByte(rs,addr);
  
	return true;
}


st_b_d.disasm={

	os << "st_b_d\tr" << (unsigned int) rp << "[0x"<< std::hex << (uint32_t)disp16 << "],r" << (unsigned int)rs << endl;
}


op st_b_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b1011[4]:0b00[2]:sa[2]:rs[4])

st_b_e.execute={

	uint32_t addr=cpu->GetGPR(rb)+( cpu->GetGPR(ri)<<(unsigned int)sa);
	cpu->IntStoreByte(rs,addr);
 
	return true;
}

st_b_e.disasm={

	os << "st_b_e\tr" << (unsigned int) rb << "[0x" << std::hex << (unsigned int) ri << "<<0x" << std::hex << (unsigned int) sa <<"]," << (unsigned int) rs << endl;
}


// ST_B_COND4 - conditional store byte

// erreur dans la documentation (architecure manual) rd au lieu de rs dans l'op code

op st_b_cond4(0b111[3]:rp[4]:0b11111[5]:rs[4]:><:cond4[4]:0b111[3]:disp9[9])

st_b_cond4.execute={
	
	if(cpu->EvaluateCond(cond4))
	{
		uint32_t addr= cpu->GetGPR(rp) + (uint32_t)disp9;

		cpu->IntStoreByte(rs,addr);
	}
		
	return true;
}

st_b_cond4.disasm={

	os << "st_b_cond4\tr" << (unsigned int)rp << "[" << disp9 << "],r" << (unsigned int)rs << endl;
}


// ST_D - store doubleword

op st_d_a(0b101[3]:rp[4]:0b100[3]:0b10[2]:rs[3]:0b0[1])

st_d_a.execute={

	if(rp==rs) return false;
	
	uint32_t addr= cpu->GetGPR(rp);

	cpu->IntStoreWord(rs+1,addr);
	cpu->IntStoreWord(rs,addr+4);

	addr+=8;
	cpu->SetGPR(rp,addr);	
	
	return true;
}

st_d_a.disasm={

	os << "st_d_a\tr" << (unsigned int) rp << "++,r" << (unsigned int)rs << endl;
}

op st_d_b(0b101[3]:rp[4]:0b100[3]:0b10[2]:rs[3]:0b1[1])

st_d_b.execute={

	if(rp==rs) return false;
	
	uint32_t addr= cpu->GetGPR(rp);

	addr-=8;
	cpu->IntStoreWord(rs+1,addr);
	cpu->IntStoreWord(rs,addr+4);

	cpu->SetGPR(rp,addr);	
	
	return true;
}

st_d_b.disasm={

	os << "st_d_b\t--r" << (unsigned int)rp << ",r" << (unsigned int)rs << endl;
}

op st_d_c(0b101[3]:rp[4]:0b100[3]:0b01[2]:rs[3]:0b1[1])

st_d_c.execute={
	
	uint32_t addr= cpu->GetGPR(rp);

	cpu->IntStoreWord(rs+1,addr);
	cpu->IntStoreWord(rs,addr+4);	
	
	return true;
}

st_d_c.disasm={

	os << "st_d_c\tr" << (unsigned int)rp  << ",r" << (unsigned int)rs << endl;
}

op st_d_d(0b111[3]:rp[4]:0b01110[5]:rs[3]:0b1[1]:><:disp16[16])

st_d_d.execute={
	
	uint32_t addr= cpu->GetGPR(rp) + SignExtend((uint32_t)disp16,16);

	cpu->IntStoreWord(rs+1,addr);
	cpu->IntStoreWord(rs,addr + 4);	
	
	return true;
}

st_d_d.disasm={

	os << "st_d_d\tr" << (unsigned int)rp << "[" << std::hex << (uint32_t)disp16 << "]r," << (unsigned int)rs << endl;
}

op st_d_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b1000[4]:0b00[2]:sa[2]:rs[4])

st_d_e.execute={
	
	uint32_t addr= cpu->GetGPR(rb) + (cpu->GetGPR(ri) << sa);

	cpu->IntStoreWord(rs+1,addr+4);
	cpu->IntStoreWord(rs,addr);	
	
	return true;
}

st_d_e.disasm={

	os << "st_d_e\tr" << rb << "[r" << ri << "<<0x"<< std::hex << (unsigned int)sa << "],r" << rs << endl;
}


// ST_H - store halfword

op st_h_a(0b000[3]:rp[4]:0b01011[5]:rs[4])

st_h_a.execute={
	
	if(rp==rs) return false;
	uint32_t addr=cpu->GetGPR(rp);

	cpu->IntStoreHalfWord(rs,addr);

	addr+=2;
	cpu->SetGPR(rp,addr);

	return true;
}

st_h_a.disasm={

	os << "st_h_a\tr" << (unsigned int)rp << "++,r" << (unsigned int)rs << endl;
}

op st_h_b(0b000[3]:rp[4]:0b01110[5]:rs[4])

st_h_b.execute={

	if(rp==rs) return false;
	uint32_t addr=cpu->GetGPR(rp);
	addr-=2;

	cpu->IntStoreHalfWord(rs,addr);
	cpu->SetGPR(rp,addr);

	return true;
	
}

st_h_b.disasm={

	os << "st_h_b\t--r" << (unsigned int)rp << ",r" << (unsigned int)rs << endl;
}

op st_h_c(0b101[3]:rp[4]:0b00[2]:disp3[3]:rs[4])

st_h_c.execute={

	uint32_t addr=cpu->GetGPR(rp)+ ((uint32_t)disp3 << 1) ;

	cpu->IntStoreHalfWord(rs,addr);

	return true;
	 
}

st_h_c.disasm={

	os << "st_h_d\tr" << (unsigned int)rp << "[0x" << std::hex << (unsigned int)disp3 << "],r" << (unsigned int)rs << endl;
}

op st_h_d(0b111[3]:rp[4]:0b10101[5]:rs[4]:><:disp16[16])

st_h_d.execute={

	uint32_t addr=cpu->GetGPR(rp)+ SignExtend((uint32_t)disp16,16);

	cpu->IntStoreHalfWord(rs,addr);

	return true;
	 
}

st_h_d.disasm={

	os << "st_h_d\tr" << rp << "[0x"<< std::hex << (unsigned int)disp16 << "],r" << rs << endl;
}

op st_h_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b1010[4]:0b00[2]:sa[2]:rs[4])

st_h_e.execute={

	uint32_t addr=cpu->GetGPR(rb)+ (cpu->GetGPR(ri)<< sa) ;

	cpu->IntStoreHalfWord(rs,addr);

	return true;
	 
}

st_h_e.disasm={

	os << "st_h_e\tr" << (unsigned int)rb << "[r" << (unsigned int)ri << "<<0x" << std::hex << (unsigned int) sa << "],r" << (unsigned int)rs << endl;
}

// ST_H_COND4 - conditionally store halfword

op st_h_cond4(0b111[3]:rp[4]:0b11111[5]:rs[4]:><:cond4[4]:0b110[3]:disp9[9])

st_h_cond4.execute={

	if(cpu->EvaluateCond(cond4))
	{
		uint32_t addr = cpu->GetGPR(rp)+ ((uint32_t)disp9 << 2) ;

		cpu->IntStoreHalfWord(rs,addr);

	}

	return true;
}

st_h_cond4.disasm={

	os << "st_h_cond4\tr" << (unsigned int)rp << "[0x" << std::hex << (unsigned int) disp9 << "],r" << (unsigned int)rs << endl;
}

// ST_W - store word

op st_w_a(0b000[3]:rp[4]:0b01010[5]:rs[4])

st_w_a.execute={


	if(rp==rs) return false;

	uint32_t addr = cpu->GetGPR(rp);

	cpu->IntStoreWord(rs,addr);
	addr+=4;
	cpu->SetGPR(rp,addr);

	return true;
}

st_w_a.disasm={

	os << "st_w_a\tr" << (unsigned int)rp << "++,r" << (unsigned int)rs << endl;
}

op st_w_b(0b000[3]:rp[4]:0b01101[5]:rs[4])

st_w_b.execute={


	if(rp==rs) return false;

	uint32_t addr = cpu->GetGPR(rp);
	addr-=4;	

	cpu->IntStoreWord(rs,addr);
	
	cpu->SetGPR(rp,addr);

	return true;
}

st_w_b.disasm={

	os << "st_w_b\t--r" << (unsigned int)rp << ",r" << (unsigned int)rs << endl;
}

op st_w_c(0b100[3]:rp[4]:0b1[1]:disp4[4]:rs[4])

st_w_c.execute={

	uint32_t addr = cpu->GetGPR(rp)+ ((uint32_t)disp4 << 2);

	cpu->IntStoreWord(rs,addr);

	return true;
}
st_w_c.disasm={

	os << "st_w_d\tr" << (unsigned int)rp << "[0x" << std::hex << (unsigned int)disp4 << "],r" << (unsigned int)rs << endl;
}

op st_w_d(0b111[3]:rp[4]:0b10100[5]:rs[4]:><:disp16[16])

st_w_d.execute={

	uint32_t addr = cpu->GetGPR(rp)+ SignExtend((uint32_t)disp16,16);

	cpu->IntStoreWord(rs,addr);

	return true;
}

st_w_d.disasm={

	os << "st_w_d\tr" <<(unsigned int)rp << "[0x" << std::hex << (uint32_t)disp16 << "],r" << (unsigned int)rs << endl;
}

op st_w_e(0b111[3]:rb[4]:0b00000[5]:ri[4]:><:0b0000[4]:0b1001[4]:0b00[2]:sa[2]:rs[4])


st_w_e.execute={

	uint32_t addr = cpu->GetGPR(rb)+ (cpu->GetGPR(ri) << sa);

	cpu->IntStoreWord(rs,addr);

	return true;
}
st_w_e.disasm={

	os << "st_w_e\tr" << (unsigned int)rb << "[r" << (unsigned int)ri << "<<0x" << std::hex<<(unsigned int)sa << "],r" << (unsigned int)rs << endl;
}

// ST_W_COND4 - conditionally store word

// erreur dans le document "architecture manual": rd au lieu de rs dans l'opcode 

op st_w_cond4(0b111[3]:rp[4]:0b11111[5]:rs[4]:><:cond4[4]:0b101[3]:disp9[9])

st_w_cond4.execute={

	if(cpu->EvaluateCond(cond4))
	{
		uint32_t addr = cpu->GetGPR(rp) + ((uint32_t)disp9 << 2);

		cpu->IntStoreWord(rs,addr);
	}

	return true;
}

st_w_cond4.disasm={

	os << "st_w_cond4\tr" << (unsigned int)rp << "[0x" << std::hex << (unsigned int)disp9 << "],r" << (unsigned int)rs << endl;
}


// STCOND - store word conditionally

op stcond(0b111[3]:rp[4]:0b10111[5]:rs[4]:><:disp16[16])

stcond.disasm={

	os << "stcond\tr" << (unsigned int)rp << "[0x" << std::hex << (unsigned int)disp16 << "],r" << (unsigned int)rs << endl;
}


// STDSP - store stack pointer relative

op stdsp(0b010[3]:0b10[2]:disp7[7]:rs[4])

stdsp.execute={

	uint32_t addr= cpu->GetSP() && 0xFFFFFFFC + ((uint32_t)disp7 << 2);

	cpu->IntStoreWord(rs,addr);	
 	
	return true;
}

stdsp.disasm={

	os << "stdsp\t" << std::hex <<(unsigned int) cpu->GetSP() << "[0x" << (unsigned int)disp7 << "],r" << (unsigned int)rs << endl;
}

// STHH_W - store halfword into word

op sthh_w_a(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b11[2]:x[1]:y[1]:disp8[8]:rp[4])

sthh_w_a.execute={

	uint32_t hight_part=cpu->GetGPR(rx);
	uint32_t low_part=cpu->GetGPR(ry);
	
	if(x==1) hight_part=hight_part & 0xFFFF0000;
	else hight_part= (hight_part & 0x0000FFFF) << 16;

	if(y==1) low_part= (low_part & 0xFFFF0000)>> 16;
	else low_part= low_part & 0x0000FFFF;
	
	uint32_t addr = cpu->GetGPR(rp) + ((uint32_t)disp8 << 2);

	uint32_t result = hight_part | low_part; 
	
	cpu->MemWriteWord(result,addr);  	
	
	return true;
}

sthh_w_a.disasm={

	os << "sthh_w_a\tr" << (unsigned int)rp << "[0x" << (unsigned int)disp8 << "],r" << (unsigned int)rx << ":<" << x << ">,r"<< (unsigned int)ry << ":[" << x << "]" << endl;

}

op sthh_w_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b10[2]:x[1]:y[1]:ri[4]:0b00[2]:sa[2]:rb[4])

sthh_w_b.execute={

	uint32_t hight_part=cpu->GetGPR(rx);
	uint32_t low_part=cpu->GetGPR(ry);
	//from rx
	if(x==1) hight_part=hight_part & 0xFFFF0000;        //get from bit 31 to 16
	else hight_part= (hight_part & 0x0000FFFF) << 16;   //get from bit 15 to 0
	// from ry 
	if(y==1) low_part= (low_part & 0xFFFF0000)>> 16;    // get from bit 31 to 16
	else low_part= low_part & 0x0000FFFF;               // get from bit 15 to 0
	
	uint32_t addr = cpu->GetGPR(rb) + (cpu->GetGPR(ri) << sa);  	
	uint32_t result = hight_part | low_part;

	cpu->MemWriteWord(result,addr);	       // write result in memory
		
	return true;
}

sthh_w_b.disasm={

	os << "sthh_w_b\tr" << (unsigned int)rb << "[r" << (unsigned int)ri << "<<0x" << std::hex <<(unsigned int)sa << "],r" << (unsigned int)rx << ":<" << x << ">,r"<< (unsigned int)ry << ":[" << y << "]" << endl;

}

// STSWP_H/W - swap and store

op stswp_h(0b111[3]:rp[4]:0b11101[5]:rs[4]:><:0b1001[4]:disp12[12])

stswp_h.execute={

	uint32_t s = cpu->GetGPR(rs);
	uint32_t temp= ((s & 0x000000FF)<< 8) | ((s & 0x0000FF00)>> 8);  // swap lower and bottom byte

	uint32_t addr= cpu->GetGPR(rp) + (SignExtend((uint32_t)disp12,12)<<1);

	cpu->MemWriteHalfWord(temp,addr);

	return true;
}

stswp_h.disasm={

	os << "stswp_h\tr" << (unsigned int)rp << "[0x" << std::hex<<(unsigned int)disp12 << "],r" << (unsigned int)rs << endl;
}


op stswp_w(0b111[3]:rp[4]:0b11101[5]:rs[4]:><:0b1010[4]:disp12[12])

stswp_w.execute={

	uint32_t s = cpu->GetGPR(rs);

	uint32_t temp= ((s & 0x000000FF)<< 24) | ((s & 0x0000FF00)<< 8) | ((s & 0x00FF0000)>>8 ) | ((s & 0xFF000000)>>24);

	uint32_t addr= cpu->GetGPR(rp) + (SignExtend((uint32_t)disp12,12)<<2);

	cpu->MemWriteWord(temp,addr);

	return true;
}

stswp_w.disasm={

	os << "stswp_w\tr" <<(unsigned int)rp << "[0x" << std::hex << (unsigned int)disp12 << "],r" << (unsigned int)rs << endl;
}

// XCHG - Exchange register and memory

op xchg(0b111[3]:rx[4]:0b00000[5]:ry[4]:><:0b0000[4]:0b10110100[8]:rd[4])

xchg.execute={
	
	uint32_t addr = cpu->GetGPR(rx); 
	uint32_t temp;
	cpu->MemReadWord(addr,temp);

	cpu->IntStoreWord(ry,addr);
	 	
	cpu->SetGPR(rd,temp);
	
	return true;
}

xchg.disasm={

	os << "xchg\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << endl;
}


//-----------------------------------------------------------------------------

//                   MULTIPLE DATA                 

//-----------------------------------------------------------------------------

//LDM - load multiple register

op ldm(0b111[3]:0b000[3]:postinc[1]:0b11100[5]:rp[4]:><:reglist16[16])

 // reglist16={R0,R1,R2,R3,R4,R5,R6,R7...R12,LR,SP,PC}

ldm.execute={   

	//Emtpy Reglist16 gives UNDEFINED result.
	if(reglist16 == 0) 
		return false;                      
	//If Rp is in Reglist16 and pointer is written back the result is UNDEFINED.
	if((rp >= 0 && rp< 16) && (((reglist16>>rp)&1)==1))
		return false;

	uint32_t p = cpu->GetGPR(rp);
	uint32_t pc = Operation<CONFIG>::GetAddr();
	uint32_t loadAddress = p;
	if(((reglist16 >> 15)& 1)==1)                  //reglist16[PC]==1
	{
		if(p == pc) loadAddress= cpu->GetSP();
		if(!cpu->MemReadWord(loadAddress++,pc))
			return false;
		cpu->SetGPR(15,pc);
		if(p==pc)
		{
			if( ((reglist16 >> 12)&3)==0b00 ) cpu->SetGPR(12,0);

			else if ( ((reglist16 >> 12)&3)==0b01  ) cpu->SetGPR(12,1);

			else cpu->SetGPR(12,-1);

			uint32_t res=cpu->GetGPR(12); 	// test r12 and update flags
			cpu->SetSR_V(0);
			cpu->SetSR_N((int32_t)res<0);
			cpu->SetSR_Z(res==0);
			cpu->SetSR_C(0);
		}
		else
		{
			if(  ((reglist16 >> 13)&1) == 1 )
			{
 				if(!cpu->IntLoadWord(14,loadAddress++)) // load LR
					return false;      
			}
			if(  ((reglist16 >> 14)&1) == 1 )
			{
 				if(!cpu->IntLoadWord(13,loadAddress++)) // load SP
					return false;      
			}
			if(  ((reglist16 >> 12)&1) == 1 )
			{
 				if(!cpu->IntLoadWord(12,loadAddress++)) // load R12
					return false;      
			}
			
			uint32_t res=cpu->GetGPR(12);	// test r12 and update flags
			cpu->SetSR_V(0);
			cpu->SetSR_N((int32_t)res<0);
			cpu->SetSR_Z(res==0);
			cpu->SetSR_C(0);
		}
	}
	else
	{
			if(  ((reglist16 >> 13)&1) == 1 )
			{
 				if(!cpu->IntLoadWord(14,loadAddress++)) // load LR
					return false;      
			}
			if(  ((reglist16 >> 14)&1) == 1 )
			{
 				if(!cpu->IntLoadWord(13,loadAddress++)) // load SP
					return false;
			}
			if(  ((reglist16 >> 12)&1) == 1 )
			{
 				if(!cpu->IntLoadWord(12,loadAddress++)) // load R12
					return false; 
			}
			for(int i=15;i>=0;i--)                           // for R11 to R0
			{
				if( ((reglist16 >> i)&1)==1 )           // if reglist ==1
				{
					if(!cpu->IntLoadWord(i,loadAddress++)) // load Ri
						return false;
				}		
			}
			if(postinc==1)
			{
				if(p==pc) cpu->SetGPR(13,loadAddress);
				else cpu->SetGPR(rp,loadAddress);	
			}
	} 	

	return true;
}

ldm.disasm={

	os << "ldm\tr" << (unsigned int)rp << "{++}," << std::hex <<(unsigned int)reglist16 << endl;
}


//LDMTS load multiple registers for atsk switch

op ldmts(0b111[3]:0b001[3]:postinc[1]:0b11100[5]:rp[4]:><:reglist16[16])

ldmts.execute={
	
	//Emtpy Reglist16 gives UNDEFINED result.
	if(reglist16==0) return false;
	//PC in Reglist16 gives UNDEFINED result.
	if( (reglist16 & 1) == 1) return false;

	uint32_t loadAddress = cpu->GetGPR(rp);

	for(int i=15;i>=0;i--)                // for R15 to R0
	{
		if( ((reglist16 >>i)&1) == 1 ) // if reglist=1
		{
			if(!cpu->IntLoadWord(i,loadAddress++)) // Load Ri
				return false;	
		}
	}
	
	if(postinc==1) cpu->SetGPR(rp,loadAddress);

	return true;
}

ldmts.disasm={

	os << "ldmts\tr" << (unsigned int)rp << "{++}," << std::hex <<(unsigned int)reglist16 << endl;
}
 
// POPM - pop multiple registers from stack

op popm(0b110[3]:0b1[1]:reglist8[8]:k[1]:0b010[3])

// reglist8 = {R0-R3,R4-R7,R8-R9,R10-R11,R12,LR,PC}

popm.execute={
	
	uint32_t sp = cpu->GetGPR(13);
	
	if( ( ((reglist8>>7) &1) && k ) == 1 )     // if reglist8[PC]=1 and k=1
	{
		if(!cpu->IntLoadWord(15,sp++))     // load PC
			return false;

		if( ((reglist8>>5)&3)==0b00 )      // if reglist[LR,R12]=00
			cpu->SetGPR(12,0);         // set 0 in R12
		
		else if( ((reglist8>>5)&3)==0b01 ) // if reglist[LR,R12]=01
			cpu->SetGPR(12,1);         // set 1

		else cpu->SetGPR(12,-1);           // set -1

		uint32_t res=cpu->GetGPR(12);      // test r12 and update flags  
		cpu->SetSR_V(0);
		cpu->SetSR_N((int32_t)res<0);
		cpu->SetSR_Z(res==0);
		cpu->SetSR_C(0);
	}
	else
	{
		if(((reglist8 >>7)&1)==1)               // if reglist[PC]=1
		{
			if(!cpu->IntLoadWord(15,sp++))  // load PC
				return false;
		}
		if(((reglist8>>6) &1)==1) 		// if reglist[LR]=1
		{
			if(!cpu->IntLoadWord(14,sp++))  // load LR
				return false;
		}
		if(((reglist8>>5) &1)==1)		// if reglist[R12]=1
		{
			if(!cpu->IntLoadWord(12,sp++))  // load R12
				return false;
		}
		if(((reglist8 >>7)&1) == 1)		// if reglist[PC]=1
		{
			uint32_t res=cpu->GetGPR(12);   // test r12 and update flags
			cpu->SetSR_V(0);
			cpu->SetSR_N((int32_t)res < 0);
			cpu->SetSR_Z(res == 0);
			cpu->SetSR_C(0);	
		}
	
	}
	if(((reglist8>>4) &1)==1)
		{
			if(!cpu->IntLoadWord(11,sp++))  // load R11
				return false;
		}
	if(((reglist8>>3) &1)==1)
		{
			if(!cpu->IntLoadWord(10,sp++))  // load R10
				return false;
		}
	if(((reglist8>>2) &1)==1)
		{
			if(!cpu->IntLoadWord(9,sp++))  // load R9
				return false;
			if(!cpu->IntLoadWord(8,sp++))  // load R8
				return false;
		}
	if(((reglist8>>1) &1)==1)
		{
			if(!cpu->IntLoadWord(7,sp++)) // load R7
				return false;
			if(!cpu->IntLoadWord(6,sp++)) // load R6
				return false;
			if(!cpu->IntLoadWord(5,sp++)) // load R5
				return false;
			if(!cpu->IntLoadWord(4,sp++)) // load R4
				return false;
		}
	if((reglist8 &1)==1)
		{
			if(!cpu->IntLoadWord(3,sp++))  // load R3
				return false;
			if(!cpu->IntLoadWord(2,sp++))  // load R2
				return false;
			if(!cpu->IntLoadWord(1,sp++))  // load R1
				return false;
			if(!cpu->IntLoadWord(0,sp++))  // load R0
				return false;
		}
	cpu->SetGPR(13,sp);
	
	return true;
}

popm.disasm={
	os << "popm\t" << std::hex <<(unsigned int)reglist8 << endl;
}

// PUSHM - push multiple registers to stack

op pushm(0b110[3]:0b1[1]:reglist8[8]:0b0001[4])

pushm.execute={

	uint32_t sp= cpu->GetGPR(13);
	
	if( (reglist8 & 1)==1 )
	{
		if(!cpu->IntStoreWord(0,--sp)) return false;
		if(!cpu->IntStoreWord(1,--sp)) return false;
		if(!cpu->IntStoreWord(2,--sp)) return false;
		if(!cpu->IntStoreWord(3,--sp)) return false;
	}
	if( ((reglist8>>1) & 1)==1 )
	{
		if(!cpu->IntStoreWord(4,--sp)) return false;
		if(!cpu->IntStoreWord(5,--sp)) return false;
		if(!cpu->IntStoreWord(6,--sp)) return false;
		if(!cpu->IntStoreWord(7,--sp)) return false;
	}
	if( ((reglist8>>2) & 1)==1 )
	{
		if(!cpu->IntStoreWord(8,--sp)) return false;
		if(!cpu->IntStoreWord(9,--sp)) return false;
	}
	if( ((reglist8>>3) & 1)==1 )
	{
		if(!cpu->IntStoreWord(10,--sp)) return false;

	}
	if( ((reglist8>>4) & 1)==1 )
	{
		if(!cpu->IntStoreWord(11,--sp)) return false;
	}
	if( ((reglist8>>5) & 1)==1 )
	{
		if(!cpu->IntStoreWord(12,--sp)) return false;
	}
	if( ((reglist8>>6) & 1)==1 )
	{
		if(!cpu->IntStoreWord(14,--sp)) return false;
	}
	if( ((reglist8>>7) & 1)==1 )
	{
		if(!cpu->IntStoreWord(15,--sp)) return false;
	}
	cpu->SetGPR(13,sp);
	return true;
}

pushm.disasm={
	os << "pushm\t" << std::hex <<(unsigned int)reglist8 << endl;
}

// STM - store multiple registers

op stm(0b111[3]:0b010[3]:predec[1]:0b11100[5]:rp[4]:><:reglist16[16])

stm.execute={

	//Emtpy Reglist16 gives UNDEFINED result.
	if(reglist16==0) return false;
	//PC in Reglist16 gives UNDEFINED result.
	if( (reglist16 & 1) == 1) return false;

	uint32_t storeAddress= cpu->GetGPR(rp);

	if(predec==1)
	{
		for(int i=0;i<16;i++)
		{
			if( ((reglist16 >> i)&1) == 1 )
				if(!cpu->IntStoreWord(i,--storeAddress)) return false;
		}
		cpu->SetGPR(rp,storeAddress);
	}
	else
	{
		for(int i=15;i>=0;i--)
		{
			if( ((reglist16 >> i)&1) == 1 )
				if(!cpu->IntStoreWord(i,storeAddress++)) return false;
		}
	}
	return true;
}

stm.disasm={

	os << "stm\t{--}r" <<(unsigned int)rp << "," <<std::hex << (unsigned int)reglist16 << endl; 

}

// STMTS - store multiple registers for task switch

op stmts(0b111[3]:0b011[3]:predec[1]:0b11100[5]:rp[4]:><:reglist16[16])

stmts.execute={

	//Emtpy Reglist16 gives UNDEFINED result.
	if(reglist16==0) return false;
	//PC in Reglist16 gives UNDEFINED result.
	if( (reglist16 & 1) == 1) return false;

	uint32_t storeAddress= cpu->GetGPR(rp);

	if(predec==1)
	{
		for(int i=0;i<16;i++)
		{
			if( ((reglist16 >> i)&1) == 1 )
				if(!cpu->IntStoreWord(i,--storeAddress)) return false;
		}
		cpu->SetGPR(rp,storeAddress);
	}
	else
	{
		for(int i=15;i>=0;i--)
		{
			if( ((reglist16 >> i)&1) == 1 )
				if(!cpu->IntStoreWord(i,storeAddress++)) return false;
		}
	}
	return true;
}


stmts.disasm={

	os << "stmts\t{--}r" << (unsigned int)rp << "," << std::hex << (unsigned int)reglist16 << endl; 

}

