//AND - logical and with optional logical shift

op and_a(0b000[3]:rs[4]:0b00110[5]:rd[4])

and_a.execute={

	uint32_t d=cpu->GetGPR(rd);
	uint32_t s=cpu->GetGPR(rs);

	uint32_t result=d & s;
	uint8_t neg= (int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);

	return true;
	
}

and_a.disasm={
	os << "and_a\tr" << (unsigned int)rd << ",r" << (unsigned int)rs << endl; 
}

op and_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0000000[7]:sa5[5]:rd[4])

and_b.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);

	uint32_t result=x & ShiftLeft(y,(unsigned int)sa5);
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	
	return true;
}

and_b.disasm={
	os << "and_b\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry <<  "<<0x" << std::hex <<(int)sa5 << endl; 
}

op and_c(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0000001[7]:sa5[5]:rd[4])

and_c.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);

	uint32_t result=x & ShiftRight(y,(unsigned int)sa5); 
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	
	return true;
}

and_c.disasm={
	os << "and_c\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry <<  ">>0x" << std::hex << (int)sa5 << endl; 
}



//AND_CON4 condiotionnal and

op and_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0010[4]:rd[4])

and_cond4.execute={

	if(cond4)  // representation de cond4
	{
		uint32_t x=cpu->GetGPR(rx);
		uint32_t y=cpu->GetGPR(ry);
		
		uint32_t result= x & y;

		cpu->SetGPR(rd,result);
		
		//flag not affected		
	}
	return true;
}


and_cond4.disasm={
	os << "and_cond4\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << endl; 
}

//ANDN - logical and not

op andn(0b000[3]:rs[4]:0b01000[5]:rd[4])

andn.execute={                                                         

	uint32_t d=cpu->GetGPR(rd);
	uint32_t s=cpu->GetGPR(rs);

	uint32_t result= d & ~s;
	uint8_t neg= (int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	
	return true;	
}


andn.disasm={
	os << "andn\tr" << (unsigned int) rd << ",r" << (unsigned int)rs<< endl; 
}

//ANDH/L - logical and into hight or low half to register   // utiliser al specialisation pour coh=0 ou 1

op andh(0b111[3]:0b00[2]:0b1[1]:coh[1]:0b00001[5]:rd[4]:><:imm16[16])

andh.execute={                                                                // !!!  IMPLEMENTATION A VERIFIER

	uint32_t d=cpu->GetGPR(rd);

	uint32_t d_h= (d & 0xFFFF0000) & ((uint32_t)imm16 << 16);
	uint32_t result;

	if(coh==0)
	{
		result= d_h | (d & 0x0000FFFF);  // preserve rd[15:0]    
	}
	else
        {
		result=d_h;                    // clear rd[15:0]
	}
	uint8_t neg=(int32_t)result <0;
	uint8_t zero=result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);

	return true;
}

andh.disasm={
	os << "andh\tr" << (unsigned int)rd << ",0x" << std::hex <<(int)imm16 << ( coh ? ",coh" : "") << endl;
}

op andl(0b111[3]:0b00[2]:0b0[1]:coh[1]:0b00001[5]:rd[4]:><:imm16[16])

andl.execute={ 							// !!!  IMPLEMENTATION A VERIFIER

	uint32_t d=cpu->GetGPR(rd);

	uint32_t d_l= (d & 0x0000FFFF) & ((uint32_t)imm16 );
	uint32_t result;

	if(coh==0)
	{
		result= (d & 0xFFFF0000) | d_l; // preserve rd[15:0]          
	}
	else
        {
		result=d_l;                    // clear rd[15:0]
	}
	uint8_t neg=(int32_t)result <0;
	uint8_t zero=result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);

	return true;
}


andl.disasm={
	os << "andl\tr" <<(unsigned int) rd << ",0x" << std::hex << (int) imm16 << ( coh ? ",coh" : "" ) << endl;
}


// COM - one's compliment

op com(0b010[3]:0b1110[4]:0b01101[5]:rd[4])

com.execute={
	
	uint32_t d= cpu->GetGPR(rd);

	uint32_t result= ~d;
	uint8_t zero= result ==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_Z(zero);

	return true;
	
}

com.disasm={

	os << "com\tr" << (unsigned int)rd << endl;
}

//EOR - logical exclusive or with optional logical shift

op eor_a(0b000[3]:rs[4]:0b00101[5]:rd[4])

eor_a.execute={

	uint32_t d=cpu->GetGPR(rd);
	uint32_t s=cpu->GetGPR(rs);

	uint32_t result= (d & ~s) | (~d | s);
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	
	return true;
}

eor_a.disasm={
	os << "eor_a\tr" << (unsigned int)rd << ",r" << (unsigned int)rs << endl;
}

op eor_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0010000[7]:sa5[5]:rd[4])

eor_b.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);

	uint32_t result=(x & ShiftLeft(y,(unsigned int)sa5)) | (~x & ShiftLeft(y, (unsigned int)sa5));
	uint8_t neg= (int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	
	return true;
}

eor_b.disasm={
	os << "eor_b\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << "<<0x" <<std::hex << (int)sa5 <<endl;
}


op eor_c(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0010001[7]:sa5[5]:rd[4])

eor_c.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);

	uint32_t result=(x & ShiftRight(y,(unsigned int)sa5)) | (~x & ShiftRight(y, (unsigned int)sa5)); 
	uint8_t neg=(int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	
	return true;
}


eor_c.disasm={

	os << "eor_c\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << ">>0x"<< std::hex << (int)sa5 <<endl;
}


//EOR_COND4 -  conditional logical EOR

op eor_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0100[4]:rd[4])

eor_cond4.execute={

	if(cond4)
	{
   		uint32_t x=cpu->GetGPR(rx);
		uint32_t y=cpu->GetGPR(ry);
		
		uint32_t result= (x & ~y) | (~x & y);

		cpu->SetGPR(rd,result);
		
	}
	return true;
}

eor_cond4.disasm={

	os << "eor_cond4\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << endl;
}


//EORH - logical EOR into hight half register

op eorh(0b111[3]:0b011100001[9]:rd[4]:><:imm16[16])

eorh.execute={                                                             

	uint32_t d=cpu->GetGPR(rd);

	uint32_t d_h= ((d & 0xFFFF0000) & ~((uint32_t)imm16 << 16) ) |( ~(d & 0xFFFF0000) & ((uint32_t)imm16 << 16));
	uint32_t result= d_h | (d & 0x0000FFFF);     
	uint8_t neg=(int32_t)result <0;
	uint8_t zero=result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);

	return true;
}

eorh.disasm={
	os << "eorh\tr" << (unsigned int)rd << ",0x" <<std::hex<< (int)imm16 << endl;
}

//EORL - logical EOR into low half register

op eorl(0b111[3]:0b011000001[9]:rd[4]:><:imm16[16])

eorl.execute={ 							// !!!  IMPLEMENTATION A VERIFIER

	uint32_t d=cpu->GetGPR(rd);

	uint32_t d_l= ((d & 0x0000FFFF) & ~(uint32_t)imm16 ) | ( ~(d & 0x0000FFFF) & (uint32_t)imm16 );
	

	uint32_t result= (d & 0xFFFF0000) | d_l;         
	uint8_t neg=(int32_t)result <0;
	uint8_t zero=result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);

	return true;
}


eorl.disasm={
	os << "eorl\tr" << (unsigned int)rd << ",r" << std::hex <<(int )imm16 << endl;
}

//OR - logical or with optional logical shift

op or_a(0b000[3]:rs[4]:0b00100[5]:rd[4])

or_a.execute={

	uint32_t d=cpu->GetGPR(rd);
	uint32_t s=cpu->GetGPR(rs);

	uint32_t result= d | s;
	uint8_t neg= (int32_t)result <0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	
	return true;
}

or_a.disasm={
	os << "or_a\tr" << (unsigned int)rd << ",r" << (unsigned int)rs << endl;
}

op or_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0001000[7]:sa5[5]:rd[4])

or_b.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);

	uint32_t result=x | ShiftLeft(y,(unsigned int)sa5);
	uint8_t neg= (int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	
	return true;
}

or_b.disasm={
	os << "or_b\tr" << (unsigned int) rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << "<<0x" << std::hex<<(int) sa5 <<endl;
}

op or_c(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0001001[7]:sa5[5]:rd[4])

or_c.execute={

	uint32_t x=cpu->GetGPR(rx);
	uint32_t y=cpu->GetGPR(ry);

	uint32_t result=x | ShiftRight(y,(unsigned int)sa5); 
	uint8_t neg=(int32_t)result < 0;
	uint8_t zero= result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);
	
	return true;
}

or_c.disasm={
	os << "or_c\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << ">>0x" << std::hex << (int)sa5 << endl;
}


//OR_COND4 - conditional logical OR

op or_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0011[4]:rd[4])

or_cond4.execute={

	if(cond4)  // representation de cond4
	{
		uint32_t x= cpu->GetGPR(rx);
		uint32_t y=cpu->GetGPR(ry);

		uint32_t result= x | y;

		cpu->SetGPR(rd,result);
		//flag not affected		
	}
	return true;
}

or_cond4.disasm={
	os << "or_cond4\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << endl;
}

//ORH - logical OR into hight half register

op orh(0b111[3]:0b010100001[9]:rd[4]:><:imm16[16])

orh.execute={                                                                

	uint32_t d=cpu->GetGPR(rd);

	uint32_t d_h= (d & 0xFFFF0000) | ((uint32_t)imm16 << 16);
	uint32_t result= d_h | (d & 0x0000FFFF);     
	uint8_t neg=(int32_t)result <0;
	uint8_t zero=result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);

	return true;
}


orh.disasm={
	os << "orh\tr" << (unsigned int)rd << ",0x" << std::hex << (int)imm16 << endl;
}

//ORL- logical OR into low

op orl(0b111[3]:0b010000001[9]:rd[4]:><:imm16[16])

orl.execute={ 							

	uint32_t d=cpu->GetGPR(rd);

	uint32_t d_l= (d & 0x0000FFFF) | ((uint32_t)imm16 );
	

	uint32_t result= (d & 0xFFFF0000) | d_l;         
	uint8_t neg=(int32_t)result <0;
	uint8_t zero=result==0;

	cpu->SetGPR(rd,result);

	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);

	return true;
}

orl.disasm={
	os << "orl\tr" << (unsigned int)rd << ",r" << std::hex << (int)imm16 << endl;
}


// TST- test register

op tst(0b000[3]:rs[4]:0b00111[5]:rd[4])

tst.execute={

	uint32_t s=cpu->GetGPR(rs);
	uint32_t d=cpu->GetGPR(rd);

	uint32_t result= d & s;
	uint8_t neg= (uint32_t)result<0;
	uint8_t zero= result==0;

	//no write back
	cpu->SetSR_N(neg);
	cpu->SetSR_Z(zero);

	return true;
}

tst.disasm={
	os << "tst\tr" << (unsigned int)rd << ",r" << (unsigned int)rs << endl;
}


