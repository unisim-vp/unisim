//AND - logical and with optional logical shift

op and_a(0b000[3]:rs[4]:0b00110[5]:rd[4])

and_a.disasm={
	os << "and_a\tr" << (unsigned int)rd << ",r" << (unsigned int)rs << endl; 
}

op and_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0000000[7]:sa5[5]:rd[4])

and_b.disasm={
	os << "and_b\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry <<  "<<0x" << std::hex <<(int)sa5 << endl; 
}

op and_c(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0000001[7]:sa5[5]:rd[4])

and_c.disasm={
	os << "and_c\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry <<  "<<0x" << std::hex << (int)sa5 << endl; 
}

//AND_CON4 condiotionnal and

op and_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0010[4]:rd[4])

and_cond4.disasm={
	os << "and_cond4\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << endl; 
}

//ANDN - logical and not

op andn(0b000[3]:rs[4]:0b01000[5]:rd[4])

andn.disasm={
	os << "andn\tr" << (unsigned int) rd << ",r" << (unsigned int)rs<< endl; 
}

//ANDH/L - logical and into hight or low half to register

op andh(0b111[3]:0b00[2]:0b1[1]:coh[1]:0b00001[5]:rd[4]:><:imm16[16])

andh.disasm={
	os << "andh\tr" << (unsigned int)rd << ",0x" << std::hex <<(int)imm16 << ",COH" << endl;
}

op andl(0b111[3]:0b00[2]:0b0[1]:coh[1]:0b00001[5]:rd[4]:><:imm16[16])

andl.disasm={
	os << "andl\tr" <<(unsigned int) rd << ",0x" << std::hex << (int) imm16 << ",COH" << endl;
}


// COM - one's compliment

op com(0b010[3]:0b1110[4]:0b01101[5]:rd[4])

com.disasm={

	os << "com\tr" << (unsigned int)rd << endl;
}

//EOR - logical exclusive or with optional logical shift

op eor_a(0b000[3]:rs[4]:0b00101[5]:rd[4])

eor_a.disasm={
	os << "eor_a\tr" << (unsigned int)rd << ",r" << (unsigned int)rs << endl;
}

op eor_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0010000[7]:sa5[5]:rd[4])

eor_b.disasm={
	os << "eor_b\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << "<<0x" <<std::hex << (int)sa5 <<endl;
}


op eor_c(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0010001[7]:sa5[5]:rd[4])

eor_c.disasm={

	os << "eor_c\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << ">>0x"<< std::hex << (int)sa5 <<endl;
}


//EOR_COND4 -  conditional logical EOR

op eor_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0100[4]:rd[4])

eor_cond4.disasm={

	os << "eor_cond4\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << endl;
}


//EORH - logical EOR into hight half register

op eorh(0b111[3]:0b011100001[9]:rd[4]:><:imm16[16])

eorh.disasm={
	os << "eorh\tr" << (unsigned int)rd << ",0x" <<std::hex<< (int)imm16 << endl;
}

//EORL - logical EOR into low half register

op eorl(0b111[3]:0b011000001[9]:rd[4]:><:imm16[16])

eorl.disasm={
	os << "eorl\tr" << (unsigned int)rd << ",r" << std::hex <<(int )imm16 << endl;
}

//OR - logical or with optional logical shift

op or_a(0b000[3]:rs[4]:0b00100[5]:rd[4])

or_a.disasm={
	os << "or_a\tr" << (unsigned int)rd << ",r" << (unsigned int)rs << endl;
}

op or_b(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0001000[7]:sa5[5]:rd[4])

or_b.disasm={
	os << "or_b\tr" << (unsigned int) rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << "<<0x" << std::hex<<(int) sa5 <<endl;
}

op or_c(0b111[3]:rx[4]:0b11110[5]:ry[4]:><:0b0001001[7]:sa5[5]:rd[4])

or_c.disasm={
	os << "or_c\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << ">>0x" << std::hex << (int)sa5 << endl;
}


//OR_COND4 - conditional logical OR

op or_cond4(0b111[3]:rx[4]:0b11101[5]:ry[4]:><:0b1110[4]:cond4[4]:0b0011[4]:rd[4])

or_cond4.disasm={
	os << "or_cond4\tr" << (unsigned int)rd << ",r" << (unsigned int)rx << ",r" << (unsigned int)ry << endl;
}

//ORH - logical OR into hight half register

op orh(0b111[3]:0b010100001[9]:rd[4]:><:imm16[16])

orh.disasm={
	os << "orh\tr" << (unsigned int)rd << ",0x" << std::hex << (int)imm16 << endl;
}

//ORL- logical OR into low half register

op orl(0b111[3]:0b010000001[9]:rd[4]:><:imm16[16])

orl.disasm={
	os << "orl\tr" << (unsigned int)rd << ",r" << std::hex << (int)imm16 << endl;
}


// TST- test register

op tst(0b000[3]:rs[4]:0b00111[5]:rd[4])

tst.disasm={
	os << "tst\tr" << (unsigned int)rd << ",r" << (unsigned int)rs << endl;
}


