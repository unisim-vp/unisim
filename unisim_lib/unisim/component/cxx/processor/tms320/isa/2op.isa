/*
 *  Copyright (c) 2009,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 *          Gilles Mouchard (gilles.mouchard@cea.fr)
 */

/* List of 2 operands operations:
 * - ABSF         absolute value of a floating-point number
 * - ABSI         absolute value of an integer
 * - ADDC         add integers with carry
 * - ADDF         add floating-point values
 * - ADDI         add integers
 * - AND          bitwise-logical AND
 * - ANDN         bitwise-logical AND with complement
 * - ASH          arithmetic shift
 * - CMPF         compare floating-point values
 * - CMPI         compare integers
 * - FIX          convert floating-point value to integer
 * - FLOAT        convert integer to floating-point value
 * - LSH          logical shift
 * - MPYF         multiply floating-point values
 * - MPYI         multiply integers
 * - NEGB         negate integer with borrow
 * - NEGF         negate floating-point value
 * - NEGI         negate integer
 * - NORM         normalize floating-point value
 * - NOT          bitwise-logical complement
 * - OR           bitwise-logical OR
 * - RND          round floating-point value
 * - ROL          rotate left
 * - ROLC         rotate left through carry
 * - ROR          rotate right
 * - RORC         rotate right through carry
 * - SUBB         subtract integers with borrow
 * - SUBC         subtract integers conditionally
 * - SUBF         subtract floating-point values
 * - SUBI         subtract integer
 * - SUBRB        subtract reverse integer with borrow
 * - SUBRF        subtract reverse floating-point value
 * - SUBRI        subtract reverse integer
 * - TSTB         test bit fields
 * - XOR          bitwise-exclusive OR
 */

/**********************************************************
 * ABSF (absolute value of a floating-point number)
 * op ABSF(0b000[3]:0b000000[6]:g[2]:dst[5]:src[16])
 */
 
op ABSF_reg  (0b000[3]:0b000000[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op ABSF_dir  (0b000[3]:0b000000[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op ABSF_indir(0b000[3]:0b000000[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op ABSF_imm  (0b000[3]:0b000000[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

ABSF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ABSF " << src_name << ", " << dst_name;
	return true;
}

ABSF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "ABSF @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

ABSF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "ABSF " << disasm_src_indir << ", " << dst_name;
	return true;
}

ABSF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ABSF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

/* end of ABSF (absolute value of a floating-point number)
 **********************************************************/

/**********************************************************
 * ABSI (absolute value of an integer)
 * op ABSI(0b000[3]:0b000001[6]:g[2]:dst[5]:src[16])
 */
 
op ABSI_reg  (0b000[3]:0b000001[6]:0b00[2]:dst[5]:0[11]:src[5])
op ABSI_dir  (0b000[3]:0b000001[6]:0b01[2]:dst[5]:direct[16])
op ABSI_indir(0b000[3]:0b000001[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ABSI_imm  (0b000[3]:0b000001[6]:0b11[2]:dst[5]:sext<32> imm[16])

ABSI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ABSI " << src_name << ", " << dst_name;
	return true;
}

ABSI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "ABSI @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

ABSI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "ABSI " << disasm_src_indir << ", " << dst_name;
	return true;
}

ABSI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ABSI " << imm << ", " << dst_name;
	return true;
}

/* end of ABSI (absolute value of an integer)
 **********************************************************/

/**********************************************************
 * ADDC (add integers with carry)
 * op ADDC(0b000[3]:0b000010[6]:g[2]:dst[5]:src[16])
 */

op ADDC_reg  (0b000[3]:0b000010[6]:0b00[2]:dst[5]:0[11]:src[5])
op ADDC_dir  (0b000[3]:0b000010[6]:0b01[2]:dst[5]:direct[16])
op ADDC_indir(0b000[3]:0b000010[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ADDC_imm  (0b000[3]:0b000010[6]:0b11[2]:dst[5]:sext<32> imm[16])

ADDC_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ADDC " << src_name << ", " << dst_name;
	return true;
}

ADDC_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "ADDC @0x" << hex << direct << dec << ", " << dst_name;
	
	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

ADDC_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "ADDC " << disasm_src_indir << ", " << dst_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

ADDC_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ADDC " << imm << ", " << dst_name;
	return true;
}

ADDC_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatAdd32(result, carry_out, overflow, dst_value, src_value, carry_in);
	else
		Add32(result, carry_out, overflow, dst_value, src_value, carry_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			carry_out,
			overflow
		);
	}
}

ADDC_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatAdd32(result, carry_out, overflow, dst_value, src_value, carry_in);
	else
		Add32(result, carry_out, overflow, dst_value, src_value, carry_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			carry_out,
			overflow
		);
	}
}

ADDC_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatAdd32(result, carry_out, overflow, dst_value, src_value, carry_in);
	else
		Add32(result, carry_out, overflow, dst_value, src_value, carry_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			carry_out,
			overflow
		);
	}
}

ADDC_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatAdd32(result, carry_out, overflow, dst_value, imm, carry_in);
	else
		Add32(result, carry_out, overflow, dst_value, imm, carry_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			carry_out,
			overflow
		);
	}
}

/* end of ADDC (add integers with carry)
 **********************************************************/

/**********************************************************
 * ADDF (add floating-point values)
 * op ADDF(0b000[3]:0b000011[6]:g[2]:dst[5]:src[16])
 */

op ADDF_reg  (0b000[3]:0b000011[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op ADDF_dir  (0b000[3]:0b000011[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op ADDF_indir(0b000[3]:0b000011[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op ADDF_imm  (0b000[3]:0b000011[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

ADDF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ADDF " << src_name << ", " << dst_name;
	return true;
}

ADDF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "ADDF @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

ADDF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "ADDF " << disasm_src_indir << ", " << dst_name;
	return true;
}

ADDF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ADDF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}


/* end of ADDF (add floating-point values)
 **********************************************************/

/**********************************************************
 * ADDI (add integers)
 * op ADDI(0b000[3]:0b000100[6]:g[2]:dst[5]:src[16])
 */

op ADDI_reg  (0b000[3]:0b000100[6]:0b00[2]:dst[5]:0[11]:src[5])
op ADDI_dir  (0b000[3]:0b000100[6]:0b01[2]:dst[5]:direct[16])
op ADDI_indir(0b000[3]:0b000100[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ADDI_imm  (0b000[3]:0b000100[6]:0b11[2]:dst[5]:sext<32> imm[16])

ADDI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ADDI " << src_name << ", " << dst_name;
	return true;
}

ADDI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "ADDI @0x" << hex << direct << dec << ", " << dst_name;
	
	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

ADDI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "ADDI " << disasm_src_indir << ", " << dst_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

ADDI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ADDI " << imm << ", " << dst_name;
	return true;
}

ADDI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatAdd32(result, carry_out, overflow, dst_value, src_value, 0);
	else
		Add32(result, carry_out, overflow, dst_value, src_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			carry_out,
			overflow
		);
	}
}

ADDI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatAdd32(result, carry_out, overflow, dst_value, src_value, 0);
	else
		Add32(result, carry_out, overflow, dst_value, src_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			carry_out,
			overflow
		);
	}
}

ADDI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatAdd32(result, carry_out, overflow, dst_value, src_value, 0);
	else
		Add32(result, carry_out, overflow, dst_value, src_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			carry_out,
			overflow
		);
	}
}

ADDI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatAdd32(result, carry_out, overflow, dst_value, imm, 0);
	else
		Add32(result, carry_out, overflow, dst_value, imm, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			carry_out,
			overflow
		);
	}
}

/* end of ADDI (add integers)
 **********************************************************/

/**********************************************************
 * AND (bitwise-logical AND)
 * op AND(0b000[3]:0b000101[6]:g[2]:dst[5]:src[16])
 */

op AND_reg  (0b000[3]:0b000101[6]:0b00[2]:dst[5]:0[11]:src[5])
op AND_dir  (0b000[3]:0b000101[6]:0b01[2]:dst[5]:direct[16])
op AND_indir(0b000[3]:0b000101[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op AND_imm  (0b000[3]:0b000101[6]:0b11[2]:dst[5]:<32> imm[16])

AND_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "AND " << src_name << ", " << dst_name;
	return true;
}

AND_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "AND @0x" << hex << direct << dec << ", " << dst_name;
	
	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

AND_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "AND " << disasm_src_indir << ", " << dst_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

AND_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "AND " << imm << ", " << dst_name;
	return true;
}

AND_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = src_value & dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

AND_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value & dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

AND_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value & dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

AND_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = imm & dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

/* end of AND (bitwise-logical AND)
 **********************************************************/

/**********************************************************
 * ANDN (bitwise-logical AND with complement)
 * op ANDN(0b000[3]:0b000110[6]:g[2]:dst[5]:src[16])
 */

op ANDN_reg  (0b000[3]:0b000110[6]:0b00[2]:dst[5]:0[11]:src[5])
op ANDN_dir  (0b000[3]:0b000110[6]:0b01[2]:dst[5]:direct[16])
op ANDN_indir(0b000[3]:0b000110[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ANDN_imm  (0b000[3]:0b000110[6]:0b11[2]:dst[5]:<32> imm[16])

ANDN_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ANDN " << src_name << ", " << dst_name;
	return true;
}

ANDN_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "ANDN @0x" << hex << direct << dec << ", " << dst_name;
	
	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

ANDN_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "ANDN " << disasm_src_indir << ", " << dst_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

ANDN_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ANDN " << imm << ", " << dst_name;
	return true;
}

ANDN_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = ~src_value & dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

ANDN_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = ~src_value & dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

ANDN_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = ~src_value & dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

ANDN_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = ~imm & dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

/* end of ANDN (bitwise-logical AND with complement)
 **********************************************************/

/**********************************************************
 * ASH (arithmetic shift)
 * op ASH(0b000[3]:0b000111[6]:g[2]:dst[5]:count[16])
 */

op ASH_reg  (0b000[3]:0b000111[6]:0b00[2]:dst[5]:0[11]:src[5])
op ASH_dir  (0b000[3]:0b000111[6]:0b01[2]:dst[5]:direct[16])
op ASH_indir(0b000[3]:0b000111[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ASH_imm  (0b000[3]:0b000111[6]:0b11[2]:dst[5]:sext<32> imm[16])

ASH_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ASH " << src_name << ", " << dst_name;
	return true;
}

ASH_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "ASH @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

ASH_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "ASH " << disasm_src_indir << ", " << dst_name;
	return true;
}

ASH_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ASH " << imm << ", " << dst_name;
	return true;
}

ASH_reg.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t carry_out;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		carry_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			carry_out = 0;
		}
		else
		{
			result = ShiftLeft(dst_value, count, carry_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			carry_out = 0;
		}
		else
		{
			result = ShiftArithmeticRight(dst_value, count, carry_out);
		}
	}

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			carry_out
		);
	}
}

ASH_dir.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t carry_out;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		carry_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			carry_out = 0;
		}
		else
		{
			result = ShiftLeft(dst_value, count, carry_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			carry_out = 0;
		}
		else
		{
			result = ShiftArithmeticRight(dst_value, count, carry_out);
		}
	}

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			carry_out
		);
	}
}

ASH_indir.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t carry_out;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		carry_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			carry_out = 0;
		}
		else
		{
			result = ShiftLeft(dst_value, count, carry_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			carry_out = 0;
		}
		else
		{
			result = ShiftArithmeticRight(dst_value, count, carry_out);
		}
	}

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			carry_out
		);
	}
}

ASH_imm.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Sign extend the 7 LSB of the immediate value to get the shift count
	int32_t count = imm; // imm has alread been sign extended by the decoder

	// Compute the result
	uint8_t carry_out;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		carry_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			carry_out = 0;
		}
		else
		{
			result = ShiftLeft(dst_value, count, carry_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			carry_out = 0;
		}
		else
		{
			result = ShiftArithmeticRight(dst_value, count, carry_out);
		}
	}

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			carry_out
		);
	}
}

/* end of ASH (arithmetic shift)
 **********************************************************/

/**********************************************************
 * CMPF (compare floating-point values)
 * op CMPF(0b000[3]:0b001000[6]:g[2]:dst[5]:src[16])
 */

op CMPF_reg  (0b000[3]:0b001000[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op CMPF_dir  (0b000[3]:0b001000[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op CMPF_indir(0b000[3]:0b001000[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op CMPF_imm  (0b000[3]:0b001000[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

CMPF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "CMPF " << src_name << ", " << dst_name;
	return true;
}

CMPF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "CMPF @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

CMPF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "CMPF " << disasm_src_indir << ", " << dst_name;
	return true;
}

CMPF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "CMPF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

/* end of CMPF (compare floating-point values)
 **********************************************************/

/**********************************************************
 * CMPI (compare integers)
 * op CMPI(0b000[3]:0b001001[6]:g[2]:dst[5]:src[16])
 */

op CMPI_reg  (0b000[3]:0b001001[6]:0b00[2]:dst[5]:0[11]:src[5])
op CMPI_dir  (0b000[3]:0b001001[6]:0b01[2]:dst[5]:direct[16])
op CMPI_indir(0b000[3]:0b001001[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op CMPI_imm  (0b000[3]:0b001001[6]:0b11[2]:dst[5]:sext<32> imm[16])

CMPI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "CMPI " << src_name << ", " << dst_name;
	return true;
}

CMPI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "CMPI @0x" << hex << direct << dec << ", " << dst_name;
	
	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

CMPI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "CMPI " << disasm_src_indir << ", " << dst_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

CMPI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "CMPI " << imm << ", " << dst_name;
	return true;
}

CMPI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	Sub32(result, borrow_out, overflow, dst_value, src_value, 0);

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
		M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
		borrow_out,
		overflow
	);
}

CMPI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	Sub32(result, borrow_out, overflow, dst_value, src_value, 0);

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
		M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
		borrow_out,
		overflow
	);
}

CMPI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	Sub32(result, borrow_out, overflow, dst_value, src_value, 0);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
		M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
		borrow_out,
		overflow
	);
}

CMPI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	Sub32(result, borrow_out, overflow, dst_value, imm, 0);

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
		M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
		borrow_out,
		overflow
	);
}

/* end of CMPI (compare integers)
 **********************************************************/

/**********************************************************
 * FIX (convert floating-point value to integer)
 * op FIX(0b000[3]:0b001010[6]:g[2]:dst[5]:src[16])
 */

op FIX_reg  (0b000[3]:0b001010[6]:0b00[2]:dst[5]:0[11]:0b00[2]:src[3])
op FIX_dir  (0b000[3]:0b001010[6]:0b01[2]:dst[5]:direct[16])
op FIX_indir(0b000[3]:0b001010[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op FIX_imm  (0b000[3]:0b001010[6]:0b11[2]:dst[5]:imm[16])

FIX_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "FIX " << src_name << ", " << dst_name;
	return true;
}

FIX_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "FIX @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

FIX_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "FIX " << disasm_src_indir << ", " << dst_name;
	return true;
}

FIX_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "FIX " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

/* end of FIX (convert floating-point value to integer)
 **********************************************************/

/**********************************************************
 * FLOAT (convert integer to floating-point value)
 * op FLOAT(0b000[3]:0b001011[6]:g[2]:dst[5]:src[16])
 */

op FLOAT_reg  (0b000[3]:0b001011[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op FLOAT_dir  (0b000[3]:0b001011[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op FLOAT_indir(0b000[3]:0b001011[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op FLOAT_imm  (0b000[3]:0b001011[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

FLOAT_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "FLOAT " << src_name << ", " << dst_name;
	return true;
}

FLOAT_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "FLOAT @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

FLOAT_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "FLOAT " << disasm_src_indir << ", " << dst_name;
	return true;
}

FLOAT_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "FLOAT " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

/* end of FLOAT (convert integer to floating-point value)
 **********************************************************/

/**********************************************************
 * LSH (logical shift)
 * op LSH(0b000[3]:0b010011[6]:g[2]:dst[5]:count[16])
 */

op LSH_reg  (0b000[3]:0b010011[6]:0b00[2]:dst[5]:0[11]:src[5])
op LSH_dir  (0b000[3]:0b010011[6]:0b01[2]:dst[5]:direct[16])
op LSH_indir(0b000[3]:0b010011[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op LSH_imm  (0b000[3]:0b010011[6]:0b11[2]:dst[5]:?[9]:sext<32> imm[7])

LSH_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "LSH " << src_name << ", " << dst_name;
	return true;
}

LSH_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "LSH @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

LSH_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "LSH " << disasm_src_indir << ", " << dst_name;
	return true;
}

LSH_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "LSH " << imm << ", " << dst_name;
	return true;
}

LSH_reg.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t bit_out;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		bit_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			bit_out = 0;
		}
		else
		{
			result = ShiftLeft(dst_value, count, bit_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			bit_out = 0;
		}
		else
		{
			result = ShiftRight(dst_value, count, bit_out);
		}
	}

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			bit_out
		);
	}
}

LSH_dir.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t bit_out;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		bit_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			bit_out = 0;
		}
		else
		{
			result = ShiftLeft(dst_value, count, bit_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			bit_out = 0;
		}
		else
		{
			result = ShiftRight(dst_value, count, bit_out);
		}
	}

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			bit_out
		);
	}
}

LSH_indir.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t bit_out;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		bit_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			bit_out = 0;
		}
		else
		{
			result = ShiftLeft(dst_value, count, bit_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			bit_out = 0;
		}
		else
		{
			result = ShiftRight(dst_value, count, bit_out);
		}
	}

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			bit_out
		);
	}
}

LSH_imm.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Sign extend the 7 LSB of the immediate value to get the shift count
	int32_t count = imm; // imm has alread been sign extended by the decoder

	// Compute the result
	uint8_t bit_out;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		bit_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			bit_out = 0;
		}
		else
		{
			result = ShiftLeft(dst_value, count, bit_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			bit_out = 0;
		}
		else
		{
			result = ShiftRight(dst_value, count, bit_out);
		}
	}

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			bit_out
		);
	}
}

/* end of LSH (logical shift)
 **********************************************************/

/**********************************************************
 * MPYF (multiply floating-point values)
 * op MPYF(0b000[3]:0b010100[6]:g[2]:dst[5]:src[16])
 */

op MPYF_reg  (0b000[3]:0b010100[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op MPYF_dir  (0b000[3]:0b010100[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op MPYF_indir(0b000[3]:0b010100[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op MPYF_imm  (0b000[3]:0b010100[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

MPYF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "MPYF " << src_name << ", " << dst_name;
	return true;
}

MPYF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "MPYF @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

MPYF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "MPYF " << disasm_src_indir << ", " << dst_name;
	return true;
}

MPYF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "MPYF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

/* end of MPYF (multiply floating-point values)
 **********************************************************/

/**********************************************************
 * MPYI (multiply integers)
 * op MPYI(0b000[3]:0b010101[6]:g[2]:dst[5]:src[16])
 */

op MPYI_reg  (0b000[3]:0b010101[6]:0b00[2]:dst[5]:0[11]:src[5])
op MPYI_dir  (0b000[3]:0b010101[6]:0b01[2]:dst[5]:direct[16])
op MPYI_indir(0b000[3]:0b010101[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op MPYI_imm  (0b000[3]:0b010101[6]:0b11[2]:dst[5]:sext<32> imm[16])

MPYI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "MPYI " << src_name << ", " << dst_name;
	return true;
}

MPYI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "MPYI @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

MPYI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "MPYI " << disasm_src_indir << ", " << dst_name;
	return true;
}

MPYI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "MPYI " << imm << ", " << dst_name;
	return true;
}

MPYI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand and sign extend value from 24 bits to 64 bits
	int64_t src_value = SignExtend((uint64_t)(cpu.GetIntReg(src) & 0xffffff), 24);

	// Read destination operand and sign extend value from 24 bits to 64 bits
	int64_t dst_value = SignExtend((uint64_t)(cpu.GetIntReg(dst) & 0xffffff), 24);

	// Compute the 32-bit result and overflow
	int64_t result64 = src_value * dst_value;   // Only 48 bits are useful
	int32_t lo32 = (int32_t) result64;          // the 32 LSBs of the result
	int32_t hi32 = (int32_t) (result64 >> 32);  // the 32 MSBs of the result
	// An overflow occurs if any of the 32-bit MSB of the result differ from MSB of the 32-bit output value
	// An arithmetic shift of 31 bits is used to duplicate 32 times the MSB of lo32
	uint8_t overflow = ((lo32 >> 31) != hi32);
	uint32_t result;
	
	if(cpu.GetST_OVM() && overflow)
		result = (result64 < 0) ? 0x80000000 : 0x7fffffff; // Saturate the result
	else
		result = lo32;                                     // No saturation

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			0,
			overflow
		);
	}
}

MPYI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand and sign extend value from 24 bits to 64 bits
	int64_t dst_value = SignExtend((uint64_t)(cpu.GetIntReg(dst) & 0xffffff), 24);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory and sign extend value from 24 bits to 64 bits
	int64_t src_value = SignExtend((uint64_t)(cpu.IntLoad(ea) & 0xffffff), 24);

	// Compute the 32-bit result and overflow
	int64_t result64 = src_value * dst_value;   // Only 48 bits are useful
	int32_t lo32 = (int32_t) result64;          // the 32 LSBs of the result
	int32_t hi32 = (int32_t) (result64 >> 32);  // the 32 MSBs of the result
	// An overflow occurs if any of the 32-bit MSB of the result differ from MSB of the 32-bit output value
	// An arithmetic shift of 31 bits is used to duplicate 32 times the MSB of lo32
	uint8_t overflow = ((lo32 >> 31) != hi32);
	uint32_t result;
	
	if(cpu.GetST_OVM() && overflow)
		result = (result64 < 0) ? 0x80000000 : 0x7fffffff; // Saturate the result
	else
		result = lo32;                                     // No saturation

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			0,
			overflow
		);
	}
}

MPYI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand and sign extend value from 24 bits to 64 bits
	int64_t dst_value = SignExtend((uint64_t)(cpu.GetIntReg(dst) & 0xffffff), 24);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory and sign extend value from 24 bits to 64 bits
	uint32_t src_value = SignExtend((uint64_t)(cpu.IntLoad(ea) & 0xffffff), 24);

	// Compute the 32-bit result and overflow
	int64_t result64 = src_value * dst_value;   // Only 48 bits are useful
	int32_t lo32 = (int32_t) result64;          // the 32 LSBs of the result
	int32_t hi32 = (int32_t) (result64 >> 32);  // the 32 MSBs of the result
	// An overflow occurs if any of the 32-bit MSB of the result differ from MSB of the 32-bit output value
	// An arithmetic shift of 31 bits is used to duplicate 32 times the MSB of lo32
	uint8_t overflow = ((lo32 >> 31) != hi32);
	uint32_t result;
	
	if(cpu.GetST_OVM() && overflow)
		result = (result64 < 0) ? 0x80000000 : 0x7fffffff; // Saturate the result
	else
		result = lo32;                                     // No saturation

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			0,
			overflow
		);
	}
}

MPYI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand and sign extend value from 24 bits to 64 bits
	int64_t dst_value = SignExtend((uint64_t)(cpu.GetIntReg(dst) & 0xffffff), 24);

	// Compute the 32-bit result and overflow
	// Note: imm has been sign extended from 16 bits to 32 bits the decoder
	// Below, imm is sign extended from 32 bits to 64 bits
	int64_t result64 = imm * dst_value;         // Only 48 bits are useful
	int32_t lo32 = (int32_t) result64;          // the 32 LSBs of the result
	int32_t hi32 = (int32_t) (result64 >> 32);  // the 32 MSBs of the result
	// An overflow occurs if any of the 32-bit MSB of the result differ from MSB of the 32-bit output value
	// An arithmetic shift of 31 bits is used to duplicate 32 times the MSB of lo32
	uint8_t overflow = ((lo32 >> 31) != hi32);
	uint32_t result;
	
	if(cpu.GetST_OVM() && overflow)
		result = (result64 < 0) ? 0x80000000 : 0x7fffffff; // Saturate the result
	else
		result = lo32;                                     // No saturation

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			0,
			overflow
		);
	}
}

/* end of MPYI (multiply integers)
 **********************************************************/

/**********************************************************
 * NEGB (negate integer with borrow)
 * op NEGB(0b000[3]:0b010110[6]:g[2]:dst[5]:src[16])
 */

op NEGB_reg  (0b000[3]:0b010110[6]:0b00[2]:dst[5]:0[11]:src[5])
op NEGB_dir  (0b000[3]:0b010110[6]:0b01[2]:dst[5]:direct[16])
op NEGB_indir(0b000[3]:0b010110[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op NEGB_imm  (0b000[3]:0b010110[6]:0b11[2]:dst[5]:sext<32> imm[16])

NEGB_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NEGB " << src_name << ", " << dst_name;
	return true;
}

NEGB_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "NEGB @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

NEGB_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "NEGB " << disasm_src_indir << ", " << dst_name;
	return true;
}

NEGB_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NEGB " << imm << ", " << dst_name;
	return true;
}

NEGB_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, 0, src_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, 0, src_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

NEGB_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, 0, src_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, 0, src_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

NEGB_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, 0, src_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, 0, src_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

NEGB_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, 0, imm, borrow_in);
	else
		Sub32(result, borrow_out, overflow, 0, imm, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

/* end of NEGB (negate integer with borrow)
 **********************************************************/

/**********************************************************
 * NEGF (negate floating-point value)
 * op NEGF(0b000[3]:0b010111[6]:g[2]:dst[5]:src[16])
 */

op NEGF_reg  (0b000[3]:0b010111[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op NEGF_dir  (0b000[3]:0b010111[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op NEGF_indir(0b000[3]:0b010111[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op NEGF_imm  (0b000[3]:0b010111[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

NEGF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NEGF " << src_name << ", " << dst_name;
	return true;
}

NEGF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "NEGF @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

NEGF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "NEGF " << disasm_src_indir << ", " << dst_name;
	return true;
}

NEGF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NEGF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

/* end of NEGF (negate floating-point value)
 **********************************************************/

/**********************************************************
 * NEGI (negate integer)
 * op NEGI(0b000[3]:0b011000[6]:g[2]:dst[5]:src[16])
 */

op NEGI_reg  (0b000[3]:0b011000[6]:0b00[2]:dst[5]:0[11]:src[5])
op NEGI_dir  (0b000[3]:0b011000[6]:0b01[2]:dst[5]:direct[16])
op NEGI_indir(0b000[3]:0b011000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op NEGI_imm  (0b000[3]:0b011000[6]:0b11[2]:dst[5]:sext<32> imm[16])

NEGI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NEGI " << src_name << ", " << dst_name;
	return true;
}

NEGI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "NEGI @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

NEGI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "NEGI " << disasm_src_indir << ", " << dst_name;
	return true;
}

NEGI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NEGI " << imm << ", " << dst_name;
	return true;
}

NEGI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, 0, src_value, 0);
	else
		Sub32(result, borrow_out, overflow, 0, src_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

NEGI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, 0, src_value, 0);
	else
		Sub32(result, borrow_out, overflow, 0, src_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

NEGI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, 0, src_value, 0);
	else
		Sub32(result, borrow_out, overflow, 0, src_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

NEGI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, 0, imm, 0);
	else
		Sub32(result, borrow_out, overflow, 0, imm, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

/* end of NEGI (negate integer)
 **********************************************************/

/**********************************************************
 * NORM (normalize floating-point value)
 * op NORM(0b000[3]:0b011010[6]:g[2]:dst[5]:src[16])
 */

op NORM_reg  (0b000[3]:0b011010[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op NORM_dir  (0b000[3]:0b011010[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op NORM_indir(0b000[3]:0b011010[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op NORM_imm  (0b000[3]:0b011010[6]:0b11[2]:0b00[2]:dst[3]:sext<32> imm[16])

NORM_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NORM " << src_name << ", " << dst_name;
	return true;
}

NORM_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "NORM @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

NORM_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "NORM " << disasm_src_indir << ", " << dst_name;
	return true;
}

NORM_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NORM " << imm << ", " << dst_name;
	return true;
}

/* end of NORM (normalize floating-point value)
 **********************************************************/

/**********************************************************
 * NOT (bitwise-logical complement)
 * op NOT(0b000[3]:0b011011[6]:g[2]:dst[5]:src[16])
 */

op NOT_reg  (0b000[3]:0b011011[6]:0b00[2]:dst[5]:0[11]:src[5])
op NOT_dir  (0b000[3]:0b011011[6]:0b01[2]:dst[5]:direct[16])
op NOT_indir(0b000[3]:0b011011[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op NOT_imm  (0b000[3]:0b011011[6]:0b11[2]:dst[5]:<32> imm[16])

NOT_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NOT " << src_name << ", " << dst_name;
	return true;
}

NOT_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "NOT @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

NOT_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "NOT " << disasm_src_indir << ", " << dst_name;
	return true;
}

NOT_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NOT " << imm << ", " << dst_name;
	return true;
}

NOT_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Compute the result
	uint32_t result = ~src_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

NOT_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = ~src_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

NOT_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = ~src_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

NOT_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = ~imm;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

/* end of NOT (bitwise-logical complement)
 **********************************************************/

/**********************************************************
 * OR (bitwise-logical OR)
 * op OR(0b000[3]:0b100000[6]:g[2]:dst[5]:src[16])
 */

op OR_reg  (0b000[3]:0b100000[6]:0b00[2]:dst[5]:0[11]:src[5])
op OR_dir  (0b000[3]:0b100000[6]:0b01[2]:dst[5]:direct[16])
op OR_indir(0b000[3]:0b100000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op OR_imm  (0b000[3]:0b100000[6]:0b11[2]:dst[5]:sext<32> imm[16])

OR_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "OR " << src_name << ", " << dst_name;
	return true;
}

OR_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "OR @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

OR_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "OR " << disasm_src_indir << ", " << dst_name;
	return true;
}

OR_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "OR " << imm << ", " << dst_name;
	return true;
}

OR_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = src_value | dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

OR_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value | dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

OR_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value | dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

OR_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = imm | dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

/* end of OR (bitwise-logical OR)
 **********************************************************/

/**********************************************************
 * RND (round floating-point value)
 * op RND(0b000[3]:0b100010[6]:g[2]:dst[5]:src[16])
 */

op RND_reg  (0b000[3]:0b100010[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op RND_dir  (0b000[3]:0b100010[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op RND_indir(0b000[3]:0b100010[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op RND_imm  (0b000[3]:0b100010[6]:0b11[2]:0b00[2]:dst[3]:sext<32> imm[16])

RND_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "RND " << src_name << ", " << dst_name;
	return true;
}

RND_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "RND @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

RND_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "RND " << disasm_src_indir << ", " << dst_name;
	return true;
}

RND_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "RND " << imm << ", " << dst_name;
	return true;
}

/* end of RND (round floating-point value)
 **********************************************************/

/**********************************************************
 * ROL (rotate left)
 * op ROL(0b000[3]:0b100011[6]:0b11[2]:dst[5]:0b0000000000000001[16])
 */

op ROL(0b000[3]:0b100011[6]:0b11[2]:dst[5]:0b0000000000000001[16])

ROL.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ROL " << dst_name;
	return true;
}

ROL.execute = {
	// Check whether the destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint8_t carry_out;
	uint32_t result = RotateLeft(dst_value, 1, carry_out);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			carry_out
		);
	}
}

/* end of ROL (rotate left)
 **********************************************************/

/**********************************************************
 * ROLC (rotate left through carry)
 * op ROLC(0b000[3]:0b100100[6]:0b11[2]:dst[5]:0b0000000000000001[16])
 */

op ROLC(0b000[3]:0b100100[6]:0b11[2]:dst[5]:0b0000000000000001[16])

ROLC.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;
	
	os << "ROLC " << dst_name;
	return true;
}

ROLC.execute = {
	// Check whether the destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint8_t carry_out;
	uint32_t result = RotateLeft(dst_value, 1, carry_in, carry_out);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			carry_out
		);
	}
}

/* end of ROLC (rotate left through carry)
 **********************************************************/

/**********************************************************
 * ROR (rotate right)
 * op ROR(0b000[3]:0b100101[6]:0b11[2]:dst[5]:0b1111111111111111[16])
 */

op ROR(0b000[3]:0b100101[6]:0b11[2]:dst[5]:0b1111111111111111[16])

ROR.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;
	
	os << "ROR " << dst_name;
	return true;
}

ROR.execute = {
	// Check whether the destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint8_t carry_out;
	uint32_t result = RotateRight(dst_value, 1, carry_out);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			carry_out
		);
	}
}

/* end of ROR (rotate right)
 **********************************************************/

/**********************************************************
 * RORC (rotate right through carry)
 * op RORC(0b000[3]:0b100110[6]:0b11[2]:dst[5]:0b1111111111111111[16])
 */

op RORC(0b000[3]:0b100110[6]:0b11[2]:dst[5]:0b1111111111111111[16])

RORC.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;
	
	os << "RORC " << dst_name;
	return true;
}

RORC.execute = {
	// Check whether the destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint8_t carry_out;
	uint32_t result = RotateRight(dst_value, 1, carry_in, carry_out);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			carry_out
		);
	}
}

/* end of RORC (rotate right through carry)
 **********************************************************/

/**********************************************************
 * SUBB (subtract integers with borrow)
 * op SUBB(0b000[3]:0b101101[6]:g[2]:dst[5]:src[16])
 */

op SUBB_reg  (0b000[3]:0b101101[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBB_dir  (0b000[3]:0b101101[6]:0b01[2]:dst[5]:direct[16])
op SUBB_indir(0b000[3]:0b101101[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBB_imm  (0b000[3]:0b101101[6]:0b11[2]:dst[5]:sext<32> imm[16])

SUBB_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBB " << src_name << ", " << dst_name;
	return true;
}

SUBB_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "SUBB @0x" << hex << direct << dec << ", " << dst_name;
	
	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

SUBB_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "SUBB " << disasm_src_indir << ", " << dst_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

SUBB_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBB " << imm << ", " << dst_name;
	return true;
}

SUBB_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, dst_value, src_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, dst_value, src_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBB_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, dst_value, src_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, dst_value, src_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBB_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, dst_value, src_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, dst_value, src_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBB_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, dst_value, imm, borrow_in);
	else
		Sub32(result, borrow_out, overflow, dst_value, imm, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

/* end of SUBB (subtract integers with borrow)
 **********************************************************/

/**********************************************************
 * SUBC (subtract integers conditionally)
 * op SUBC(0b000[3]:0b101110[6]:g[2]:dst[5]:src[16])
 */

op SUBC_reg  (0b000[3]:0b101110[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBC_dir  (0b000[3]:0b101110[6]:0b01[2]:dst[5]:direct[16])
op SUBC_indir(0b000[3]:0b101110[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBC_imm  (0b000[3]:0b101110[6]:0b11[2]:dst[5]:sext<32> imm[16])

SUBC_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBC " << src_name << ", " << dst_name;
	return true;
}

SUBC_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "SUBC @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

SUBC_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "SUBC " << disasm_src_indir << ", " << dst_name;
	return true;
}

SUBC_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBC " << imm << ", " << dst_name;
	return true;
}

SUBC_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	int32_t substract_result = dst_value - src_value;
	uint32_t result = (substract_result << 1) | ((substract_result >= 0) ? 1 : 0);

	// Write back result
	cpu.SetIntReg(dst, result);
}

SUBC_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	int32_t substract_result = dst_value - src_value;
	uint32_t result = (substract_result << 1) | ((substract_result >= 0) ? 1 : 0);

	// Write back result
	cpu.SetIntReg(dst, result);
}

SUBC_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	int32_t substract_result = dst_value - src_value;
	uint32_t result = (substract_result << 1) | ((substract_result >= 0) ? 1 : 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}
}

SUBC_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	int32_t substract_result = dst_value - imm;
	uint32_t result = (substract_result << 1) | ((substract_result >= 0) ? 1 : 0);

	// Write back result
	cpu.SetIntReg(dst, result);
}

/* end of SUBC (subtract integers conditionally)
 **********************************************************/

/**********************************************************
 * SUBF (subtract floating-point values)
 * op SUBF(0b000[3]:0b101111[6]:g[2]:dst[5]:src[16])
 */

op SUBF_reg  (0b000[3]:0b101111[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op SUBF_dir  (0b000[3]:0b101111[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op SUBF_indir(0b000[3]:0b101111[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op SUBF_imm  (0b000[3]:0b101111[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

SUBF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBF " << src_name << ", " << dst_name;
	return true;
}

SUBF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "SUBF @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

SUBF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "SUBF " << disasm_src_indir << ", " << dst_name;
	return true;
}

SUBF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

/* end of SUBF (subtract floating-point values)
 **********************************************************/

/**********************************************************
 * SUBI (subtract integer)
 * op SUBI(0b000[3]:0b110000[6]:g[2]:dst[5]:src[16])
 */

op SUBI_reg  (0b000[3]:0b110000[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBI_dir  (0b000[3]:0b110000[6]:0b01[2]:dst[5]:direct[16])
op SUBI_indir(0b000[3]:0b110000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBI_imm  (0b000[3]:0b110000[6]:0b11[2]:dst[5]:sext<32> imm[16])

SUBI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBI " << src_name << ", " << dst_name;
	return true;
}

SUBI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "SUBI @0x" << hex << direct << dec << ", " << dst_name;
	
	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

SUBI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "SUBI " << disasm_src_indir << ", " << dst_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

SUBI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBI " << imm << ", " << dst_name;
	return true;
}

SUBI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, dst_value, src_value, 0);
	else
		Sub32(result, borrow_out, overflow, dst_value, src_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, dst_value, src_value, 0);
	else
		Sub32(result, borrow_out, overflow, dst_value, src_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, dst_value, src_value, 0);
	else
		Sub32(result, borrow_out, overflow, dst_value, src_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, dst_value, imm, 0);
	else
		Sub32(result, borrow_out, overflow, dst_value, imm, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

/* end of SUBI (subtract integer)
 **********************************************************/

/**********************************************************
 * SUBRB (subtract reverse integer with borrow)
 * op SUBRB(0b000[3]:0b110001[6]:g[2]:dst[5]:src[16])
 */

op SUBRB_reg  (0b000[3]:0b110001[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBRB_dir  (0b000[3]:0b110001[6]:0b01[2]:dst[5]:direct[16])
op SUBRB_indir(0b000[3]:0b110001[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBRB_imm  (0b000[3]:0b110001[6]:0b11[2]:dst[5]:sext<32> imm[16])

SUBRB_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBRB " << src_name << ", " << dst_name;
	return true;
}

SUBRB_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "SUBRB @0x" << hex << direct << dec << ", " << dst_name;
	
	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

SUBRB_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "SUBRB " << disasm_src_indir << ", " << dst_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

SUBRB_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBRB " << imm << ", " << dst_name;
	return true;
}

SUBRB_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, src_value, dst_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, src_value, dst_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBRB_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, src_value, dst_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, src_value, dst_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBRB_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, src_value, dst_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, src_value, dst_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBRB_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, imm, dst_value, borrow_in);
	else
		Sub32(result, borrow_out, overflow, imm, dst_value, borrow_in);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

/* end of SUBRB (subtract reverse integer with borrow)
 **********************************************************/

/**********************************************************
 * SUBRF (subtract reverse floating-point value)
 * op SUBRF(0b000[3]:0b110010[6]:g[2]:dst[5]:src[16])
 */

op SUBRF_reg  (0b000[3]:0b110010[6]:0b00[2]:0b00[2]:dst[3]:0[11]:0b00[2]:src[3])
op SUBRF_dir  (0b000[3]:0b110010[6]:0b01[2]:0b00[2]:dst[3]:direct[16])
op SUBRF_indir(0b000[3]:0b110010[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])
op SUBRF_imm  (0b000[3]:0b110010[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

SUBRF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBRF " << src_name << ", " << dst_name;
	return true;
}

SUBRF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "SUBRF @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

SUBRF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "SUBRF " << disasm_src_indir << ", " << dst_name;
	return true;
}

SUBRF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBRF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

/* end of SUBRF (subtract reverse floating-point value)
 **********************************************************/

/**********************************************************
 * SUBRI (subtract reverse integer)
 * op SUBRI(0b000[3]:0b110011[6]:g[2]:dst[5]:src[16])
 */

op SUBRI_reg  (0b000[3]:0b110011[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBRI_dir  (0b000[3]:0b110011[6]:0b01[2]:dst[5]:direct[16])
op SUBRI_indir(0b000[3]:0b110011[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBRI_imm  (0b000[3]:0b110011[6]:0b11[2]:dst[5]:sext<32> imm[16])

SUBRI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBRI " << src_name << ", " << dst_name;
	return true;
}

SUBRI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "SUBRI @0x" << hex << direct << dec << ", " << dst_name;
	
	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

SUBRI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "SUBRI " << disasm_src_indir << ", " << dst_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

SUBRI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBRI " << imm << ", " << dst_name;
	return true;
}

SUBRI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, src_value, dst_value, 0);
	else
		Sub32(result, borrow_out, overflow, src_value, dst_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBRI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, src_value, dst_value, 0);
	else
		Sub32(result, borrow_out, overflow, src_value, dst_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBRI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, src_value, dst_value, 0);
	else
		Sub32(result, borrow_out, overflow, src_value, dst_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

SUBRI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
		SignedSatSub32(result, borrow_out, overflow, imm, dst_value, 0);
	else
		Sub32(result, borrow_out, overflow, imm, dst_value, 0);

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			borrow_out,
			overflow
		);
	}
}

/* end of SUBRI (subtract reverse integer)
 **********************************************************/

/**********************************************************
 * TSTB (test bit fields)
 * op TSTB(0b000[3]:0b110100[6]:g[2]:dst[5]:src[16])
 */

op TSTB_reg  (0b000[3]:0b110100[6]:0b00[2]:dst[5]:0[11]:src[5])
op TSTB_dir  (0b000[3]:0b110100[6]:0b01[2]:dst[5]:direct[16])
op TSTB_indir(0b000[3]:0b110100[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op TSTB_imm  (0b000[3]:0b110100[6]:0b11[2]:dst[5]:sext<32> imm[16])

TSTB_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "TSTB " << src_name << ", " << dst_name;
	return true;
}

TSTB_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "TSTB @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

TSTB_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "TSTB " << disasm_src_indir << ", " << dst_name;
	return true;
}

TSTB_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "TSTB " << imm << ", " << dst_name;
	return true;
}

TSTB_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = src_value & dst_value;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_N | M_ST_Z    // or mask
	);
}

TSTB_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value & dst_value;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_N | M_ST_Z    // or mask
	);
}

TSTB_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value & dst_value;

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_N | M_ST_Z    // or mask
	);
}

TSTB_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = imm & dst_value;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_N | M_ST_Z    // or mask
	);
}

/* end of TSTB (test bit fields)
 **********************************************************/

/**********************************************************
 * XOR (bitwise-exclusive OR)
 * op XOR(0b000[3]:0b110101[6]:g[2]:dst[5]:src[16])
 */

op XOR_reg  (0b000[3]:0b110101[6]:0b00[2]:dst[5]:0[11]:src[5])
op XOR_dir  (0b000[3]:0b110101[6]:0b01[2]:dst[5]:direct[16])
op XOR_indir(0b000[3]:0b110101[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op XOR_imm  (0b000[3]:0b110101[6]:0b11[2]:dst[5]:sext<32> imm[16])

XOR_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "XOR " << src_name << ", " << dst_name;
	return true;
}

XOR_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (dst_name != NULL)
		return false;
	
	os << "XOR @0x" << hex << direct << dec << ", " << dst_name;
	
	return true;
}

XOR_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) 
		return false;

	os << "XOR " << disasm_src_indir << ", " << dst_name;
	return true;
}

XOR_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "XOR " << imm << ", " << dst_name;
	return true;
}

XOR_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = src_value ^ dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

XOR_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value ^ dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

XOR_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value ^ dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

XOR_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetIntReg(dst);

	// Compute the result
	uint32_t result = imm ^ dst_value;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

/* end of XOR (bitwise-exclusive OR)
 **********************************************************/
