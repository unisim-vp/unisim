/*
 *  Copyright (c) 2009,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 *          Gilles Mouchard (gilles.mouchard@cea.fr)
 */

/* List of load/store operations:
 * - LDE          load floating-point exponent
 * - LDF          load floating-point value
 * - LDFcond      load floating-point value conditionally
 * - LDI          load integer
 * - LDIcond      load integer conditionally
 * - LDM          load floating-point mantissa
 * - LDP          load data page pointer
 * - POP          pop integer from stack
 * - POPF         pop floating-point value from stack
 * - PUSH         push integer on stack
 * - PUSHF        push floating-point value on stack
 * - STF          store floating-point value
 * - STI          store integer
 */
 
/************************************************
 * LDE (load floating-point exponent)
 * op LDE(0b000[3]:0b001101[6]:g[2]:dst[5]:src[16])
 */

op LDE_reg  (0b000[3]:0b001101[6]:0b00[2]:0b00[2]:dst[3]:0[11]:src[5])

LDE_reg.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!dst_reg_name || !src_reg_name) return false;

	os << "LDE " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDE_dir  (0b000[3]:0b001101[6]:0b01[2]:0b00[2]:dst[3]:direct[16])

LDE_dir.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDE @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDE_indir(0b000[3]:0b001101[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])

LDE_indir.disasm = {
	string disasm_src_indir;
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDE " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDE_imm  (0b000[3]:0b001101[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

LDE_imm.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;
	os << "LDE " << cpu.DisasmShortFloat(imm) << ", " << dst_reg_name;
	return true;
}

/* end of LDE (load floating-point exponent)
 *************************************************/
 
/************************************************
 * LDF (load floating-point value)
 * op LDF(0b000[3]:0b001110[6]:g[2]:dst[5]:ext<32> src[16])
 */
 
op LDF_reg  (0b000[3]:0b001110[6]:0b00[2]:0b00[2]:dst[3]:0[11]:src[5])

LDF_reg.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!dst_reg_name || !src_reg_name) return false;

	os << "LDF " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDF_dir  (0b000[3]:0b001110[6]:0b01[2]:0b00[2]:dst[3]:direct[16])

LDF_dir.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDF @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDF_indir(0b000[3]:0b001110[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])

LDF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDF " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDF_imm  (0b000[3]:0b001110[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

LDF_imm.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;
	os << "LDF " << cpu.DisasmShortFloat(imm) << ", " << dst_reg_name;
	return true;
}

/* end of LDF (load floating-point value)
 *************************************************/

/************************************************
 * LDFcond (load floating-point value conditionally)
 * op LDFcond(0b0100[4]:cond[4]:g[2]:dst[5]:ext<32> src[16])
 */

op LDFcond_reg  (0b0100[4]:cond[5]:0b00[2]:0b00[2]:dst[3]:0[11]:src[5])

LDFcond_reg.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!cond_name || !dst_reg_name || !src_reg_name) return false;

	os << "LDF" << cond_name << " " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDFcond_dir  (0b0100[4]:cond[5]:0b01[2]:0b00[2]:dst[3]:direct[16])

LDFcond_dir.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];
	if(!cond_name || !dst_reg_name) return false;

	os << "LDF" << cond_name << " @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDFcond_indir(0b0100[4]:cond[5]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])

LDFcond_indir.disasm = {
	string disasm_src_indir;
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];
	if(!cond_name || !dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDF" << cond_name << " " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDFcond_imm  (0b0100[4]:cond[5]:0b11[2]:0b00[2]:dst[3]:imm[16])

LDFcond_imm.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];

	if(!cond_name || !dst_reg_name) return false;
	os << "LDF" << cond_name << " " << cpu.DisasmShortFloat(imm) << ", " << dst_reg_name;
	return true;
}

/* end of LDFcond (load floating-point value conditionally)
 *************************************************/

/*************************************************
 * LDI (load integer)
 * op LDI(0b000[3]:0b010000[6]:g[2]:dst[5]:ext<32> src[16])
 */

op LDI_reg  (0b000[3]:0b010000[6]:0b00[2]:dst[5]:0[11]:src[5])

LDI_reg.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!dst_reg_name || !src_reg_name) return false;

	os << "LDI " << src_reg_name << ", " << dst_reg_name;
	return true;
}

LDI_reg.execute = {
	// Check whether the source and destination register number are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand
	uint32_t result = cpu.GetIntReg(src);

	// Write back result in destination operand
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

op LDI_dir  (0b000[3]:0b010000[6]:0b01[2]:dst[5]:direct[16])

LDI_dir.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDI @0x" << hex << direct << dec << ", " << dst_reg_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

LDI_dir.execute = {
	// Check whether the destination register number is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Compute the result
	uint32_t result = ea;

	// Write back result
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

op LDI_indir(0b000[3]:0b010000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])

LDI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDI " << disasm_src_indir << ", " << dst_reg_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

LDI_indir.execute = {
	// Check whether the destination register number is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Load the word from memory
	uint32_t result = cpu.IntLoad(ea);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

op LDI_imm  (0b000[3]:0b010000[6]:0b11[2]:dst[5]:sext<32> imm[16])

LDI_imm.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDI " << imm << ", " << dst_reg_name;
	return true;
}

LDI_imm.execute = {
	// Check whether the destination register number is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the result
	uint32_t result = imm; // imm has already been sign extended by the decoder

	// Write back result in destination operand
	cpu.SetIntReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

/* end of LDI (load integer)
 *************************************************/

/*************************************************
 * LDIcond (load integer conditionally)
 * op LDIcond(0b0101[4]:cond[4]:g[2]:dst[5]:src[16])
 */
 
op LDIcond_reg  (0b0101[4]:cond[5]:0b00[2]:dst[5]:0[11]:src[5])

LDIcond_reg.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *src_reg_name = REG_NAME[src];
	const char *dst_reg_name = REG_NAME[dst];
	if(!cond_name || !src_reg_name || !dst_reg_name) return false;

	os << "LDI" << cond_name << " " << src_reg_name << ", " << dst_reg_name;
	return true;
}

LDIcond_reg.execute = {
	// Check whether the source and destination registers, and the condition are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst) || !cpu.HasCondition(cond)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check the condition
	if(!cpu.CheckCondition(cond)) return;

	// Read the source operand
	uint32_t result = cpu.GetIntReg(src);

	// Write back result in destination operand
	cpu.SetIntReg(dst, result);
}

op LDIcond_dir  (0b0101[4]:cond[5]:0b01[2]:dst[5]:direct[16])

LDIcond_dir.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];
	if(!cond_name || !dst_reg_name) return false;

	os << "LDI" << cond_name << " @0x" << hex << direct << dec << ", " << dst_reg_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

LDIcond_dir.execute = {
	// Check whether the destination register and the condition are valid
	if(unlikely(!cpu.HasReg(dst) || !cpu.HasCondition(cond)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check the condition
	if(!cpu.CheckCondition(cond)) return;

	// Compute the effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Compute the result
	uint32_t result = ea;

	// Write back result
	cpu.SetIntReg(dst, result);
}

op LDIcond_indir(0b0101[4]:cond[5]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])

LDIcond_indir.disasm = {
	string disasm_src_indir;
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];

	if(!cond_name || !dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDI" << cond_name << " " << disasm_src_indir << ", " << dst_reg_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

LDIcond_indir.execute = {
	// Check whether the destination register and the condition are valid
	if(unlikely(!cpu.HasReg(dst) || !cpu.HasCondition(cond)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check the condition
	if(!cpu.CheckCondition(cond)) return;

	// Load the word from memory
	uint32_t result = cpu.IntLoad(ea);

	// Write back result
	cpu.SetIntReg(dst, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}
}

op LDIcond_imm  (0b0101[4]:cond[5]:0b11[2]:dst[5]:sext<32> imm[16])

LDIcond_imm.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];

	if(!cond_name || !dst_reg_name) return false;

	os << "LDI" << cond_name << " " << imm << ", " << dst_reg_name;
	return true;
}

LDIcond_imm.execute = {
	// Check whether the destination register and the condition are valid
	if(unlikely(!cpu.HasReg(dst) || !cpu.HasCondition(cond)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check the condition
	if(!cpu.CheckCondition(cond)) return;

	// Compute the result
	uint32_t result = imm; // imm has already been sign extended by the decoder

	// Write back result in destination operand
	cpu.SetIntReg(dst, result);
}

/* end of LDIcond (load integer conditionally)
 *************************************************/

/*************************************************
 * LDM (load floating-point mantissa)
 * op LDM(0b000[3]:0b010010[6]:g[2]:dst[5]:src[16])
 */
 
op LDM_reg  (0b000[3]:0b010010[6]:0b00[2]:0b00[2]:dst[3]:0[11]:src[5])

LDM_reg.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!dst_reg_name || !src_reg_name) return false;

	os << "LDM " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDM_dir  (0b000[3]:0b010010[6]:0b01[2]:0b00[2]:dst[3]:direct[16])

LDM_dir.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDM @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDM_indir(0b000[3]:0b010010[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])

LDM_indir.disasm = {
	string disasm_src_indir;
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDM " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDM_imm  (0b000[3]:0b010010[6]:0b11[2]:0b00[2]:dst[3]:0[4]:imm[12])

LDM_imm.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;
	os << "LDM " << cpu.DisasmShortFloat(imm) << ", " << dst_reg_name;
	return true;
}

/* end of LDM (load floating-point mantissa)
 *************************************************/

/*************************************************
 * LDP (load data page pointer)
 * op LDP(0b000[3]:0b010000[6]:0b11[2]:0b10000[5]:0b00000000[8]:src[8])
 */

op LDP(0b000[3]:0b010000[6]:0b11[2]:0b10000[5]:0b00000000[8]:src[8])

LDP.disasm = {
	os << "LDP @0x" << hex << (src << 16) << dec;
	return true;
}

LDP.execute = {
	// Update DP
	cpu.SetDP(src);
}

/* end of LDP (load data page pointer)
 *************************************************/

/*************************************************
 * POP (pop integer from stack)
 * op POP(0b000[3]:0b011100[6]:0b01[2]:dst[5]:0[16])
 */

op POP(0b000[3]:0b011100[6]:0b01[2]:dst[5]:0[16])

POP.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;

	os << "POP " << dst_reg_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.GetSP()) << ">";
	}
	return true;
}

POP.execute = {
	// Check whether the destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read SP
	typename CONFIG::address_t sp = cpu.GetSP();

	// Read the word at SP from memory
	uint32_t result = cpu.IntLoad(sp);

	// Compute the new value of SP
	sp = sp - 1;

	// Write back the result
	cpu.SetIntReg(dst, result);

	// Update SP
	cpu.SetSP(sp);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z    // or mask
		);
	}
}

/* end of POP (pop integer from stack)
 *************************************************/

/*************************************************
 * POPF (pop floating-point value from stack)
 * op POPF(0b000[3]:0b011101[6]:0b01[2]:dst[5]:0[16])
 */

op POPF(0b000[3]:0b011101[6]:0b01[2]:0b00[2]:dst[3]:0[16])

POPF.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;

	os << "POPF " << dst_reg_name;
	return true;
}

/* end of POPF (pop floating-point value from stack)
 *************************************************/

/*************************************************
 * PUSH (push integer on stack)
 * op PUSH(0b000[3]:0b011110[6]:0b01[2]:src[5]:0[16])
 */

op PUSH(0b000[3]:0b011110[6]:0b01[2]:src[5]:0[16])

PUSH.disasm = {
	const char *src_reg_name = REG_NAME[src];

	if(!src_reg_name) return false;

	os << "PUSH " << src_reg_name;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.GetSP() + 1) << ">";
	}
	return true;
}

PUSH.execute = {
	// Check whether the source register number is valid
	if(unlikely(!cpu.HasReg(src)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand
	uint32_t src_value = cpu.GetIntReg(src);

	// Read SP and compute its new value
	typename CONFIG::address_t sp = cpu.GetSP() + 1;

	// Store the source operand at SP + 1
	cpu.IntStore(sp, src_value);

	// Update SP
	cpu.SetSP(sp);
}

/* end of POPF (pop floating-point value from stack)
 *************************************************/

/*************************************************
 * PUSHF (push floating-point value on stack)
 * op PUSHF(0b000[3]:0b011111[6]:0b01[2]:src[5]:0[16])
 */

op PUSHF(0b000[3]:0b011111[6]:0b01[2]:0b00[2]:src[3]:0[16])

PUSHF.disasm = {
	const char *src_reg_name = REG_NAME[src];

	if(!src_reg_name) return false;

	os << "PUSHF " << src_reg_name;
	return true;
}

/* end of PUSHF (push floating-point value on stack)
 *************************************************/

/*************************************************
 * STF (store floating-point value)
 * op STF(0b000[3]:0b101000[6]:g[2]:src[5]:dst[16])
 */

op STF_dir  (0b000[3]:0b101000[6]:0b01[2]:src[5]:direct[16])

STF_dir.disasm = {
	const char *src_reg_name = REG_NAME[src];
	if(!src_reg_name) return false;

	os << "STF " << src_reg_name << ", @0x" << hex << direct << dec;
	return true;
}

op STF_indir(0b000[3]:0b101000[6]:0b10[2]:0b00[2]:src[3]:mod[5]:ar[3]:disp[8])

STF_indir.disasm = {
	string disasm_dst_indir;
	const char *src_reg_name = REG_NAME[src];
	if(!src_reg_name || !cpu.DisasmIndir(disasm_dst_indir, mod, ar, disp)) return false;

	os << "STF " << src_reg_name << ", " << disasm_dst_indir;
	return true;
}


/* end of STF (store floating-point value)
 *************************************************/

/*************************************************
 * STI (store integer)
 * op STI(0b000[3]:0b101010[6]:g[2]:src[5]:dst[16])
 */
 
op STI_dir  (0b000[3]:0b101010[6]:0b01[2]:0b00[2]:src[3]:direct[16])

STI_dir.disasm = {
	const char *src_reg_name = REG_NAME[src];
	if(!src_reg_name) return false;

	os << "STI " << src_reg_name << ", @0x" << hex << direct << dec;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <" << cpu.GetObjectFriendlyName(cpu.ComputeDirEA(direct)) << ">";
	}
	return true;
}

STI_dir.execute = {
	// Read the source operand
	uint32_t result = cpu.GetIntReg(src);

	// Compute the effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Store the word into memory
	cpu.IntStore(ea, result);
}

op STI_indir(0b000[3]:0b101010[6]:0b10[2]:src[5]:mod[5]:ar[3]:disp[8])

STI_indir.disasm = {
	string disasm_dst_indir;
	const char *src_reg_name = REG_NAME[src];
	if(!src_reg_name || !cpu.DisasmIndir(disasm_dst_indir, mod, ar, disp)) return false;

	os << "STI " << src_reg_name << ", " << disasm_dst_indir;

	if(cpu.GetPC() == (Operation<CONFIG, DEBUG>::GetAddr() / 4))
	{
		os << " <";
		typename CONFIG::address_t ea;        // The effective address
		bool update_ar;                       // Whether to update ARn
		typename CONFIG::address_t output_ar; // New value of ARn if it is updated
		if(cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp))
		{
			os << cpu.GetObjectFriendlyName(ea);
		}
		else
		{
			os << "?";
		}
		os << ">";
	}
	return true;
}

STI_indir.execute = {
	// Read the source operand
	uint32_t result = cpu.GetIntReg(src);

	// Check that indirect addressing mode is valid and compute the effective address
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Store the word into memory
	cpu.IntStore(ea, result);

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR(ar, output_ar);
	}
}

/* end of STI (store integer)
 *************************************************/
