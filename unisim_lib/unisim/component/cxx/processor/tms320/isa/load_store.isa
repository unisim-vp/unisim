/*
 *  Copyright (c) 2009,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 *          Gilles Mouchard (gilles.mouchard@cea.fr)
 */

/* List of load/store operations:
 * - LDE          load floating-point exponent
 * - LDF          load floating-point value
 * - LDFcond      load floating-point value conditionally
 * - LDI          load integer
 * - LDIcond      load integer conditionally
 * - LDM          load floating-point mantissa
 * - LDP          load data page pointer
 * - POP          pop integer from stack
 * - POPF         pop floating-point value from stack
 * - PUSH         push integer on stack
 * - PUSHF        push floating-point value on stack
 * - STF          store floating-point value
 * - STI          store integer
 */
 
/************************************************
 * LDE (load floating-point exponent)
 * op LDE(0b000[3]:0b001101[6]:g[2]:dst[5]:src[16])
 */

op LDE_reg  (0b000[3]:0b001101[6]:0b00[2]:0b00[2]:dst[3]:0[11]:src[5])

LDE_reg.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!dst_reg_name || !src_reg_name) return false;

	os << "LDE " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDE_dir  (0b000[3]:0b001101[6]:0b01[2]:0b00[2]:dst[3]:direct[16])

LDE_dir.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDE @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDE_indir(0b000[3]:0b001101[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])

LDE_indir.disasm = {
	string disasm_src_indir;
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDE " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDE_imm  (0b000[3]:0b001101[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

LDE_imm.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;
	os << "LDE " << cpu.DisasmShortFloat(imm) << ", " << dst_reg_name;
	return true;
}

/* end of LDE (load floating-point exponent)
 *************************************************/
 
/************************************************
 * LDF (load floating-point value)
 * op LDF(0b000[3]:0b001110[6]:g[2]:dst[5]:ext<32> src[16])
 */
 
op LDF_reg  (0b000[3]:0b001110[6]:0b00[2]:0b00[2]:dst[3]:0[11]:src[5])

LDF_reg.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!dst_reg_name || !src_reg_name) return false;

	os << "LDF " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDF_dir  (0b000[3]:0b001110[6]:0b01[2]:0b00[2]:dst[3]:direct[16])

LDF_dir.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDF @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDF_indir(0b000[3]:0b001110[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])

LDF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDF " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDF_imm  (0b000[3]:0b001110[6]:0b11[2]:0b00[2]:dst[3]:imm[16])

LDF_imm.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;
	os << "LDF " << cpu.DisasmShortFloat(imm) << ", " << dst_reg_name;
	return true;
}

/* end of LDF (load floating-point value)
 *************************************************/

/************************************************
 * LDFcond (load floating-point value conditionally)
 * op LDFcond(0b0100[4]:cond[4]:g[2]:dst[5]:ext<32> src[16])
 */

op LDFcond_reg  (0b0100[4]:cond[5]:0b00[2]:0b00[2]:dst[3]:0[11]:src[5])

LDFcond_reg.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!cond_name || !dst_reg_name || !src_reg_name) return false;

	os << "LDF" << cond_name << " " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDFcond_dir  (0b0100[4]:cond[5]:0b01[2]:0b00[2]:dst[3]:direct[16])

LDFcond_dir.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];
	if(!cond_name || !dst_reg_name) return false;

	os << "LDF" << cond_name << " @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDFcond_indir(0b0100[4]:cond[5]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])

LDFcond_indir.disasm = {
	string disasm_src_indir;
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];
	if(!cond_name || !dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDF" << cond_name << " " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDFcond_imm  (0b0100[4]:cond[5]:0b11[2]:0b00[2]:dst[3]:imm[16])

LDFcond_imm.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];

	if(!cond_name || !dst_reg_name) return false;
	os << "LDF" << cond_name << " " << cpu.DisasmShortFloat(imm) << ", " << dst_reg_name;
	return true;
}

/* end of LDFcond (load floating-point value conditionally)
 *************************************************/

/*************************************************
 * LDI (load integer)
 * op LDI(0b000[3]:0b010000[6]:g[2]:dst[5]:ext<32> src[16])
 */

op LDI_reg  (0b000[3]:0b010000[6]:0b00[2]:dst[5]:0[11]:src[5])

LDI_reg.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!dst_reg_name || !src_reg_name) return false;

	os << "LDI " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDI_dir  (0b000[3]:0b010000[6]:0b01[2]:dst[5]:direct[16])

LDI_dir.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDI @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDI_indir(0b000[3]:0b010000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])

LDI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDI " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDI_imm  (0b000[3]:0b010000[6]:0b11[2]:dst[5]:sext<32> imm[16])

LDI_imm.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDI " << imm << ", " << dst_reg_name;
	return true;
}

/* end of LDI (load integer)
 *************************************************/

/*************************************************
 * LDIcond (load integer conditionally)
 * op LDIcond(0b0101[4]:cond[4]:g[2]:dst[5]:src[16])
 */
 
op LDIcond_reg  (0b0101[4]:cond[5]:0b00[2]:dst[5]:0[11]:src[5])

LDIcond_reg.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *src_reg_name = REG_NAME[src];
	const char *dst_reg_name = REG_NAME[dst];
	if(!cond_name || !src_reg_name || !dst_reg_name) return false;

	os << "LDI" << cond_name << " " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDIcond_dir  (0b0101[4]:cond[5]:0b01[2]:dst[5]:direct[16])

LDIcond_dir.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];
	if(!cond_name || !dst_reg_name) return false;

	os << "LDI" << cond_name << " @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDIcond_indir(0b0101[4]:cond[5]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])

LDIcond_indir.disasm = {
	string disasm_src_indir;
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];

	if(!cond_name || !dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDI" << cond_name << " " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDIcond_imm  (0b0101[4]:cond[5]:0b11[2]:dst[5]:sext<32> imm[16])

LDIcond_imm.disasm = {
	const char *cond_name = COND_NAME[cond];
	const char *dst_reg_name = REG_NAME[dst];

	if(!cond_name || !dst_reg_name) return false;

	os << "LDI" << cond_name << " " << imm << ", " << dst_reg_name;
	return true;
}

/* end of LDIcond (load integer conditionally)
 *************************************************/

/*************************************************
 * LDM (load floating-point mantissa)
 * op LDM(0b000[3]:0b010010[6]:g[2]:dst[5]:src[16])
 */
 
op LDM_reg  (0b000[3]:0b010010[6]:0b00[2]:0b00[2]:dst[3]:0[11]:src[5])

LDM_reg.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	const char *src_reg_name = REG_NAME[src];
	if(!dst_reg_name || !src_reg_name) return false;

	os << "LDM " << src_reg_name << ", " << dst_reg_name;
	return true;
}

op LDM_dir  (0b000[3]:0b010010[6]:0b01[2]:0b00[2]:dst[3]:direct[16])

LDM_dir.disasm = {
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name) return false;

	os << "LDM @0x" << hex << direct << dec << ", " << dst_reg_name;
	return true;
}

op LDM_indir(0b000[3]:0b010010[6]:0b10[2]:0b00[2]:dst[3]:mod[5]:ar[3]:disp[8])

LDM_indir.disasm = {
	string disasm_src_indir;
	const char *dst_reg_name = REG_NAME[dst];
	if(!dst_reg_name || !cpu.DisasmIndir(disasm_src_indir, mod, ar, disp)) return false;

	os << "LDM " << disasm_src_indir << ", " << dst_reg_name;
	return true;
}

op LDM_imm  (0b000[3]:0b010010[6]:0b11[2]:0b00[2]:dst[3]:0[4]:imm[12])

LDM_imm.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;
	os << "LDM " << cpu.DisasmShortFloat(imm) << ", " << dst_reg_name;
	return true;
}

/* end of LDM (load floating-point mantissa)
 *************************************************/

/*************************************************
 * LDP (load data page pointer)
 * op LDP(0b000[3]:0b010000[6]:0b11[2]:0b10000[5]:0b00000000[8]:src[8])
 */

op LDP(0b000[3]:0b010000[6]:0b11[2]:0b10000[5]:0b00000000[8]:src[8])

LDP.disasm = {
	os << "LDP @0x" << hex << (src << 16) << dec;
	return true;
}


/* end of LDP (load data page pointer)
 *************************************************/

/*************************************************
 * POP (pop integer from stack)
 * op POP(0b000[3]:0b011100[6]:0b01[2]:dst[5]:0[16])
 */

op POP(0b000[3]:0b011100[6]:0b01[2]:dst[5]:0[16])

POP.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;

	os << "POP " << dst_reg_name;
	return true;
}

/* end of POP (pop integer from stack)
 *************************************************/

/*************************************************
 * POPF (pop floating-point value from stack)
 * op POPF(0b000[3]:0b011101[6]:0b01[2]:dst[5]:0[16])
 */

op POPF(0b000[3]:0b011101[6]:0b01[2]:0b00[2]:dst[3]:0[16])

POPF.disasm = {
	const char *dst_reg_name = REG_NAME[dst];

	if(!dst_reg_name) return false;

	os << "POPF " << dst_reg_name;
	return true;
}

/* end of POPF (pop floating-point value from stack)
 *************************************************/

/*************************************************
 * PUSH (push integer on stack)
 * op PUSH(0b000[3]:0b011110[6]:0b01[2]:src[5]:0[16])
 */

op PUSH(0b000[3]:0b011110[6]:0b01[2]:src[5]:0[16])

PUSH.disasm = {
	const char *src_reg_name = REG_NAME[src];

	if(!src_reg_name) return false;

	os << "PUSH " << src_reg_name;
	return true;
}

/* end of POPF (pop floating-point value from stack)
 *************************************************/

/*************************************************
 * PUSHF (push floating-point value on stack)
 * op PUSHF(0b000[3]:0b011111[6]:0b01[2]:src[5]:0[16])
 */

op PUSHF(0b000[3]:0b011111[6]:0b01[2]:0b00[2]:src[3]:0[16])

PUSHF.disasm = {
	const char *src_reg_name = REG_NAME[src];

	if(!src_reg_name) return false;

	os << "PUSHF " << src_reg_name;
	return true;
}

/* end of PUSHF (push floating-point value on stack)
 *************************************************/

/*************************************************
 * STF (store floating-point value)
 * op STF(0b000[3]:0b101000[6]:g[2]:src[5]:dst[16])
 */

op STF_dir  (0b000[3]:0b101000[6]:0b01[2]:src[5]:direct[16])

STF_dir.disasm = {
	const char *src_reg_name = REG_NAME[src];
	if(!src_reg_name) return false;

	os << "STF " << src_reg_name << ", @0x" << direct;
	return true;
}

op STF_indir(0b000[3]:0b101000[6]:0b10[2]:0b00[2]:src[3]:mod[5]:ar[3]:disp[8])

STF_indir.disasm = {
	string disasm_dst_indir;
	const char *src_reg_name = REG_NAME[src];
	if(!src_reg_name || !cpu.DisasmIndir(disasm_dst_indir, mod, ar, disp)) return false;

	os << "STF " << src_reg_name << ", " << disasm_dst_indir;
	return true;
}


/* end of STF (store floating-point value)
 *************************************************/

/*************************************************
 * STI (store integer)
 * op STI(0b000[3]:0b101010[6]:g[2]:src[5]:dst[16])
 */
 
op STI_dir  (0b000[3]:0b101010[6]:0b01[2]:src[5]:direct[16])

STI_dir.disasm = {
	const char *src_reg_name = REG_NAME[src];
	if(!src_reg_name) return false;

	os << "STI " << src_reg_name << ", @0x" << direct;
	return true;
}

op STI_indir(0b000[3]:0b101010[6]:0b10[2]:src[5]:mod[5]:ar[3]:disp[8])

STI_indir.disasm = {
	string disasm_dst_indir;
	const char *src_reg_name = REG_NAME[src];
	if(!src_reg_name || !cpu.DisasmIndir(disasm_dst_indir, mod, ar, disp)) return false;

	os << "STI " << src_reg_name << ", " << disasm_dst_indir;
	return true;
}

/* end of STI (store integer)
 *************************************************/
