/***************************************************************************
                              generator.cc
                             -------------------
    begin                : Thu May 25 2003
    copyright            : (C) 2003-2007 CEA and Universite Paris Sud
    authors              : Gilles Mouchard, Yves Lhuillier
    email                : gilles.mouchard@cea.fr, yves.lhuillier@cea.fr
***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License version 2        *
 *   as published by the Free Software Foundation.                         *
 *                                                                         *
 ***************************************************************************/

#include <generator.hh>
#include <scanner.hh>
#include <isa.hh>
#include <action.hh>
#include <bitfield.hh>
#include <comment.hh>
#include <operation.hh>
#include <sourcecode.hh>
#include <subdecoder.hh>
#include <variable.hh>
#include <product.hh>
#include <strtools.hh>
#include <vect.hh>
#include <iostream>
#include <limits>
#include <stdexcept>
#include <cassert>


Generator::Generator( Isa& _source, Opts const& _options )
  : source( _source ), options( _options ), m_minwordsize()
{
  // Actual minimal word size is determined by minimal word size
  // requirements from both command line and source code
  m_minwordsize = least_ctype_size( std::max( _options.minwordsize, source.m_minwordsize ) );
  
}

/* Generates the topological graph of operations, checks for conflicts (overlapping encodings), and sort operations accordingly.
 */
void
Generator::toposort()
{
}

/** Dumps ISA statistics
    @param _sink a std::ostream reference where to dump statistics
    @param verbosity the level of verbosity
 */
void
Generator::isastats()
{
  options.log(1) << "Instruction Size: ";
  if (source.m_insnsizes.size() == 1)
    options.log(1) << (*source.m_insnsizes.begin());
  else
    {
      char const* sep = "[";
      for (unsigned size : source.m_insnsizes)
      {
        options.log(1) << sep << size;
        sep = ",";
      }
      options.log(1) << "] (gcd=" << source.gcd() << ")";
    }
  
  options.log(1) << std::endl;
  options.log(1) << "Instruction Set Encoding: " << (source.m_little_endian ? "little-endian" : "big-endian") << "\n";
  /* Statistics about operation and actions */
  options.log(1) << "Operation count: " << source.m_operations.size() << "\n";
  {
    options.log(3) << "Operations (actions details):\n";
    typedef std::map<ActionProto const*,uint64_t> ActionCount;
    ActionCount actioncount;
    for (Vector<Operation>::const_iterator op = source.m_operations.begin(); op < source.m_operations.end(); ++ op) {
      options.log(3) << "  " << (**op).symbol.str() << ':';
      for (Vector<Action>::const_iterator action = (**op).actions.begin(); action < (**op).actions.end(); ++ action) {
        ActionProto const* ap = (**action).m_actionproto;
        options.log(3) << " ." << ap->m_symbol.str();
        actioncount[ap] += 1;
      }
      options.log(3) << '\n';
    }
    options.log(1) << "Action count:\n";
    for (ActionCount::const_iterator itr = actioncount.begin(); itr != actioncount.end(); ++itr) {
      options.log(1) << "   ." << itr->first->m_symbol.str() << ": " << itr->second << '\n';
    }
  }
}

/** Generates one C source file and one C header
    @param output a C string containing the name of the output filenames without the file name extension
    @param word_size define the minimum word size to hold the operand bit field,
    if zero uses the smallest type which hold the operand bit field
*/
void
Generator::iss() const
{
  /*******************/
  /*** Header file ***/
  /*******************/
  {
    FProduct sink( options.outputprefix, ".hh", options.sourcelines );
    if (not sink.good()) {
      std::cerr << options.appname() << ": can't open header file '" << sink.m_filename.str() << "'.\n";
      throw GenerationError;
    }
    
    sink.code( "/*** File generated by %s version %s: DO NOT MODIFY ***/\n", options.appname(), options.appversion() );
    
    ConstStr headerid;
    
    {
      std::string ns_header_str;
      std::string sep = "";
      for( std::vector<ConstStr>::const_iterator piece = source.m_namespace.begin(); piece < source.m_namespace.end(); ++ piece ) {
        ns_header_str += sep + (*piece).str();
        sep = "__";
      }
      headerid = Str::fmt( "__%s_%s_HH__", Str::tokenize( options.outputprefix ).str(), ns_header_str.c_str() );
    }

    sink.code( "#ifndef %s\n", headerid.str() );
    sink.code( "#define %s\n", headerid.str() );
  
    sink.code( "\n#ifndef __STDC_FORMAT_MACROS\n"
               "#define __STDC_FORMAT_MACROS\n"
               "#endif\n\n" );
  
    sink.code( "#include <vector>\n" );
    sink.code( "#include <inttypes.h>\n" );
    sink.code( "#include <cstring>\n" );
  
    //   sink.code( "#ifndef GCC_VERSION\n" );
    //   sink.code( "#define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n" );
    //   sink.code( "#endif\n" );

    additional_decl_includes( sink );
  
    sink.ns_enter( source.m_namespace );
  
    codetype_decl( sink );
    decoder_decl( sink );
  
    sink.ns_leave( source.m_namespace );

    for( Vector<SourceCode>::const_iterator srccode = source.m_decl_srccodes.begin(); srccode < source.m_decl_srccodes.end(); ++ srccode ) {
      sink.usercode( **srccode );
    }
  
    sink.ns_enter( source.m_namespace );
  
    operation_decl( sink );
  
    sink.ns_leave( source.m_namespace );
  
    sink.code( "#endif\n" );
  
    sink.require_newline();
  }
  
  /*******************/
  /*** Source file ***/
  /*******************/
  {
    FProduct sink( options.outputprefix, source.m_tparams.empty() ? ".cc" : ".tcc", options.sourcelines );
    if (not sink.good()) {
      std::cerr << options.appname() << ": can't open source file '" << sink.m_filename.str() << "'.\n";
      throw GenerationError;
    }
  
    // sink.code( "/*** File generated by %s version %s: DO NOT MODIFY ***/\n", options.appname(), options.appversion() );
  
    sink.code( "#include \"%s.hh\"\n", options.outputprefix );
    additional_impl_includes( sink );
  
    for( Vector<SourceCode>::const_iterator srccode = source.m_impl_srccodes.begin(); srccode < source.m_impl_srccodes.end(); ++ srccode ) {
      sink.usercode( **srccode );
    }
  
    sink.ns_enter( source.m_namespace );
  
    codetype_impl( sink );
    operation_impl( sink );
  
    isa_operations_decl( sink );
    isa_operations_methods( sink );
    isa_operations_ctors( sink );
    if (source.m_withencode)
      isa_operations_encoders( sink );
  
    decoder_impl( sink );
  
    sink.ns_leave( source.m_namespace );
  
    sink.require_newline();
  }
  
  /******************************/
  /*** Subdecoder header file ***/
  /******************************/
  if (source.m_is_subdecoder) {
    FProduct sink( options.outputprefix, "_sub.isa", options.sourcelines );
    if (not sink.good()) {
      std::cerr << options.appname() << ": can't open header file '" << sink.m_filename.str() << "'.\n";
      throw GenerationError;
    }
    
    sink.code( "subdecoder " );
    
    std::vector<ConstStr> const& nmspc = source.m_namespace;
    char const* sep = "";
    for( std::vector<ConstStr>::const_iterator ns = nmspc.begin(); ns < nmspc.end(); sep = "::", ++ ns )
      sink.code( "%s%s", sep, (*ns).str() );
    
    sink.code( " [" );
    sep = "";
    for (unsigned size : source.m_insnsizes)
      sink.code( "%s%u", sep, size );
    
    sink.code( "]\n" );
    
    sink.require_newline();
  }
}

/** Returns a type format of the good bit size
    @param size a size in bits
    @param is_signed_type non-zero if the type is signed
    @return a C string containing the format for printf functions
*/
char const*
get_type_format( int size, int is_signed_type ) {
  if (is_signed_type) {
    if (size <= 8)  return "%\" PRIi8 \"";
    if (size <= 16) return "%\" PRIi16 \"";
    if (size <= 32) return "%\" PRIi32 \"";
    if (size <= 64) return "%\" PRIi64 \"";
  }
  else {
    if (size <= 8)  return "%\" PRIu8 \"";
    if (size <= 16) return "%\" PRIu16 \"";
    if (size <= 32) return "%\" PRIu32 \"";
    if (size <= 64) return "%\" PRIu64 \"";
  }
  return 0;
}

void
Generator::decoder_decl( Product& _product ) const {
  _product.template_signature( source.m_tparams );
  _product.code( "class Operation;\n" );
  
  if (source.m_withcache) {
    _product.code( "const unsigned int NUM_OPERATIONS_PER_PAGE = 4096;\n" );
    _product.template_signature( source.m_tparams );
    _product.code( "class DecodeMapPage\n" );
    _product.code( "{\n" );
    _product.code( "public:\n" );
    _product.code( " DecodeMapPage(%s key);\n", source.m_addrtype.str() );
    _product.code( " ~DecodeMapPage();\n" );
    _product.code( " %s key;\n", source.m_addrtype.str() );
    _product.code( " DecodeMapPage *next;\n" );
    _product.code( " Operation" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *operation[NUM_OPERATIONS_PER_PAGE];\n" );
    _product.code( "};\n\n" );
  }

  _product.template_signature( source.m_tparams );
  _product.code( "class DecodeTableEntry\n" );
  _product.code( "{\n" );
  _product.code( "public:\n" );
  _product.code( " DecodeTableEntry(%s opcode, %s opcode_mask, Operation", codetype_constref().str(), codetype_constref().str() );
  _product.template_abbrev( source.m_tparams );
  _product.code( " *(*decode)(%s, %s));\n", codetype_constref().str(), source.m_addrtype.str() );
  _product.code( " %s opcode;\n", codetype_name().str() );
  _product.code( " %s opcode_mask;\n", codetype_name().str() );
  _product.code( " Operation" );
  _product.template_abbrev( source.m_tparams );
  _product.code( " *(*decode)(%s code, %s addr);\n", codetype_constref().str(), source.m_addrtype.str() );
  _product.code( "};\n" );

  if (source.m_withcache) {
    _product.code( "const unsigned int NUM_DECODE_HASH_TABLE_ENTRIES = 4096;\n" );
  }

  _product.template_signature( source.m_tparams );
  _product.code( "class Decoder\n" );
  _product.code( "{\n" );
  _product.code( "public:\n" );
  _product.code( " typedef Operation" );
  _product.template_abbrev( source.m_tparams );
  _product.code( " operation_type;\n" );
  _product.code( " typedef %s address_type;\n", source.m_addrtype.str() );
  _product.code( " typedef CodeType code_type;\n" );
  _product.code( " enum { alignment = %u };\n\n", source.gcd() );
  _product.code( " Decoder();\n" );
  _product.code( " virtual ~Decoder();\n" );
  _product.code( "\n" );
  if (not source.m_is_subdecoder) {
    _product.code( " Operation" );
    _product.template_abbrev( source.m_tparams );
    _product.code( "*NCDecode(%s addr);\n", source.m_addrtype.str() );
  }
  _product.code( " Operation" );
  _product.template_abbrev( source.m_tparams );
  _product.code( " *NCDecode(%s addr, %s code);\n", source.m_addrtype.str(), codetype_constref().str() );
  if (source.m_withcache) {
    _product.code( " Operation" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *Decode(%s addr, %s insn);\n", source.m_addrtype.str(), codetype_constref().str() );
  }
  _product.code( " std::vector<DecodeTableEntry" );
  _product.template_abbrev( source.m_tparams );
  _product.code( " > const& GetDecodeTable() const { return decode_table; };\n" );
  if (source.m_withcache) {
    _product.code( " void InvalidateDecodingCacheEntry(%s addr);\n", source.m_addrtype.str() );
    _product.code( " void InvalidateDecodingCache();\n\n" );
  }
  _product.code( " void SetLittleEndian();\n" );
  _product.code( " void SetBigEndian();\n" );
  _product.code( options.privatemembers ? "private:\n" : "public:\n" );
  _product.code( " std::vector<DecodeTableEntry" );
  _product.template_abbrev( source.m_tparams );
  _product.code( " > decode_table;\n" );
  if (source.m_withcache) {
    _product.code( " DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *mru_page;\n" );
    _product.code( " DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *decode_hash_table[NUM_DECODE_HASH_TABLE_ENTRIES];\n" );
    _product.code( " DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *FindPage(%s page_key)\n", source.m_addrtype.str() );
    _product.code( "#if defined(__GNUC__) && (__GNUC__ >= 3 && (__GNUC__ != 3 || __GNUC_MINOR__ != 4 || __GNUC_PATCHLEVEL__ != 6))\n" );
    _product.code( " __attribute__((always_inline))\n" );
    _product.code( "#endif\n" );
    _product.code( " ;\n" );
  }
  _product.code( "};\n\n" );
  if (source.m_is_subdecoder) {
    if( not source.m_tparams.empty() ) {
      _product.template_signature( source.m_tparams );
    } else {
      _product.code( "inline\n" );
    }
    _product.code( "Operation *sub_decode(%s addr, %s code) {\n", source.m_addrtype.str(), codetype_constref().str() );
    _product.code( " static Decoder" );
    _product.template_abbrev( source.m_tparams );
    _product.code(" decoder;\n" );
    _product.code( " return decoder.NCDecode( addr, code );\n" );
    _product.code( "}\n" );
  }
}

void
Generator::operation_decl( Product& _product ) const
{
  _product.template_signature( source.m_tparams );
  _product.code( "class Operation\n" );
  _product.code( "{\n" );
  _product.code( "public:\n" );

  _product.code( " Operation(%s code, %s addr, const char *name);\n", codetype_constref().str(), source.m_addrtype.str() );
  _product.code( " virtual ~Operation();\n" );
  if (source.m_withencode)
    _product.code( " virtual void Encode(%s code) const {}\n", codetype_ref().str() );
  _product.code( " inline %s GetAddr() const { return addr; }\n", source.m_addrtype.str() );
  _product.code( " inline void SetAddr(%s _addr) { this->addr = _addr; }\n", source.m_addrtype.str() );
  _product.code( " inline %s GetEncoding() const { return encoding; }\n", codetype_constref().str() );
  op_getlen_decl( _product );
  _product.code( " inline const char *GetName() const { return name; }\n" );
  _product.code( " inline bool Match(%s _addr, %s _code) const { return ", source.m_addrtype.str(), codetype_constref().str());
  op_match( _product, "_code" );
  _product.code( " and GetAddr() == _addr; }\n" );
  
  _product.code( " static unsigned int const minsize = %d;\n", (*source.m_insnsizes.begin()) );
  _product.code( " static unsigned int const maxsize = %d;\n", (*source.m_insnsizes.rbegin()) );
  
  for( Vector<Variable>::const_iterator var = source.m_vars.begin(); var < source.m_vars.end(); ++ var ) {
    _product.code(" ").usercode( *(**var).ctype ).code( " %s;", (**var).symbol.str() );
  }
  
  for( intptr_t idx = source.m_actionprotos.size(); (--idx) >= 0; ) {
    if (source.m_actionprotos[idx]->m_type != ActionProto::Static or not source.m_actionprotos[idx]->m_returns) continue;
    _product.code( " %s %s_result;\n", source.m_actionprotos[idx]->m_returns->content.str(), source.m_actionprotos[idx]->m_symbol.str() );
  }
  
  if (source.m_withsource) {
    /* base declaration for internal encoding and decoding code
     * introspection methods */
    if (source.m_withencode)
      _product.code( "virtual char const* Encode_text() const;\n" );
    _product.code( "virtual char const* Decode_text() const;\n" );
  }
  
  for( intptr_t idx = source.m_actionprotos.size(); (--idx) >= 0; ) {
    if (source.m_withsource) {
      /* base declaration for user-defined code introspection
       * methods */
      _product.code( " virtual char const* %s_text() const;\n", source.m_actionprotos[idx]->m_symbol.str() );
    }
    _product.code( " virtual " );
    if (source.m_actionprotos[idx]->m_returns) {
      _product.usercode( *(source.m_actionprotos[idx]->m_returns) );
    } else {
      _product.code( "void" );
    }

    _product.code( " %s(", source.m_actionprotos[idx]->m_symbol.str() );

    if( not source.m_actionprotos[idx]->m_params.empty() ) {
      char const* sep = " ";
      for( Vector<CodePair>::const_iterator param = source.m_actionprotos[idx]->m_params.begin();
           param < source.m_actionprotos[idx]->m_params.end(); ++ param, sep = ",\n" )
        {
          _product.code( sep ).usercode( *(**param).ctype ).code( " " ).usercode( *(**param).csymbol );
        }
    }

    _product.code( " )%s;\n", (source.m_actionprotos[idx]->m_constness ? " const" : "") );
  }

  _product.code( "protected:\n" );

  _product.code( " %s encoding;\n", codetype_name().str() );
  _product.code( " %s addr;\n", source.m_addrtype.str() );
  _product.code( " const char *name;\n" );

  _product.code( "};\n\n" );
}

unsigned
Generator::membersize( unsigned size ) const
{
  // Operand's C type size is determined by 1/ the least C type
  // required by the ISA operand itself and 2/ the minimal C type
  // required for all operands.
  return std::max( least_ctype_size( size ), m_minwordsize );
}

void
Generator::isa_operations_decl( Product& _product ) const
{
  for( Vector<Operation>::const_iterator op = source.m_operations.begin(); op < source.m_operations.end(); ++ op ) {
    _product.template_signature( source.m_tparams );
    _product.code( "class Op%s : public Operation", Str::capitalize( (**op).symbol.str() ).str() );
    _product.template_abbrev( source.m_tparams );
    _product.code( "\n" );

    _product.code( "{\n" );
    _product.code( "public:\n" );
    _product.code( " Op%s(%s code, %s addr);\n", Str::capitalize( (**op).symbol.str() ).str(),
                   codetype_constref().str(), source.m_addrtype.str() );
    insn_destructor_decl( _product, **op );
    insn_getlen_decl( _product, **op );
    if (source.m_withencode)
      _product.code( " void Encode(%s code) const;\n", codetype_ref().str() );
    
    for( Vector<BitField>::const_iterator bf = (**op).bitfields.begin(); bf < (**op).bitfields.end(); ++ bf )
      {
        if      (OperandBitField const* opbf = dynamic_cast<OperandBitField const*>( &**bf ))
          {
            _product.code( "%sint%d_t %s;\n", (opbf->sext ? "" : "u"), membersize( *opbf ), opbf->symbol.str() );
          }
        else if (SpOperandBitField const* sopbf = dynamic_cast<SpOperandBitField const*>( &**bf ))
          {
            _product.code( "static %sint%d_t const %s = %s;\n",
                           (sopbf->sext ? "" : "u"), membersize( *sopbf ), sopbf->symbol.str(), sopbf->constval().str() );
          }
        else if (SubOpBitField const* sobf = dynamic_cast<SubOpBitField const*>( &**bf ))
          {
            SDInstance const* sdinstance = sobf->sdinstance;
            SDClass const* sdclass = sdinstance->sdclass;
            SourceCode const* tpscheme =  sdinstance->template_scheme;
        
            _product.code(" ").usercode( sdclass->nmcode ).code( "::Operation" );
            if (tpscheme)
              _product.code( "< " ).usercode( *tpscheme ).code( " >");
            _product.code( "* %s;\n", sobf->symbol.str() );
          }
      }

    if (not (**op).variables.empty())
      {
        for (Vector<Variable>::const_iterator var = (**op).variables.begin(); var < (**op).variables.end(); ++ var)
          {
            _product.code( "   " ).usercode( *(**var).ctype, "", Str::fmt(" %s;", (**var).symbol.str()).str() );
          }
      }
    
    if (source.m_withsource) {
      /* insn declaration for internal encoding and decoding code
       * introspection methods */
      if (source.m_withencode)
        _product.code( "char const* Encode_text() const;\n" );
      _product.code( "char const* Decode_text() const;\n" );
    }


    for( Vector<Action>::const_iterator action = (**op).actions.begin(); action < (**op).actions.end(); ++ action ) {
      ActionProto const* actionproto = (**action).m_actionproto;

      if (options.comments)
      {
        for (Vector<Comment>::const_iterator comm = actionproto->m_comments.begin(); comm < actionproto->m_comments.end(); ++ comm)
          _product.code( " %s\n", (**comm).content.str() );
      }
      
      if (source.m_withsource) {
        // for cstring version of the action
        _product.code( " virtual char const* %s_text() const;\n", actionproto->m_symbol.str() );
      }

      _product.code( " virtual\n " );

      if (actionproto->m_returns) {
        _product.usercode( *actionproto->m_returns );
      } else {
        _product.code( "void\n" );
      }

      _product.code( " %s(", actionproto->m_symbol.str() );

      if( not actionproto->m_params.empty() ) {
        char const* sep = " ";
        for( Vector<CodePair>::const_iterator param = actionproto->m_params.begin();
             param < actionproto->m_params.end(); ++ param, sep = ",\n" )
          {
            _product.code( sep ).usercode( *(**param).ctype ).code( " " ).usercode( *(**param).csymbol );
          }
        _product.code( " " );
      }

      _product.code( ")%s;\n", (actionproto->m_constness ? " const" : "") );
    }

    _product.code( options.privatemembers ? "private:\n" : "public:\n" );

    _product.code( "};\n\n" );
  }
}

void
Generator::operation_impl( Product& _product ) const {
  _product.template_signature( source.m_tparams );
  _product.code( "Operation" );
  _product.template_abbrev( source.m_tparams );
  _product.code( "::Operation(%s _code, %s _addr, const char *_name)\n", codetype_constref().str(), source.m_addrtype.str() );
  _product.code( ": \n");
  
  for( Vector<Variable>::const_iterator var = source.m_vars.begin(); var < source.m_vars.end(); ++ var ) {
    if (not (**var).cinit) continue;
    _product.code( " %s(", (**var).symbol.str() ).usercode( *(**var).cinit ).code( "),\n" );
  }

  _product.code( " encoding(_code),\n" );
  _product.code( " addr(_addr),\n" );
  _product.code( " name(_name)\n" );
  _product.code( "{\n" );
  _product.code( "}\n\n" );
  _product.template_signature( source.m_tparams );
  _product.code( "Operation" );
  _product.template_abbrev( source.m_tparams );
  _product.code( "::~Operation()\n" );
  _product.code( "{\n" );
  
  for( intptr_t idx = source.m_actionprotos.size(); (--idx) >= 0; ) {
    if (source.m_actionprotos[idx]->m_type != ActionProto::Destructor) continue;
    _product.code( " %s();\n", source.m_actionprotos[idx]->m_symbol.str() );
  }
  _product.code( "}\n\n" );

  if (source.m_withsource) {
    /* base implemantation for internal encoding and decoding code
     * introspection methods */
    char const* xxcode[2] = {"Decode", "Encode"};
    for (int step = 0; step < 2; ++step) {
      if (step == 1 and not source.m_withencode) continue;
      _product.template_signature( source.m_tparams );
      _product.code( " char const* Operation" );
      _product.template_abbrev( source.m_tparams );
      _product.code( "::%s_text() const { return\"\"; }\n", xxcode[step] );
    }
  }
  
  for( intptr_t idx = source.m_actionprotos.size(); (--idx) >= 0; ) {
    if (source.m_withsource) {
      // for cstring version of the method
      _product.template_signature( source.m_tparams );
      _product.code( " char const* Operation" );
      _product.template_abbrev( source.m_tparams );
      _product.code( "::%s_text() const\n", source.m_actionprotos[idx]->m_symbol.str() );
      _product.code( " { return %s; }", Str::dqcstring( source.m_actionprotos[idx]->m_defaultcode->content.str() ).str() );
    }
    
    _product.template_signature( source.m_tparams );

    if(source.m_actionprotos[idx]->m_returns) {
      _product.usercode( *(source.m_actionprotos[idx]->m_returns) );
    }
    else {
      _product.code( "\nvoid\n" );
    }

    _product.code( " Operation" );
    _product.template_abbrev( source.m_tparams );
    _product.code( "::%s(", source.m_actionprotos[idx]->m_symbol.str() );

    if( not source.m_actionprotos[idx]->m_params.empty() ) {
      char const* sep = " ";
      for( Vector<CodePair>::const_iterator param = source.m_actionprotos[idx]->m_params.begin();
           param < source.m_actionprotos[idx]->m_params.end(); ++ param, sep = ",\n" )
        {
          _product.code( sep ).usercode( *(**param).ctype ).code( " " ).usercode( *(**param).csymbol );
        }
    }

    _product.code( ")%s\n{\n", (source.m_actionprotos[idx]->m_constness ? " const" : "") );
    _product.usercode( *source.m_actionprotos[idx]->m_defaultcode, "{", "}" );
    _product.code( "}\n" );
  }
}

void
Generator::isa_operations_methods( Product& _product ) const
{
  for (Vector<Operation>::const_iterator op = source.m_operations.begin(); op < source.m_operations.end(); ++ op)
  {
    if (options.comments)
    {
      for (Vector<Comment>::const_iterator comm = (**op).comments.begin(); comm < (**op).comments.end(); ++ comm)
        _product.code( "%s\n", (**comm).content.str() );
    }
    
    if (source.m_withsource) {
      /* insn implementation for internal encoding and decoding code
       * introspection methods */
      char const* xxcode[2] = {"Decode", "Encode"};
      for (int step = 0; step < 2; ++step) {
        if (step == 1 and not source.m_withencode) continue;
        SProduct xxcode_text( _product.m_filename, options.sourcelines );
        switch (step) {
        case 0: insn_decode_impl( xxcode_text, **op, "code", "addr" ); break;
        case 1: insn_encode_impl( xxcode_text, **op, "code" ); break;
        }
        _product.template_signature( source.m_tparams );
        _product.code( " char const* Op%s", Str::capitalize( (**op).symbol.str() ).str() );
        _product.template_abbrev( source.m_tparams );
        _product.code( "::%s_text() const\n", xxcode[step] );
        _product.code( " { return %s; }\n", Str::dqcstring( xxcode_text.m_content.c_str() ).str() );
      }
    }
    
    for (Vector<Action>::const_iterator action = (**op).actions.begin(); action < (**op).actions.end(); ++ action) {
      ActionProto const* actionproto = (**action).m_actionproto;

      if (options.comments)
      {
        for (Vector<Comment>::const_iterator comm = (**action).m_comments.begin(); comm < (**action).m_comments.end(); ++ comm)
          _product.code( "%s\n", (**comm).content.str() );
      }

      if (source.m_withsource) {
        // for cstring version of the method
        _product.template_signature( source.m_tparams );
        _product.code( " char const* Op%s", Str::capitalize( (**op).symbol.str() ).str() );
        _product.template_abbrev( source.m_tparams );
        _product.code( "::%s_text() const\n", actionproto->m_symbol.str() );
        _product.code( " { return %s; }", Str::dqcstring( (**action).m_source_code->content.str() ).str() );
      }

      _product.template_signature( source.m_tparams );

      if (actionproto->m_returns) {
        _product.usercode( *actionproto->m_returns );
      }
      else {
        _product.code( "\nvoid\n" );
      }

      _product.code( " Op%s", Str::capitalize( (**op).symbol.str() ).str() );
      _product.template_abbrev( source.m_tparams );
      _product.code( "::%s(", actionproto->m_symbol.str() );

      if( not actionproto->m_params.empty() ) {
        char const* sep = " ";
        for( Vector<CodePair>::const_iterator param = actionproto->m_params.begin();
             param < actionproto->m_params.end(); ++ param, sep = ",\n" )
          {
            _product.code( sep ).usercode( *(**param).ctype ).code( " " ).usercode( *(**param).csymbol );
          }
      }

      _product.code( ")%s\n{\n", (actionproto->m_constness ? " const" : "") );
      _product.usercode( *(**action).m_source_code, "{", "}" );
      _product.code( "}\n" );
    }

    _product.code( "\n" );

    _product.template_signature( source.m_tparams );
    _product.code( "static Operation" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *DecodeOp%s(", Str::capitalize( (**op).symbol.str() ).str() );
    _product.code( "%s code, %s addr)\n", codetype_constref().str(), source.m_addrtype.str() );
    _product.code( "{\n" );
    _product.code( " return new Op%s", Str::capitalize( (**op).symbol.str() ).str() );
    _product.template_abbrev( source.m_tparams );
    _product.code( "(code, addr);\n" );
    _product.code( "}\n\n" );
  }
}

void
Generator::isa_operations_ctors( Product& _product ) const {
  for( Vector<Operation>::const_iterator op = source.m_operations.begin(); op < source.m_operations.end(); ++ op ) {
    _product.template_signature( source.m_tparams );
    _product.code( "Op%s", Str::capitalize( (**op).symbol.str() ).str() );
    _product.template_abbrev( source.m_tparams );
    _product.code( "::Op%s(%s code, %s addr) : Operation", Str::capitalize( (**op).symbol.str() ).str(),
                   codetype_constref().str(), source.m_addrtype.str() );
    _product.template_abbrev( source.m_tparams );
    _product.code( "(code, addr, \"%s\")\n",
                   (**op).symbol.str() );

    _product.code( "{\n" );
    
    insn_decode_impl( _product, **op, "code", "addr" );

    if (not (**op).variables.empty()) {
      for( Vector<Variable>::const_iterator var = (**op).variables.begin(); var < (**op).variables.end(); ++ var ) {
        if ((**var).cinit) {
          _product.code( "%s = ", (**var).symbol.str() ).usercode( *(**var).cinit ).code( ";\n" );
        }
      }
    }

    _product.code( "}\n\n" );
    
    insn_destructor_impl( _product, **op );
  }
}

void
Generator::isa_operations_encoders( Product& _product ) const {
  for( Vector<Operation>::const_iterator op = source.m_operations.begin(); op < source.m_operations.end(); ++ op ) {
    _product.template_signature( source.m_tparams );
    _product.code( "void Op%s", Str::capitalize( (**op).symbol.str() ).str() );
    _product.template_abbrev( source.m_tparams );
    _product.code( "::Encode(%s code) const\n", codetype_ref().str() );

    _product.code( "{\n" );
    
    insn_encode_impl( _product, **op, "code" );

    _product.code( "}\n\n" );
  }
}

void
Generator::decoder_impl( Product& _product ) const {
  if (source.m_withcache) {
    _product.template_signature( source.m_tparams );
    _product.code( "DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( "::DecodeMapPage(%s key)\n", source.m_addrtype.str() );
    _product.code( "{\n" );
    _product.code( " this->key = key;\n" );
    _product.code( " memset(operation, 0, sizeof(operation));\n" );
    _product.code( " next = 0;\n" );
    _product.code( "}\n\n" );
    
    _product.template_signature( source.m_tparams );
    _product.code( "DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( "::~DecodeMapPage()\n" );
    _product.code( "{\n" );
    _product.code( " unsigned int idx;\n" );
    _product.code( " for(idx = 0; idx < NUM_OPERATIONS_PER_PAGE; idx++)\n" );
    _product.code( "  delete operation[idx];\n" );
    _product.code( "}\n\n" );
  }
  _product.template_signature( source.m_tparams );
  _product.code( " DecodeTableEntry" );
  _product.template_abbrev( source.m_tparams );
  _product.code( "::DecodeTableEntry(%s opcode, %s opcode_mask, Operation", codetype_constref().str(), codetype_constref().str() );
  _product.template_abbrev( source.m_tparams );
  _product.code( " *(*decode)(%s, %s))\n", codetype_constref().str(), source.m_addrtype.str() );
  _product.code( " {\n" );
  _product.code( "  this->opcode = opcode;\n" );
  _product.code( "  this->opcode_mask = opcode_mask;\n" );
  _product.code( "  this->decode = decode;\n" );
  _product.code( " }\n\n" );
  
  
  _product.template_signature( source.m_tparams );
  _product.code( "Decoder" );
  _product.template_abbrev( source.m_tparams );
  _product.code( "::Decoder()\n" );
  char const* member_init_separator = ": ";
  if (source.m_withcache)
    {
      _product.code( "%smru_page( 0 )", member_init_separator );
      member_init_separator = ", ";
    }
  _product.code( "\n{\n" );
  if (source.m_withcache)
    _product.code( " memset(decode_hash_table, 0, sizeof(decode_hash_table));\n" );
  
  for( Vector<Operation>::const_reverse_iterator op = source.m_operations.rbegin(); op < source.m_operations.rend(); ++ op ) {
    if( (**op).condition ) {
      _product.code( "if(" ).usercode( *(**op).condition ).code( ")" );
    }
    _product.code( " decode_table.push_back(DecodeTableEntry" );
    _product.template_abbrev( source.m_tparams );
    _product.code( "(" );
    insn_bits_code( _product, **op );
    _product.code( ", " );
    insn_mask_code( _product, **op );
    _product.code( ", DecodeOp%s", Str::capitalize( (**op).symbol.str() ).str() );
    _product.template_abbrev( source.m_tparams );
    _product.code( "));\n" );
  }
  _product.code( "}\n\n" );

  _product.template_signature( source.m_tparams );
  _product.code( "Decoder" );
  _product.template_abbrev( source.m_tparams );
  _product.code( "::~Decoder()\n" );
  _product.code( "{\n" );
  if (source.m_withcache) {
    _product.code( " InvalidateDecodingCache();\n" );
  }
  _product.code( "}\n\n" );
  
  /*** NCDecode( Address_t addr, CodeType_t code ) ***/
  _product.template_signature( source.m_tparams );
  _product.code( "Operation" );
  _product.template_abbrev( source.m_tparams );
  _product.code( " *Decoder" );
  _product.template_abbrev( source.m_tparams );
  _product.code( "::NCDecode(%s addr, %s code)\n", source.m_addrtype.str(), codetype_constref().str() );
  _product.code( "{\n" );
  _product.code( " Operation" );
  _product.template_abbrev( source.m_tparams );
  _product.code( " *operation;\n" );
  _product.code( " unsigned int count = decode_table.size();\n" );
  _product.code( " unsigned int idx;\n" );
  _product.code( " for(idx = 0; idx < count; idx++)\n" );
  _product.code( " {\n" );
  insn_match_ifexpr( _product, "code", "decode_table[idx].opcode_mask", "decode_table[idx].opcode" );
  _product.code( "  {\n" );
  _product.code( "   operation = decode_table[idx].decode(code, addr);\n" );

  for( intptr_t idx = source.m_actionprotos.size();  (--idx) >= 0; ) {
    switch( source.m_actionprotos[idx]->m_type ) {
    case ActionProto::Constructor:
      _product.code( "   operation->%s();\n", source.m_actionprotos[idx]->m_symbol.str() );
      break;
        
    case ActionProto::Static:
      _product.code( "   " );
      if (source.m_actionprotos[idx]->m_returns)
        _product.code( "operation->%s_result = ", source.m_actionprotos[idx]->m_symbol.str() );
      _product.code( "operation->%s();\n", source.m_actionprotos[idx]->m_symbol.str() );
      break;
        
    default: break;
    }
  }
    
  _product.code( "   return operation;\n" );
  _product.code( "  }\n" );
  _product.code( " }\n" );
  
  _product.code( " operation = new Operation" );
  _product.template_abbrev( source.m_tparams );
  _product.code( "(code, addr, \"???\");\n" );
    
    
  for( intptr_t idx = source.m_actionprotos.size();  (--idx) >= 0; ) {
    switch( source.m_actionprotos[idx]->m_type ) {
    case ActionProto::Constructor:
      _product.code( " operation->%s();\n", source.m_actionprotos[idx]->m_symbol.str() );
      break;
    case ActionProto::Static:
      _product.code( " " );
      if (source.m_actionprotos[idx]->m_returns)
        _product.code( "operation->%s_result = ", source.m_actionprotos[idx]->m_symbol.str() );
      _product.code( "operation->%s();\n", source.m_actionprotos[idx]->m_symbol.str() );
      break;
    default: break;
    }
  }
    
  _product.code( " return operation;\n" );
  _product.code( "}\n\n" );
  
  if (source.m_withcache) {
    /*** InvalidateDecodingCache() ***/
    _product.template_signature( source.m_tparams );
    _product.code( "void Decoder" );
    _product.template_abbrev( source.m_tparams );
    _product.code( "::InvalidateDecodingCache()\n" );
    _product.code( "{\n" );
    _product.code( " uint32_t index;\n" );
    _product.code( " mru_page = 0;\n" );
    _product.code( " for(index = 0; index < NUM_DECODE_HASH_TABLE_ENTRIES; index++)\n" );
    _product.code( " {\n" );
    _product.code( "  DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *page, *next_page;\n" );

    _product.code( "  page = decode_hash_table[index];\n" );
    _product.code( "  if(page)\n" );
    _product.code( "  {\n" );
    _product.code( "   do\n" );
    _product.code( "   {\n" );
    _product.code( "   next_page = page->next;\n" );
    _product.code( "   delete page;\n" );
    _product.code( "   page = next_page;\n" );
    _product.code( "   } while(page);\n" );
    _product.code( "  decode_hash_table[index] = 0;\n" );
    _product.code( "  }\n" );
    _product.code( " }\n" );
    _product.code( "}\n\n" );
  
    ConstStr instid = insn_id_expr( "addr" );

    /*** InvalidateDecodingCacheEntry( Address_t addr ) ***/
    _product.template_signature( source.m_tparams );
    _product.code( "void Decoder" );
    _product.template_abbrev( source.m_tparams );
    _product.code( "::InvalidateDecodingCacheEntry(%s addr)\n", source.m_addrtype.str() );
    _product.code( "{\n" );
    _product.code( " %s page_key = %s / NUM_OPERATIONS_PER_PAGE;\n", source.m_addrtype.str(), instid.str() );
    _product.code( " if(mru_page && mru_page->key == page_key) mru_page = 0;\n" );
    _product.code( " uint32_t index = page_key %% NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key\n" );
    _product.code( " DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *prev, *cur;\n" );
    _product.code( " cur = decode_hash_table[index];\n" );
    _product.code( " if(cur)\n" );
    _product.code( " {\n" );
    _product.code( "  if(cur->key == page_key)\n" );
    _product.code( "  {\n" );
    _product.code( "   decode_hash_table[index] = cur->next;\n" );
    _product.code( "   delete cur;\n" );
    _product.code( "   return;\n" );
    _product.code( "  }\n" );
    _product.code( "  prev = cur;\n" );
    _product.code( "  cur = cur->next;\n" );
    _product.code( "  if(cur)\n" );
    _product.code( "  {\n" );
    _product.code( "   do\n" );
    _product.code( "   {\n" );
    _product.code( "    if(cur->key == page_key)\n" );
    _product.code( "    {\n" );
    _product.code( "     prev->next = cur->next;\n" );
    _product.code( "     cur->next = 0;\n" );
    _product.code( "     delete cur;\n" );
    _product.code( "     return;\n" );
    _product.code( "    }\n" );
    _product.code( "    prev = cur;\n" );
    _product.code( "   } while((cur = cur->next) != 0);\n" );
    _product.code( "  }\n" );
    _product.code( " }\n" );
    _product.code( "}\n\n" );

    /*** FindPage( Address_t page_key ) ***/
    _product.template_signature( source.m_tparams );
    _product.code( "inline DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *Decoder" );
    _product.template_abbrev( source.m_tparams );
    _product.code( "::FindPage(%s page_key)\n", source.m_addrtype.str() );
    _product.code( "{\n" );
    _product.code( " if(mru_page && mru_page->key == page_key) return mru_page;\n" );
    _product.code( " uint32_t index = page_key %% NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key\n" );
    _product.code( " DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *prev, *cur;\n" );
    _product.code( " cur = decode_hash_table[index];\n" );
    _product.code( " if(cur)\n" );
    _product.code( " {\n" );
    _product.code( "  if(cur->key == page_key)\n" );
    _product.code( "  {\n" );
    _product.code( "   mru_page = cur;\n" );
    _product.code( "   return cur;\n" );
    _product.code( "  }\n" );
    _product.code( "  prev = cur;\n" );
    _product.code( "  cur = cur->next;\n" );
    _product.code( "  if(cur)\n" );
    _product.code( "  {\n" );
    _product.code( "   do\n" );
    _product.code( "   {\n" );
    _product.code( "    if(cur->key == page_key)\n" );
    _product.code( "    {\n" );
    _product.code( "     prev->next = cur->next;\n" );
    _product.code( "     cur->next= decode_hash_table[index];\n" );
    _product.code( "     decode_hash_table[index] = cur;\n" );
    _product.code( "     mru_page = cur;\n" );
    _product.code( "     return cur;\n" );
    _product.code( "    }\n" );
    _product.code( "    prev = cur;\n" );
    _product.code( "   } while((cur = cur->next) != 0);\n" );
    _product.code( "  }\n" );
    _product.code( " }\n" );
    _product.code( " return 0;\n" );
    _product.code( "}\n\n" );

    /*** Decode( Address_t addr, CodeType_t const& insn ) ***/
    _product.template_signature( source.m_tparams );
    _product.code( "Operation" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *Decoder" );
    _product.template_abbrev( source.m_tparams );
    _product.code( "::Decode(%s addr, %s insn)\n", source.m_addrtype.str(), codetype_constref().str() );
    _product.code( "{\n" );
    _product.code( " Operation" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *operation;\n" );
    _product.code( " %s page_key = %s / NUM_OPERATIONS_PER_PAGE;\n", source.m_addrtype.str(), instid.str() );
    _product.code( " DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " *page;\n" );
    _product.code( " page = FindPage(page_key);\n" );
    _product.code( " if(!page)\n" );
    _product.code( " {\n" );
    // _product.code( "   fprintf(stderr, \"page miss at 0x%%08x\\n\", addr);\n" );
    _product.code( "  page = new DecodeMapPage" );
    _product.template_abbrev( source.m_tparams );
    _product.code( " (page_key);\n" );
    _product.code( "  uint32_t index = page_key %% NUM_DECODE_HASH_TABLE_ENTRIES; // hash the key\n" );
    _product.code( "  page->next = decode_hash_table[index];\n" );
    _product.code( "  decode_hash_table[index] = page;\n" );
    _product.code( "  mru_page = page;\n" );
    _product.code( " }\n" );
    _product.code( " operation = page->operation[(%s) & (NUM_OPERATIONS_PER_PAGE - 1)];\n", instid.str() );
    _product.code( " if(operation)\n" );
    _product.code( " {\n" );
    // _product.code( "  fprintf(stderr, \"hit at 0x%%08x\\n\", addr);\n" );
    _product.code( "  if(operation->Match(addr, insn))\n");
    _product.code( "   return operation;\n" );
    _product.code( "  delete operation;\n" );
    _product.code( " }\n" );
    // _product.code( " fprintf(stderr, \"miss at 0x%%08x\\n\", addr);\n" );
    _product.code( " operation = NCDecode(addr, insn);\n" );
    _product.code( " page->operation[(%s) & (NUM_OPERATIONS_PER_PAGE - 1)] = operation;\n", instid.str() );
    _product.code( " return operation;\n" );
    _product.code( "}\n\n" );
  }
}

unsigned int
Generator::least_ctype_size( unsigned int bits ) {
  if (bits > 64) throw GenerationError;
  unsigned int size = 8;
  while (size < bits) size *= 2;
  return size;
}
