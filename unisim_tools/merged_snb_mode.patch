Index: genisslib/ciscgenerator.hh
===================================================================
--- genisslib/ciscgenerator.hh	(revision 11941)
+++ genisslib/ciscgenerator.hh	(working copy)
@@ -27,19 +27,25 @@
 struct CiscGenerator : public Generator {
   /* The opcode structure used to work on operation structures*/
   struct OpCode_t {
-    unsigned int                m_size;
     uint8_t*                    m_mask;
     uint8_t*                    m_bits;
+    unsigned int                m_prefixsize;
+    unsigned int                m_fullsize;
+    bool                        m_vlen;
     // Topology information
     OpCode_t*                   m_upper;
     intptr_t                    m_lowercount;
     
-    OpCode_t() : m_size( 0 ), m_mask( 0 ), m_bits( 0 ), m_upper( 0 ), m_lowercount( 0 ) {}
+    OpCode_t()
+      : m_mask( 0 ), m_bits( 0 ), m_prefixsize( 0 ), m_fullsize( 0 ), m_vlen( false ),
+        m_upper( 0 ), m_lowercount( 0 ) {}
     ~OpCode_t() { delete [] m_mask; }
     
-    void                        size( unsigned int _size );
+    void                        size_attrs( unsigned int prefixsize, unsigned int fullsize, bool vlen );
     bool                        match( OpCode_t const& _oc ) const;
-    void                        optimize();
+    void                        optimize( bool is_little_endian );
+    unsigned int                maskbytesize() const { return (m_prefixsize+7)/8; };
+    
     // Topology methods
     enum Location_t { Outside, Overlaps, Inside, Contains, Equal };
     Location_t                  locate( OpCode_t const& _oc ) const;
@@ -51,7 +57,7 @@
   typedef std::map<Operation_t const*,OpCode_t> OpCodes_t;
 
   OpCodes_t                     m_opcodes;
-  unsigned int                  m_insn_bytesize;
+  unsigned int                  m_code_capacity;
   
   CiscGenerator();
   ~CiscGenerator() {};
Index: genisslib/riscgenerator.cc
===================================================================
--- genisslib/riscgenerator.cc	(revision 11941)
+++ genisslib/riscgenerator.cc	(working copy)
@@ -124,12 +124,21 @@
   for( Vect_t<Operation_t>::const_iterator op = operations.begin(); op < operations.end(); ++ op ) {
     Vect_t<BitField_t> const& bitfields = (**op).m_bitfields;
     
-    bool vlen = false, outprefix = false;
+    bool vlen = false, outprefix = false, vword = false;
     unsigned int insn_size = 0;
     uint64_t mask = 0, bits = 0;
     
     for (FieldIterator fi( isa().m_little_endian, bitfields, m_insn_maxsize ); fi.next(); ) { 
+      if (fi.item().type() == BitField_t::Separator) {
+        if (dynamic_cast<SeparatorBitField_t const&>( fi.item() ).m_rewind and vword) {
+          (**op).m_fileloc.err( "error: operation `%s' rewinds a variable length word.", (**op).m_symbol.str() );
+          throw GenerationError;
+        }
+        vword = false;
+      }
+      
       if (fi.item().minsize() != fi.item().maxsize()) {
+        vword = true;
         vlen = true;
         outprefix = true;
       }
@@ -140,7 +149,7 @@
       bits |= fi.item().bits() << fi.pos();
       mask |= fi.item().mask() << fi.pos();
     }
-    m_opcodes[*op] = OpCode_t( vlen, insn_size, mask, bits );
+    m_opcodes[*op] = OpCode_t( mask, bits, insn_size, vlen );
   }
   
   /* Generating the topological graph of operations, checking for
@@ -241,7 +250,7 @@
       _product.code( "%s = ", opbf.m_symbol.str() );
       
       if( opbf.m_sext ) {
-        int sizeofop = std::max( opbf.dstsize(), m_minwordsize );
+        int sizeofop = std::max( least_ctype_size( opbf.dstsize() ), m_minwordsize );
         int sext_shift = sizeofop - opbf.m_size;
         _product.code( "(((((int%d_t)(%s >> %u)) & 0x%llx) << %u) >> %u)",
                        sizeofop, _codename, fi.pos(),
Index: genisslib/ciscgenerator.cc
===================================================================
--- genisslib/ciscgenerator.cc	(revision 11941)
+++ genisslib/ciscgenerator.cc	(working copy)
@@ -40,26 +40,40 @@
  *  @brief  Default constructor, create a CiscGenerator.
  */
 CiscGenerator::CiscGenerator()
-  : m_insn_bytesize( 0 )
+  : m_code_capacity( 0 )
 {};
 
 /** Set the size of the OpCode and allocates mask and bits buffers
 */
 void
-CiscGenerator::OpCode_t::size( unsigned int _size ) {
-  assert( m_size == 0 );
-  m_size = _size;
-  m_mask = new uint8_t[_size*2];
-  m_bits = &m_mask[_size];
-  memset( m_mask, 0, _size*2 );
+
+CiscGenerator::OpCode_t::size_attrs( unsigned int prefixsize, unsigned int fullsize, bool vlen ) {
+  assert( m_prefixsize == 0 );
+  m_prefixsize = prefixsize;
+  unsigned int mbsz = maskbytesize();
+  m_fullsize = fullsize;
+  m_mask = new uint8_t[mbsz*2];
+  m_bits = &m_mask[mbsz];
+  memset( m_mask, 0, mbsz*2 );
+  m_vlen = vlen;
 }
 
-/** Optimize the size of OpCode object: right zero-mask bytes are stripped. */
+/** Optimize the size of OpCode object: upper zero-mask bits are stripped. */
 void
-CiscGenerator::OpCode_t::optimize() {
-  unsigned int stripped_size = m_size;
-  while( stripped_size > 0 and m_mask[stripped_size-1] == 0 ) stripped_size -= 1;
-  m_size = stripped_size;
+CiscGenerator::OpCode_t::optimize( bool is_little_endian ) {
+  unsigned int stripped_size = m_prefixsize;
+  if (is_little_endian) {
+    for (; stripped_size > 0; stripped_size -= 1) {
+      unsigned int byte = (stripped_size-1)/8, bit = (stripped_size-1)%8;
+      if (((m_mask[byte] >> bit) & 1) != 0) break;
+    }
+  } else {
+    for (; stripped_size > 0; stripped_size -= 1) {
+      unsigned int byte = (stripped_size-1)/8, bit = (-stripped_size)%8;
+      if (((m_mask[byte] >> bit) & 1) != 0) break;
+    }
+  }
+  m_prefixsize = stripped_size;
 }
 
 /**
@@ -79,13 +93,13 @@
 CiscGenerator::OpCode_t::Location_t
 CiscGenerator::OpCode_t::locate( CiscGenerator::OpCode_t const& _that ) const {
   /* this is named A and _that is named B */
-  unsigned int asize = m_size, bsize = _that.m_size, maxsize = std::max( asize, bsize );
+  unsigned int abytesize = maskbytesize(), bbytesize = _that.maskbytesize(), maxsize = std::max( abytesize, bbytesize );
   bool some_a_outside_B = false, some_b_outside_A = false;
 
   for( unsigned int idx = 0; idx < maxsize; ++ idx ) {
     uint8_t amask, abits, bmask, bbits;
-    if( idx < asize ) { amask = this->m_mask[idx]; abits = this->m_bits[idx]; } else { amask = 0; abits = 0; }
-    if( idx < bsize ) { bmask = _that.m_mask[idx]; bbits = _that.m_bits[idx]; } else { bmask = 0; bbits = 0; }
+    if( idx < abytesize ) { amask = this->m_mask[idx]; abits = this->m_bits[idx]; } else { amask = 0; abits = 0; }
+    if( idx < bbytesize ) { bmask = _that.m_mask[idx]; bbits = _that.m_bits[idx]; } else { bmask = 0; bbits = 0; }
     
     if( (((amask) & (bmask)) & ((abits) ^ (bbits))) != 0 ) return Outside;
     if( ~(amask) & (bmask) ) some_a_outside_B = true;
@@ -131,7 +145,7 @@
  */
 bool
 CiscGenerator::OpCode_t::match( OpCode_t const& _oc ) const {
-  unsigned int bytesize = std::min( m_size, _oc.m_size );
+  unsigned int bytesize = std::min( maskbytesize(), _oc.maskbytesize() );
   for( unsigned int byte = 0; byte < bytesize; ++byte ) {
     if( (_oc.m_bits[byte] & m_mask[byte]) != m_bits[byte] )
       return false;
@@ -147,10 +161,10 @@
 operator<<( std::ostream& _sink, CiscGenerator::OpCode_t const& _oc ) {
   char hex[] = "0123456789abcdef";
   uint32_t byte;
-  _sink << "{size: " << _oc.m_size << ", mask: 0x";
-  for( unsigned int idx = 0; idx < _oc.m_size; ++ idx ) { byte = _oc.m_mask[idx]; _sink << hex[byte/16] << hex[byte%16]; }
+  _sink << "{size: " << _oc.maskbytesize() << ", mask: 0x";
+  for( unsigned int idx = 0; idx < _oc.maskbytesize(); ++ idx ) { byte = _oc.m_mask[idx]; _sink << hex[byte/16] << hex[byte%16]; }
   _sink << ", bits: 0x";
-  for( unsigned int idx = 0; idx < _oc.m_size; ++ idx ) { byte = _oc.m_bits[idx]; _sink << hex[byte/16] << hex[byte%16]; }
+  for( unsigned int idx = 0; idx < _oc.maskbytesize(); ++ idx ) { byte = _oc.m_bits[idx]; _sink << hex[byte/16] << hex[byte%16]; }
   _sink << "}";
   return _sink;
 }
@@ -207,17 +221,34 @@
 void
 CiscGenerator::finalize() {
   // Finalize size information
-  m_insn_bytesize = m_insn_maxsize / 8;
+  m_code_capacity = (m_insn_maxsize + 7) / 8;
   
   // Process the opcodes needed by the decoder
   for( Vect_t<Operation_t>::const_iterator op = isa().m_operations.begin(); op < isa().m_operations.end(); ++ op ) {
     // compute prefix size
-    unsigned int prefixsize = 0;
+    unsigned int prefixsize = 0, insn_size = 0;
+    bool vlen = false, outprefix = false, vword = false;
+    
     for (FieldIterator fi( isa().m_little_endian, (**op).m_bitfields, m_insn_maxsize ); fi.next(); ) {
-      if (fi.item().minsize() != fi.item().maxsize()) break;
+      if (fi.item().type() == BitField_t::Separator) {
+        if (dynamic_cast<SeparatorBitField_t const&>( fi.item() ).m_rewind and vword) {
+          (**op).m_fileloc.err( "error: operation `%s' rewinds a variable length word.", (**op).m_symbol.str() );
+          throw GenerationError;
+        }
+        vword = false;
+      }
+      
+      if (fi.item().minsize() != fi.item().maxsize()) {
+        vword = true;
+        outprefix = true;
+        vlen = true;
+      }
+      
+      insn_size = std::max( insn_size, fi.insn_size() );
+      if (outprefix) continue;
       if (prefixsize < fi.insn_size()) prefixsize = fi.insn_size();
     }
-    m_opcodes[*op].size( prefixsize / 8 );
+    m_opcodes[*op].size_attrs( prefixsize, insn_size, vlen );
     
     // compute opcode
     OpCode_t& oc = opcode( *op );
@@ -240,7 +271,7 @@
         pos = little_endian ? pos + shift : pos - shift;
       }
     }
-    oc.optimize();
+    oc.optimize( isa().m_little_endian );
   }
   
   /* Generating the topological graph of operations, and checking for
@@ -314,45 +345,110 @@
 
 void
 CiscGenerator::codetype_decl( Product_t& _product ) const {
+  bool little_endian = isa().m_little_endian;
+  char const* dsh = little_endian ? ">>" : "<<";
+  char const* ash = little_endian ? "<<" : ">>";
   _product.code( "struct CodeType {\n" );
-  _product.code( " static const unsigned int maxsize = %d;\n", m_insn_bytesize );
+  _product.code( " static const unsigned int capacity = %d;\n", m_code_capacity );
   _product.code( " unsigned int              size;\n" );
-  _product.code( " uint8_t                   str[maxsize];\n" );
+  _product.code( " uint8_t                   str[capacity];\n" );
   _product.code( " enum Exception_t { NotEnoughBytes };\n" );
   _product.code( " CodeType() : size( 0 ) {};\n" );
-  _product.code( " CodeType( uint8_t* _src, unsigned int _size )\n" );
-  _product.code( " : size( std::min( _size, maxsize ) ) { memcpy( str, _src, size ); }\n" );
-  _product.code( " CodeType( CodeType const& _ct )\n" );
-  _product.code( " : size( _ct.size ) { memcpy( str, _ct.str, _ct.size ); }\n" );
-  _product.code( " bool match( CodeType const& _bits, CodeType const& _mask ) const {\n" );
-  _product.code( "  for( unsigned int idx = 0; idx < _mask.size; ++idx ) {\n" );
-  _product.code( "   if( idx >= size ) throw NotEnoughBytes;\n" );
-  _product.code( "   if( (str[idx] & _mask.str[idx]) != _bits.str[idx] ) return false;\n" );
+  _product.code( " CodeType( uint8_t* src, unsigned int sz )\n" );
+  _product.code( " : size( std::min( sz, capacity*8 ) )\n{\n" );
+  _product.code( "   for (int idx = (size+7)/8; (--idx) >= 0;) str[idx] = src[idx];\n" );
+  _product.code( " }\n" );
+  _product.code( " CodeType( CodeType const& ct )\n" );
+  _product.code( " : size( ct.size )\n{\n" );
+  for (unsigned int idx = 0; idx < m_code_capacity; ++idx)
+    _product.code( " str[%u] = ct.str[%u];", idx, idx );
+  _product.code( "\n }\n" );
+  _product.code( " bool match( CodeType const& bits, CodeType const& mask ) const {\n" );
+  _product.code( "  unsigned int maskbound = (mask.size+7)/8, codebound = (size+7)/8;\n" );
+  _product.code( "  for (unsigned int idx = 0; idx < maskbound; ++idx) {\n" );
+  _product.code( "   if (idx >= codebound) throw NotEnoughBytes;\n" );
+  _product.code( "   if ((str[idx] & mask.str[idx]) != bits.str[idx]) return false;\n" );
   _product.code( "  };\n" );
   _product.code( "  return true;\n" );
-  _product.code( " };\n" );
-  _product.code( " bool match( CodeType const& _bits ) const {\n" );
-  _product.code( "  if( size < _bits.size ) throw NotEnoughBytes;\n" );
-  _product.code( "  return memcmp( str, _bits.str, _bits.size ) == 0;\n" );
   _product.code( " }\n" );
-  _product.code( " void pop( unsigned int _bytes ) {\n" );
-  _product.code( "  if( size < _bytes ) throw NotEnoughBytes;\n" );
-  _product.code( "  size -= _bytes;\n" );
-  _product.code( "  memmove( str, str + _bytes, size );\n" );
+  _product.code( " bool match( CodeType const& bits ) const {\n" );
+  _product.code( "  if (size < bits.size) throw NotEnoughBytes;\n" );
+  _product.code( "  unsigned int end = bits.size/8;\n" );
+  _product.code( "  for (unsigned int idx = 0; idx < end; idx += 1)\n" );
+  _product.code( "   if (str[idx] != bits.str[idx]) return false;\n" );
+  _product.code( "  unsigned int tail = (bits.size % 8);\n" );
+  _product.code( "  if (tail == 0); return true;" );
+  _product.code( "  uint8_t tailmask = 0xff %s (8-tail);\n", isa().m_little_endian ? ">>" : "<<" );
+  _product.code( "  return ((str[end] ^ bits.str[end]) & tailmask) == 0;\n" );
   _product.code( " }\n" );
+  _product.code( " CodeType& stretch_front( unsigned int shift ) {\n" );
+  _product.code( "  int hish = shift / 8, losh = shift % 8;\n" );
+  _product.code( "  for (int dst = %u, src = dst - hish; dst >= 0; dst-=1, src-=1) {\n",
+                 m_code_capacity - 1 );
+  _product.code( "   if (src > 0) str[dst] = (str[src] %s losh) | (str[src-1] %s (8-losh));\n",
+                 ash, dsh );
+  _product.code( "   else if (src == 0) str[dst] = (str[src] %s losh);\n", ash );
+  _product.code( "   else str[dst] = 0;\n" );
+  _product.code( "  }\n" );
+  _product.code( "  return *this;\n" );
+  _product.code( " }\n" );
+  _product.code( " CodeType& shrink_front( unsigned int shift ) {\n" );
+  _product.code( "  int hish = shift / 8, losh = shift % 8;\n" );
+  _product.code( "  for (unsigned int dst = 0, src = dst + hish; dst < %u; dst+=1, src+=1) {\n",
+                 m_code_capacity);
+  _product.code( "   if (src < %u) str[dst] = (str[src] %s losh) | (str[src-1] %s (8-losh));\n",
+                 m_code_capacity - 1, dsh, ash );
+  _product.code( "   else if (src == %u) str[dst] = (str[src] %s losh);\n",
+                 m_code_capacity - 1, dsh );
+  _product.code( "   else str[dst] = 0;\n" );
+  _product.code( "  }\n" );
+  _product.code( "  return *this;\n" );
+  _product.code( " }\n" );
+  _product.code( " CodeType& extend( uint8_t* src, unsigned int sz ) {\n" );
+  _product.code( "  CodeType tail( src, sz );\n" );
+  _product.code( "  unsigned int mod = this->size % 8;\n" );
+  _product.code( "  if (mod) {\n" );
+  _product.code( "   tail.size = std::min( tail.size + mod, capacity*8 );\n" );
+  _product.code( "   tail.stretch_front( mod );\n" );
+  _product.code( "   tail.str[0] = (tail.str[0] & (0xff %s mod)) | "
+                 "(this->str[this->size/8] & (0xff %s (8-mod)));\n", ash, dsh );
+  _product.code( "   this->size -= mod;\n" );
+  _product.code( "  }\n" );
+  _product.code( "  for (unsigned int src = 0, dst = this->size/8; "
+                 "(src < this->capacity) and (dst < this->capacity); src+=1, dst+=1) {\n" );
+  _product.code( "   this->str[dst] = tail.str[src];\n" );
+  _product.code( "  }\n" );
+  _product.code( "  this->size = std::min( this->size + tail.size, capacity*8 );\n" );
+  _product.code( "  return *this;\n" );
+  _product.code( " }\n" );
   _product.code( " friend std::ostream& operator << ( std::ostream& _sink, CodeType const& _ct );\n" );
   _product.code( "};\n" );
 }
 
 void
 CiscGenerator::codetype_impl( Product_t& _product ) const {
-  _product.code( "unsigned int const CodeType::maxsize;\n" );
+  _product.code( "unsigned int const CodeType::capacity;\n" );
   _product.code( "std::ostream& operator << ( std::ostream& _sink, CodeType const& _ct ) {\n" );
-  _product.code( " char const* xrepr = \"0123456789abcdef\";\n" );
-  _product.code( " char const* sep = \"\";\n" );
-  _product.code( " for( unsigned int idx = 0; idx < _ct.size; ++idx, sep = \" \" ) {\n" );
-  _product.code( "  uint32_t byte = _ct.str[idx];\n" );
-  _product.code( "  _sink << sep << xrepr[byte/16] << xrepr[byte%%16];\n" );
+  _product.code( " if (_ct.size % 8) {\n" );
+  if (isa().m_little_endian) {
+    _product.code( "  for (int idx = _ct.size; (--idx) >= 0; ) {\n" );
+    _product.code( "   _sink << (((_ct.str[idx/8] >> (idx%8)) & 1) ? '1' : '0');\n" );
+    _product.code( "  }\n" );
+  } else {
+    _product.code( "  for (unsigned int idx = 0; idx < _ct.size; ++idx ) {\n" );
+    _product.code( "   _sink << (((_ct.str[idx/8] >> ((7-idx)%8)) & 1) ? '1' : '0');" );
+    _product.code( "  }\n" );
+  }
+  _product.code( " } else {\n" );
+  _product.code( "  char const* xrepr = \"0123456789abcdef\";\n" );
+  if (isa().m_little_endian) {
+    _product.code( "  for (int idx = _ct.size/8; (--idx) >= 0; ) {\n" );
+  } else {
+    _product.code( "  for (unsigned int idx = 0; idx < _ct.size/8; ++idx ) {\n" );
+  }
+  _product.code( "    uint8_t byte = _ct.str[idx/8];\n" );
+  _product.code( "   _sink << xrepr[(byte >> 4) & 0xf] << xrepr[(byte >> 0) & 0xf];\n" );
+  _product.code( "  }\n" );
   _product.code( " }\n" );
   _product.code( " return _sink;\n" );
   _product.code( "}\n" );
@@ -363,9 +459,9 @@
   OpCode_t const& oc = opcode( &_op );
   _product.code( "CodeType( (uint8_t*)( \"" );
   char const* hex = "0123456789abcdef";
-  for( unsigned int idx = 0; idx < oc.m_size; ++idx )
+  for( unsigned int idx = 0; idx < oc.maskbytesize(); ++idx )
     _product.code( "\\x%c%c", hex[oc.m_bits[idx]/16], hex[oc.m_bits[idx]%16] );
-  _product.code( "\" ), %u )", oc.m_size );
+  _product.code( "\" ), %u )", oc.m_prefixsize );
 }
 
 void
@@ -373,9 +469,9 @@
   OpCode_t const& oc = opcode( &_op );
   _product.code( "CodeType( (uint8_t*)( \"" );
   char const* hex = "0123456789abcdef";
-  for( unsigned int idx = 0; idx < oc.m_size; ++idx )
+  for( unsigned int idx = 0; idx < oc.maskbytesize(); ++idx )
     _product.code( "\\x%c%c", hex[oc.m_mask[idx]/16], hex[oc.m_mask[idx]%16] );
-  _product.code( "\" ), %u )", oc.m_size );
+  _product.code( "\" ), %u )", oc.m_prefixsize );
 }
 
 void
@@ -386,68 +482,86 @@
 void
 CiscGenerator::insn_decode_impl( Product_t& _product, Operation_t const& _op, char const* _codename, char const* _addrname ) const
 {
-  _product.code( "CodeType _code_( %s );\n", _codename );
-  for (BFWordIterator bfword( _op.m_bitfields ); bfword.next();) {
-    if (bfword.m_has_subop) {
-      SubOpBitField_t const& sobf = dynamic_cast<SubOpBitField_t const&>( **bfword.m_left );
+  OpCode_t const& oc = opcode( &_op );
+  _product.code( "this->encoding.size = %u;\n", oc.m_fullsize );
+  if (oc.m_vlen) {
+    char const* ncodename = "_code_";
+    _product.code( "CodeType %s( %s );\n", ncodename, _codename );
+    _codename = ncodename;
+  }
+  
+  bool little_endian = isa().m_little_endian;
+  char const* dsh = little_endian ? ">>" : "<<";
+  char const* ash = little_endian ? "<<" : ">>";
+  
+  for (FieldIterator fi( isa().m_little_endian, _op.m_bitfields, m_insn_maxsize ); fi.next(); ) {
+    if (fi.item().type() == BitField_t::SubOp) {
+      SubOpBitField_t const& sobf = dynamic_cast<SubOpBitField_t const&>( fi.item() );
       SDInstance_t const* sdinstance = sobf.m_sdinstance;
       SDClass_t const* sdclass = sdinstance->m_sdclass;
       SourceCode_t const* tpscheme =  sdinstance->m_template_scheme;
-        
+      
+      _product.code( "{\n" );
+      _product.code( "%s::CodeType _subcode_;\n", sdclass->qd_namespace().str() );
+      _product.code( "_subcode_.size = %u;\n", sdclass->m_maxsize );
+      
+      unsigned int shift = fi.insn_size() - fi.m_size;
+      unsigned int byteshift = shift / 8;
+      shift = shift % 8;
+      unsigned int subbytes = (sdclass->m_maxsize + 7) / 8;
+      
+      for (unsigned int idx = 0; idx < subbytes; ++idx) {
+        unsigned int didx = idx + byteshift;
+        _product.code( "_subcode_.str[%u] = ", idx );
+        _product.code( "uint8_t( %s.str[%u] %s %u )", _codename, didx, dsh, shift );
+        if (shift > 0 and (didx + 1) < m_code_capacity)
+          _product.code( "| uint8_t( %s.str[%u] %s %u )", _codename, didx + 1, ash, 8 - shift );
+        _product.code( ";\n" );
+      }
+      
       _product.code( "%s = %s::sub_decode", sobf.m_symbol.str(), sdclass->qd_namespace().str() );
       if( tpscheme )
         _product.usercode( tpscheme->m_fileloc, "< %s >", tpscheme->m_content.str() );
-      _product.code( "( %s, %s::CodeType( _code_.str, _code_.size ) );\n", _addrname, sdclass->qd_namespace().str() );
-      if( not bfword.m_rewind )
-        _product.code( "_code_.pop( %s->GetEncoding().size );\n", sobf.m_symbol.str() );
-      continue;
+      _product.code( "( %s, _subcode_ );\n", _addrname );
+      _product.code( "unsigned int shortening = %u - %s->GetLength();\n",
+                     sdclass->m_maxsize, sobf.m_symbol.str() );
+      _product.code( "this->encoding.size -= shortening;\n" );
+      _product.code( "%s.stretch_front( shortening );\n", _codename );
+      _product.code( "}\n" );
     }
-    unsigned int bytesize = bfword.m_maxsize / 8;
     
-    if (bfword.m_has_operand) {
-      ConstStr_t subwordtype = Str::fmt( "uint%d_t", least_ctype_size( bfword.m_maxsize ) );
-      _product.code( "{\n" );
-      _product.code( "%s _subword_ = ", subwordtype.str() );
+    else if (fi.item().type() == BitField_t::Operand) {
+      OperandBitField_t const& opbf = dynamic_cast<OperandBitField_t const&>( fi.item() );
+      _product.code( "%s = ", opbf.m_symbol.str() );
+      unsigned int opsize = std::max( least_ctype_size( opbf.dstsize() ), m_minwordsize );
       char const* sep = "";
-      for( unsigned int byteidx = 0; byteidx < bytesize; ++byteidx, sep = " | " ) {
-        unsigned int shift = isa().m_little_endian ? 8*byteidx : 8*(bytesize - byteidx - 1);
-        _product.code( "%s(%s( _code_.str[%u] ) << %u)", sep, subwordtype.str(), byteidx, shift );
-      }
-      _product.code( ";\n" );
-      unsigned int nshift = isa().m_little_endian ? 0 : bfword.m_maxsize;
-      for( Vect_t<BitField_t>::const_iterator bf = bfword.m_left; bf < bfword.m_right; ++ bf ) {
-        unsigned int shift;
-        if (isa().m_little_endian) { shift = nshift; nshift += (**bf).m_size; }
-        else                       { nshift -= (**bf).m_size; shift = nshift; }
-        if( (**bf).type() == BitField_t::Operand ) {
-          OperandBitField_t const& opbf = dynamic_cast<OperandBitField_t const&>( **bf );
-          _product.code( "%s = ", opbf.m_symbol.str() );
+      
+      for (unsigned int end = fi.insn_size(), start = end - fi.m_size,
+             substart = start, subend; substart < end; substart = subend)
+        {
+          subend = std::min( (substart + 8) & -8, end);
+          unsigned int
+            bound = 1 << (subend - substart),
+            pos = little_endian ? (substart % 8) : ((-subend) % 8),
+            bytepos = substart / 8,
+            dstpos = little_endian ? (substart - start) : (end - subend);
           
-          if( opbf.m_sext ) {
-            int sizeofop = std::max( opbf.dstsize(), m_minwordsize );
-            int sext_shift = sizeofop - opbf.m_size;
-            _product.code( "(((int%d_t((_subword_ >> %u) & 0x%llxLL)) << %u) >> %u)",
-                           sizeofop, shift, opbf.mask(), sext_shift, sext_shift );
-          } else {
-            // FIXME: a cast from the instruction type to the operand type
-            // may be wiser...
-            _product.code( "((_subword_ >> %u) & 0x%llxULL)", shift, opbf.mask() );
-          }
-          if( opbf.m_shift > 0 )
-            _product.code( " >> %u", +opbf.m_shift );
-          if( opbf.m_shift < 0 )
-            _product.code( " << %u", -opbf.m_shift );
-          _product.code( ";\n" );
+          _product.code( "%s(((uint%u_t( %s.str[%u] ) >> %u) %% %u) << %u)", sep, opsize, _codename, bytepos, pos, bound, dstpos );
+          sep = " | ";
         }
+      _product.code( ";\n" );
+      
+      if( opbf.m_sext ) {
+        int sext_shift = opsize - opbf.m_size;
+        _product.code( "%s = (%s << %u) >> %u;\n", opbf.m_symbol.str(), opbf.m_symbol.str(), sext_shift, sext_shift );
       }
-      _product.code( "}\n" );
+    
+      if( opbf.m_shift > 0 )
+        _product.code( "%s >>= %u;\n", opbf.m_symbol.str(), +opbf.m_shift );
+      if( opbf.m_shift < 0 )
+        _product.code( "%s <<= %u;\n", opbf.m_symbol.str(), -opbf.m_shift );
     }
-    
-    if( not bfword.m_rewind )
-      _product.code( "_code_.pop( %u );\n", bytesize );
   }
-  
-  _product.code( "this->encoding.size -= _code_.size;\n" );
 }
 
 void
Index: genisslib/riscgenerator.hh
===================================================================
--- genisslib/riscgenerator.hh	(revision 11941)
+++ genisslib/riscgenerator.hh	(working copy)
@@ -25,17 +25,20 @@
 
 struct RiscGenerator : public Generator {
   struct OpCode_t {
-    bool                        m_vlen;
-    unsigned int                m_size;
     uint64_t                    m_mask;
     uint64_t                    m_bits;
+    unsigned int                m_size;
+    bool                        m_vlen;
     // Topology information
     OpCode_t*                   m_upper;
     intptr_t                    m_lowercount;
     
-    OpCode_t() : m_size( 0 ), m_mask( 0 ), m_bits( 0 ), m_upper( 0 ), m_lowercount( 0 ) {}
-    OpCode_t( bool vlen, unsigned int size, uint64_t mask, uint64_t bits )
-      : m_vlen( vlen ), m_size( size ), m_mask( mask ), m_bits( bits ), m_upper( 0 ), m_lowercount( 0 ) {}
+    OpCode_t()
+      : m_mask( 0 ), m_bits( 0 ), m_size( 0 ), m_vlen( false ),
+        m_upper( 0 ), m_lowercount( 0 ) {}
+    OpCode_t( uint64_t mask, uint64_t bits, unsigned int size, bool vlen )
+      : m_mask( mask ), m_bits( bits ), m_size( size ), m_vlen( vlen ),
+        m_upper( 0 ), m_lowercount( 0 ) {}
     
     // Topology methods
     enum Location_t { Outside, Overlaps, Inside, Contains, Equal };
